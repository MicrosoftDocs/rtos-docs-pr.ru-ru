---
title: Глава 2. Установка и использование ThreadX SMP для ОСРВ Azure
description: В этой главе описаны различные проблемы, связанные с установкой, настройкой и использованием высокопроизводительного ядра ThreadX SMP для ОСРВ Azure.
author: philmea
ms.author: philmea
ms.date: 06/04/2020
ms.topic: article
ms.service: rtos
ms.openlocfilehash: d0a63f3798adbc634a43cdda7e9d44941de655d9333f9ae0fb4181f1a6c0566e
ms.sourcegitcommit: 93d716cf7e3d735b18246d659ec9ec7f82c336de
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/07/2021
ms.locfileid: "116801909"
---
# <a name="chapter-2---installation--use-of-azure-rtos-threadx-smp"></a>Глава 2. Установка и использование ThreadX SMP для ОСРВ Azure

В этой главе описаны различные проблемы, связанные с установкой, настройкой и использованием высокопроизводительного ядра ThreadX SMP для ОСРВ Azure.

## <a name="host-considerations"></a>Рекомендации по размещению

Встраиваемое программное обеспечение обычно разрабатывается на главных компьютерах Windows или Linux (UNIX). После компиляции, связывания и размещения на главном компьютере приложение скачивается на целевое оборудование для выполнения.

Как правило, скачивание на целевой объект запускается из отладчика средства разработки. После скачивания отладчик отвечает за управление выполнением на целевом объекте (запуск, остановка, точка останова и т. д.), а также за доступ к памяти и регистрам процессора.

Большинство отладчиков инструментов разработки обмениваются данными с целевым оборудованием через подключения OCD (отладка на микросхеме), например JTAG (IEEE 1149.1) и BDM (режим фоновой отладки). Кроме того, отладчики взаимодействуют с целевым оборудованием через подключения ICE (внутрисхемная эмуляция). Подключения OCD и ICE обеспечивают надежную передачу данных с минимальным влиянием на резидентное ПО на целевом объекте.

Как и в случае с ресурсами, используемыми на главном компьютере, исходный код для ThreadX SMP предоставляется в формате ASCII и требует около 1 МБ свободного пространства на жестком диске главного компьютера.

> [!IMPORTANT]
> Дополнительные рекомендации и параметры системы узла см. в предоставленном файле **readme_threadx.txt**.

## <a name="target-considerations"></a>Рекомендации по целевому оборудованию

ThreadX SMP требует от 2 до 20 КБ доступной только для чтения памяти в целевой системе. Еще 1–2 КБ ОЗУ целевого объекта необходимо для стека системы ThreadX SMP и других глобальных структур данных.

Для использования функций, связанных с таймером, таких как время ожидания при вызовах службы, временной срез и таймеры приложений, базовое целевое оборудование должно предоставлять источник периодических прерываний. Если процессор поддерживает такую возможность, ThreadX SMP использует ее. В противном случае, когда у целевого процессора нет возможности создавать периодические прерывания, их должно обеспечивать оборудование пользователя. Установка и настройка прерываний по таймеру обычно выполняется в файле сборки ***tx_initialize_low_level*** из дистрибутива ThreadX SMP.

> [!IMPORTANT]
> ThreadX SMP работает, даже если источник периодических прерываний по таймеру недоступен. Однако ни одна из служб, связанных с таймером, работать не будет. Дополнительные рекомендации и параметры системы узла см. в предоставленном файле **readme_threadx.txt**.

## <a name="product-distribution"></a>Распространение продукта

Точное содержимое диска распространения зависит от целевого процессора, средств разработки и приобретенного пакета ThreadX SMP. Однако ниже приведен список ряда важных файлов, которые являются общими для большинства дистрибутивов.

### <a name="threadx_express_startuppdf"></a>ThreadX_Express_Startup.pdf

Этот PDF-файл содержит простую процедуру из четырех шагов для запуска ThreadX SMP на определенных целевых процессоре и плате и с использованием определенных средств разработки.

### <a name="readme_threadxtxt"></a>readme_threadx.txt

Текстовый файл, содержащий сведения о порте ThreadX SMP, включая сведения о целевом процессоре и средствах разработки.

| Инструмент | Описание |
| -------------- | ------------------------------------------------------------------------------------------------- |
| **tx_api.h**  | Файл заголовка на C включает все системные равенства, структуры данных и прототипы служб.             |
| **tx_port.h** | Файл заголовка на C, содержащий все определения и структуры данных для средств разработки и целевой системы. |
|**demo_threadx.c**| Файл на C, содержащий небольшое демонстрационное приложение.|
|**tx.a (или tx.lib)**| Двоичная версия библиотеки ThreadX SMP на C, распространяемая со *стандартным* пакетом.|

> [!IMPORTANT]
> Все имена файлов указаны в нижнем регистре. Такое соглашение об именовании упрощает преобразование команд для платформ разработки Linux (UNIX).

## <a name="threadx-smp-installation"></a>Установка ThreadX SMP

Установка ThreadX SMP осуществляется просто. Сведения об установке ThreadX SMP в конкретной среде см. в файлах ***ThreadX_Express_Startup.pdf** _ и _ *_readme_threadx.txt_**.

> [!IMPORTANT]
> Обязательно создайте резервную копию диска с дистрибутивом ThreadX SMP и сохраните ее в надежном месте.

> [!IMPORTANT]
> Программному обеспечению требуется доступ к файлу библиотеки ThreadX SMP (обычно это **tx.a** или **tx.lib**) и к включаемым файлам на C **tx_api.h** и **tx_port.h**. Для этого задайте путь к файлам в средствах разработки или скопируйте файлы в область разработки приложения.

## <a name="using-threadx-smp"></a>Использование ThreadX SMP

Использовать ThreadX SMP очень просто. Код приложения должен включить файл ***tx_api.h** _ во время компиляции и компоноваться с библиотекой ThreadX SMP времени выполнения _*_tx.a_*_ (или _*_tx.lib)_ **.

Для создания приложения ThreadX SMP необходимо выполнить четыре действия.

Включите файл ***tx_api.h*** во все файлы приложения, которые используют службы или структуры данных ThreadX SMP.

Создайте стандартную функцию ***main** _на C. Эта функция должна в конце выполнения вызывать _ *_tx_kernel_enter_** для запуска ядра ThreadX SMP. Перед входом в ядро допускается выполнить инициализацию конкретного приложения, которая не имеет отношения к ThreadX SMP.

> [!IMPORTANT]
> Функция **tx_kernel_enter** для входа в ThreadX SMP не возвращает управление. Поэтому не размещайте после нее никакие вызовы функций и процедуры вычислений.

Создайте функцию ***tx_application_define***. Именно здесь создаются исходные системные ресурсы. К таким системным ресурсам могут относиться потоки, очереди, пулы памяти, группы флагов событий, мьютексы и семафоры.

Скомпилируйте исходный код приложения и скомпонуйте его с библиотекой ThreadX SMP времени выполнения ***tx.lib***. Полученный образ можно скачать в целевую систему и запустить.

## <a name="small-example-system"></a>Пример небольшой системы

В небольшом примере системы, который представлен на рис. 1 на стр. 28, создается один поток с приоритетом 3. Этот поток выполняется и увеличивает значение счетчика, а затем переходит в спящий режим и остается в нем в течение такта длительностью в один час. Этот процесс повторяется неограниченно долго.

```c
#include              "tx_api.h"

unsigned long         my_thread_counter = 0;
TX_THREAD             my_thread;

main( )
{
      /* Enter the ThreadX SMP kernel. */
      tx_kernel_enter( );
}

void tx_application_define(void *first_unused_memory)
{

      /* Create my_thread! */
      tx_thread_create(&my_thread, "My Thread",
          my_thread_entry, 0x1234, first_unused_memory, 1024,
             3, 3, TX_NO_TIME_SLICE, TX_AUTO_START);
}

void my_thread_entry(ULONG thread_input)
{
      /* Enter into a forever loop. */
      while(1)
      {

            /* Increment thread counter. */
            my_thread_counter++;

            /* Sleep for 1 tick. */
            tx_thread_sleep(1);
      }
}
```
**Рис. 1. Шаблон для разработки приложения**

Это очень простой пример, но он предоставляет хороший шаблон для разработки реальных приложений. Дополнительные сведения также см. в файле ***readme_threadx.txt***.

## <a name="troubleshooting"></a>Устранение неполадок

Версии ThreadX SMP для любой системы включают демонстрационное приложение. Мы рекомендуем всегда начинать с запуска этой демонстрационной системы как на реальном оборудовании, так и в имитированной среде.

> [!IMPORTANT]
> Более подробные сведения о демонстрационной системе см. в файле **readme_threadx.txt**, прилагаемом к дистрибутиву.

Если демонстрационная система не работает должным образом, воспользуйтесь приведенными ниже советами по устранению неполадок.

  - Определите, на каком этапе демонстрации возникает ошибка.

  - Увеличьте размеры стека (это с большей вероятностью принесет пользу в фактическом коде приложения, чем в демонстрации).

  - Перестройте библиотеку ThreadX SMP, определив параметр TX_ENABLE_STACK_CHECKING. Это позволит включить встроенную проверку стека ThreadX SMP.

  - Временно отключите все недавно внесенные изменения и проверьте, сохраняется ли проблема и изменяется ли ее проявление. Такая информация будет полезной специалистам поддержки.

Выполните инструкции, приведенные в разделе "Что нам нужно" на стр. 12, чтобы отправить собранную информацию.

## <a name="configuration-options"></a>Параметры конфигурации

При сборке библиотеки ThreadX SMP и приложения, использующего ThreadX SMP, можно применить несколько параметров конфигурации. Указанные ниже параметры можно определить в исходном коде приложения, в командной строке или во включаемом файле ***tx_user.h***.

> [!IMPORTANT]
> Параметры, определенные в файле **tx_user.h**, применяются только в случае сборки библиотеки ThreadX SMP с определенным параметром **TX_INCLUDE_USER_DEFINE_FILE**.

### <a name="smallest-configuration"></a>Наименьшая конфигурация
Чтобы получить код наименьшего размера, попробуйте применить следующие параметры конфигурации ThreadX SMP (без всех остальных параметров).

- TX_DISABLE_ERROR_CHECKING
- TX_DISABLE_PREEMPTION_THRESHOLD
- TX_DISABLE_NOTIFY_CALLBACKS 
- TX_DISABLE_REDUNDANT_CLEARING 
- TX_DISABLE_STACK_FILLING 
- TX_NOT_INTERRUPTABLE 
- TX_TIMER_PROCESS_IN_ISR

### <a name="fastest-configuration"></a>Самая быстрая конфигурация 
Чтобы добиться наиболее быстрого выполнения, используйте те же параметры, что и для минимальной конфигурации, но с возможным добавлением следующего параметра.

- TX_REACTIVATE_INLINE

Дополнительные параметры для своей версии ThreadX SMP см. в файле ***readme_threadx.txt***. Параметры конфигурации подробно описываются, начиная со страницы 28.

### <a name="global-time-source"></a>Глобальный источник времени  
Для других продуктов ОСРВ Azure (FileX, NetX, GUIX,USBX и т. д.) ThreadX SMP вычисляет количество тактов таймера ThreadX SMP, которое соответствует одной секунде. Остальные службы определяют свои требования к времени на основе этой константы. По умолчанию используется значение 100, то есть одно прерывание каждые 10 мс. Пользователь может переопределить это значение, указав нужное значение параметра TX_TIMER_TICKS_PER_SECOND в файле ***tx_port.h***, в интегрированной среде разработки или в командной строке.

### <a name="detailed-configuration-options"></a>Подробное описание параметров конфигурации

- **TX_BLOCK_POOL_ENABLE_PERFORMANCE_INFO**. Если этот параметр определен, включается сбор сведений о производительности для пулов блоков. По умолчанию этот параметр не определен.
- **TX_BYTE_POOL_ENABLE_PERFORMANCE_INFO**. Если этот параметр определен, включается сбор сведений о производительности для пулов байтов. По умолчанию этот параметр не определен.
- **TX_DISABLE_ERROR_CHECKING**. Пропуск базовой проверки на предмет ошибок при вызове службы. Если этот параметр определен в исходном коде приложения, отключаются все базовые проверки на предмет ошибок в параметрах. Это может повысить производительность на 30 % и уменьшить размер образа.

> [!NOTE]
> *Проверку на предмет ошибок можно отключать, только если приложение полностью гарантирует допустимые значения всех входных параметров в любых обстоятельствах, в том числе для параметров, полученных из внешних источников. Если проверку на предмет ошибок отключить и в API будут переданы недопустимые входные данные, поведение системы будет неопределенным и может привести к повреждению памяти или аварийному завершению.*

> [!NOTE]
> *Возвращаемые из API ThreadX SMP значения, на которые не влияет отключение проверки на предмет ошибок, выделены полужирным шрифтом в разделе "Возвращаемые значения" в описании каждого API в главе 4. Возвращаемые значения, не выделенные полужирным шрифтом, всегда будут пустыми, если проверка на предмет ошибок отключена при заданном параметре TX_DISABLE_ERROR_CHECKING.*
- **TX_DISABLE_NOTIFY_CALLBACKS**. Если этот параметр определен, обратные вызовы оповещения для разных объектов ThreadX SMP отключаются. Использование этого параметра немного сокращает размер кода и повышает производительность. По умолчанию этот параметр не определен.
- **TX_DISABLE_PREEMPTION_THRESHOLD**. Если этот параметр определен, отключается функция проверки порога вытеснения, что немного уменьшает размер кода и повышает производительность. Разумеется, при этом становится недоступной проверка порога вытеснения. По умолчанию этот параметр не определен.
- **TX_DISABLE_REDUNDANT_CLEARING**. Если этот параметр определен, удаляется логика инициализации с обнулением для глобальных структур данных C среды ThreadX SMP. Этот параметр следует использовать, только если код инициализации компилятора устанавливает значение 0 для всех неинициализированных глобальных данных C. При использовании этого параметра немного сокращается размер кода и повышается производительность на этапе инициализации. По умолчанию этот параметр не определен.
- **TX_DISABLE_STACK_FILLING**. Если этот параметр определен, отключается присвоение значения 0xEF каждому байту стека каждого потока при его создании. По умолчанию этот параметр не определен.
- **TX_ENABLE_EVENT_TRACE**. Если этот параметр определен, ThreadX SMP включает код сбора событий для создания буфера трассировки TraceX. Подробные сведения см. в руководстве пользователя TraceX.
- **TX_ENABLE_STACK_CHECKING**. Если этот параметр определен, включается проверка стека времени выполнения ThreadX SMP, в которую входит анализ объема использованного стека и изучение "ограждений" шаблона данных до и после области стека. При обнаружении ошибки стека вызывается зарегистрированный обработчик ошибок стека приложений. При использовании этого параметра немного увеличиваются затраты времени и размер кода. Дополнительные сведения см. в описании функции API **_tx_- thread_stack_error_notify_** . По умолчанию этот параметр не определен.
- **TX_EVENT_FLAGS_ENABLE_PERFORMANCE_INFO**. Если этот параметр определен, включается сбор сведений о производительности для групп флагов событий. По умолчанию этот параметр не определен.
- **TX_INLINE_THREAD_RESUME_SUSPEND**. Если этот параметр определен, ThreadX SMP улучшает вызовы API **_tx_thread_resume_ *_ и _* _tx_thread_suspend_** путем применения встроенного кода. Это увеличивает размер кода, но повышает производительность для этих двух вызовов API.
- **TX_MAX_PRIORITIES**. Определяет уровни приоритета для ThreadX SMP. Допускаются значения в диапазоне от 32 до 1024 (включительно), но строго кратные 32. При увеличении числа поддерживаемых уровней приоритета увеличивается объем использования ОЗУ на 128 байт для каждой группы из 32 уровней приоритета. Но это оказывает крайне несущественное влияние на производительность. По умолчанию используются 32 уровня приоритета.
- **TX_MINIMUM_STACK**. Определяет минимальный размер стека (в байтах). Он используется для проверки на предмет ошибок при создании потоков. Значение по умолчанию зависит от конкретной версии и определяется в файле **_tx_port.h_**.
- **TX_MISRA_ENABLE**. Если этот параметр определен, ThreadX SMP использует соглашения, совместимые с MISRA C. Дополнительные сведения см. в файле **_ThreadX_MISRA_Compliance.pdf_**.
- **TX_MUTEX_ENABLE_PERFORMANCE_INFO**. Если этот параметр определен, включается сбор сведений о производительности для мьютексов. По умолчанию этот параметр не определен.
- **TX_NO_TIMER**. Если этот параметр определен, полностью отключается логика таймера ThreadX SMP. Это полезно в тех случаях, когда функции таймера ThreadX SMP не используются (режим сна для потока, время ожидания ответов API, временной срез или таймеры приложений).
- **TX_NOT_INTERRUPTABLE**. Если этот параметр определен, ThreadX SMP не пытается сокращать время блокировки прерываний. Это приводит к ускорению выполнения, но немного увеличивает время блокировки прерываний.
- **TX_QUEUE_ENABLE_PERFORMANCE_INFO**. Если этот параметр определен, включается сбор сведений о производительности для очередей. По умолчанию этот параметр не определен.
- **TX_REACTIVATE_INLINE**. Если этот параметр определен, повторная активация встроенных таймеров ThreadX SMP выполняется во встроенном коде, без вызова функции. Это повышает производительность, но немного увеличивает размер кода. По умолчанию этот параметр не определен.
- **TX_SEMAPHORE_ENABLE_PERFORMANCE_INFO**. Если этот параметр определен, включается сбор сведений о производительности для семафоров. По умолчанию этот параметр не определен.
- **TX_THREAD_ENABLE_PERFORMANCE_INFO**. Если этот параметр определен, включается сбор сведений о производительности для потоков. По умолчанию этот параметр не определен.
- **TX_THREAD_SMP_CORE_MASK**. Определяет битовую маску сопоставления для исключения CORE. Например, 4-ядерная среда имеет значение 0xF для этого определения.
- **TX_THREAD_SMP_DEBUG_ENABLE**. Если этот параметр определен, сведения об отладке ThreadX SMP сохраняются в циклическом буфере.
- **TX_THREAD_SMP_DYNAMIC_CORE_MAX**. Если этот параметр определен, включается динамическое максимальное число ядер, которое может корректироваться во время выполнения.
- **TX_THREAD_SMP_EQUAL_PRIORITY**. Если этот параметр определен, ThreadX SMP планирует параллельное выполнение потоков только с одинаковым приоритетом. Он должен быть определен до создания библиотеки ThreadX SMP.
- **TX_THREAD_SMP_INTER_CORE_INTERRUPT**. Если этот параметр определен, ThreadX SMP создает межъядерные прерывания.
- **TX_THREAD_SMP_MAX_CORES**. Определяет максимальное число ядер.
- **TX_THREAD_SMP_ONLY_CORE_0_DEFAULT**. Если этот параметр определен, ThreadX SMP по умолчанию выполняет все потоки и таймеры только в ядре 0. Приложение может переопределить это поведение, вызвав интерфейсы API исключения ядер. Он должен быть определен до создания библиотеки ThreadX SMP.
- **TX_THREAD_SMP_WAKEUP_LOGIC**. Если этот параметр определен, запускается макрос приложения для пробуждения ядра i. Должен быть определен до включения **_tx_port.h_**.
- **TX_THREAD_SMP_WAKEUP(i)** . Определяет макрос приложения для пробуждения ядра i. Должен быть определен до включения **_tx_port.h_**.
- **TX_TIMER_ENABLE_PERFORMANCE_INFO**. Если этот параметр определен, включается сбор сведений о производительности для таймеров. По умолчанию этот параметр не определен.
- **TX_TIMER_PROCESS_IN_ISR**. Если этот параметр определен, из ThreadX SMP удаляется внутренний поток системного таймера. Это приводит к повышению производительности событий таймера и уменьшению объема требований к ОЗУ, так как стек таймера и блок управления становятся не нужны. Но при использовании этого параметра вся обработка периодов для таймера переносится на уровень таймера ISR. По умолчанию этот параметр не определен.

    > [!NOTE]
    > Службы, разрешенные в таймерах, могут быть запрещены в ISR, а значит, они не смогут работать при использовании этого параметра.

- **TX_TIMER_THREAD_PRIORITY**. Определяет приоритет для внутреннего потока системного таймера ThreadX SMP. По умолчанию используется приоритет 0, то есть максимальный возможный приоритет в ThreadX SMP. Значение по умолчанию определяется в файле **_tx_port.h_**.
- **TX_TIMER_THREAD_STACK_SIZE**. Определяет размер стека (в байтах) для внутреннего потока системного таймера ThreadX SMP. Этот поток обрабатывает все запросы спящего режима и периоды ожидания для вызовов служб. Кроме того, из этого контекста вызываются все подпрограммы обратного вызова таймера приложений. Значение по умолчанию зависит от конкретной версии и определяется в файле **_tx_port.h_**.

## <a name="threadx-smp-version-id"></a>Идентификатор версии ThreadX SMP

Идентификатор версии ThreadX SMP можно найти в файле ***readme_threadx.txt** _. Кроме того, этот файл содержит журнал версий для соответствующей платформы. Программное обеспечение приложения может получить сведения о версии ThreadX SMP из глобальной строки _ *_ _tx_version_id_**.