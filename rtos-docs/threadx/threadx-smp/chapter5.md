---
title: Глава 5. Драйверы устройств для ThreadX SMP для ОСРВ Azure
description: В этой главе приводится описание драйверов устройств для ThreadX SMP для ОСРВ Azure.
author: philmea
ms.author: philmea
ms.date: 06/04/2020
ms.topic: article
ms.service: rtos
ms.openlocfilehash: acfb54a25cc8bc27b7d0aaeff48956529d90c9e1
ms.sourcegitcommit: e3d42e1f2920ec9cb002634b542bc20754f9544e
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/22/2021
ms.locfileid: "104816064"
---
# <a name="chapter-5---device-drivers-for-azure-rtos-threadx-smp"></a>Глава 5. Драйверы устройств для ThreadX SMP для ОСРВ Azure

В этой главе приводится описание драйверов устройств для ThreadX SMP для ОСРВ Azure. Сведения, представленные в этой главе, призваны помочь разработчикам при написании драйверов для конкретных приложений. 

## <a name="device-driver-introduction"></a>Введение в драйверы устройств

Связь с внешней средой — это важная составляющая большинства внедренных приложений. Такая связь осуществляется с помощью аппаратных устройств, доступных ПО внедренных приложений. Программные компоненты, которые отвечают за управление такими устройствами, обычно называются *драйверами*.

Драйверы устройств представляют собой внедренные работающие в реальном времени системы, которые по своей природе зависимы от приложения. Это так по двум основным причинам: невероятное разнообразие целевого оборудования и настолько же широкие требования к производительности, предъявляемые к работающим в реальном времени приложениям. Поэтому практически невозможно предоставить общий набор драйверов, удовлетворяющих требованиям любого приложения. В связи с этим сведения в этой главе призваны помочь пользователям настроить *стандартные* драйверы устройств ThreadX SMP и написать собственные драйверы.

## <a name="driver-functions"></a>Функции драйверов

Драйверы устройств ThreadX SMP включают восемь основных выполняемых функций:

- **инициализация драйвера;**
- **управление драйвером;**
- **доступ к драйверу;**
- **получение данных драйвером;**
- **вывод данных драйвером;**
- **прерывания драйвера;**
- **состояние драйвера;**
- **завершение работы драйвера.**

За исключением инициализации, каждая из таких выполняемых функций является необязательной. Более того, обработка каждой выполняемой функции зависит от драйвера устройства.

### <a name="driver-initialization"></a>Инициализация драйвера 
Эта выполняемая функция отвечает за инициализацию реального аппаратного устройства и внутренних структур данных драйвера. Вызов других служб драйвера невозможен, пока не завершится этап инициализации.

> [!IMPORTANT]
> Компонент функции для инициализации драйвера обычно вызывается из функции **tx_application_define** или из потока инициализации.

### <a name="driver-control"></a>Управление драйвером 
После того как драйвер будет инициализирован и готов к работе, эта функция отвечает за управление им во время выполнения. Обычно управление во время выполнения заключается в реализации изменений в работе базового аппаратного устройства. Например, это может быть изменение скорости передачи (бит/с) для устройства с последовательным интерфейсом или поиск нового сектора на диске.

### <a name="driver-access"></a>Доступ к драйверу 
Некоторые драйверы устройств вызываются только из одного потока приложения. В таких случаях эту функцию выполнять не требуется. Но в приложениях, в которых к драйверу требуется одновременный доступ из нескольких потоков, их взаимодействием можно управлять с помощью средств назначения и освобождения в драйвере устройства. Приложение также может использовать семафор для управления доступом к драйверу и таким образом избежать излишней нагрузки на ресурсы и усложнения кода в драйвере. 

### <a name="driver-input"></a>Получение данных драйвером 
Эта функция отвечает за все операции ввода данных на устройстве. Основные проблемы, связанные с входными данными драйвера, обычно касаются способов буферизации входных данных и их ожидания потоками. 

### <a name="driver-output"></a>Вывод данных драйвером 
Эта выполняемая функция отвечает за обработку всех выходных данных устройства. Основные проблемы, связанные с выходными данными драйвера, обычно касаются способов буферизации выходных данных и их ожидания потоками. 

### <a name="driver-interrupts"></a>Прерывания драйвера 
Большинство систем, работающих в реальном времени, используют аппаратные прерывания для уведомления драйвера о событиях ввода, вывода, управления и ошибок на устройстве. Прерывания предоставляют таким внешним событиям гарантированное время отклика. Вместо прерываний ПО драйвера может периодически проверять наличие таких событий на внешнем оборудовании. Такая методика называется *опросом*. Так как она предъявляет меньше требований к обработке в реальном времени, опросы могут лучше подходить для соответствующих приложений. 

### <a name="driver-status"></a>Состояние драйвера 
Эта выполняемая функция отвечает за предоставление данных о состоянии и статистики среды выполнения, связанных с работой драйвера. Сведения, которые обрабатывает эта функция, обычно включают следующую информацию: 
- текущее состояние устройства;
- входные байты;
- выходные байты;
- число ошибок устройства.

### <a name="driver-termination"></a>Завершение работы драйвера 
Эта выполняемая функция необязательна. Она необходима только в том случае, если необходимо завершить работу драйвера и (или) физического аппаратного устройства. После завершения работы драйвер нельзя вызвать, пока он не будет повторно инициализирован. 

## <a name="simple-driver-example"></a>Пример простого драйвера

Пример позволяет лучше понять, как работает драйвер устройства. В этом примере для драйвера предполагается простое аппаратное устройство с последовательным интерфейсом, с регистром конфигурации, регистрами входных и выходных данных. Этот пример простого драйвера демонстрирует выполнение функций инициализации, ввода данных, вывода данных и прерываний.

### <a name="simple-driver-initialization"></a>Инициализация простого драйвера 
Функция ***tx_sdriver_initialize*** простого драйвера создает два вычислительных семафора, которые используются для управления операциями с входными и выходными данными драйвера. Семафор входных данных задается обработчиком прерываний входных данных, когда аппаратное устройство с последовательным интерфейсом получает символ. По этой причине семафор ввода создается со счетчиком, имеющим значение 0.

И наоборот, семафор вывода указывает на доступность регистра передачи для оборудования с последовательным интерфейсом. Он создается со значением 1, чтобы указать на первоначальную доступность регистра передачи.

Функция инициализации также отвечает за установку обработчиков векторов прерывания низкого уровня для уведомлений входных и выходных данных. Как и другие подпрограммы службы прерываний ThreadX SMP, обработчик низкого уровня должен вызвать * **_tx_thread_context_save** _ до вызова обработчика прерываний простого драйвера. После того как обработчик прерываний драйвера будет возвращен, обработчик низкого уровня должен вызвать _*_ _tx_thread_context_restore_**.

> [!IMPORTANT]
> Важно, чтобы инициализация была вызвана до любых других функций драйвера. Обычно инициализация драйвера вызывается из функции **tx_application_define**.

Исходный код инициализации для простого драйвера см. на рис. 9 на стр. 306.

```C
VOID     tx_sdriver_initialize(VOID)
{

    /* Initialize the two counting semaphores used to control
       the simple driver I/O. */
    tx_semaphore_create(&tx_sdriver_input_semaphore,
                       "simple driver input semaphore", 0);
    tx_semaphore_create(&tx_sdriver_output_semaphore,
                       "simple driver output semaphore", 1);

    /* Setup interrupt vectors for input and output ISRs.
       The initial vector handling should call the ISRs
       defined in this file. */

    /* Configure serial device hardware for RX/TX interrupt
       generation, baud rate, stop bits, etc. */
}
```
**Рис. 9. Инициализация простого драйвера**

### <a name="simple-driver-input"></a>Входные данные простого драйвера 
Входные данные для простого драйвера управляются семафором ввода. При получении прерывания входных данных устройства задается семафор ввода. Если один или несколько потоков ожидают получения символа от драйвера, работу продолжает поток с наибольшим временем ожидания. Если работают все потоки, семафор сохраняется до того момента, пока поток не вызовет функцию ввода драйвера.

Существует несколько ограничений при обработки входных данных простым драйвером. Самое значительное — возможность удаления символов входных данных. Это возможно, так как нельзя выполнить буферизацию символов входных данных, которые принимаются до завершения обработки предыдущего символа. Эта проблема легко решается путем добавления буфера символов входных данных.

> [!IMPORTANT]
> Функцию **tx_sdriver_input** могут вызывать только потоки.

На рис. 10 приведен исходный код, связанный с входными данными простого драйвера.

```C
UCHAR     tx_sdriver_input(VOID)
{

    /* Determine if there is a character waiting. If not,
        suspend. */
    tx_semaphore_get(&tx_sdriver_input_semaphore,
                                             TX_WAIT_FOREVER;
    /* Return character from serial RX hardware register. */
    return(*serial_hardware_input_ptr);
}

VOID     tx_sdriver_input_ISR(VOID)
{
    /* See if an input character notification is pending. */
    if (!tx_sdriver_input_semaphore.tx_semaphore_count)
    {
        /* If not, notify thread of an input character. */
        tx_semaphore_put(&tx_sdriver_input_semaphore);
    }
}
```
**Рис. 10. Входные данные простого драйвера**

### <a name="simple-driver-output"></a>Выходные данные простого драйвера 
При обработке выходных данных используется семафор вывода для уведомления о том, что регистр передачи устройства с последовательным интерфейсом освободился. Перед фактической записью символа выходных данных на устройство выполняется получение семафора вывода. Если он недоступен, возможно, предыдущая операция передачи еще не завершена.

Обработчик прерываний выходных данных отвечает за обработку прерывания завершения при передаче. Его операции заключаются в установке семафора вывода, что позволяет выполнить вывод другого символа.

> [!IMPORTANT]
> Вызывать функцию **tx_sdriver_output** могут только потоки.

На рис. 11 приведен исходный код, связанный с выходными данными простого драйвера.

```C
VOID     tx_sdriver_output(UCHAR alpha)
{

    /* Determine if the hardware is ready to transmit a
       character. If not, suspend until the previous output
        completes. */
    tx_semaphore_get(&tx_sdriver_output_semaphore,
                                            TX_WAIT_FOREVER);
    /* Send the character through the hardware. */
    *serial_hardware_output_ptr = alpha;
}

VOID     tx_sdriver_output_ISR(VOID)
{
    /* Notify thread last character transmit is
        complete. */
    tx_semaphore_put(&tx_sdriver_output_semaphore);
}
```
**Рис. 11. Выходные данные простого драйвера**

### <a name="simple-driver-shortcomings"></a>Недостатки простого драйвера 
Этот пример простого драйвера устройства иллюстрирует принцип работы драйвера со ThreadX SMP. Но так как в этом простом драйвере устройства не устранены проблемы с буферизацией данных или излишней нагрузкой на ресурсы, он не полностью эквивалентен реальным драйверам со ThreadX SMP. В разделе ниже описаны некоторые более сложные проблемы, связанные с драйверами устройств.

## <a name="advanced-driver-issues"></a>Сложные проблемы с драйверами

Как было сказано ранее, требования драйверов устройств аналогичны требованиям их приложений. Некоторым приложениям может требоваться выполнять буферизацию огромного объема данных, а другие приложения могут нуждаться в оптимизированном обработчике прерываний драйвера из-за высокой частоты прерываний устройства.

### <a name="io-buffering"></a>Буферизация ввода-вывода 
Буферизация данных во внедренных приложениях, работающих в реальном времени, требует тщательного планирования. В некоторых случаях его реализация будет зависеть от базового аппаратного устройства. Если устройство предоставляет базовый побайтовый ввод-вывод, вероятно, имеет смысл добавить простой циклический буфер. Но если устройство предоставляет блочный, пакетный ввод-вывод или ввод-вывод с прямым доступом к памяти, более оптимально будет использовать схему управления буфером. 

### <a name="circular-byte-buffers"></a>Циклические байтовые буферы 
Циклические байтовые буферы обычно используются в драйверах, которые управляют простым аппаратным устройством с последовательным интерфейсом, например UART. В таких ситуациях чаще всего используются два циклических буфера — один для входных, а другой для выходных данных.

Каждый циклический байтовый буфер состоит из байтовой области памяти (обычно это массив из UCHAR), указателя на чтение и указателя на запись. Буфер считается пустым, если указатель на чтение и указатели на запись ссылаются на одно расположение памяти в буфере. Инициализация драйвера задает для указателей буфера на чтение и запись расположение в начальном адресе буфера.

### <a name="circular-buffer-input"></a>Входные данные циклического буфера 
Буфер ввода используется для хранения символов, которые приложение еще не готово обработать. При получении символа входных данных (обычно в обработчике прерываний) от аппаратного устройства принимается новый символ и помещается в буфер ввода в расположении, на которое ссылается указатель на запись. Затем указатель на запись перемещается на следующую позицию в буфере. Если следующая позиция находится за пределами буфера, указатель на запись устанавливается на начало буфера. Условие заполнения очереди обрабатывается путем отмены перемещения указателя на запись, если новый указатель на запись не отличается от указателя на чтение.

Побайтовые запросы к входным данным приложения, направляемые драйверу, сначала проверяют указатели на чтение и запись буфера ввода. Если указатели на чтение и запись идентичны, это означает, что буфер пуст. Если же указатель на чтение отличается, байт, на который ссылается указатель на чтение, копируется из буфера ввода, а указатель на чтение перемещается на следующее расположение в буфере. Если новый указатель на чтение выходит за пределы буфера, он сбрасывается на начало. На рис. 12 приведена логика для циклического буфера ввода.

```C
UCHAR     tx_input_buffer[MAX_SIZE];
UCHAR     tx_input_write_ptr;
UCHAR     tx_input_read_ptr;

/* Initialization.  */
tx_input_write_ptr =  &tx_input_buffer[0];
tx_input_read_ptr =    &tx_input_buffer[0];

/* Input byte ISR... UCHAR alpha has character from device. */
save_ptr =  tx_input_write_ptr;
*tx_input_write_ptr++ =  alpha;
if (tx_input_write_ptr > &tx_input_buffer[MAX_SIZE-1])
    tx_input_write_ptr =  &tx_input_buffer[0];  /* Wrap */
if (tx_input_write_ptr == tx_input_read_ptr)
    tx_input_write_ptr =  save_ptr;  /* Buffer full */

/* Retrieve input byte from buffer... */
if (tx_input_read_ptr != tx_input_write_ptr)
{
    alpha =  *tx_input_read_ptr++;
    if (tx_input_read_ptr > &tx_input_buffer[MAX_SIZE-1])
        tx_input_read_ptr =  &tx_input_buffer[0];
}
```
**Рис. 12. Логика для циклического буфера ввода**

> [!IMPORTANT]
> Для надежной работы может потребоваться заблокировать прерывания при изменении указателей на чтение и запись для циклических буферов ввода и вывода.

### <a name="circular-output-buffer"></a>Циклический буфер вывода 
Буфер вывода используется для хранения символов, которые были приняты на вывод до того, как аппаратное устройство завершило отправку предыдущего байта. Обработка буфера вывода аналогична обработке для буфера ввода, за исключением того, что обработка прерывания завершений передачи используется с указателем на чтение выходных данных, а запрос выходных данных к приложению использует указатель на запись выходных данных. В остальном обработка буфера выходных данных не отличается. На рис. 13 приведена логика для циклического буфера вывода.

```C
UCHAR     tx_output_buffer[MAX_SIZE];
UCHAR     tx_output_write_ptr;
UCHAR     tx_output_read_ptr;

/* Initialization.  */
tx_output_write_ptr =  &tx_output_buffer[0];
tx_output_read_ptr =   &tx_output_buffer[0];

/* Transmit complete ISR... Device ready to send. */
if (tx_output_read_ptr != tx_output_write_ptr)
{
    *device_reg =  *tx_output_read_ptr++;
    if (tx_output_read_reg > &tx_output_buffer[MAX_SIZE-1])
    tx_output_read_ptr =  &tx_output_buffer[0];
}

/* Output byte driver service. If device busy, buffer! */
save_ptr =  tx_output_write_ptr;
*tx_output_write_ptr++ =  alpha;
if (tx_output_write_ptr > &tx_output_buffer[MAX_SIZE-1])
    tx_output_write_ptr =  &tx_output_buffer[0];  /* Wrap */
if (tx_output_write_ptr == tx_output_read_ptr)
    tx_output_write_ptr =  save_ptr;  /* Buffer full!  */
```
**Рис. 13. Логика для циклического буфера вывода**

### <a name="buffer-io-management"></a>Управление вводом-выводом буфера 
Для улучшения производительности внедренных микропроцессоров многие периферийные устройства передают и получают данные с помощью буферов, предоставляемых программным обеспечением. В некоторых реализациях могут использоваться несколько буферов для передачи или получения отдельных пакетов данных. 

Размер и расположение буферов ввода-вывода определяются приложением и (или) ПО драйвера. Обычно буферы имеют фиксированный размер и управляются в пуле блочной памяти ThreadX SMP. На рис. 14 приведен типичный буфер ввода-вывода и пул блочной памяти ThreadX SMP, который управляет их выделением.

```C
typedef struct TX_IO_BUFFER_STRUCT
{

      struct TX_IO_BUFFER_STRUCT *tx_next_packet;
    struct TX_IO_BUFFER_STRUCT *tx_next_buffer;
      UCHAR  tx_buffer_area[TX_MAX_BUFFER_SIZE];
} TX_IO_BUFFER;

TX_BLOCK_POOL tx_io_block_pool;

/* Create a pool of I/O buffers. Assume that the pointer
   "free_memory_ptr"points to an available memory area that
   is 64 KBytes in size. */

tx_block_pool_create(&tx_io_block_pool,
                  "Sample IO Driver Buffer Pool",
                  free_memory_ptr, 0x10000,
                  sizeof(TX_IO_BUFFER));
```
**Рис. 14. Буфер ввода-вывода**

### <a name="tx_io_buffer"></a>TX_IO_BUFFER 
typedef TX_IO_BUFFER состоит из двух указателей. Указатель ***tx_next_packet** _ используется для связывания нескольких пакетов в списке входных или выходных данных. Указатель _ *_tx_next_buffer_** используется для связывания буферов, которые составляют отдельный пакет данных от устройства. Для обоих этих указателей задано значение NULL при выделении буфера из пула. Кроме того, некоторые устройства могут требовать дополнительное поле для указания того, насколько область буфера заполнена данными.

### <a name="buffered-io-advantage"></a>Преимущества буферизованного ввода-вывода 
Каковы преимуществ схемы ввода-вывода с буфером? Основное преимущество — данные не копируются между регистрами устройства и памятью приложения. Вместо этого драйвер предоставляет устройству серию указателей на буфер. Операции ввода-вывода физического устройства используют предоставляемую память буфера напрямую.

Использование процессора для копирования входящих или исходящих пакетов данных требует большого объема ресурсов, поэтому этого следует избегать в любых ситуациях ввода-вывода с высокой пропускной способностью.

Еще одно преимущество подхода с буферизацией ввода-вывода заключается в том, что списки входных и выходных данных не имеют условий заполнения. Все доступные буферы могут в отдельный момент времени работать с любым списком. Этим они отличаются от простых байтовых циклических буферов, представленных ранее в этой главе. Каждый из них имеет фиксированный размер, определяемый при компиляции.

### <a name="buffered-driver-responsibilities"></a>Задачи буферизованного драйвера 
Буферизованные драйверы устройства выполняют только управление связанными списками буферов ввода-вывода. Список буфера входных данных поддерживается для пакетов, которые принимаются до того, как ПО приложения готово их обработать. А список буфера выходных данных поддерживается для пакетов, которые отправляются быстрее, чем аппаратное устройством может обработать их. На рис. 15 на стр. 314 показаны простые связанные списки входных и выходных данных для пакетов и буферы, образующие каждый пакет.

![Задачи буферизованного драйвера](media/image11.png)

**Рис. 15. Списки входных и выходных данных**

Приложения взаимодействуют с буферизованными драйверами с аналогичными буферами ввода-вывода. При передаче данных ПО приложения предоставляет драйвер с одним или несколькими передаваемыми буферами. Если ПО приложения запрашивает входные данные, драйвер возвращает входные данные в буферах ввода-вывода.

> [!IMPORTANT]
> В некоторых приложениях может быть полезнее создать интерфейс входных данных драйвера, который будет требовать от приложения заменить свободный буфер на буфер входных данных от драйвера. Это может упростить некоторую обработку выделения буфера в драйвере.

### <a name="interrupt-management"></a>Управление прерываниями 
В некоторых приложениях частота прерываний устройства может препятствовать написанию обработчика прерываний на C или взаимодействию со ThreadX SMP при каждом прерывании. Например, если для сохранения и восстановления прерванного контекста требуется 25 мкс, не рекомендуется выполнять сохранение полного контекста, если частота прерывания составляла 50 мкс. В таких случаях для обработки большинства прерываний устройства используется обработчик прерываний языка в компактной сборке. Такой нетребовательный к ресурсам обработчик будет взаимодействовать со ThreadX SMP только при необходимости.

Подробное обсуждение можно найти в описании управления прерываниями в конце главы 3.

> [!NOTE]
> Если для защиты критически важных разделов в коде драйвера от кода обработчика прерываний драйвера используется блокировка прерываний, код драйвера на уровне потока должен всегда выполняться на том же ядре, на котором выполняется обработчик прерываний. В противном случае необходимо использовать примитивы ThreadX SMP, например TX_DISABLE и TX_RESTORE, которые также имеют встроенную защиту от перехода на другие ядра.

### <a name="thread-suspension"></a>Приостановка потока 
В простом примере драйвера, представленном ранее в этой главе, вызывающий компонент службы ввода приостанавливает работу, если символ недоступен. Для некоторых приложений это может быть недопустимым.

Например, если поток, отвечающий за обработку входных данных от драйвера, также выполняет другие задачи, приостановка только приема данных драйвером может не сработать. В таком случае для драйвера необходимо настроить отправку запроса на обработку так же, как и отправку других запросов на обработку в поток.

В большинстве случаев это означает создание буфера ввода для связанного списка и отправку входящего сообщения о событии во входную очередь потока.