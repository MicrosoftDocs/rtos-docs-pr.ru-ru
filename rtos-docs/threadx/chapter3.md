---
title: Глава 3. Функциональные компоненты ОСРВ Azure ThreadX
description: В этой главе описывается высокопроизводительное ядро ОСРВ Azure ThreadX с точки зрения функциональности.
author: philmea
ms.author: philmea
ms.date: 05/19/2020
ms.topic: article
ms.service: rtos
ms.openlocfilehash: aa66ad392171958e5d2cc765992fd1a9e41250a6
ms.sourcegitcommit: e3d42e1f2920ec9cb002634b542bc20754f9544e
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/22/2021
ms.locfileid: "104815635"
---
# <a name="chapter-3---functional-components-of-azure-rtos-threadx"></a><span data-ttu-id="7769e-103">Глава 3. Функциональные компоненты ОСРВ Azure ThreadX</span><span class="sxs-lookup"><span data-stu-id="7769e-103">Chapter 3 - Functional Components of Azure RTOS ThreadX</span></span>

<span data-ttu-id="7769e-104">В этой главе описывается высокопроизводительное ядро ОСРВ Azure ThreadX с точки зрения функциональности.</span><span class="sxs-lookup"><span data-stu-id="7769e-104">This chapter contains a description of the high-performance Azure RTOS ThreadX kernel from a functional perspective.</span></span> <span data-ttu-id="7769e-105">Каждый функциональный компонент представлен простым и понятным способом.</span><span class="sxs-lookup"><span data-stu-id="7769e-105">Each functional component is presented in an easy-to-understand manner.</span></span>

## <a name="execution-overview"></a><span data-ttu-id="7769e-106">Общие сведения о выполнении</span><span class="sxs-lookup"><span data-stu-id="7769e-106">Execution Overview</span></span>

<span data-ttu-id="7769e-107">В приложении ThreadX существуют четыре типа выполнения программы: инициализация, выполнение потока, подпрограммы обработки прерываний (ISR) и таймеры приложения.</span><span class="sxs-lookup"><span data-stu-id="7769e-107">There are four types of program execution within a ThreadX application: Initialization, Thread Execution, Interrupt Service Routines (ISRs), and Application Timers.</span></span>

<span data-ttu-id="7769e-108">На рисунке 2 показаны типы выполнения программы.</span><span class="sxs-lookup"><span data-stu-id="7769e-108">Figure 2 shows each different type of program execution.</span></span> <span data-ttu-id="7769e-109">Более подробные сведения о каждом из этих типов приведены в последующих разделах этой главы.</span><span class="sxs-lookup"><span data-stu-id="7769e-109">More detailed information about each of these types is found in subsequent sections of this chapter.</span></span>

### <a name="initialization"></a><span data-ttu-id="7769e-110">Инициализация</span><span class="sxs-lookup"><span data-stu-id="7769e-110">Initialization</span></span>

<span data-ttu-id="7769e-111">Как предполагает название, это первый тип выполнения программы в приложении ThreadX.</span><span class="sxs-lookup"><span data-stu-id="7769e-111">As the name implies, this is the first type of program execution in a ThreadX application.</span></span> <span data-ttu-id="7769e-112">Инициализация включает в себя все выполнение программы между сбросом процессора и точкой входа *цикла планирования потоков*.</span><span class="sxs-lookup"><span data-stu-id="7769e-112">Initialization includes all program execution between processor reset and the entry point of the *thread scheduling loop.*</span></span>

### <a name="thread-execution"></a><span data-ttu-id="7769e-113">Выполнение потока</span><span class="sxs-lookup"><span data-stu-id="7769e-113">Thread Execution</span></span>

<span data-ttu-id="7769e-114">После завершения инициализации ThreadX входит в цикл планирования потоков.</span><span class="sxs-lookup"><span data-stu-id="7769e-114">After initialization is complete, ThreadX enters its thread scheduling loop.</span></span> <span data-ttu-id="7769e-115">Цикл планирования выполняет поиск потока приложения, готового к выполнению.</span><span class="sxs-lookup"><span data-stu-id="7769e-115">The scheduling loop looks for an application thread ready for execution.</span></span> <span data-ttu-id="7769e-116">При обнаружении готового потока ThreadX передает ему управление.</span><span class="sxs-lookup"><span data-stu-id="7769e-116">When a ready thread is found, ThreadX transfers control to it.</span></span> <span data-ttu-id="7769e-117">По завершении потока (или при готовности другого потока с более высоким приоритетом) выполнение передается обратно в цикл планирования потоков, чтобы найти следующий готовый к выполнению высокоприоритетный поток.</span><span class="sxs-lookup"><span data-stu-id="7769e-117">After the thread is finished (or another higher-priority thread becomes ready), execution transfers back to the thread scheduling loop to find the next highest priority ready thread.</span></span>

<span data-ttu-id="7769e-118">Этот процесс непрерывного выполнения и планирования потоков — наиболее распространенный тип выполнения программы в приложениях ThreadX.</span><span class="sxs-lookup"><span data-stu-id="7769e-118">This process of continually executing and scheduling threads is the most common type of program execution in ThreadX applications.</span></span>

### <a name="interrupt-service-routines-isr"></a><span data-ttu-id="7769e-119">Подпрограммы обработки прерываний (ISR)</span><span class="sxs-lookup"><span data-stu-id="7769e-119">Interrupt Service Routines (ISR)</span></span>

<span data-ttu-id="7769e-120">Прерывания — это основной механизм в системах реального времени.</span><span class="sxs-lookup"><span data-stu-id="7769e-120">Interrupts are the cornerstone of real-time systems.</span></span> <span data-ttu-id="7769e-121">Без прерываний было бы очень сложно своевременно реагировать на изменения во внешнем мире.</span><span class="sxs-lookup"><span data-stu-id="7769e-121">Without interrupts it would be extremely difficult to respond to changes in the external world in a timely manner.</span></span> <span data-ttu-id="7769e-122">При обнаружении прерывания процессор сохраняет ключевые сведения о текущем выполнении программы (обычно в стеке), а затем передает управление предопределенной области программы.</span><span class="sxs-lookup"><span data-stu-id="7769e-122">On detection of an interrupt, the processor saves key information about the current program execution (usually on the stack), then transfers control to a predefined program area.</span></span> <span data-ttu-id="7769e-123">Эта предопределенная область программы обычно называется подпрограммой обработки прерываний.</span><span class="sxs-lookup"><span data-stu-id="7769e-123">This predefined program area is commonly called an Interrupt Service Routine.</span></span> <span data-ttu-id="7769e-124">В большинстве случаев прерывания происходят во время выполнения потока (или в цикле планирования потоков).</span><span class="sxs-lookup"><span data-stu-id="7769e-124">In most cases, interrupts occur during thread execution (or in the thread scheduling loop).</span></span> <span data-ttu-id="7769e-125">Однако прерывания могут также возникать внутри выполняемой подпрограммы ISR или таймера приложения.</span><span class="sxs-lookup"><span data-stu-id="7769e-125">However, interrupts may also occur inside of an executing ISR or an Application Timer.</span></span>

![Типы выполнения программы](./media/user-guide/types-program-execution.png)

<span data-ttu-id="7769e-127">**РИСУНОК 2. Типы выполнения программы**</span><span class="sxs-lookup"><span data-stu-id="7769e-127">**FIGURE 2. Types of Program Execution**</span></span>

### <a name="application-timers"></a><span data-ttu-id="7769e-128">Таймеры приложения</span><span class="sxs-lookup"><span data-stu-id="7769e-128">Application Timers</span></span>

<span data-ttu-id="7769e-129">Таймеры приложения похожи на подпрограммы ISR, за исключением того, что их аппаратная реализация (обычно используется одно периодическое аппаратное прерывание) скрыта от приложения.</span><span class="sxs-lookup"><span data-stu-id="7769e-129">Application Timers are similar to ISRs, except the hardware implementation (usually a single periodic hardware interrupt is used) is hidden from the application.</span></span> <span data-ttu-id="7769e-130">Такие таймеры используются приложениями для прерывания при истечении времени ожидания, периодического выполнения и (или) запуска служб наблюдения.</span><span class="sxs-lookup"><span data-stu-id="7769e-130">Such timers are used by applications to perform time-outs, periodics, and/or watchdog services.</span></span> <span data-ttu-id="7769e-131">Как и в случае с подпрограммами ISR, таймеры приложения чаще всего прерывают выполнение потоков.</span><span class="sxs-lookup"><span data-stu-id="7769e-131">Just like ISRs, Application Timers most often interrupt thread execution.</span></span> <span data-ttu-id="7769e-132">Однако в отличие от ISR таймеры приложения не могут прерывать друг друга.</span><span class="sxs-lookup"><span data-stu-id="7769e-132">Unlike ISRs, however, Application Timers cannot interrupt each other.</span></span>

## <a name="memory-usage"></a><span data-ttu-id="7769e-133">Использование памяти</span><span class="sxs-lookup"><span data-stu-id="7769e-133">Memory Usage</span></span>

<span data-ttu-id="7769e-134">ThreadX размещается в памяти вместе с прикладной программой.</span><span class="sxs-lookup"><span data-stu-id="7769e-134">ThreadX resides along with the application program.</span></span> <span data-ttu-id="7769e-135">В результате использование статической памяти (или фиксированной памяти) в ThreadX зависит от используемых инструментов разработки (например, компилятора, компоновщика и указателя).</span><span class="sxs-lookup"><span data-stu-id="7769e-135">As a result, the static memory (or fixed memory) usage of ThreadX is determined by the development tools; e.g., the compiler, linker, and locator.</span></span> <span data-ttu-id="7769e-136">Использование динамической памяти (или памяти во время выполнения) контролируется непосредственно приложением.</span><span class="sxs-lookup"><span data-stu-id="7769e-136">Dynamic memory (or run-time memory) usage is under direct control of the application.</span></span>

### <a name="static-memory-usage"></a><span data-ttu-id="7769e-137">Использование статической памяти</span><span class="sxs-lookup"><span data-stu-id="7769e-137">Static Memory Usage</span></span>

<span data-ttu-id="7769e-138">Большинство инструментов разработки разделяют образ прикладной программы на пять основных областей: *инструкции*, *константы*, *инициализированные данные*, *неинициализированные данные* и *системный стек*.</span><span class="sxs-lookup"><span data-stu-id="7769e-138">Most of the development tools divide the application program image into five basic areas: *instruction*, *constant*, *initialized data*, *uninitialized data*, and *system stack*.</span></span> <span data-ttu-id="7769e-139">На рисунке 3 показан пример этих областей памяти.</span><span class="sxs-lookup"><span data-stu-id="7769e-139">Figure 3 shows an example of these memory areas.</span></span>

<span data-ttu-id="7769e-140">Важно учитывать, что это только пример.</span><span class="sxs-lookup"><span data-stu-id="7769e-140">It is important to understand that this is only an example.</span></span> <span data-ttu-id="7769e-141">Структура фактической статической памяти зависит от используемых процессора, инструментов разработки и базового оборудования.</span><span class="sxs-lookup"><span data-stu-id="7769e-141">The actual static memory layout is specific to the processor, development tools, and the underlying hardware.</span></span>

<span data-ttu-id="7769e-142">В области инструкций содержатся все инструкции процессора для программы.</span><span class="sxs-lookup"><span data-stu-id="7769e-142">The instruction area contains all of the program's processor instructions.</span></span> <span data-ttu-id="7769e-143">Эта область обычно является самой крупной и часто размещается в ПЗУ.</span><span class="sxs-lookup"><span data-stu-id="7769e-143">This area is typically the largest and is often located in ROM.</span></span>

<span data-ttu-id="7769e-144">Область констант содержит различные скомпилированные константы, включая строки, определения которых или ссылки на которые указаны в программе.</span><span class="sxs-lookup"><span data-stu-id="7769e-144">The constant area contains various compiled constants, including strings defined or referenced within the program.</span></span> <span data-ttu-id="7769e-145">Кроме того, эта область содержит "начальную копию" области инициализированных данных.</span><span class="sxs-lookup"><span data-stu-id="7769e-145">In addition, this area contains the "initial copy" of the initialized data area.</span></span> <span data-ttu-id="7769e-146">В процессе инициализации в компиляторе для *использования памяти* эта часть области констант используется для настройки инициализированных данных в ОЗУ.</span><span class="sxs-lookup"><span data-stu-id="7769e-146">During the *Memory Usage* compiler's initialization process, this portion of the constant area is used to set up the initialized data area in RAM.</span></span> <span data-ttu-id="7769e-147">Область констант обычно следует за областью инструкций и часто размещается в ПЗУ.</span><span class="sxs-lookup"><span data-stu-id="7769e-147">The constant area usually follows the instruction area and is often located in ROM.</span></span>

<span data-ttu-id="7769e-148">Области инициализированных и неинициализированных данных содержат все глобальные и статические переменные.</span><span class="sxs-lookup"><span data-stu-id="7769e-148">The initialized data and uninitialized data areas contain all of the global and static variables.</span></span> <span data-ttu-id="7769e-149">Эти области всегда размещаются в ОЗУ.</span><span class="sxs-lookup"><span data-stu-id="7769e-149">These areas are always located in RAM.</span></span>

<span data-ttu-id="7769e-150">Системный стек обычно настраивается сразу после областей инициализированных и неинициализированных данных.</span><span class="sxs-lookup"><span data-stu-id="7769e-150">The system stack is generally set up immediately following the initialized and uninitialized data areas.</span></span>

<span data-ttu-id="7769e-151">Системный стек используется компилятором во время инициализации, а затем — системой ThreadX во время инициализации, после чего применяется при обработке ISR.</span><span class="sxs-lookup"><span data-stu-id="7769e-151">The system stack is used by the compiler during initialization, then by ThreadX during initialization and, subsequently, in ISR processing.</span></span>

![Пример области памяти](./media/user-guide/memory-area-example.png)

<span data-ttu-id="7769e-153">**РИСУНОК 3. Пример области памяти**</span><span class="sxs-lookup"><span data-stu-id="7769e-153">**FIGURE 3. Memory Area Example**</span></span>

### <a name="dynamic-memory-usage"></a><span data-ttu-id="7769e-154">Использование динамической памяти</span><span class="sxs-lookup"><span data-stu-id="7769e-154">Dynamic Memory Usage</span></span>

<span data-ttu-id="7769e-155">Как упоминалось ранее, использование динамической памяти контролируется непосредственно приложением.</span><span class="sxs-lookup"><span data-stu-id="7769e-155">As mentioned before, dynamic memory usage is under direct control of the application.</span></span> <span data-ttu-id="7769e-156">Блоки управления и области памяти, связанные со стеками, очередями и пулами памяти, можно разместить в любом месте в области памяти на целевом оборудовании.</span><span class="sxs-lookup"><span data-stu-id="7769e-156">Control blocks and memory areas associated with stacks, queues, and memory pools can be placed anywhere in the target's memory space.</span></span> <span data-ttu-id="7769e-157">Это важная возможность, так как она упрощает использование различных типов физической памяти.</span><span class="sxs-lookup"><span data-stu-id="7769e-157">This is an important feature because it facilitates easy utilization of different types of physical memory.</span></span>

<span data-ttu-id="7769e-158">Например, предположим, что целевая аппаратная среда использует как быстродействующую, так и медленнодействующую память.</span><span class="sxs-lookup"><span data-stu-id="7769e-158">For example, suppose a target hardware environment has both fast memory and slow memory.</span></span> <span data-ttu-id="7769e-159">Если приложению требуется дополнительная производительность для обработки потока с высоким приоритетом, его блок управления (TX_THREAD) и стек можно поместить в область быстродействующей памяти, что может значительно повысить производительность.</span><span class="sxs-lookup"><span data-stu-id="7769e-159">If the application needs extra performance for a high-priority thread, its control block (TX_THREAD) and stack can be placed in the fast memory area, which may greatly enhance its performance.</span></span>

## <a name="initialization"></a><span data-ttu-id="7769e-160">Инициализация</span><span class="sxs-lookup"><span data-stu-id="7769e-160">Initialization</span></span>

<span data-ttu-id="7769e-161">Важно понимать, как происходит процесс инициализации.</span><span class="sxs-lookup"><span data-stu-id="7769e-161">Understanding the initialization process is important.</span></span> <span data-ttu-id="7769e-162">В ходе его выполнения настраивается начальная аппаратная среда.</span><span class="sxs-lookup"><span data-stu-id="7769e-162">The initial hardware environment is set up here.</span></span> <span data-ttu-id="7769e-163">Кроме того, при инициализации приложение получает свои начальные параметры.</span><span class="sxs-lookup"><span data-stu-id="7769e-163">In addition, this is where the application is given its initial personality.</span></span>

> [!NOTE]
> <span data-ttu-id="7769e-164">*ThreadX пытается использовать (по возможности) полный процесс инициализации инструмента разработки. Это упрощает обновление до новых версий инструментов разработки в будущем.*</span><span class="sxs-lookup"><span data-stu-id="7769e-164">*ThreadX attempts to utilize (whenever possible) the complete development tool's initialization process. This makes it easier to upgrade to new versions of the development tools in the future.*</span></span>

### <a name="system-reset-vector"></a><span data-ttu-id="7769e-165">Вектор сброса системы</span><span class="sxs-lookup"><span data-stu-id="7769e-165">System Reset Vector</span></span>

<span data-ttu-id="7769e-166">Все микропроцессоры имеют логику сброса.</span><span class="sxs-lookup"><span data-stu-id="7769e-166">All microprocessors have reset logic.</span></span> <span data-ttu-id="7769e-167">Когда происходит сброс (аппаратный или программный), адрес точки входа приложения извлекается из определенного расположения в памяти.</span><span class="sxs-lookup"><span data-stu-id="7769e-167">When a reset occurs (either hardware or software), the address of the application's entry point is retrieved from a specific memory location.</span></span> <span data-ttu-id="7769e-168">После получения точки входа процессор передает управление в это расположение.</span><span class="sxs-lookup"><span data-stu-id="7769e-168">After the entry point is retrieved, the processor transfers control to that location.</span></span> <span data-ttu-id="7769e-169">Точка входа приложения довольно часто программируется на языке ассемблера и обычно предоставляется инструментами разработки (по крайней мере в виде шаблона).</span><span class="sxs-lookup"><span data-stu-id="7769e-169">The application entry point is quite often written in the native assembly language and is usually supplied by the development tools (at least in template form).</span></span> <span data-ttu-id="7769e-170">В некоторых случаях в ThreadX предоставляется специальная версия программы входа.</span><span class="sxs-lookup"><span data-stu-id="7769e-170">In some cases, a special version of the entry program is supplied with ThreadX.</span></span>

### <a name="development-tool-initialization"></a><span data-ttu-id="7769e-171">Инициализация инструментов разработки</span><span class="sxs-lookup"><span data-stu-id="7769e-171">Development Tool Initialization</span></span>

<span data-ttu-id="7769e-172">После завершения инициализации низкого уровня управление передается инструменту разработки для инициализации высокого уровня.</span><span class="sxs-lookup"><span data-stu-id="7769e-172">After the low-level initialization is complete, control transfers to the development tool's high-level initialization.</span></span> <span data-ttu-id="7769e-173">Обычно на этом этапе настраиваются инициализированные глобальные и статические переменные C.</span><span class="sxs-lookup"><span data-stu-id="7769e-173">This is usually the place where initialized global and static C variables are set up.</span></span> <span data-ttu-id="7769e-174">Напомним, что их исходные значения извлекаются из области констант.</span><span class="sxs-lookup"><span data-stu-id="7769e-174">Remember their initial values are retrieved from the constant area.</span></span> <span data-ttu-id="7769e-175">Особенности инициализации зависят от конкретного инструмента разработки.</span><span class="sxs-lookup"><span data-stu-id="7769e-175">Exact initialization processing is development tool specific.</span></span>

### <a name="main-function"></a><span data-ttu-id="7769e-176">Функция main</span><span class="sxs-lookup"><span data-stu-id="7769e-176">main Function</span></span>

<span data-ttu-id="7769e-177">После завершения инициализации инструмента разработки управление передается в функцию *main*, предоставляемую пользователем.</span><span class="sxs-lookup"><span data-stu-id="7769e-177">When the development tool initialization is complete, control transfers to the user-supplied *main* function.</span></span> <span data-ttu-id="7769e-178">На этом этапе приложение определяет, что произойдет дальше.</span><span class="sxs-lookup"><span data-stu-id="7769e-178">At this point, the application controls what happens next.</span></span> <span data-ttu-id="7769e-179">Для большинства приложений функция main просто вызывает функцию *tx_kernel_enter*, которая выполняет вход в ThreadX.</span><span class="sxs-lookup"><span data-stu-id="7769e-179">For most applications, the main function simply calls *tx_kernel_enter*, which is the entry into ThreadX.</span></span> <span data-ttu-id="7769e-180">Однако перед входом в ThreadX приложения могут выполнять предварительную обработку (обычно для инициализации оборудования).</span><span class="sxs-lookup"><span data-stu-id="7769e-180">However, applications can perform preliminary processing (usually for hardware initialization) prior to entering ThreadX.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="7769e-181">*Вызов tx_kernel_enter не возвращает управление, поэтому обработка после него не выполняется.*</span><span class="sxs-lookup"><span data-stu-id="7769e-181">*The call to tx_kernel_enter does not return, so do not place any processing after it.*</span></span>

### <a name="tx_kernel_enter"></a><span data-ttu-id="7769e-182">tx_kernel_enter</span><span class="sxs-lookup"><span data-stu-id="7769e-182">tx_kernel_enter</span></span>

<span data-ttu-id="7769e-183">Функция входа координирует инициализацию различных внутренних структур данных ThreadX, а затем вызывает функцию определения приложения, ***tx_application_define***.</span><span class="sxs-lookup"><span data-stu-id="7769e-183">The entry function coordinates initialization of various internal ThreadX data structures and then calls the application's definition function ***tx_application_define***.</span></span>

<span data-ttu-id="7769e-184">Когда функция ***tx_application_define*** возвращает результат, управление передается в цикл планирования потоков.</span><span class="sxs-lookup"><span data-stu-id="7769e-184">When ***tx_application_define*** returns, control is transferred to the thread scheduling loop.</span></span> <span data-ttu-id="7769e-185">Это свидетельствует о завершении инициализации.</span><span class="sxs-lookup"><span data-stu-id="7769e-185">This marks the end of initialization.</span></span>

### <a name="application-definition-function"></a><span data-ttu-id="7769e-186">Функция определения приложения</span><span class="sxs-lookup"><span data-stu-id="7769e-186">Application Definition Function</span></span>

<span data-ttu-id="7769e-187">Функция ***tx_application_define*** определяет все начальные потоки, очереди, семафоры, мьютексы, флаги событий, пулы памяти и таймеры приложения.</span><span class="sxs-lookup"><span data-stu-id="7769e-187">The ***tx_application_define*** function defines all of the initial application threads, queues, semaphores, mutexes, event flags, memory pools, and timers.</span></span> <span data-ttu-id="7769e-188">Можно также создавать и удалять ресурсы системы из потоков во время нормальной работы приложения.</span><span class="sxs-lookup"><span data-stu-id="7769e-188">It is also possible to create and delete system resources from threads during the normal operation of the application.</span></span> <span data-ttu-id="7769e-189">Однако все начальные ресурсы приложения определяются этой функцией.</span><span class="sxs-lookup"><span data-stu-id="7769e-189">However, all initial application resources are defined here.</span></span>

<span data-ttu-id="7769e-190">Функция **tx_application_define** имеет один входной параметр, о котором, безусловно, стоит упомянуть.</span><span class="sxs-lookup"><span data-stu-id="7769e-190">The \***tx_application_define** _ function has a single input parameter and it is certainly worth mentioning.</span></span> <span data-ttu-id="7769e-191">Единственным входным параметром этой функции является адрес ОЗУ _first-available\*.</span><span class="sxs-lookup"><span data-stu-id="7769e-191">The _first-available\* RAM address is the sole input parameter to this function.</span></span> <span data-ttu-id="7769e-192">Обычно он используется в качестве отправной точки при начальном выделении памяти среды выполнения для стеков потоков, очередей и пулов памяти.</span><span class="sxs-lookup"><span data-stu-id="7769e-192">It is typically used as a starting point for initial run-time memory allocations of thread stacks, queues, and memory pools.</span></span>

> [!NOTE]
> <span data-ttu-id="7769e-193">*После завершения инициализации только выполняющийся поток может создавать и удалять системные ресурсы, включая другие потоки. Поэтому во время инициализации необходимо создать хотя бы один поток.*</span><span class="sxs-lookup"><span data-stu-id="7769e-193">*After initialization is complete, only an executing thread can create and delete system resources— including other threads. Therefore, at least one thread must be created during initialization.*</span></span>

### <a name="interrupts"></a><span data-ttu-id="7769e-194">Прерывания</span><span class="sxs-lookup"><span data-stu-id="7769e-194">Interrupts</span></span>

<span data-ttu-id="7769e-195">Прерывания остаются отключенными в ходе всего процесса инициализации.</span><span class="sxs-lookup"><span data-stu-id="7769e-195">Interrupts are left disabled during the entire initialization process.</span></span> <span data-ttu-id="7769e-196">Если приложение каким-либо образом включит прерывания, это может привести к непредсказуемому поведению.</span><span class="sxs-lookup"><span data-stu-id="7769e-196">If the application somehow enables interrupts, unpredictable behavior may occur.</span></span> <span data-ttu-id="7769e-197">На рисунке 4 показан весь процесс инициализации — от сброса системы до инициализации конкретного приложения.</span><span class="sxs-lookup"><span data-stu-id="7769e-197">Figure 4 shows the entire initialization process, from system reset through application-specific initialization.</span></span>

## <a name="thread-execution"></a><span data-ttu-id="7769e-198">Выполнение потока</span><span class="sxs-lookup"><span data-stu-id="7769e-198">Thread Execution</span></span>

<span data-ttu-id="7769e-199">Планирование и выполнение потоков приложения — наиболее важная задача ThreadX.</span><span class="sxs-lookup"><span data-stu-id="7769e-199">Scheduling and executing application threads is the most important activity of ThreadX.</span></span> <span data-ttu-id="7769e-200">Поток обычно определяется в виде частично независимого сегмента программы с конкретной целью.</span><span class="sxs-lookup"><span data-stu-id="7769e-200">A thread is typically defined as a semi-independent program segment with a dedicated purpose.</span></span> <span data-ttu-id="7769e-201">Объединенная обработка всех потоков формирует приложение.</span><span class="sxs-lookup"><span data-stu-id="7769e-201">The combined processing of all threads makes an application.</span></span>

<span data-ttu-id="7769e-202">Потоки создаются динамически путем вызова функции \***tx_thread_create** _ во время инициализации или выполнения потока.</span><span class="sxs-lookup"><span data-stu-id="7769e-202">Threads are created dynamically by calling \***tx_thread_create** _ during initialization or during thread execution.</span></span> <span data-ttu-id="7769e-203">Потоки создаются в состоянии готовности (_ready\*) или *приостановки*.</span><span class="sxs-lookup"><span data-stu-id="7769e-203">Threads are created in either a _ready\* or *suspended* state.</span></span>

![Процесс инициализации](./media/user-guide/initialization-process.png)

<span data-ttu-id="7769e-205">**РИСУНОК 4. Процесс инициализации**</span><span class="sxs-lookup"><span data-stu-id="7769e-205">**FIGURE 4. Initialization Process**</span></span>

### <a name="thread-execution-states"></a><span data-ttu-id="7769e-206">Состояния выполнения потока</span><span class="sxs-lookup"><span data-stu-id="7769e-206">Thread Execution States</span></span>

<span data-ttu-id="7769e-207">Понимание различных состояний обработки потоков играет ключевую роль для понимания всей многопоточной среды.</span><span class="sxs-lookup"><span data-stu-id="7769e-207">Understanding the different processing states of threads is a key ingredient to understanding the entire multithreaded environment.</span></span> <span data-ttu-id="7769e-208">В ThreadX используются пять отдельных состояний потока: *готов*, *приостановлен*, *выполняется*, *завершен* и *выполнен*.</span><span class="sxs-lookup"><span data-stu-id="7769e-208">In ThreadX there are five distinct thread states: *ready*, *suspended*, *executing*, *terminated*, and *completed*.</span></span> <span data-ttu-id="7769e-209">На рисунке 5 показана схема перехода состояния потока в ThreadX.</span><span class="sxs-lookup"><span data-stu-id="7769e-209">Figure 5 shows the thread state transition diagram for ThreadX.</span></span>

![Переход состояния потока](./media/user-guide/thread-state-transition.png)

<span data-ttu-id="7769e-211">**РИСУНОК 5. Переход состояния потока**</span><span class="sxs-lookup"><span data-stu-id="7769e-211">**FIGURE 5. Thread State Transition**</span></span>

<span data-ttu-id="7769e-212">Поток находится в состоянии *готов*, когда он готов к выполнению.</span><span class="sxs-lookup"><span data-stu-id="7769e-212">A thread is in a *ready* state when it is ready for execution.</span></span> <span data-ttu-id="7769e-213">Готовый поток не выполняется, пока не станет потоком с наивысшим приоритетом в состоянии готовности.</span><span class="sxs-lookup"><span data-stu-id="7769e-213">A ready thread is not executed until it is the highest priority thread in ready state.</span></span> <span data-ttu-id="7769e-214">В этом случае ThreadX его выполняет и он переходит в состояние *выполняется*.</span><span class="sxs-lookup"><span data-stu-id="7769e-214">When this happens, ThreadX executes the thread, which then changes its state to *executing*.</span></span>

<span data-ttu-id="7769e-215">Если поток с более высоким приоритетом перейдет в состояние готовности, выполняющийся поток вернется в состояние *готов*.</span><span class="sxs-lookup"><span data-stu-id="7769e-215">If a higher-priority thread becomes ready, the executing thread reverts back to a *ready* state.</span></span> <span data-ttu-id="7769e-216">Затем будет выполнен новый готовый поток с высоким приоритетом, который перейдет в логическое состояние *выполняется*.</span><span class="sxs-lookup"><span data-stu-id="7769e-216">The newly ready high-priority thread is then executed, which changes its logical state to *executing*.</span></span> <span data-ttu-id="7769e-217">Переход между состоянием *готов* и *выполняется* происходит при каждом вытеснении потока.</span><span class="sxs-lookup"><span data-stu-id="7769e-217">This transition between *ready* and *executing* states occurs every time thread preemption occurs.</span></span>

<span data-ttu-id="7769e-218">В определенный момент времени в состоянии *выполняется* может находиться только один поток.</span><span class="sxs-lookup"><span data-stu-id="7769e-218">At any given moment, only one thread is in an *executing* state.</span></span> <span data-ttu-id="7769e-219">Это происходит потому, что поток в состоянии *выполняется* управляет базовым процессором.</span><span class="sxs-lookup"><span data-stu-id="7769e-219">This is because a thread in the *executing* state has control of the underlying processor.</span></span>

<span data-ttu-id="7769e-220">Потоки в состоянии *приостановлен* не могут быть выполнены.</span><span class="sxs-lookup"><span data-stu-id="7769e-220">Threads in a *suspended* state are not eligible for execution.</span></span> <span data-ttu-id="7769e-221">Причинами перехода в состояние *приостановлен* могут быть временная приостановка, сообщения очереди, семафоры, мьютексы, флаги событий, память и приостановка основного потока.</span><span class="sxs-lookup"><span data-stu-id="7769e-221">Reasons for being in a *suspended* state include suspension for time, queue messages, semaphores, mutexes, event flags, memory, and basic thread suspension.</span></span> <span data-ttu-id="7769e-222">После устранения причины приостановки поток возвращается в состояние *готов*.</span><span class="sxs-lookup"><span data-stu-id="7769e-222">After the cause for suspension is removed, the thread is placed back in a *ready* state.</span></span>

<span data-ttu-id="7769e-223">Поток в состоянии *выполнен* — это поток, который завершил обработку и возвратил результат из своей функции входа.</span><span class="sxs-lookup"><span data-stu-id="7769e-223">A thread in a *completed* state is a thread that has completed its processing and returned from its entry function.</span></span> <span data-ttu-id="7769e-224">Функция входа указывается во время создания потока.</span><span class="sxs-lookup"><span data-stu-id="7769e-224">The entry function is specified during thread creation.</span></span> <span data-ttu-id="7769e-225">Поток в состоянии *выполнен* не может быть выполнен повторно.</span><span class="sxs-lookup"><span data-stu-id="7769e-225">A thread in a *completed* state cannot execute again.</span></span>

<span data-ttu-id="7769e-226">Поток находится в состоянии *завершен*, если он сам или другой поток вызвал службу *tx_thread_terminate*.</span><span class="sxs-lookup"><span data-stu-id="7769e-226">A thread is in a *terminated* state because another thread or the thread itself called the *tx_thread_terminate* service.</span></span> <span data-ttu-id="7769e-227">Поток в состоянии *завершен* не может быть выполнен повторно.</span><span class="sxs-lookup"><span data-stu-id="7769e-227">A thread in a *terminated* state cannot execute again.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="7769e-228">*Если требуется перезапустить выполненный или завершенный поток, приложение должно сначала удалить поток. Затем его можно повторно создать и повторно запустить.*</span><span class="sxs-lookup"><span data-stu-id="7769e-228">*If re-starting a completed or terminated thread is desired, the application must first delete the thread. It can then be re-created and re-started.*</span></span>

### <a name="thread-entryexit-notification"></a><span data-ttu-id="7769e-229">Уведомление о входе и выходе в потоке</span><span class="sxs-lookup"><span data-stu-id="7769e-229">Thread Entry/Exit Notification</span></span>

<span data-ttu-id="7769e-230">Некоторые приложения могут отправлять уведомления о том, что определенный поток выполнил вход в первый раз, был выполнен или завершен.</span><span class="sxs-lookup"><span data-stu-id="7769e-230">Some applications may find it advantageous to be notified when a specific thread is entered for the first time, when it completes, or is terminated.</span></span> <span data-ttu-id="7769e-231">ThreadX обеспечивает эту возможность с помощью службы ***tx_thread_entry_exit_notify***.</span><span class="sxs-lookup"><span data-stu-id="7769e-231">ThreadX provides this ability through the ***tx_thread_entry_exit_notify*** service.</span></span> <span data-ttu-id="7769e-232">Эта служба регистрирует функцию уведомления приложения для определенного потока, которая вызывается ThreadX всякий раз, когда этот поток начал выполнение, выполнен или завершен.</span><span class="sxs-lookup"><span data-stu-id="7769e-232">This service registers an application notification function for a specific thread, which is called by ThreadX whenever the thread starts running, completes, or is terminated.</span></span> <span data-ttu-id="7769e-233">После вызова функция уведомления приложения может выполнить специализированную обработку для приложения.</span><span class="sxs-lookup"><span data-stu-id="7769e-233">After being invoked, the application notification function can perform the application-specific processing.</span></span> <span data-ttu-id="7769e-234">Обычно это подразумевает информирование другого потока приложения о событии с помощью примитива синхронизации ThreadX.</span><span class="sxs-lookup"><span data-stu-id="7769e-234">This typically involves informing another application thread of the event via a ThreadX synchronization primitive.</span></span>

### <a name="thread-priorities"></a><span data-ttu-id="7769e-235">Приоритеты потоков</span><span class="sxs-lookup"><span data-stu-id="7769e-235">Thread Priorities</span></span>

<span data-ttu-id="7769e-236">Как было сказано ранее, поток — это частично независимый сегмент программы с определенной целью.</span><span class="sxs-lookup"><span data-stu-id="7769e-236">As mentioned before, a thread is a semi-independent program segment with a dedicated purpose.</span></span> <span data-ttu-id="7769e-237">Однако потоки не идентичны с точки зрения приоритетности задач, которые они выполняют.</span><span class="sxs-lookup"><span data-stu-id="7769e-237">However, all threads are not created equal!</span></span> <span data-ttu-id="7769e-238">Одни потоки гораздо важнее других.</span><span class="sxs-lookup"><span data-stu-id="7769e-238">The dedicated purpose of some threads is much more important than others.</span></span> <span data-ttu-id="7769e-239">Такая разная важность потоков присуща внедренным приложениям реального времени.</span><span class="sxs-lookup"><span data-stu-id="7769e-239">This heterogeneous type of thread importance is a hallmark of embedded realtime applications.</span></span>

<span data-ttu-id="7769e-240">ThreadX определяет важность потока при создании, назначая ему числовое значение *приоритета*.</span><span class="sxs-lookup"><span data-stu-id="7769e-240">ThreadX determines a thread's importance when the thread is created by assigning a numerical value representing its *priority*.</span></span> <span data-ttu-id="7769e-241">В ThreadX можно настроить максимальное число приоритетов от 32 до 1024 с шагом 32.</span><span class="sxs-lookup"><span data-stu-id="7769e-241">The maximum number of ThreadX priorities is configurable from 32 through 1024 in increments of 32.</span></span> <span data-ttu-id="7769e-242">Фактическое максимальное число приоритетов определяется константой **TX_MAX_PRIORITIES** во время компиляции библиотеки ThreadX.</span><span class="sxs-lookup"><span data-stu-id="7769e-242">The actual maximum number of priorities is determined by the **TX_MAX_PRIORITIES** constant during compilation of the ThreadX library.</span></span> <span data-ttu-id="7769e-243">Наличие большего количества приоритетов не приводит к значительному увеличению временных затрат на обработку.</span><span class="sxs-lookup"><span data-stu-id="7769e-243">Having a larger number of priorities does not significantly increase processing overhead.</span></span> <span data-ttu-id="7769e-244">Однако для управления каждой группой из 32 уровней приоритета требуются дополнительные 128 байтов ОЗУ.</span><span class="sxs-lookup"><span data-stu-id="7769e-244">However, for each group of 32 priority levels an additional 128 bytes of RAM is required to manage them.</span></span> <span data-ttu-id="7769e-245">Например, для 32 уровней приоритета требуются 128 байтов ОЗУ, для 64 уровней приоритета — 256 байтов ОЗУ, а для 96 уровней приоритета — 384 байта ОЗУ.</span><span class="sxs-lookup"><span data-stu-id="7769e-245">For example, 32 priority levels require 128 bytes of RAM, 64 priority levels require 256 bytes of RAM, and 96 priority levels requires 384 bytes of RAM.</span></span>

<span data-ttu-id="7769e-246">По умолчанию ThreadX использует 32 уровня приоритета, от 0 до 31.</span><span class="sxs-lookup"><span data-stu-id="7769e-246">By default, ThreadX has 32 priority levels, ranging from priority 0 through priority 31.</span></span> <span data-ttu-id="7769e-247">Чем ниже числовое значение, тем выше приоритет.</span><span class="sxs-lookup"><span data-stu-id="7769e-247">Numerically smaller values imply higher priority.</span></span> <span data-ttu-id="7769e-248">Таким образом, приоритет 0 наивысший, а приоритет (**TX_MAX_PRIORITIES**–1) самый низкий.</span><span class="sxs-lookup"><span data-stu-id="7769e-248">Hence, priority 0 represents the highest priority, while priority (**TX_MAX_PRIORITIES**-1) represents the lowest priority.</span></span>

<span data-ttu-id="7769e-249">Несколько потоков могут иметь одинаковый приоритет при совместном планировании или использовании временных срезов.</span><span class="sxs-lookup"><span data-stu-id="7769e-249">Multiple threads can have the same priority relying on cooperative scheduling or time-slicing.</span></span> <span data-ttu-id="7769e-250">Кроме того, приоритеты потоков можно изменить во время выполнения.</span><span class="sxs-lookup"><span data-stu-id="7769e-250">In addition, thread priorities can be changed during run-time.</span></span>

### <a name="thread-scheduling"></a><span data-ttu-id="7769e-251">Планирование потоков</span><span class="sxs-lookup"><span data-stu-id="7769e-251">Thread Scheduling</span></span>

<span data-ttu-id="7769e-252">ThreadX планирует потоки в зависимости от их приоритета.</span><span class="sxs-lookup"><span data-stu-id="7769e-252">ThreadX schedules threads based on their priority.</span></span> <span data-ttu-id="7769e-253">Сначала выполняется готовый поток с наивысшим приоритетом.</span><span class="sxs-lookup"><span data-stu-id="7769e-253">The ready thread with the highest priority is executed first.</span></span> <span data-ttu-id="7769e-254">Если готово несколько потоков с одинаковым приоритетом, они выполняются по принципу *первым поступил — первым обслужен* (FIFO).</span><span class="sxs-lookup"><span data-stu-id="7769e-254">If multiple threads of the same priority are ready, they are executed in a *first-in-first-out* (FIFO) manner.</span></span>

### <a name="round-robin-scheduling"></a><span data-ttu-id="7769e-255">Планирование с использованием циклического перебора</span><span class="sxs-lookup"><span data-stu-id="7769e-255">Round-robin Scheduling</span></span>

<span data-ttu-id="7769e-256">ThreadX поддерживает планирование с *циклическим перебором* нескольких потоков, имеющих одинаковый приоритет.</span><span class="sxs-lookup"><span data-stu-id="7769e-256">ThreadX supports *round-robin* scheduling of multiple threads having the same priority.</span></span> <span data-ttu-id="7769e-257">Для этого используются совместные вызовы службы \***tx_thread_relinquish** _.</span><span class="sxs-lookup"><span data-stu-id="7769e-257">This is accomplished through cooperative calls to \***tx_thread_relinquish** _.</span></span> <span data-ttu-id="7769e-258">Эта служба предоставляет всем другим готовым потокам с таким же приоритетом возможность выполнения, прежде чем снова будет выполнена вызывающая служба _ \*_tx_thread_relinquish_\*\*.</span><span class="sxs-lookup"><span data-stu-id="7769e-258">This service gives all other ready threads of the same priority a chance to execute before the _ *_tx_thread_relinquish_*\* caller executes again.</span></span>

### <a name="time-slicing"></a><span data-ttu-id="7769e-259">Временные срезы</span><span class="sxs-lookup"><span data-stu-id="7769e-259">Time-Slicing</span></span>

<span data-ttu-id="7769e-260">*Временные срезы* — это еще один тип планирования с циклическим перебором.</span><span class="sxs-lookup"><span data-stu-id="7769e-260">*Time-slicing* is another form of round-robin scheduling.</span></span> <span data-ttu-id="7769e-261">Временной срез определяет максимальное количество тактов таймера (прерываний таймера), которые поток может выполнять, не отдавая управление процессором.</span><span class="sxs-lookup"><span data-stu-id="7769e-261">A time-slice specifies the maximum number of timer ticks (timer interrupts) that a thread can execute without giving up the processor.</span></span> <span data-ttu-id="7769e-262">В ThreadX временные срезы задаются отдельно для каждого потока.</span><span class="sxs-lookup"><span data-stu-id="7769e-262">In ThreadX, time-slicing is available on a per-thread basis.</span></span> <span data-ttu-id="7769e-263">Временной срез потока назначается во время создания и может быть изменен во время выполнения.</span><span class="sxs-lookup"><span data-stu-id="7769e-263">The thread's time-slice is assigned during creation and can be modified during run-time.</span></span> <span data-ttu-id="7769e-264">По истечении срока действия временного среза все остальные готовые потоки с таким же уровнем приоритета получают шанс выполнения до того, как этот поток с временным срезом будет выполнен повторно.</span><span class="sxs-lookup"><span data-stu-id="7769e-264">When a time-slice expires, all other ready threads of the same priority level are given a chance to execute before the time-sliced thread executes again.</span></span>

<span data-ttu-id="7769e-265">После приостановки или освобождения потока, вызова им службы ThreadX для вытеснения, а также после того, как поток сам изменит свой временной срез, ему назначается новый временной срез.</span><span class="sxs-lookup"><span data-stu-id="7769e-265">A fresh thread time-slice is given to a thread after it suspends, relinquishes, makes a ThreadX service call that causes preemption, or is itself time-sliced.</span></span>

<span data-ttu-id="7769e-266">Если поток с временным срезом будет вытеснен, он возобновится до других готовых потоков с таким же приоритетом и будет выполняться оставшуюся часть своего временного среза.</span><span class="sxs-lookup"><span data-stu-id="7769e-266">When a time-sliced thread is preempted, it will resume before other ready threads of equal priority for the remainder of its time-slice.</span></span>

> [!NOTE]
> <span data-ttu-id="7769e-267">*Использование временного среза приводит к незначительным системным издержкам. Так как временной срез полезен только в случаях, когда несколько потоков имеют одинаковый приоритет, его не следует назначать потокам с уникальными приоритетами.*</span><span class="sxs-lookup"><span data-stu-id="7769e-267">*Using time-slicing results in a slight amount of system overhead. Because time-slicing is only useful in cases in which multiple threads share the same priority, threads having a unique priority should not be assigned a time-slice.*</span></span>

### <a name="preemption"></a><span data-ttu-id="7769e-268">Вытеснение</span><span class="sxs-lookup"><span data-stu-id="7769e-268">Preemption</span></span>

<span data-ttu-id="7769e-269">Вытеснение — это процесс временного прерывания выполнения потока в пользу потока с более высоким приоритетом.</span><span class="sxs-lookup"><span data-stu-id="7769e-269">Preemption is the process of temporarily interrupting an executing thread in favor of a higher-priority thread.</span></span> <span data-ttu-id="7769e-270">Этот процесс невидим для выполняющегося потока.</span><span class="sxs-lookup"><span data-stu-id="7769e-270">This process is invisible to the executing thread.</span></span> <span data-ttu-id="7769e-271">После выполнения потока с более высоким приоритетом управление возвращается именно тому потоку, на котором произошло вытеснение.</span><span class="sxs-lookup"><span data-stu-id="7769e-271">When the higher-priority thread is finished, control is transferred back to the exact place where the preemption took place.</span></span> <span data-ttu-id="7769e-272">Это очень важная функция в системах реального времени, так как она упрощает быстрое реагирование на важные события приложений.</span><span class="sxs-lookup"><span data-stu-id="7769e-272">This is a very important feature in real-time systems because it facilitates fast response to important application events.</span></span> <span data-ttu-id="7769e-273">Хотя это очень важная функция, вытеснение может также быть источником различных проблем, включая нехватку ресурсов, чрезмерную нагрузку и инверсию приоритета.</span><span class="sxs-lookup"><span data-stu-id="7769e-273">Although a very important feature, preemption can also be a source of a variety of problems, including starvation, excessive overhead, and priority inversion.</span></span>

### <a name="preemption-thresholdtrade"></a><span data-ttu-id="7769e-274">Возможность Preemption Threshold&trade;</span><span class="sxs-lookup"><span data-stu-id="7769e-274">Preemption Threshold&trade;</span></span>

<span data-ttu-id="7769e-275">Чтобы устранить некоторые проблемы, связанные с вытеснением, ThreadX предоставляет уникальную расширенную возможность, называемую *preemption-threshold* (порог вытеснения).</span><span class="sxs-lookup"><span data-stu-id="7769e-275">To ease some of the inherent problems of preemption, ThreadX provides a unique and advanced feature called *preemption-threshold*.</span></span>

<span data-ttu-id="7769e-276">Порог вытеснения позволяет потоку указать *порог* приоритета для отключения вытеснения.</span><span class="sxs-lookup"><span data-stu-id="7769e-276">A preemption-threshold allows a thread to specify a priority *ceiling* for disabling preemption.</span></span> <span data-ttu-id="7769e-277">Потоки, имеющие приоритет выше этого порога, по-прежнему могут быть вытеснены, а потоки, приоритет которых ниже данного порога, не вытесняются.</span><span class="sxs-lookup"><span data-stu-id="7769e-277">Threads that have higher priorities than the ceiling are still allowed to preempt, while those less than the ceiling are not allowed to preempt.</span></span>

<span data-ttu-id="7769e-278">Например, предположим, что поток с приоритетом 20 взаимодействует с группой потоков, имеющих приоритеты от 15 до 20.</span><span class="sxs-lookup"><span data-stu-id="7769e-278">For example, suppose a thread of priority 20 only interacts with a group of threads that have priorities between 15 and 20.</span></span> <span data-ttu-id="7769e-279">При выполнении критических разделов поток с приоритетом 20 может установить порог вытеснения, равный 15, тем самым предотвращая вытеснение любыми потоками, с которыми он взаимодействует.</span><span class="sxs-lookup"><span data-stu-id="7769e-279">During its critical sections, the thread of priority 20 can set its preemption-threshold to 15, thereby preventing preemption from all of the threads that it interacts with.</span></span> <span data-ttu-id="7769e-280">Очень важные потоки (с приоритетом от 0 до 14) по-прежнему смогут вытеснить этот поток во время обработки его критических разделов, что обеспечит более адаптивную обработку.</span><span class="sxs-lookup"><span data-stu-id="7769e-280">This still permits really important threads (priorities between 0 and 14) to preempt this thread during its critical section processing, which results in much more responsive processing.</span></span>

<span data-ttu-id="7769e-281">Разумеется, поток может отключить любое вытеснение, установив порог вытеснения, равный 0.</span><span class="sxs-lookup"><span data-stu-id="7769e-281">Of course, it is still possible for a thread to disable all preemption by setting its preemption-threshold to 0.</span></span> <span data-ttu-id="7769e-282">Кроме того, порог вытеснения можно изменить во время выполнения.</span><span class="sxs-lookup"><span data-stu-id="7769e-282">In addition, preemption-threshold can be changed during run-time.</span></span>

> [!NOTE]
> <span data-ttu-id="7769e-283">*При использовании порога вытеснения отключаются временные срезы для указанного потока.*</span><span class="sxs-lookup"><span data-stu-id="7769e-283">*Using preemption-threshold disables time-slicing for the specified thread.*</span></span>

### <a name="priority-inheritance"></a><span data-ttu-id="7769e-284">Наследование приоритетов</span><span class="sxs-lookup"><span data-stu-id="7769e-284">Priority Inheritance</span></span>

<span data-ttu-id="7769e-285">ThreadX также поддерживает необязательное наследование приоритета в своих службах мьютексов, описанное далее в этой главе.</span><span class="sxs-lookup"><span data-stu-id="7769e-285">ThreadX also supports optional priority inheritance within its mutex services described later in this chapter.</span></span> <span data-ttu-id="7769e-286">Наследование приоритета позволяет потоку с более низким приоритетом временно принять приоритет потока с более высоким приоритетом, который ожидает мьютекс, принадлежащий к потоку с более низким приоритетом.</span><span class="sxs-lookup"><span data-stu-id="7769e-286">Priority inheritance allows a lower priority thread to temporarily assume the priority of a high priority thread that is waiting for a mutex owned by the lower priority thread.</span></span> <span data-ttu-id="7769e-287">Эта возможность позволяет приложению избежать недетерминированной инверсии приоритета, устраняя вытеснение потоков с промежуточным приоритетом.</span><span class="sxs-lookup"><span data-stu-id="7769e-287">This capability helps the application to avoid nondeterministic priority inversion by eliminating preemption of intermediate thread priorities.</span></span> <span data-ttu-id="7769e-288">Конечно, для получения аналогичного результата можно использовать *порог вытеснения*.</span><span class="sxs-lookup"><span data-stu-id="7769e-288">Of course, *preemption-threshold* may be used to achieve a similar result.</span></span>

### <a name="thread-creation"></a><span data-ttu-id="7769e-289">Создание потока</span><span class="sxs-lookup"><span data-stu-id="7769e-289">Thread Creation</span></span>

<span data-ttu-id="7769e-290">Потоки приложения создаются во время инициализации или во время выполнения других потоков приложения.</span><span class="sxs-lookup"><span data-stu-id="7769e-290">Application threads are created during initialization or during the execution of other application threads.</span></span> <span data-ttu-id="7769e-291">Количество потоков, которые может создать приложение, не ограничено.</span><span class="sxs-lookup"><span data-stu-id="7769e-291">There is no limit on the number of threads that can be created by an application.</span></span>

### <a name="thread-control-block-tx_thread"></a><span data-ttu-id="7769e-292">TX_THREAD: блок управления потока</span><span class="sxs-lookup"><span data-stu-id="7769e-292">Thread Control Block TX_THREAD</span></span>

<span data-ttu-id="7769e-293">Характеристики каждого потока содержатся в его блоке управления.</span><span class="sxs-lookup"><span data-stu-id="7769e-293">The characteristics of each thread are contained in its control block.</span></span> <span data-ttu-id="7769e-294">Эта структура определена в файле ***tx_api.h***.</span><span class="sxs-lookup"><span data-stu-id="7769e-294">This structure is defined in the ***tx_api.h*** file.</span></span>

<span data-ttu-id="7769e-295">Блок управления потока может размещаться в любом месте в памяти, но чаще всего он определяется вне области какой-либо функции, благодаря чему функционирует как глобальная структура.</span><span class="sxs-lookup"><span data-stu-id="7769e-295">A thread's control block can be located anywhere in memory, but it is most common to make the control block a global structure by defining it outside the scope of any function.</span></span>

<span data-ttu-id="7769e-296">Поиск блока управления в других областях требует больших усилий, как и в любой динамически выделяемой памяти.</span><span class="sxs-lookup"><span data-stu-id="7769e-296">Locating the control block in other areas requires a bit more care, just like all dynamically-allocated memory.</span></span> <span data-ttu-id="7769e-297">Если блок управления выделяется в функции C, то связанная с ним память является частью стека вызывающего потока.</span><span class="sxs-lookup"><span data-stu-id="7769e-297">If a control block is allocated within a C function, the memory associated with it is part of the calling thread's stack.</span></span> <span data-ttu-id="7769e-298">Как правило, не следует использовать локальное хранилище для блоков управления, так как после того, как функция возвратит результат, все пространство его стека локальных переменных освобождается, независимо от того, используется ли оно другим потоком для блока управления.</span><span class="sxs-lookup"><span data-stu-id="7769e-298">In general, avoid using local storage for control blocks because after the function returns, all of its local variable stack space is released—regardless of whether another thread is using it for a control block.</span></span>

<span data-ttu-id="7769e-299">В большинстве случаев приложение игнорирует содержимое блока управления потока.</span><span class="sxs-lookup"><span data-stu-id="7769e-299">In most cases, the application is oblivious to the contents of the thread's control block.</span></span> <span data-ttu-id="7769e-300">Однако в некоторых ситуациях, особенно при отладке, полезно изучить определенные элементы.</span><span class="sxs-lookup"><span data-stu-id="7769e-300">However, there are some situations, especially during debug, in which looking at certain members is useful.</span></span> <span data-ttu-id="7769e-301">Ниже приведены некоторые из наиболее полезных элементов блока управления.</span><span class="sxs-lookup"><span data-stu-id="7769e-301">The following are some of the more useful control block members.</span></span>

<span data-ttu-id="7769e-302">**tx_thread_run_count**: содержит счетчик запланированных выполнений потока.</span><span class="sxs-lookup"><span data-stu-id="7769e-302">**tx_thread_run_count** contains a counter of the number of many times the thread has been scheduled.</span></span> <span data-ttu-id="7769e-303">Если значение счетчика увеличилось, это означает, что поток запланирован и выполняется.</span><span class="sxs-lookup"><span data-stu-id="7769e-303">An increasing counter indicates the thread is being scheduled and executed.</span></span>

<span data-ttu-id="7769e-304">**tx_thread_state**: содержит состояние связанного потока.</span><span class="sxs-lookup"><span data-stu-id="7769e-304">**tx_thread_state** contains the state of the associated thread.</span></span> <span data-ttu-id="7769e-305">Ниже перечислены возможные состояния потока.</span><span class="sxs-lookup"><span data-stu-id="7769e-305">The following lists the possible thread states.</span></span>

|  <span data-ttu-id="7769e-306">Состояние потока</span><span class="sxs-lookup"><span data-stu-id="7769e-306">Thread state</span></span>   | <span data-ttu-id="7769e-307">Значение</span><span class="sxs-lookup"><span data-stu-id="7769e-307">Value</span></span> |
| --------------- | ------ |
| <span data-ttu-id="7769e-308">TX_READY</span><span class="sxs-lookup"><span data-stu-id="7769e-308">TX_READY</span></span>       | <span data-ttu-id="7769e-309">(0x00)</span><span class="sxs-lookup"><span data-stu-id="7769e-309">(0x00)</span></span> |
| <span data-ttu-id="7769e-310">TX_COMPLETED</span><span class="sxs-lookup"><span data-stu-id="7769e-310">TX_COMPLETED</span></span>   | <span data-ttu-id="7769e-311">(0x01)</span><span class="sxs-lookup"><span data-stu-id="7769e-311">(0x01)</span></span> |
| <span data-ttu-id="7769e-312">TX_TERMINATED</span><span class="sxs-lookup"><span data-stu-id="7769e-312">TX_TERMINATED</span></span>  | <span data-ttu-id="7769e-313">(0x02)</span><span class="sxs-lookup"><span data-stu-id="7769e-313">(0x02)</span></span> |
| <span data-ttu-id="7769e-314">TX_SUSPENDED</span><span class="sxs-lookup"><span data-stu-id="7769e-314">TX_SUSPENDED</span></span>   | <span data-ttu-id="7769e-315">(0x03)</span><span class="sxs-lookup"><span data-stu-id="7769e-315">(0x03)</span></span> |
| <span data-ttu-id="7769e-316">TX_SLEEP</span><span class="sxs-lookup"><span data-stu-id="7769e-316">TX_SLEEP</span></span>       | <span data-ttu-id="7769e-317">(0x04)</span><span class="sxs-lookup"><span data-stu-id="7769e-317">(0x04)</span></span> |
| <span data-ttu-id="7769e-318">TX_QUEUE_SUSP</span><span class="sxs-lookup"><span data-stu-id="7769e-318">TX_QUEUE_SUSP</span></span> | <span data-ttu-id="7769e-319">(0x05)</span><span class="sxs-lookup"><span data-stu-id="7769e-319">(0x05)</span></span> |
| <span data-ttu-id="7769e-320">TX_SEMAPHORE_SUSP</span><span class="sxs-lookup"><span data-stu-id="7769e-320">TX_SEMAPHORE_SUSP</span></span> | <span data-ttu-id="7769e-321">(0x06)</span><span class="sxs-lookup"><span data-stu-id="7769e-321">(0x06)</span></span> |
| <span data-ttu-id="7769e-322">TX_EVENT_FLAG</span><span class="sxs-lookup"><span data-stu-id="7769e-322">TX_EVENT_FLAG</span></span>   | <span data-ttu-id="7769e-323">(0x07)</span><span class="sxs-lookup"><span data-stu-id="7769e-323">(0x07)</span></span> |
| <span data-ttu-id="7769e-324">TX_BLOCK_MEMORY</span><span class="sxs-lookup"><span data-stu-id="7769e-324">TX_BLOCK_MEMORY</span></span> | <span data-ttu-id="7769e-325">(0x08)</span><span class="sxs-lookup"><span data-stu-id="7769e-325">(0x08)</span></span> |
| <span data-ttu-id="7769e-326">TX_BYTE_MEMORY</span><span class="sxs-lookup"><span data-stu-id="7769e-326">TX_BYTE_MEMORY</span></span>  | <span data-ttu-id="7769e-327">(0x09)</span><span class="sxs-lookup"><span data-stu-id="7769e-327">(0x09)</span></span> |
| <span data-ttu-id="7769e-328">TX_MUTEX_SUSP</span><span class="sxs-lookup"><span data-stu-id="7769e-328">TX_MUTEX_SUSP</span></span>   | <span data-ttu-id="7769e-329">(0x0D)</span><span class="sxs-lookup"><span data-stu-id="7769e-329">(0x0D)</span></span> |

> [!NOTE]
> <span data-ttu-id="7769e-330">*Конечно, в блоке управления потока существует множество других интересных полей, включая указатель на стек, значение временного среза, приоритеты и т. д. Пользователи могут просматривать элементы блока управления, но изменять их строго запрещено!*</span><span class="sxs-lookup"><span data-stu-id="7769e-330">*Of course there are many other interesting fields in the thread control block, including the stack pointer, time-slice value, priorities, etc. Users are welcome to review control block members, but modifications are strictly prohibited!*</span></span>

> [!IMPORTANT]
> <span data-ttu-id="7769e-331">*В этом разделе нет эквивалента для состояния "выполняется", упомянутого ранее. Это необязательно, поскольку в данный момент времени существует только один исполняемый поток. Состояние выполнения потока также* **TX_READY**.</span><span class="sxs-lookup"><span data-stu-id="7769e-331">*There is no equate for the "executing" state mentioned earlier in this section. It is not necessary because there is only one executing thread at a given time. The state of an executing thread is also* **TX_READY**.</span></span>

### <a name="currently-executing-thread"></a><span data-ttu-id="7769e-332">Текущий выполняемый поток</span><span class="sxs-lookup"><span data-stu-id="7769e-332">Currently Executing Thread</span></span>

<span data-ttu-id="7769e-333">Как упоминалось ранее, в любой заданный момент времени может выполняться только один поток.</span><span class="sxs-lookup"><span data-stu-id="7769e-333">As mentioned before, there is only one thread executing at any given time.</span></span> <span data-ttu-id="7769e-334">Существует несколько способов определения выполняемого потока. Они зависят от того, какой поток делает запрос.</span><span class="sxs-lookup"><span data-stu-id="7769e-334">There are several ways to identify the executing thread, depending on which thread is making the request.</span></span>
<span data-ttu-id="7769e-335">Сегмент программы может получить адрес блока управления выполняемого потока, вызвав службу ***tx_thread_identify***.</span><span class="sxs-lookup"><span data-stu-id="7769e-335">A program segment can get the control block address of the executing thread by calling ***tx_thread_identify***.</span></span> <span data-ttu-id="7769e-336">Это удобно использовать в общих фрагментах кода приложения, которые выполняются в нескольких потоках.</span><span class="sxs-lookup"><span data-stu-id="7769e-336">This is useful in shared portions of application code that are executed from multiple threads.</span></span>

<span data-ttu-id="7769e-337">Во время сеансов отладки пользователи могут изучить внутренний указатель ThreadX ***_tx_thread_current_ptr***.</span><span class="sxs-lookup"><span data-stu-id="7769e-337">In debug sessions, users can examine the internal ThreadX pointer ***_tx_thread_current_ptr***.</span></span> <span data-ttu-id="7769e-338">Он содержит адрес блока управления текущего выполняемого потока.</span><span class="sxs-lookup"><span data-stu-id="7769e-338">It contains the control block address of the currently executing thread.</span></span> <span data-ttu-id="7769e-339">Если этот указатель равен NULL, то потоки приложения не выполняются, т. е. ThreadX во время цикла планирования ожидает, когда какой-либо поток станет готовым.</span><span class="sxs-lookup"><span data-stu-id="7769e-339">If this pointer is NULL, no application thread is executing; i.e., ThreadX is waiting in its scheduling loop for a thread to become ready.</span></span>

### <a name="thread-stack-area"></a><span data-ttu-id="7769e-340">Область стека потока</span><span class="sxs-lookup"><span data-stu-id="7769e-340">Thread Stack Area</span></span>

<span data-ttu-id="7769e-341">Каждый поток должен иметь собственный стек для сохранения контекста последнего выполнения и использования компилятором.</span><span class="sxs-lookup"><span data-stu-id="7769e-341">Each thread must have its own stack for saving the context of its last execution and compiler use.</span></span> <span data-ttu-id="7769e-342">Большинство компиляторов C использует стек для выполнения вызовов функций и временного выделения локальных переменных.</span><span class="sxs-lookup"><span data-stu-id="7769e-342">Most C compilers use the stack for making function calls and for temporarily allocating local variables.</span></span> <span data-ttu-id="7769e-343">На рисунке 6 показан типичный стек потока.</span><span class="sxs-lookup"><span data-stu-id="7769e-343">Figure 6 shows a typical thread's stack.</span></span>

<span data-ttu-id="7769e-344">Область памяти, в которой размещается стек потока, выбирает приложение.</span><span class="sxs-lookup"><span data-stu-id="7769e-344">Where a thread stack is located in memory is up to the application.</span></span> <span data-ttu-id="7769e-345">Область стека указывается во время создания потока и может размещаться в любом месте адресного пространства целевого оборудования.</span><span class="sxs-lookup"><span data-stu-id="7769e-345">The stack area is specified during thread creation and can be located anywhere in the target's address space.</span></span> <span data-ttu-id="7769e-346">Это важная функция, так как она позволяет приложениям повысить производительность важных потоков, помещая их стек в высокоскоростную оперативную память.</span><span class="sxs-lookup"><span data-stu-id="7769e-346">This is an important feature because it allows applications to improve performance of important threads by placing their stack in high-speed RAM.</span></span>

<span data-ttu-id="7769e-347">**Область памяти стека** (пример)</span><span class="sxs-lookup"><span data-stu-id="7769e-347">**Stack Memory Area** (example)</span></span>

![Типичный стек потоков](./media/user-guide/typical-thread-stack.png)

<span data-ttu-id="7769e-349">**РИСУНОК 6. Типичный стек потока**</span><span class="sxs-lookup"><span data-stu-id="7769e-349">**FIGURE 6. Typical Thread Stack**</span></span>

<span data-ttu-id="7769e-350">Можно сказать, что вопрос о размере стека — один из наиболее часто задаваемых вопросов о потоках.</span><span class="sxs-lookup"><span data-stu-id="7769e-350">How big a stack should be is one of the most frequently asked questions about threads.</span></span> <span data-ttu-id="7769e-351">Область стека потока должна быть достаточно большой, чтобы обеспечить вложенность вызова функций в наиболее неблагоприятном случае, выделение локальных переменных и сохранение контекста последнего выполнения этого потока.</span><span class="sxs-lookup"><span data-stu-id="7769e-351">A thread's stack area must be large enough to accommodate worst-case function call nesting, local variable allocation, and saving its last execution context.</span></span>

<span data-ttu-id="7769e-352">Минимальный размер стека, **TX_MINIMUM_STACK**, определяет ThreadX.</span><span class="sxs-lookup"><span data-stu-id="7769e-352">The minimum stack size, **TX_MINIMUM_STACK**, is defined by ThreadX.</span></span> <span data-ttu-id="7769e-353">Стек этого размера поддерживает сохранение контекста потока, минимальное количество вызовов функций и выделение локальных переменных.</span><span class="sxs-lookup"><span data-stu-id="7769e-353">A stack of this size supports saving a thread's context and minimum amount of function calls and local variable allocation.</span></span>

<span data-ttu-id="7769e-354">Однако для большинства потоков минимальный размер стека недостаточен, и пользователь должен проверить требование размера для наиболее неблагоприятного случая, проверив вложенность вызова функций и выделение локальных переменных.</span><span class="sxs-lookup"><span data-stu-id="7769e-354">For most threads, however, the minimum stack size is too small, and the user must ascertain the worst-case size requirement by examining function-call nesting and local variable allocation.</span></span> <span data-ttu-id="7769e-355">Конечно, всегда лучше начать с более крупной области стека.</span><span class="sxs-lookup"><span data-stu-id="7769e-355">Of course, it is always better to start with a larger stack area.</span></span>

<span data-ttu-id="7769e-356">Если объем памяти ограничен, размер стека потока можно будет точно настроить после отладки приложения.</span><span class="sxs-lookup"><span data-stu-id="7769e-356">After the application is debugged, it is possible to tune the thread stack sizes if memory is scarce.</span></span> <span data-ttu-id="7769e-357">Прежде чем создавать потоки, предпочтительно заранее задать все области стека, используя легко идентифицируемый шаблон данных, например (0xEFEF).</span><span class="sxs-lookup"><span data-stu-id="7769e-357">A favorite trick is to preset all stack areas with an easily identifiable data pattern like (0xEFEF) prior to creating the threads.</span></span> <span data-ttu-id="7769e-358">После тщательной проверки приложения можно будет изучить области стека, чтобы узнать, какой объем стека фактически использовался. Для этого можно выполнить поиск области стека, в которой шаблон данных остался неизменным.</span><span class="sxs-lookup"><span data-stu-id="7769e-358">After the application has been thoroughly put through its paces, the stack areas can be examined to see how much stack was actually used by finding the area of the stack where the data pattern is still intact.</span></span> <span data-ttu-id="7769e-359">На рисунке 7 показана предварительная установка для стека значения 0xEFEF после обстоятельного выполнения потока.</span><span class="sxs-lookup"><span data-stu-id="7769e-359">Figure 7 shows a stack preset to 0xEFEF after thorough thread execution.</span></span>

<span data-ttu-id="7769e-360">**Область памяти стека** (другой пример)</span><span class="sxs-lookup"><span data-stu-id="7769e-360">**Stack Memory Area** (another example)</span></span>

![Предварительная установка для стека значения 0xEFEF\*](./media/user-guide/stack-preset.png)

<span data-ttu-id="7769e-362">**РИСУНОК 7. Предварительная установка для стека значения 0xEFEF**</span><span class="sxs-lookup"><span data-stu-id="7769e-362">**FIGURE 7. Stack Preset to 0xEFEF**</span></span>

> [!IMPORTANT]
> <span data-ttu-id="7769e-363">*По умолчанию ThreadX инициализирует каждый байт каждого стека потока, используя значение 0xEF.*</span><span class="sxs-lookup"><span data-stu-id="7769e-363">*By default, ThreadX initializes every byte of each thread stack with a value of 0xEF.*</span></span>

### <a name="memory-pitfalls"></a><span data-ttu-id="7769e-364">Проблемы с памятью</span><span class="sxs-lookup"><span data-stu-id="7769e-364">Memory Pitfalls</span></span>

<span data-ttu-id="7769e-365">Требования к стеку для потоков могут быть высокими.</span><span class="sxs-lookup"><span data-stu-id="7769e-365">The stack requirements for threads can be large.</span></span> <span data-ttu-id="7769e-366">Поэтому важно разработать приложение, использующее разумное количество потоков.</span><span class="sxs-lookup"><span data-stu-id="7769e-366">Therefore, it is important to design the application to have a reasonable number of threads.</span></span> <span data-ttu-id="7769e-367">Более того, необходимо уделить внимание тому, чтобы избежать чрезмерного использования стека в потоках.</span><span class="sxs-lookup"><span data-stu-id="7769e-367">Furthermore, some care must be taken to avoid excessive stack usage within threads.</span></span> <span data-ttu-id="7769e-368">Следует избегать рекурсивных алгоритмов и больших локальных структур данных.</span><span class="sxs-lookup"><span data-stu-id="7769e-368">Recursive algorithms and large local data structures should be avoided.</span></span>

<span data-ttu-id="7769e-369">В большинстве случаев переполнение стека приводит к тому, что выполнение потока повреждает область памяти, смежную с его областью стека (обычно повреждается область перед стеком потока).</span><span class="sxs-lookup"><span data-stu-id="7769e-369">In most cases, an overflowed stack causes thread execution to corrupt memory adjacent (usually before) its stack area.</span></span> <span data-ttu-id="7769e-370">Результаты могут быть непредсказуемыми, но чаще всего это приводит к необычному изменению счетчика программы.</span><span class="sxs-lookup"><span data-stu-id="7769e-370">The results are unpredictable, but most often result in an unnatural change in the program counter.</span></span> <span data-ttu-id="7769e-371">Это часто называют "залезать в дебри".</span><span class="sxs-lookup"><span data-stu-id="7769e-371">This is often called "jumping into the weeds."</span></span> <span data-ttu-id="7769e-372">Разумеется, единственный способ избежать этого — обеспечить достаточный размер всех стеков потоков.</span><span class="sxs-lookup"><span data-stu-id="7769e-372">Of course, the only way to prevent this is to ensure all thread stacks are large enough.</span></span>

### <a name="optional-run-time-stack-checking"></a><span data-ttu-id="7769e-373">Дополнительная проверка стека во время выполнения</span><span class="sxs-lookup"><span data-stu-id="7769e-373">Optional Run-time Stack Checking</span></span>

<span data-ttu-id="7769e-374">ThreadX позволяет проверять стек каждого потока на наличие повреждений во время выполнения.</span><span class="sxs-lookup"><span data-stu-id="7769e-374">ThreadX provides the ability to check each thread's stack for corruption during run-time.</span></span> <span data-ttu-id="7769e-375">По умолчанию ThreadX заполняет каждый байт создаваемых стеков потоков шаблоном данных 0xEF.</span><span class="sxs-lookup"><span data-stu-id="7769e-375">By default, ThreadX fills every byte of thread stacks with a 0xEF data pattern during creation.</span></span> <span data-ttu-id="7769e-376">Если приложение создает библиотеку ThreadX с определенным параметром **TX_ENABLE_STACK_CHECKING**, ThreadX будет анализировать стек каждого потока на наличие повреждений, когда его выполнение будет приостанавливаться или возобновляться.</span><span class="sxs-lookup"><span data-stu-id="7769e-376">If the application builds the ThreadX library with **TX_ENABLE_STACK_CHECKING** defined, ThreadX will examine each thread's stack for corruption as it is suspended or resumed.</span></span> <span data-ttu-id="7769e-377">При обнаружении повреждения стека ThreadX вызовет подпрограмму обработки ошибок стека приложения, указанную в вызове **_tx_thread_stack_error_notify_ *_. В противном случае, если не был указан обработчик ошибок стека, ThreadX вызовет внутреннюю подпрограмму _* _ _tx_thread_stack_error_handler_**.</span><span class="sxs-lookup"><span data-stu-id="7769e-377">If stack corruption is detected, ThreadX will call the application's stack error handling routine as specified by the call to **_tx_thread_stack_error_notify_*_. Otherwise, if no stack error handler was specified, ThreadX will call the internal _\* _ _tx_thread_stack_error_handler_*\* routine.</span></span>

### <a name="reentrancy"></a><span data-ttu-id="7769e-378">Повторный вход</span><span class="sxs-lookup"><span data-stu-id="7769e-378">Reentrancy</span></span>

<span data-ttu-id="7769e-379">Одним из реальных преимуществ многопоточности является то, что одна и та же функция C может быть вызвана из нескольких потоков.</span><span class="sxs-lookup"><span data-stu-id="7769e-379">One of the real beauties of multithreading is that the same C function can be called from multiple threads.</span></span> <span data-ttu-id="7769e-380">Это дает широкие возможности, а также сокращает объем кода.</span><span class="sxs-lookup"><span data-stu-id="7769e-380">This provides great power and also helps reduce code space.</span></span> <span data-ttu-id="7769e-381">Однако для этого требуется, чтобы функции C, вызываемые из нескольких потоков, были *реентерабельными*.</span><span class="sxs-lookup"><span data-stu-id="7769e-381">However, it does require that C functions called from multiple threads are *reentrant*.</span></span>

<span data-ttu-id="7769e-382">В сущности, реентерабельная функция сохраняет адрес возвращения вызывающего объекта в текущем стеке и не использует глобальные или статические переменные C, которые были настроены ранее.</span><span class="sxs-lookup"><span data-stu-id="7769e-382">Basically, a reentrant function stores the caller's return address on the current stack and does not rely on global or static C variables that it previously set up.</span></span> <span data-ttu-id="7769e-383">Большинство компиляторов помещает адрес возвращения в стек.</span><span class="sxs-lookup"><span data-stu-id="7769e-383">Most compilers place the return address on the stack.</span></span> <span data-ttu-id="7769e-384">Следовательно, разработчикам приложений остается только позаботиться об использовании *глобальных* и *статических* переменных.</span><span class="sxs-lookup"><span data-stu-id="7769e-384">Hence, application developers must only worry about the use of *globals* and *statics*.</span></span>

<span data-ttu-id="7769e-385">Примером функции, не являющейся реентерабельной, является функция строкового маркера ***strtok***, доступная в стандартной библиотеке C.</span><span class="sxs-lookup"><span data-stu-id="7769e-385">An example of a non-reentrant function is the string token function ***strtok*** found in the standard C library.</span></span> <span data-ttu-id="7769e-386">Эта функция "запоминает" указатель на предыдущую строку при последующих вызовах.</span><span class="sxs-lookup"><span data-stu-id="7769e-386">This function "remembers" the previous string pointer on subsequent calls.</span></span> <span data-ttu-id="7769e-387">Для этого она использует статический указатель на строку.</span><span class="sxs-lookup"><span data-stu-id="7769e-387">It does this with a static string pointer.</span></span> <span data-ttu-id="7769e-388">Если эта функция будет вызвана из нескольких потоков, скорее всего, будет возвращен недопустимый указатель.</span><span class="sxs-lookup"><span data-stu-id="7769e-388">If this function is called from multiple threads, it would most likely return an invalid pointer.</span></span>

### <a name="thread-priority-pitfalls"></a><span data-ttu-id="7769e-389">Проблемы, связанные с приоритетами потоков</span><span class="sxs-lookup"><span data-stu-id="7769e-389">Thread Priority Pitfalls</span></span>

<span data-ttu-id="7769e-390">Выбор приоритетов потоков является одним из наиболее важных аспектов многопоточности.</span><span class="sxs-lookup"><span data-stu-id="7769e-390">Selecting thread priorities is one of the most important aspects of multithreading.</span></span> <span data-ttu-id="7769e-391">Иногда назначение приоритетов на основе кажущейся важности потока без определения того, что именно требуется во время выполнения, выглядит очень заманчиво.</span><span class="sxs-lookup"><span data-stu-id="7769e-391">It is sometimes very tempting to assign priorities based on a perceived notion of thread importance rather than determining what is exactly required during run-time.</span></span> <span data-ttu-id="7769e-392">Неправильное назначение приоритетов потоков может привести к нехватке ресурсов для потоков, породить инверсию приоритета, уменьшить пропускную способность обработки и привести к тому, что поведение приложения во время выполнения будет сложно понять.</span><span class="sxs-lookup"><span data-stu-id="7769e-392">Misuse of thread priorities can starve other threads, create priority inversion, reduce processing bandwidth, and make the application's run-time behavior difficult to understand.</span></span>

<span data-ttu-id="7769e-393">Как упоминалось ранее, ThreadX предоставляет алгоритм планирования с вытеснением на основе приоритета.</span><span class="sxs-lookup"><span data-stu-id="7769e-393">As mentioned before, ThreadX provides a priority-based, preemptive scheduling algorithm.</span></span> <span data-ttu-id="7769e-394">Потоки с низким приоритетом не выполняются до тех пор, пока не останется ни одного готового к выполнению потока с более высоким приоритетом.</span><span class="sxs-lookup"><span data-stu-id="7769e-394">Lower priority threads do not execute until there are no higher priority threads ready for execution.</span></span> <span data-ttu-id="7769e-395">Если поток с более высоким приоритетом всегда готов, потоки с низким приоритетом никогда не выполнятся.</span><span class="sxs-lookup"><span data-stu-id="7769e-395">If a higher priority thread is always ready, the lower priority threads never execute.</span></span> <span data-ttu-id="7769e-396">Это состояние называется *нехваткой ресурсов потоков*.</span><span class="sxs-lookup"><span data-stu-id="7769e-396">This condition is called *thread starvation*.</span></span>

<span data-ttu-id="7769e-397">Большинство проблем, связанных с нехваткой ресурсов потоков, обнаруживается на ранних этапах отладки и могут быть устранены. Для этого нужно сделать так, чтобы выполнение потоков с более высоким приоритетом не было непрерывным.</span><span class="sxs-lookup"><span data-stu-id="7769e-397">Most thread starvation problems are detected early in debug and can be solved by ensuring that higher priority threads don't execute continuously.</span></span> <span data-ttu-id="7769e-398">Кроме того, можно добавить в приложение логику, которая постепенно повышает приоритет потоков, испытывающих нехватку ресурсов, пока они не получат шанс на выполнение.</span><span class="sxs-lookup"><span data-stu-id="7769e-398">Alternatively, logic can be added to the application that gradually raises the priority of starved threads until they get a chance to execute.</span></span>

<span data-ttu-id="7769e-399">Еще одной проблемой, связанной с приоритетами потоков, является *инверсия приоритета*.</span><span class="sxs-lookup"><span data-stu-id="7769e-399">Another pitfall associated with thread priorities is *priority inversion*.</span></span> <span data-ttu-id="7769e-400">Она происходит, когда поток с более высоким приоритетом приостанавливается из-за того, что требуемый ему ресурс используется потоком с более низким приоритетом.</span><span class="sxs-lookup"><span data-stu-id="7769e-400">Priority inversion takes place when a higher priority thread is suspended because a lower priority thread has a needed resource.</span></span> <span data-ttu-id="7769e-401">Конечно, в некоторых случаях нужно, чтобы два потока с разными приоритетами совместно использовали общий ресурс.</span><span class="sxs-lookup"><span data-stu-id="7769e-401">Of course, in some instances it is necessary for two threads of different priority to share a common resource.</span></span> <span data-ttu-id="7769e-402">Если активны только эти потоки, то время инверсии приоритета ограничено периодом, в течение которого поток с низким приоритетом владеет ресурсом.</span><span class="sxs-lookup"><span data-stu-id="7769e-402">If these threads are the only ones active, the priority inversion time is bounded by the time the lower priority thread holds the resource.</span></span> <span data-ttu-id="7769e-403">Такая ситуация детерминирована и вполне приемлема.</span><span class="sxs-lookup"><span data-stu-id="7769e-403">This condition is both deterministic and quite normal.</span></span> <span data-ttu-id="7769e-404">Однако если в случае инверсии приоритета становятся активными потоки с промежуточным приоритетом, то время инверсии приоритета больше не является детерминированным и может привести к сбою приложения.</span><span class="sxs-lookup"><span data-stu-id="7769e-404">However, if threads of intermediate priority become active during this priority inversion condition, the priority inversion time is no longer deterministic and could cause an application failure.</span></span>

<span data-ttu-id="7769e-405">Существуют три принципиально разных метода предотвращения недетерминированной инверсии приоритета в ThreadX.</span><span class="sxs-lookup"><span data-stu-id="7769e-405">There are principally three distinct methods of preventing nondeterministic priority inversion in ThreadX.</span></span> <span data-ttu-id="7769e-406">Во-первых, назначение приоритетов и поведение во время выполнения в приложении можно спроектировать таким образом, чтобы не возникала проблема с инверсией приоритета.</span><span class="sxs-lookup"><span data-stu-id="7769e-406">First, the application priority selections and run-time behavior can be designed in a manner that prevents the priority inversion problem.</span></span> <span data-ttu-id="7769e-407">Во-вторых, для потоков с низким приоритетом можно использовать *порог вытеснения*, чтобы блокировать их вытеснение промежуточными потоками, пока они используют ресурсы совместно с потоками с более высоким приоритетом.</span><span class="sxs-lookup"><span data-stu-id="7769e-407">Second, lower priority threads can utilize *preemption threshold* to block preemption from intermediate threads while they share resources with higher priority threads.</span></span> <span data-ttu-id="7769e-408">Наконец, для потоков, использующих объекты мьютексов ThreadX для защиты системных ресурсов, можно устранить недетерминированную инверсию приоритета с помощью необязательного *наследования приоритета* мьютекса.</span><span class="sxs-lookup"><span data-stu-id="7769e-408">Finally, threads using ThreadX mutex objects to protect system resources may utilize the optional mutex *priority inheritance* to eliminate nondeterministic priority inversion.</span></span>

### <a name="priority-overhead"></a><span data-ttu-id="7769e-409">Временные затраты из-за приоритетов</span><span class="sxs-lookup"><span data-stu-id="7769e-409">Priority Overhead</span></span>

<span data-ttu-id="7769e-410">Одним из наиболее упускаемых из виду способов снижения временных затрат на многопоточность является сокращение переключений контекста.</span><span class="sxs-lookup"><span data-stu-id="7769e-410">One of the most overlooked ways to reduce overhead in multithreading is to reduce the number of context switches.</span></span> <span data-ttu-id="7769e-411">Как упоминалось выше, переключение контекста происходит, когда выполнение потока с более высоким приоритетом оказывается предпочтительнее выполнения текущего потока.</span><span class="sxs-lookup"><span data-stu-id="7769e-411">As previously mentioned, a context switch occurs when execution of a higher priority thread is favored over that of the executing thread.</span></span> <span data-ttu-id="7769e-412">Стоит упомянуть, что потоки с более высоким приоритетом могут оказаться готовыми к работе как в результате внешних событий (например, прерываний), так и вследствие вызовов служб выполняемым потоком.</span><span class="sxs-lookup"><span data-stu-id="7769e-412">It is worthwhile to mention that higher priority threads can become ready as a result of both external events (like interrupts) and from service calls made by the executing thread.</span></span>

<span data-ttu-id="7769e-413">Чтобы проиллюстрировать влияние приоритетов потоков на временные затраты из-за переключения контекста, предположим, что существуют три среды потоков с потоками *thread_1*, *thread_2* и *thread_3*.</span><span class="sxs-lookup"><span data-stu-id="7769e-413">To illustrate the effects thread priorities have on context switch overhead, assume a three thread environment with threads named *thread_1*, *thread_2*, and *thread_3*.</span></span> <span data-ttu-id="7769e-414">Предположим, что все эти потоки находятся в состоянии приостановки и ожидают сообщения.</span><span class="sxs-lookup"><span data-stu-id="7769e-414">Assume further that all of the threads are in a state of suspension waiting for a message.</span></span> <span data-ttu-id="7769e-415">Когда поток thread_1 получает сообщение, он немедленно пересылает его потоку thread_2.</span><span class="sxs-lookup"><span data-stu-id="7769e-415">When thread_1 receives a message, it immediately forwards it to thread_2.</span></span> <span data-ttu-id="7769e-416">Затем поток thread_2 пересылает это сообщение потоку thread_3.</span><span class="sxs-lookup"><span data-stu-id="7769e-416">Thread_2 then forwards the message to thread_3.</span></span> <span data-ttu-id="7769e-417">Поток thread_3 просто отклоняет сообщение.</span><span class="sxs-lookup"><span data-stu-id="7769e-417">Thread_3 just discards the message.</span></span> <span data-ttu-id="7769e-418">После того как каждый поток обработал сообщение, он возвращается и ожидает другое сообщение.</span><span class="sxs-lookup"><span data-stu-id="7769e-418">After each thread processes its message, it goes back and waits for another message.</span></span>

<span data-ttu-id="7769e-419">Обработка, необходимая для выполнения этих трех потоков, сильно зависит от их приоритетов.</span><span class="sxs-lookup"><span data-stu-id="7769e-419">The processing required to execute these three threads varies greatly depending on their priorities.</span></span> <span data-ttu-id="7769e-420">Если все потоки имеют одинаковый приоритет, то перед выполнением каждого потока происходит одно переключение контекста.</span><span class="sxs-lookup"><span data-stu-id="7769e-420">If all of the threads have the same priority, a single context switch occurs before the execution of each thread.</span></span> <span data-ttu-id="7769e-421">Переключение контекста происходит, когда каждый поток приостанавливается при пустой очереди сообщений.</span><span class="sxs-lookup"><span data-stu-id="7769e-421">The context switch occurs when each thread suspends on an empty message queue.</span></span>

<span data-ttu-id="7769e-422">Но если у потока thread_2 более высокий приоритет, чем у потока thread_1, а у потока thread_3 более высокий приоритет, чем у потока thread_2, то число переключений контекста удваивается.</span><span class="sxs-lookup"><span data-stu-id="7769e-422">However, if thread_2 is higher priority than thread_1 and thread_3 is higher priority than thread_2, the number of context switches doubles.</span></span> <span data-ttu-id="7769e-423">Это связано с тем, что в службе *tx_queue_send* происходит еще одно переключение контекста, когда она обнаруживает, что поток с более высоким приоритетом уже готов.</span><span class="sxs-lookup"><span data-stu-id="7769e-423">This is because another context switch occurs inside of the *tx_queue_send* service when it detects that a higher priority thread is now ready.</span></span>

<span data-ttu-id="7769e-424">Механизм применения порога вытеснения ThreadX позволяет избежать этих дополнительных переключений контекста, не меняя исходные приоритеты.</span><span class="sxs-lookup"><span data-stu-id="7769e-424">The ThreadX preemption-threshold mechanism can avoid these extra context switches and still allow the previously mentioned priority selections.</span></span> <span data-ttu-id="7769e-425">Это важная функция, так как она позволяет использовать несколько приоритетов потоков во время планирования, одновременно устраняя нежелательные переключения контекста между ними во время выполнения потоков.</span><span class="sxs-lookup"><span data-stu-id="7769e-425">This is an important feature because it allows several thread priorities during scheduling, while at the same time eliminating some of the unwanted context switching between them during thread execution.</span></span>

### <a name="run-time-thread-performance-information"></a><span data-ttu-id="7769e-426">Сведения о производительности потоков во время выполнения</span><span class="sxs-lookup"><span data-stu-id="7769e-426">Run-time Thread Performance Information</span></span>

<span data-ttu-id="7769e-427">ThreadX предоставляет дополнительные сведения о производительности потоков во время выполнения.</span><span class="sxs-lookup"><span data-stu-id="7769e-427">ThreadX provides optional run-time thread performance information.</span></span> <span data-ttu-id="7769e-428">Если при сборке приложения и библиотеки ThreadX был определен параметр **TX_THREAD_ENABLE_PERFORMANCE_INFO**, ThreadX собирает следующую информацию.</span><span class="sxs-lookup"><span data-stu-id="7769e-428">If the ThreadX library and application is built with **TX_THREAD_ENABLE_PERFORMANCE_INFO** defined, ThreadX accumulates the following information.</span></span>

<span data-ttu-id="7769e-429">Общее число (для всей системы):</span><span class="sxs-lookup"><span data-stu-id="7769e-429">Total number for the overall system:</span></span>

  - <span data-ttu-id="7769e-430">возобновлений потоков;</span><span class="sxs-lookup"><span data-stu-id="7769e-430">thread resumptions</span></span>

  - <span data-ttu-id="7769e-431">приостановок потоков;</span><span class="sxs-lookup"><span data-stu-id="7769e-431">thread suspensions</span></span>

  - <span data-ttu-id="7769e-432">вытеснений путем вызова службы;</span><span class="sxs-lookup"><span data-stu-id="7769e-432">service call preemptions</span></span>

  - <span data-ttu-id="7769e-433">вытеснений путем прерывания;</span><span class="sxs-lookup"><span data-stu-id="7769e-433">interrupt preemptions</span></span>

  - <span data-ttu-id="7769e-434">инверсий приоритета;</span><span class="sxs-lookup"><span data-stu-id="7769e-434">priority inversions</span></span>

  - <span data-ttu-id="7769e-435">временных срезов;</span><span class="sxs-lookup"><span data-stu-id="7769e-435">time-slices</span></span>

  - <span data-ttu-id="7769e-436">освобождений;</span><span class="sxs-lookup"><span data-stu-id="7769e-436">relinquishes</span></span>

  - <span data-ttu-id="7769e-437">превышений времени ожидания потока;</span><span class="sxs-lookup"><span data-stu-id="7769e-437">thread timeouts</span></span>

  - <span data-ttu-id="7769e-438">прерываний приостановки;</span><span class="sxs-lookup"><span data-stu-id="7769e-438">suspension aborts</span></span>

  - <span data-ttu-id="7769e-439">возвращений состояния бездействия системы;</span><span class="sxs-lookup"><span data-stu-id="7769e-439">idle system returns</span></span>

  - <span data-ttu-id="7769e-440">возвращений состояния системы, отличного от бездействия.</span><span class="sxs-lookup"><span data-stu-id="7769e-440">non-idle system returns</span></span>

<span data-ttu-id="7769e-441">Общее число (для каждого потока):</span><span class="sxs-lookup"><span data-stu-id="7769e-441">Total number for each thread:</span></span>

  - <span data-ttu-id="7769e-442">возобновлений;</span><span class="sxs-lookup"><span data-stu-id="7769e-442">resumptions</span></span>

  - <span data-ttu-id="7769e-443">приостановок;</span><span class="sxs-lookup"><span data-stu-id="7769e-443">suspensions</span></span>

  - <span data-ttu-id="7769e-444">вытеснений путем вызова службы;</span><span class="sxs-lookup"><span data-stu-id="7769e-444">service call preemptions</span></span>

  - <span data-ttu-id="7769e-445">вытеснений путем прерывания;</span><span class="sxs-lookup"><span data-stu-id="7769e-445">interrupt preemptions</span></span>

  - <span data-ttu-id="7769e-446">инверсий приоритета;</span><span class="sxs-lookup"><span data-stu-id="7769e-446">priority inversions</span></span>

  - <span data-ttu-id="7769e-447">временных срезов;</span><span class="sxs-lookup"><span data-stu-id="7769e-447">time-slices</span></span>

  - <span data-ttu-id="7769e-448">освобождений потока;</span><span class="sxs-lookup"><span data-stu-id="7769e-448">thread relinquishes</span></span>

  - <span data-ttu-id="7769e-449">превышений времени ожидания потока;</span><span class="sxs-lookup"><span data-stu-id="7769e-449">thread timeouts</span></span>

  - <span data-ttu-id="7769e-450">прерываний приостановки.</span><span class="sxs-lookup"><span data-stu-id="7769e-450">suspension aborts</span></span>

<span data-ttu-id="7769e-451">Эти сведения можно получить во время выполнения с помощью служб ***tx_thread_performance_info_get** _ и _*_tx_thread_performance_system_info_get_\*\*.</span><span class="sxs-lookup"><span data-stu-id="7769e-451">This information is available at run-time through the services ***tx_thread_performance_info_get** _ and _*_tx_thread_performance_system_info_get_\*\*.</span></span> <span data-ttu-id="7769e-452">С помощью сведений о производительности потоков удобно определять, правильно ли работает приложение.</span><span class="sxs-lookup"><span data-stu-id="7769e-452">Thread performance information is useful in determining if the application is behaving properly.</span></span> <span data-ttu-id="7769e-453">Они также полезны для оптимизации приложения.</span><span class="sxs-lookup"><span data-stu-id="7769e-453">It is also useful in optimizing the application.</span></span> <span data-ttu-id="7769e-454">Например, относительно частое вытеснение путем вызова службы может указывать на слишком низкое значение приоритета потока и (или) порога вытеснения.</span><span class="sxs-lookup"><span data-stu-id="7769e-454">For example, a relatively high number of service call preemptions might suggest the thread's priority and/or preemption-threshold is too low.</span></span> <span data-ttu-id="7769e-455">Более того, относительно редкое возвращение состояния бездействия системы может означать, что потоки с низким приоритетом недостаточно приостанавливаются.</span><span class="sxs-lookup"><span data-stu-id="7769e-455">Furthermore, a relatively low number of idle system returns might suggest that lower priority threads are not suspending enough.</span></span>

### <a name="debugging-pitfalls"></a><span data-ttu-id="7769e-456">Проблемы при отладке</span><span class="sxs-lookup"><span data-stu-id="7769e-456">Debugging Pitfalls</span></span>

<span data-ttu-id="7769e-457">Отладка многопоточных приложений немного сложнее, так как один программный код может выполняться из нескольких потоков.</span><span class="sxs-lookup"><span data-stu-id="7769e-457">Debugging multithreaded applications is a little more difficult because the same program code can be executed from multiple threads.</span></span> <span data-ttu-id="7769e-458">В таких случаях просто точки останова может быть недостаточно.</span><span class="sxs-lookup"><span data-stu-id="7769e-458">In such cases, a break-point alone may not be enough.</span></span> <span data-ttu-id="7769e-459">Отладчик также должен просмотреть текущий указатель на поток **_tx_thread_current_ptr** с помощью условной точки останова, чтобы определить, следует ли отлаживать вызывающий поток.</span><span class="sxs-lookup"><span data-stu-id="7769e-459">The debugger must also view the current thread pointer **_tx_thread_current_ptr** using a conditional breakpoint to see if the calling thread is the one to debug.</span></span>

<span data-ttu-id="7769e-460">Большую часть этих функций выполняют пакеты поддержки многопоточности, предлагаемые различными поставщиками инструментов разработки.</span><span class="sxs-lookup"><span data-stu-id="7769e-460">Much of this is being handled in multithreading support packages offered through various development tool vendors.</span></span> <span data-ttu-id="7769e-461">Благодаря простой структуре ThreadX интегрировать эту систему с различными инструментами разработки относительно легко.</span><span class="sxs-lookup"><span data-stu-id="7769e-461">Because of its simple design, integrating ThreadX with different development tools is relatively easy.</span></span>

<span data-ttu-id="7769e-462">Размер стека всегда играет важную роль при отладке в режиме многопоточности.</span><span class="sxs-lookup"><span data-stu-id="7769e-462">Stack size is always an important debug topic in multithreading.</span></span> <span data-ttu-id="7769e-463">При обнаружении необъяснимого поведения обычно стоит начать с увеличения размера стека для всех потоков, особенно это касается размера стека последнего выполнявшегося потока.</span><span class="sxs-lookup"><span data-stu-id="7769e-463">Whenever unexplained behavior is observed, it is usually a good first guess to increase stack sizes for all threads—especially the stack size of the last thread to execute!</span></span>

> [!TIP]
> <span data-ttu-id="7769e-464">*Кроме того, рекомендуется создать библиотеку ThreadX с определенным параметром **TX_ENABLE_STACK_CHECKING**. Это поможет как можно раньше изолировать проблемы, связанные с повреждением стека.*</span><span class="sxs-lookup"><span data-stu-id="7769e-464">*It is also a good idea to build the ThreadX library with **TX_ENABLE_STACK_CHECKING** defined. This will help isolate stack corruption problems as early in the processing as possible.*</span></span>

## <a name="message-queues"></a><span data-ttu-id="7769e-465">Очереди сообщений</span><span class="sxs-lookup"><span data-stu-id="7769e-465">Message Queues</span></span>

<span data-ttu-id="7769e-466">Очереди сообщений являются основным средством взаимодействия между потоками в ThreadX.</span><span class="sxs-lookup"><span data-stu-id="7769e-466">Message queues are the primary means of inter-thread communication in ThreadX.</span></span> <span data-ttu-id="7769e-467">В очереди сообщений может находиться одно или несколько сообщений.</span><span class="sxs-lookup"><span data-stu-id="7769e-467">One or more messages can reside in a message queue.</span></span> <span data-ttu-id="7769e-468">Очередь сообщений, содержащая одно сообщение, обычно называется *почтовым ящиком*.</span><span class="sxs-lookup"><span data-stu-id="7769e-468">A message queue that holds a single message is commonly called a *mailbox*.</span></span>

<span data-ttu-id="7769e-469">Сообщения копируются в очередь службой ***tx_queue_send** _, а из очереди — службой _*_tx_queue_receive_\*\*.</span><span class="sxs-lookup"><span data-stu-id="7769e-469">Messages are copied to a queue by ***tx_queue_send** _ and are copied from a queue by _*_tx_queue_receive_\*\*.</span></span> <span data-ttu-id="7769e-470">Единственным исключением является ситуация, когда поток приостанавливается, ожидая сообщения в пустой очереди.</span><span class="sxs-lookup"><span data-stu-id="7769e-470">The only exception to this is when a thread is suspended while waiting for a message on an empty queue.</span></span> <span data-ttu-id="7769e-471">В этом случае следующее сообщение, отправленное в очередь, помещается непосредственно в область назначения потока.</span><span class="sxs-lookup"><span data-stu-id="7769e-471">In this case, the next message sent to the queue is placed directly into the thread's destination area.</span></span>

<span data-ttu-id="7769e-472">Каждая очередь сообщений является общедоступным ресурсом.</span><span class="sxs-lookup"><span data-stu-id="7769e-472">Each message queue is a public resource.</span></span> <span data-ttu-id="7769e-473">В ThreadX нет ограничений на использование очередей сообщений.</span><span class="sxs-lookup"><span data-stu-id="7769e-473">ThreadX places no constraints on how message queues are used.</span></span>

### <a name="creating-message-queues"></a><span data-ttu-id="7769e-474">Создание очередей сообщений</span><span class="sxs-lookup"><span data-stu-id="7769e-474">Creating Message Queues</span></span>

<span data-ttu-id="7769e-475">Очереди сообщений создаются во время инициализации или во время выполнения потоками приложения.</span><span class="sxs-lookup"><span data-stu-id="7769e-475">Message queues are created either during initialization or during run-time by application threads.</span></span> <span data-ttu-id="7769e-476">Количество очередей сообщений в приложении не ограничено.</span><span class="sxs-lookup"><span data-stu-id="7769e-476">There is no limit on the number of message queues in an application.</span></span>

### <a name="message-size"></a><span data-ttu-id="7769e-477">Размер сообщения</span><span class="sxs-lookup"><span data-stu-id="7769e-477">Message Size</span></span>

<span data-ttu-id="7769e-478">Каждая очередь сообщений поддерживает ряд фиксированных размеров сообщений.</span><span class="sxs-lookup"><span data-stu-id="7769e-478">Each message queue supports a number of fixed-sized messages.</span></span> <span data-ttu-id="7769e-479">Доступные размеры сообщений: от 1 до 16 32-разрядных слов включительно.</span><span class="sxs-lookup"><span data-stu-id="7769e-479">The available message sizes are 1 through 16 32-bit words inclusive.</span></span> <span data-ttu-id="7769e-480">Размер сообщения указывается при создании очереди.</span><span class="sxs-lookup"><span data-stu-id="7769e-480">The message size is specified when the queue is created.</span></span> <span data-ttu-id="7769e-481">Сообщения приложения, размер которых превышает 16 слов, должны передаваться посредством указателя.</span><span class="sxs-lookup"><span data-stu-id="7769e-481">Application messages greater than 16 words must be passed by pointer.</span></span> <span data-ttu-id="7769e-482">Для этого создается очередь с размером сообщения в 1 слово (достаточно для хранения указателя), после чего вместо всего сообщения отправляются и принимаются указатели на сообщение.</span><span class="sxs-lookup"><span data-stu-id="7769e-482">This is accomplished by creating a queue with a message size of 1 word (enough to hold a pointer) and then sending and receiving message pointers instead of the entire message.</span></span>

### <a name="message-queue-capacity"></a><span data-ttu-id="7769e-483">Емкость очереди сообщений</span><span class="sxs-lookup"><span data-stu-id="7769e-483">Message Queue Capacity</span></span>

<span data-ttu-id="7769e-484">Количество сообщений, которые может хранить очередь, зависит от заданного для нее размера сообщения и области памяти, предоставленной ей во время создания.</span><span class="sxs-lookup"><span data-stu-id="7769e-484">The number of messages a queue can hold is a function of its message size and the size of the memory area supplied during creation.</span></span> <span data-ttu-id="7769e-485">Общая емкость сообщений в очереди вычисляется путем деления числа байтов в каждом сообщении на общее число байтов в указанной области памяти.</span><span class="sxs-lookup"><span data-stu-id="7769e-485">The total message capacity of the queue is calculated by dividing the number of bytes in each message into the total number of bytes in the supplied memory area.</span></span>

<span data-ttu-id="7769e-486">Например, если очередь сообщений, поддерживающая размер сообщения в одно 32-разрядное слово (4 байта), создается для области памяти в 100 байт, то ее емкость составляет 25 сообщений.</span><span class="sxs-lookup"><span data-stu-id="7769e-486">For example, if a message queue that supports a message size of 1 32-bit word (4 bytes) is created with a 100-byte memory area, its capacity is 25 messages.</span></span>

### <a name="queue-memory-area"></a><span data-ttu-id="7769e-487">Область памяти очереди</span><span class="sxs-lookup"><span data-stu-id="7769e-487">Queue Memory Area</span></span>

<span data-ttu-id="7769e-488">Как упоминалось ранее, область памяти для буферизации сообщений указывается во время создания очереди.</span><span class="sxs-lookup"><span data-stu-id="7769e-488">As mentioned previously, the memory area for buffering messages is specified during queue creation.</span></span> <span data-ttu-id="7769e-489">Как и в случае с другими областями памяти в ThreadX, она может находиться в любом месте адресного пространства целевого оборудования.</span><span class="sxs-lookup"><span data-stu-id="7769e-489">Like other memory areas in ThreadX, it can be located anywhere in the target's address space.</span></span>

<span data-ttu-id="7769e-490">Это важная возможность, так как она обеспечивает значительную гибкость для приложения.</span><span class="sxs-lookup"><span data-stu-id="7769e-490">This is an important feature because it gives the application considerable flexibility.</span></span> <span data-ttu-id="7769e-491">Например, приложение может разместить область памяти важной очереди в высокоскоростном ОЗУ для повышения производительности.</span><span class="sxs-lookup"><span data-stu-id="7769e-491">For example, an application might locate the memory area of an important queue in high-speed RAM to improve performance.</span></span>

### <a name="thread-suspension"></a><span data-ttu-id="7769e-492">Приостановка потока</span><span class="sxs-lookup"><span data-stu-id="7769e-492">Thread Suspension</span></span>

<span data-ttu-id="7769e-493">Потоки приложения могут быть приостановлены при попытке отправить или получить сообщение из очереди.</span><span class="sxs-lookup"><span data-stu-id="7769e-493">Application threads can suspend while attempting to send or receive a message from a queue.</span></span> <span data-ttu-id="7769e-494">Как правило, приостановка потока предполагает ожидание сообщения из пустой очереди.</span><span class="sxs-lookup"><span data-stu-id="7769e-494">Typically, thread suspension involves waiting for a message from an empty queue.</span></span> <span data-ttu-id="7769e-495">Однако поток также может быть приостановлен при попытке отправить сообщение в полную очередь.</span><span class="sxs-lookup"><span data-stu-id="7769e-495">However, it is also possible for a thread to suspend trying to send a message to a full queue.</span></span>

<span data-ttu-id="7769e-496">Когда условие приостановки разрешается, запрошенная служба завершает выполнение и ожидающий поток возобновляется.</span><span class="sxs-lookup"><span data-stu-id="7769e-496">After the condition for suspension is resolved, the service requested is completed and the waiting thread is resumed.</span></span> <span data-ttu-id="7769e-497">Если на одной очереди приостанавливается несколько потоков, они возобновляются в том же порядке, в котором были приостановлены (FIFO).</span><span class="sxs-lookup"><span data-stu-id="7769e-497">If multiple threads are suspended on the same queue, they are resumed in the order they were suspended (FIFO).</span></span>

<span data-ttu-id="7769e-498">Однако также возможно возобновление по приоритету, если приложение вызовет ***tx_queue_prioritize*** перед вызовом службы очередей, которая прекращает приостановку потоков.</span><span class="sxs-lookup"><span data-stu-id="7769e-498">However, priority resumption is also possible if the application calls ***tx_queue_prioritize*** prior to the queue service that lifts thread suspension.</span></span> <span data-ttu-id="7769e-499">Служба назначения приоритетов для очереди помещает поток с наибольшим приоритетом в начало списка приостановки, оставляя прочие приостановленные потоки в том же порядке по принципу FIFO.</span><span class="sxs-lookup"><span data-stu-id="7769e-499">The queue prioritize service places the highest priority thread at the front of the suspension list, while leaving all other suspended threads in the same FIFO order.</span></span>

<span data-ttu-id="7769e-500">Для всех приостановок очередей также доступно прерывание по истечении времени ожидания.</span><span class="sxs-lookup"><span data-stu-id="7769e-500">Time-outs are also available for all queue suspensions.</span></span> <span data-ttu-id="7769e-501">По сути, время ожидания задает максимальное число тактов таймера, в которые поток будет оставаться приостановленным.</span><span class="sxs-lookup"><span data-stu-id="7769e-501">Basically, a time-out specifies the maximum number of timer ticks the thread will stay suspended.</span></span> <span data-ttu-id="7769e-502">По истечении времени ожидания поток возобновляется и служба возвращает соответствующий код ошибки.</span><span class="sxs-lookup"><span data-stu-id="7769e-502">If a time-out occurs, the thread is resumed and the service returns with the appropriate error code.</span></span>

### <a name="queue-send-notification"></a><span data-ttu-id="7769e-503">Уведомление об отправке в очередь</span><span class="sxs-lookup"><span data-stu-id="7769e-503">Queue Send Notification</span></span>

<span data-ttu-id="7769e-504">Некоторые приложения могут использовать преимущества уведомлений о каждом добавлении сообщения в очередь.</span><span class="sxs-lookup"><span data-stu-id="7769e-504">Some applications may find it advantageous to be notified whenever a message is placed on a queue.</span></span> <span data-ttu-id="7769e-505">ThreadX обеспечивает эту возможность с помощью службы ***tx_queue_send_notify***.</span><span class="sxs-lookup"><span data-stu-id="7769e-505">ThreadX provides this ability through the ***tx_queue_send_notify*** service.</span></span> <span data-ttu-id="7769e-506">Эта служба регистрирует указанную функцию уведомления приложения для заданной очереди.</span><span class="sxs-lookup"><span data-stu-id="7769e-506">This service registers the supplied application notification function with the specified queue.</span></span> <span data-ttu-id="7769e-507">После чего ThreadX будет вызывать эту функцию уведомления приложения всякий раз, когда в очередь будет отправлено сообщение.</span><span class="sxs-lookup"><span data-stu-id="7769e-507">ThreadX will subsequently invoke this application notification function whenever a message is sent to the queue.</span></span> <span data-ttu-id="7769e-508">Конкретная обработка в функции уведомления приложения определяется самим приложением. Однако обычно она предполагает возобновление соответствующего потока для обработки нового сообщения.</span><span class="sxs-lookup"><span data-stu-id="7769e-508">The exact processing within the application notification function is determined by the application; however, it typically consists of resuming the appropriate thread for processing the new message.</span></span>

### <a name="queue-event-chainingtrade"></a><span data-ttu-id="7769e-509">Event chaining&trade; для очереди</span><span class="sxs-lookup"><span data-stu-id="7769e-509">Queue Event chaining&trade;</span></span>

<span data-ttu-id="7769e-510">Возможности уведомлений в ThreadX можно использовать для объединения различных событий синхронизации в цепочку.</span><span class="sxs-lookup"><span data-stu-id="7769e-510">The notification capabilities in ThreadX can be used to chain various synchronization events together.</span></span> <span data-ttu-id="7769e-511">Обычно это удобно, когда один поток должен обрабатывать несколько событий синхронизации.</span><span class="sxs-lookup"><span data-stu-id="7769e-511">This is typically useful when a single thread must process multiple synchronization events.</span></span>

<span data-ttu-id="7769e-512">Например, предположим, что один поток отвечает за обработку сообщений из пяти разных очередей. При этом он должен приостанавливаться, если нет доступных сообщений.</span><span class="sxs-lookup"><span data-stu-id="7769e-512">For example, suppose a single thread is responsible for processing messages from five different queues and must also suspend when no messages are available.</span></span> <span data-ttu-id="7769e-513">Это легко реализовать, зарегистрировав функцию уведомления приложения для каждой очереди и введя дополнительный семафор со счетчиком.</span><span class="sxs-lookup"><span data-stu-id="7769e-513">This is easily accomplished by registering an application notification function for each queue and introducing an additional counting semaphore.</span></span> <span data-ttu-id="7769e-514">В частности, функция уведомления приложения вызывает службу *tx_semaphore_put* при каждом вызове (значение семафора представляет общее количество сообщений во всех пяти очередях).</span><span class="sxs-lookup"><span data-stu-id="7769e-514">Specifically, the application notification function performs a *tx_semaphore_put* whenever it is called (the semaphore count represents the total number of messages in all five queues).</span></span> <span data-ttu-id="7769e-515">Поток обработки приостанавливается на этом семафоре с помощью службы *tx_semaphore_get*.</span><span class="sxs-lookup"><span data-stu-id="7769e-515">The processing thread suspends on this semaphore via the *tx_semaphore_get* service.</span></span> <span data-ttu-id="7769e-516">Если семафор доступен (в данном случае, когда доступно сообщение), то поток обработки возобновляется.</span><span class="sxs-lookup"><span data-stu-id="7769e-516">When the semaphore is available (in this case, when a message is available!), the processing thread is resumed.</span></span> <span data-ttu-id="7769e-517">Затем выполняется опрос каждой очереди на наличие сообщения, найденное сообщение обрабатывается и выполняется вызов службы ***tx_semaphore_get*** для ожидания следующего сообщения.</span><span class="sxs-lookup"><span data-stu-id="7769e-517">It then interrogates each queue for a message, processes the found message, and performs another ***tx_semaphore_get*** to wait for the next message.</span></span> <span data-ttu-id="7769e-518">Реализовать это без цепочки событий довольно сложно, и, скорее всего, для этого потребуется большее число потоков и (или) дополнительный код приложения.</span><span class="sxs-lookup"><span data-stu-id="7769e-518">Accomplishing this without event-chaining is quite difficult and likely would require more threads and/or additional application code.</span></span>

<span data-ttu-id="7769e-519">Как правило, *цепочки событий* позволяют уменьшить количество потоков, временные затраты и требования к ОЗУ.</span><span class="sxs-lookup"><span data-stu-id="7769e-519">In general, *event-chaining* results in fewer threads, less overhead, and smaller RAM requirements.</span></span> <span data-ttu-id="7769e-520">Они также предоставляют очень гибкий механизм для соблюдения требований синхронизации в более сложных системах.</span><span class="sxs-lookup"><span data-stu-id="7769e-520">It also provides a highly flexible mechanism to handle synchronization requirements of more complex systems.</span></span>

### <a name="run-time-queue-performance-information"></a><span data-ttu-id="7769e-521">Сведения о производительности очередей во время выполнения</span><span class="sxs-lookup"><span data-stu-id="7769e-521">Run-time Queue Performance Information</span></span>
<span data-ttu-id="7769e-522">ThreadX предоставляет дополнительные сведения о производительности очередей во время выполнения.</span><span class="sxs-lookup"><span data-stu-id="7769e-522">ThreadX provides optional run-time queue performance information.</span></span> <span data-ttu-id="7769e-523">Если при сборке приложения и библиотеки ThreadX был определен параметр ***TX_QUEUE_ENABLE_PERFORMANCE_INFO***, ThreadX собирает следующую информацию.</span><span class="sxs-lookup"><span data-stu-id="7769e-523">If the ThreadX library and application is built with ***TX_QUEUE_ENABLE_PERFORMANCE_INFO*** defined, ThreadX accumulates the following information.</span></span>

<span data-ttu-id="7769e-524">Общее число (для всей системы):</span><span class="sxs-lookup"><span data-stu-id="7769e-524">Total number for the overall system:</span></span>

  - <span data-ttu-id="7769e-525">отправленных сообщений;</span><span class="sxs-lookup"><span data-stu-id="7769e-525">messages sent</span></span>

  - <span data-ttu-id="7769e-526">полученных сообщений;</span><span class="sxs-lookup"><span data-stu-id="7769e-526">messages received</span></span>

  - <span data-ttu-id="7769e-527">приостановок из-за пустой очереди;</span><span class="sxs-lookup"><span data-stu-id="7769e-527">queue empty suspensions</span></span>

  - <span data-ttu-id="7769e-528">приостановок из-за переполнения очереди;</span><span class="sxs-lookup"><span data-stu-id="7769e-528">queue full suspensions</span></span>

  - <span data-ttu-id="7769e-529">возвращенных ошибок из-за переполнения очереди (приостановка не задана);</span><span class="sxs-lookup"><span data-stu-id="7769e-529">queue full error returns (suspension not specified)</span></span>

  - <span data-ttu-id="7769e-530">превышений времени ожидания очереди.</span><span class="sxs-lookup"><span data-stu-id="7769e-530">queue timeouts</span></span>

<span data-ttu-id="7769e-531">Общее число (для каждой очереди):</span><span class="sxs-lookup"><span data-stu-id="7769e-531">Total number for each queue:</span></span>

  - <span data-ttu-id="7769e-532">отправленных сообщений;</span><span class="sxs-lookup"><span data-stu-id="7769e-532">messages sent</span></span>

  - <span data-ttu-id="7769e-533">полученных сообщений;</span><span class="sxs-lookup"><span data-stu-id="7769e-533">messages received</span></span>

  - <span data-ttu-id="7769e-534">приостановок из-за пустой очереди;</span><span class="sxs-lookup"><span data-stu-id="7769e-534">queue empty suspensions</span></span>

  - <span data-ttu-id="7769e-535">приостановок из-за переполнения очереди;</span><span class="sxs-lookup"><span data-stu-id="7769e-535">queue full suspensions</span></span>

  - <span data-ttu-id="7769e-536">возвращенных ошибок из-за переполнения очереди (приостановка не задана);</span><span class="sxs-lookup"><span data-stu-id="7769e-536">queue full error returns (suspension not specified)</span></span>

  - <span data-ttu-id="7769e-537">превышений времени ожидания очереди.</span><span class="sxs-lookup"><span data-stu-id="7769e-537">queue timeouts</span></span>

<span data-ttu-id="7769e-538">Эти сведения можно получить во время выполнения с помощью служб ***tx_queue_performance_info_get** _ и _*_tx_queue_performance_system_info_get_\*\*.</span><span class="sxs-lookup"><span data-stu-id="7769e-538">This information is available at run-time through the services ***tx_queue_performance_info_get** _ and _*_tx_queue_performance_system_info_get_\*\*.</span></span> <span data-ttu-id="7769e-539">С помощью сведений о производительности очередей удобно определять, правильно ли работает приложение.</span><span class="sxs-lookup"><span data-stu-id="7769e-539">Queue performance information is useful in determining if the application is behaving properly.</span></span> <span data-ttu-id="7769e-540">Они также полезны для оптимизации приложения.</span><span class="sxs-lookup"><span data-stu-id="7769e-540">It is also useful in optimizing the application.</span></span> <span data-ttu-id="7769e-541">Например, относительно большое число приостановок из-за переполнения очереди позволяет предположить, что следует увеличить размер очереди.</span><span class="sxs-lookup"><span data-stu-id="7769e-541">For example, a relatively high number of "queue full suspensions" suggests an increase in the queue size might be beneficial.</span></span>

### <a name="queue-control-block-tx_queue"></a><span data-ttu-id="7769e-542">TX_QUEUE: блок управления очереди</span><span class="sxs-lookup"><span data-stu-id="7769e-542">Queue Control Block TX_QUEUE</span></span>

<span data-ttu-id="7769e-543">Характеристики каждой очереди сообщений находятся в ее блоке управления.</span><span class="sxs-lookup"><span data-stu-id="7769e-543">The characteristics of each message queue are found in its control block.</span></span> <span data-ttu-id="7769e-544">Он содержит важные сведения, например количество сообщений в очереди.</span><span class="sxs-lookup"><span data-stu-id="7769e-544">It contains interesting information such as the number of messages in the queue.</span></span> <span data-ttu-id="7769e-545">Эта структура определена в файле ***tx_api.h***.</span><span class="sxs-lookup"><span data-stu-id="7769e-545">This structure is defined in the ***tx_api.h*** file.</span></span>

<span data-ttu-id="7769e-546">Блоки управления очереди могут размещаться в любом месте в памяти, но чаще всего они определяются вне области какой-либо функции, благодаря чему функционируют как глобальная структура.</span><span class="sxs-lookup"><span data-stu-id="7769e-546">Message queue control blocks can also be located anywhere in memory, but it is most common to make the control block a global structure by defining it outside the scope of any function.</span></span>

### <a name="message-destination-pitfall"></a><span data-ttu-id="7769e-547">Проблемы с назначением сообщений</span><span class="sxs-lookup"><span data-stu-id="7769e-547">Message Destination Pitfall</span></span>

<span data-ttu-id="7769e-548">Как упоминалось ранее, сообщения копируются между областью очереди и областями данных приложения.</span><span class="sxs-lookup"><span data-stu-id="7769e-548">As mentioned previously, messages are copied between the queue area and application data areas.</span></span> <span data-ttu-id="7769e-549">Важно убедиться, что область назначения для получаемого сообщения достаточно велика, чтобы вместить все сообщение.</span><span class="sxs-lookup"><span data-stu-id="7769e-549">It is important to ensure the destination for a received message is large enough to hold the entire message.</span></span> <span data-ttu-id="7769e-550">В противном случае память, следующая за областью назначения сообщения, скорее всего, будет повреждена.</span><span class="sxs-lookup"><span data-stu-id="7769e-550">If not, the memory following the message destination will likely be corrupted.</span></span>

> [!NOTE]
> <span data-ttu-id="7769e-551">*Это особенно фатально, когда область назначения сообщений в стеке слишком мала. В этом случае повреждение обратного адреса функции гарантировано.*</span><span class="sxs-lookup"><span data-stu-id="7769e-551">*This is especially lethal when a too-small message destination is on the stack—nothing like corrupting the return address of a function!*</span></span>

## <a name="counting-semaphores"></a><span data-ttu-id="7769e-552">Семафоры со счетчиком</span><span class="sxs-lookup"><span data-stu-id="7769e-552">Counting Semaphores</span></span>

<span data-ttu-id="7769e-553">ThreadX предоставляет 32-разрядные семафоры со счетчиком, значения которых находятся в диапазоне от 0 до 4 294 967 295.</span><span class="sxs-lookup"><span data-stu-id="7769e-553">ThreadX provides 32-bit counting semaphores that range in value between 0 and 4,294,967,295.</span></span> <span data-ttu-id="7769e-554">Существуют две операции для семафоров со счетчиком: *tx_semaphore_get* и *tx_semaphore_put*.</span><span class="sxs-lookup"><span data-stu-id="7769e-554">There are two operations for counting semaphores: *tx_semaphore_get* and *tx_semaphore_put*.</span></span> <span data-ttu-id="7769e-555">Операция Get уменьшает значение семафора на один.</span><span class="sxs-lookup"><span data-stu-id="7769e-555">The get operation decreases the semaphore by one.</span></span> <span data-ttu-id="7769e-556">Если значение семафора равно 0, то операция Get не выполняется.</span><span class="sxs-lookup"><span data-stu-id="7769e-556">If the semaphore is 0, the get operation is not successful.</span></span> <span data-ttu-id="7769e-557">Обратная операции Get — операция Put.</span><span class="sxs-lookup"><span data-stu-id="7769e-557">The inverse of the get operation is the put operation.</span></span>
<span data-ttu-id="7769e-558">Она увеличивает значение семафора на один.</span><span class="sxs-lookup"><span data-stu-id="7769e-558">It increases the semaphore by one.</span></span>

<span data-ttu-id="7769e-559">Каждый семафор со счетчиком является общедоступным ресурсом.</span><span class="sxs-lookup"><span data-stu-id="7769e-559">Each counting semaphore is a public resource.</span></span> <span data-ttu-id="7769e-560">В ThreadX нет ограничений на использование семафоров со счетчиком.</span><span class="sxs-lookup"><span data-stu-id="7769e-560">ThreadX places no constraints on how counting semaphores are used.</span></span>

<span data-ttu-id="7769e-561">Семафоры со счетчиком обычно используются для *взаимного исключения*.</span><span class="sxs-lookup"><span data-stu-id="7769e-561">Counting semaphores are typically used for *mutual exclusion*.</span></span> <span data-ttu-id="7769e-562">Однако семафоры со счетчиком можно также использовать для уведомления о событиях.</span><span class="sxs-lookup"><span data-stu-id="7769e-562">However, counting semaphores can also be used as a method for event notification.</span></span>

### <a name="mutual-exclusion"></a><span data-ttu-id="7769e-563">Взаимное исключение</span><span class="sxs-lookup"><span data-stu-id="7769e-563">Mutual Exclusion</span></span>

 <span data-ttu-id="7769e-564">Взаимное исключение применяется при управлении доступом потоков к определенным областям приложения (также называемым *критическими разделами* или *ресурсами приложения*).</span><span class="sxs-lookup"><span data-stu-id="7769e-564">Mutual exclusion pertains to controlling the access of threads to certain application areas (also called *critical sections* or *application resources*).</span></span> <span data-ttu-id="7769e-565">Если семафор используется для взаимного исключения, то его текущее значение равно общему числу потоков, которым разрешен доступ.</span><span class="sxs-lookup"><span data-stu-id="7769e-565">When used for mutual exclusion, the "current count" of a semaphore represents the total number of threads that are allowed access.</span></span> <span data-ttu-id="7769e-566">В большинстве случаев семафоры со счетчиком, используемые для взаимного исключения, будут иметь начальное значение 1, то есть в каждый момент времени доступ к связанному ресурсу сможет получить только один поток.</span><span class="sxs-lookup"><span data-stu-id="7769e-566">In most cases, counting semaphores used for mutual exclusion will have an initial value of 1, meaning that only one thread can access the associated resource at a time.</span></span> <span data-ttu-id="7769e-567">Семафоры со счетчиком, которые принимают только значение 0 или 1, обычно называются *двоичными семафорами*.</span><span class="sxs-lookup"><span data-stu-id="7769e-567">Counting semaphores that only have values of 0 or 1 are commonly called *binary semaphores*.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="7769e-568">*Если используется двоичный семафор, пользователь должен сделать так, чтобы поток не выполнял операцию Get с семафором, которым он уже владеет. Вторая операция Get завершится сбоем, что может привести к бессрочной приостановке вызывающего потока и постоянной недоступности ресурса.*</span><span class="sxs-lookup"><span data-stu-id="7769e-568">*If a binary semaphore is being used, the user must prevent the same thread from performing a get operation on a semaphore it already owns. A second get would be unsuccessful and could cause indefinite suspension of the calling thread and permanent unavailability of the resource.*</span></span>

### <a name="event-notification"></a><span data-ttu-id="7769e-569">Уведомление о событии</span><span class="sxs-lookup"><span data-stu-id="7769e-569">Event Notification</span></span>

<span data-ttu-id="7769e-570">Семафоры со счетчиком можно также использовать для уведомления о событиях по схеме "производитель — получатель".</span><span class="sxs-lookup"><span data-stu-id="7769e-570">It is also possible to use counting semaphores as event notification, in a producer-consumer fashion.</span></span> <span data-ttu-id="7769e-571">Получатель пытается получить семафор со счетчиком, тогда как производитель увеличивает значение семафора при каждом обращении.</span><span class="sxs-lookup"><span data-stu-id="7769e-571">The consumer attempts to get the counting semaphore while the producer increases the semaphore whenever something is available.</span></span> <span data-ttu-id="7769e-572">Такие семафоры обычно имеют начальное значение 0, и их значение не увеличивается до тех пор, пока производитель не подготовит что-либо для получателя.</span><span class="sxs-lookup"><span data-stu-id="7769e-572">Such semaphores usually have an initial value of 0 and will not increase until the producer has something ready for the consumer.</span></span> <span data-ttu-id="7769e-573">Семафоры, используемые для уведомления о событиях, также могут использовать вызов службы ***tx_semaphore_ceiling_put***.</span><span class="sxs-lookup"><span data-stu-id="7769e-573">Semaphores used for event notification may also benefit from use of the ***tx_semaphore_ceiling_put*** service call.</span></span> <span data-ttu-id="7769e-574">Эта служба гарантирует, что значение семафора никогда не превысит значение, указанное в вызове.</span><span class="sxs-lookup"><span data-stu-id="7769e-574">This service ensures that the semaphore count never exceeds the value supplied in the call.</span></span>

### <a name="creating-counting-semaphores"></a><span data-ttu-id="7769e-575">Создание семафоров со счетчиком</span><span class="sxs-lookup"><span data-stu-id="7769e-575">Creating Counting Semaphores</span></span>

<span data-ttu-id="7769e-576">Семафоры со счетчиком создаются во время инициализации или во время выполнения потоками приложения.</span><span class="sxs-lookup"><span data-stu-id="7769e-576">Counting semaphores are created either during initialization or during run-time by application threads.</span></span> <span data-ttu-id="7769e-577">Начальное значение семафора задается во время создания.</span><span class="sxs-lookup"><span data-stu-id="7769e-577">The initial count of the semaphore is specified during creation.</span></span> <span data-ttu-id="7769e-578">Число семафоров со счетчиком в приложении не ограничено.</span><span class="sxs-lookup"><span data-stu-id="7769e-578">There is no limit on the number of counting semaphores in an application.</span></span>

### <a name="thread-suspension"></a><span data-ttu-id="7769e-579">Приостановка потока</span><span class="sxs-lookup"><span data-stu-id="7769e-579">Thread Suspension</span></span>

<span data-ttu-id="7769e-580">Потоки приложения могут быть приостановлены при попытке выполнить операцию Get с семафором, текущее значение которого равно 0.</span><span class="sxs-lookup"><span data-stu-id="7769e-580">Application threads can suspend while attempting to perform a get operation on a semaphore with a current count of 0.</span></span>

<span data-ttu-id="7769e-581">После выполнения операции Put выполняется операция Get приостановленного потока и поток возобновляется.</span><span class="sxs-lookup"><span data-stu-id="7769e-581">After a put operation is performed, the suspended thread's get operation is performed and the thread is resumed.</span></span> <span data-ttu-id="7769e-582">Если на одном семафоре со счетчиком приостанавливается несколько потоков, они возобновляются в том же порядке, в котором были приостановлены (FIFO).</span><span class="sxs-lookup"><span data-stu-id="7769e-582">If multiple threads are suspended on the same counting semaphore, they are resumed in the same order they were suspended (FIFO).</span></span>

<span data-ttu-id="7769e-583">Однако также возможно возобновление по приоритету, если приложение вызовет ***tx_semaphore_prioritize*** перед вызовом операции Put для семафора, которая прекращает приостановку потоков.</span><span class="sxs-lookup"><span data-stu-id="7769e-583">However, priority resumption is also possible if the application calls ***tx_semaphore_prioritize*** prior to the semaphore put call that lifts thread suspension.</span></span> <span data-ttu-id="7769e-584">Служба назначения приоритетов для семафора помещает поток с наибольшим приоритетом в начало списка приостановки, оставляя прочие приостановленные потоки в том же порядке по принципу FIFO.</span><span class="sxs-lookup"><span data-stu-id="7769e-584">The semaphore prioritize service places the highest priority thread at the front of the suspension list, while leaving all other suspended threads in the same FIFO order.</span></span>

### <a name="semaphore-put-notification"></a><span data-ttu-id="7769e-585">Уведомление об операции Put с семафором</span><span class="sxs-lookup"><span data-stu-id="7769e-585">Semaphore Put Notification</span></span>

<span data-ttu-id="7769e-586">Некоторые приложения могут использовать преимущества уведомлений о каждой операции Put, выполняемой с семафором.</span><span class="sxs-lookup"><span data-stu-id="7769e-586">Some applications may find it advantageous to be notified whenever a semaphore is put.</span></span> <span data-ttu-id="7769e-587">ThreadX обеспечивает эту возможность с помощью службы ***tx_semaphore_put_notify***.</span><span class="sxs-lookup"><span data-stu-id="7769e-587">ThreadX provides this ability through the ***tx_semaphore_put_notify*** service.</span></span> <span data-ttu-id="7769e-588">Эта служба регистрирует указанную функцию уведомления приложения для заданного семафора.</span><span class="sxs-lookup"><span data-stu-id="7769e-588">This service registers the supplied application notification function with the specified semaphore.</span></span> <span data-ttu-id="7769e-589">После чего ThreadX будет вызывать эту функцию уведомления приложения всякий раз, когда с семафором будет выполнена операция Put.</span><span class="sxs-lookup"><span data-stu-id="7769e-589">ThreadX will subsequently invoke this application notification function whenever the semaphore is put.</span></span> <span data-ttu-id="7769e-590">Конкретная обработка в функции уведомления приложения определяется самим приложением. Однако обычно она включает в себя возобновление соответствующего потока для обработки нового события операции Put с семафором.</span><span class="sxs-lookup"><span data-stu-id="7769e-590">The exact processing within the application notification function is determined by the application; however, it typically consists of resuming the appropriate thread for processing the new semaphore put event.</span></span>

### <a name="semaphore-event-chainingtrade"></a><span data-ttu-id="7769e-591">Цепочка событий семафора&trade;</span><span class="sxs-lookup"><span data-stu-id="7769e-591">Semaphore Event chaining&trade;</span></span>

<span data-ttu-id="7769e-592">Возможности уведомлений в ThreadX можно использовать для объединения различных событий синхронизации в цепочку.</span><span class="sxs-lookup"><span data-stu-id="7769e-592">The notification capabilities in ThreadX can be used to chain various synchronization events together.</span></span> <span data-ttu-id="7769e-593">Обычно это удобно, когда один поток должен обрабатывать несколько событий синхронизации.</span><span class="sxs-lookup"><span data-stu-id="7769e-593">This is typically useful when a single thread must process multiple synchronization events.</span></span>

<span data-ttu-id="7769e-594">Например, вместо того чтобы приостанавливать отдельные потоки для сообщения очереди, флагов событий или семафора, приложение может зарегистрировать подпрограмму уведомления для каждого объекта.</span><span class="sxs-lookup"><span data-stu-id="7769e-594">For example, instead of having separate threads suspend for a queue message, event flags, and a semaphore, the application can register a notification routine for each object.</span></span> <span data-ttu-id="7769e-595">Тогда при вызове эта подпрограмма уведомления приложения сможет возобновить работу одного потока, который сможет опросить каждый объект, чтобы найти и обработать новое событие.</span><span class="sxs-lookup"><span data-stu-id="7769e-595">When invoked, the application notification routine can then resume a single thread, which can interrogate each object to find and process the new event.</span></span>

<span data-ttu-id="7769e-596">Как правило, *цепочки событий* позволяют уменьшить количество потоков, временные затраты и требования к ОЗУ.</span><span class="sxs-lookup"><span data-stu-id="7769e-596">In general, *event-chaining* results in fewer threads, less overhead, and smaller RAM requirements.</span></span> <span data-ttu-id="7769e-597">Они также предоставляют очень гибкий механизм для соблюдения требований синхронизации в более сложных системах.</span><span class="sxs-lookup"><span data-stu-id="7769e-597">It also provides a highly flexible mechanism to handle synchronization requirements of more complex systems.</span></span>

### <a name="run-time-semaphore-performance-information"></a><span data-ttu-id="7769e-598">Сведения о производительности семафоров во время выполнения</span><span class="sxs-lookup"><span data-stu-id="7769e-598">Run-time Semaphore Performance Information</span></span>

<span data-ttu-id="7769e-599">ThreadX предоставляет дополнительные сведения о производительности семафоров во время выполнения.</span><span class="sxs-lookup"><span data-stu-id="7769e-599">ThreadX provides optional run-time semaphore performance information.</span></span> <span data-ttu-id="7769e-600">Если при сборке приложения и библиотеки ThreadX был определен параметр **TX_SEMAPHORE_ENABLE_PERFORMANCE_INFO**, ThreadX собирает следующую информацию.</span><span class="sxs-lookup"><span data-stu-id="7769e-600">If the ThreadX library and application is built with **TX_SEMAPHORE_ENABLE_PERFORMANCE_INFO** defined, ThreadX accumulates the following information.</span></span>

<span data-ttu-id="7769e-601">Общее число (для всей системы):</span><span class="sxs-lookup"><span data-stu-id="7769e-601">Total number for the overall system:</span></span>

  - <span data-ttu-id="7769e-602">операций Put с семафорами;</span><span class="sxs-lookup"><span data-stu-id="7769e-602">semaphore puts</span></span>

  - <span data-ttu-id="7769e-603">операций Get с семафором;</span><span class="sxs-lookup"><span data-stu-id="7769e-603">semaphore gets</span></span>

  - <span data-ttu-id="7769e-604">приостановок из-за операций Get с семафором;</span><span class="sxs-lookup"><span data-stu-id="7769e-604">semaphore get suspensions</span></span>

  - <span data-ttu-id="7769e-605">превышений времени ожидания операций Get с семафорами.</span><span class="sxs-lookup"><span data-stu-id="7769e-605">semaphore get timeouts</span></span>

<span data-ttu-id="7769e-606">Общее число (для каждого семафора):</span><span class="sxs-lookup"><span data-stu-id="7769e-606">Total number for each semaphore:</span></span>

  - <span data-ttu-id="7769e-607">операций Put с семафорами;</span><span class="sxs-lookup"><span data-stu-id="7769e-607">semaphore puts</span></span>

  - <span data-ttu-id="7769e-608">операций Get с семафором;</span><span class="sxs-lookup"><span data-stu-id="7769e-608">semaphore gets</span></span>

  - <span data-ttu-id="7769e-609">приостановок из-за операций Get с семафором;</span><span class="sxs-lookup"><span data-stu-id="7769e-609">semaphore get suspensions</span></span>

  - <span data-ttu-id="7769e-610">превышений времени ожидания операций Get с семафорами.</span><span class="sxs-lookup"><span data-stu-id="7769e-610">semaphore get timeouts</span></span>

<span data-ttu-id="7769e-611">Эти сведения можно получить во время выполнения с помощью служб ***tx_semaphore_performance_info_get** _ и _*_tx_semaphore_performance_system_info_get_\*\*.</span><span class="sxs-lookup"><span data-stu-id="7769e-611">This information is available at run-time through the services ***tx_semaphore_performance_info_get** _ and _*_tx_semaphore_performance_system_info_get_\*\*.</span></span> <span data-ttu-id="7769e-612">Сведения о производительности семафоров удобно использовать, чтобы определить, правильно ли работает приложение.</span><span class="sxs-lookup"><span data-stu-id="7769e-612">Semaphore performance information is useful in determining if the application is behaving properly.</span></span> <span data-ttu-id="7769e-613">Они также полезны для оптимизации приложения.</span><span class="sxs-lookup"><span data-stu-id="7769e-613">It is also useful in optimizing the application.</span></span> <span data-ttu-id="7769e-614">Например, относительно частое превышение времени ожидания операций Get с семафором позволяет предположить, что другие потоки удерживают ресурсы слишком долго.</span><span class="sxs-lookup"><span data-stu-id="7769e-614">For example, a relatively high number of "semaphore get timeouts" might suggest that other threads are holding resources too long.</span></span>

### <a name="semaphore-control-block-tx_semaphore"></a><span data-ttu-id="7769e-615">TX_SEMAPHORE: блок управления семафора</span><span class="sxs-lookup"><span data-stu-id="7769e-615">Semaphore Control Block TX_SEMAPHORE</span></span>

<span data-ttu-id="7769e-616">Характеристики каждого семафора со счетчиком находятся в его блоке управления.</span><span class="sxs-lookup"><span data-stu-id="7769e-616">The characteristics of each counting semaphore are found in its control block.</span></span> <span data-ttu-id="7769e-617">Он содержит такие сведения, как текущее значение семафора.</span><span class="sxs-lookup"><span data-stu-id="7769e-617">It contains information such as the current semaphore count.</span></span> <span data-ttu-id="7769e-618">Эта структура определена в файле ***tx_api.h***.</span><span class="sxs-lookup"><span data-stu-id="7769e-618">This structure is defined in the ***tx_api.h*** file.</span></span>

<span data-ttu-id="7769e-619">Блоки управления семафора могут размещаться в любом месте в памяти, но чаще всего они определяются вне области какой-либо функции, благодаря чему функционируют как глобальная структура.</span><span class="sxs-lookup"><span data-stu-id="7769e-619">Semaphore control blocks can be located anywhere in memory, but it is most common to make the control block a global structure by defining it outside the scope of any function.</span></span>

### <a name="deadly-embrace"></a><span data-ttu-id="7769e-620">Взаимная блокировка</span><span class="sxs-lookup"><span data-stu-id="7769e-620">Deadly Embrace</span></span>

<span data-ttu-id="7769e-621">Одной из наиболее интересных и опасных проблем, связанных с семафорами, используемыми для взаимного исключения, является *взаимная блокировка*.</span><span class="sxs-lookup"><span data-stu-id="7769e-621">One of the most interesting and dangerous pitfalls associated with semaphores used for mutual exclusion is the *deadly embrace*.</span></span> <span data-ttu-id="7769e-622">Взаимная блокировка (или *взаимоблокировка*) — это ситуация, в которой два или более потоков бессрочно приостанавливаются при попытке получить семафоры, которые уже принадлежат им обоим.</span><span class="sxs-lookup"><span data-stu-id="7769e-622">A deadly embrace, or *deadlock*, is a condition in which two or more threads are suspended indefinitely while attempting to get semaphores already owned by each other.</span></span>

<span data-ttu-id="7769e-623">Эту ситуацию лучше всего можно продемонстрировать на примере двух потоков и двух семафоров.</span><span class="sxs-lookup"><span data-stu-id="7769e-623">This condition is best illustrated by a two thread, two semaphore example.</span></span> <span data-ttu-id="7769e-624">Предположим, первый поток владеет первым семафором, а второй поток — вторым.</span><span class="sxs-lookup"><span data-stu-id="7769e-624">Suppose the first thread owns the first semaphore and the second thread owns the second semaphore.</span></span> <span data-ttu-id="7769e-625">Если первый поток пытается получить второй семафор и в то же время второй поток пытается получить первый, оба входят в состояние взаимоблокировки.</span><span class="sxs-lookup"><span data-stu-id="7769e-625">If the first thread attempts to get the second semaphore and at the same time the second thread attempts to get the first semaphore, both threads enter a deadlock condition.</span></span> <span data-ttu-id="7769e-626">Кроме того, если эти потоки бессрочно приостановлены, связанные с ними ресурсы также окончательно блокируются.</span><span class="sxs-lookup"><span data-stu-id="7769e-626">In addition, if these threads stay suspended forever, their associated resources are locked-out forever as well.</span></span> <span data-ttu-id="7769e-627">Этот пример показан на рис. 8.</span><span class="sxs-lookup"><span data-stu-id="7769e-627">Figure 8 illustrates this example.</span></span>

<span data-ttu-id="7769e-628">**Взаимная блокировка** (пример)</span><span class="sxs-lookup"><span data-stu-id="7769e-628">**Deadly Embrace** (example)</span></span>

![Пример приостановленных потоков](./media/user-guide/example-suspended-threads.png)

<span data-ttu-id="7769e-630">**Рисунок 8. Пример приостановленных потоков**</span><span class="sxs-lookup"><span data-stu-id="7769e-630">**FIGURE 8. Example of Suspended Threads**</span></span>

<span data-ttu-id="7769e-631">Для систем реального времени взаимную блокировку можно предотвратить, наложив определенные ограничения на то, как потоки получают семафоры.</span><span class="sxs-lookup"><span data-stu-id="7769e-631">For real-time systems, deadly embraces can be prevented by placing certain restrictions on how threads obtain semaphores.</span></span> <span data-ttu-id="7769e-632">В каждый момент времени потоки могут владеть только одним семафором.</span><span class="sxs-lookup"><span data-stu-id="7769e-632">Threads can only have one semaphore at a time.</span></span> <span data-ttu-id="7769e-633">При этом они могут владеть несколькими семафорами, если собирают их значения в одном и том же порядке.</span><span class="sxs-lookup"><span data-stu-id="7769e-633">Alternatively, threads can own multiple semaphores if they gather them in the same order.</span></span> <span data-ttu-id="7769e-634">Если в предыдущем примере первый и второй потоки будут получать первый и второй семафоры по порядку, взаимная блокировка будет предотвращена.</span><span class="sxs-lookup"><span data-stu-id="7769e-634">In the previous example, if the first and second thread obtain the first and second semaphore in order, the deadly embrace is prevented.</span></span>

> [!TIP]
> <span data-ttu-id="7769e-635">*Для выхода из взаимной блокировки можно также использовать время ожидания приостановки, связанное с операцией Get.*</span><span class="sxs-lookup"><span data-stu-id="7769e-635">*It is also possible to use the suspension time-out associated with the get operation to recover from a deadly embrace.*</span></span>

### <a name="priority-inversion"></a><span data-ttu-id="7769e-636">Инверсия приоритета</span><span class="sxs-lookup"><span data-stu-id="7769e-636">Priority Inversion</span></span>

<span data-ttu-id="7769e-637">Еще одной проблемой, связанной с взаимоисключающими семафорами, является инверсия приоритета.</span><span class="sxs-lookup"><span data-stu-id="7769e-637">Another pitfall associated with mutual exclusion semaphores is priority inversion.</span></span> <span data-ttu-id="7769e-638">Эта тема более подробно рассмотрена в разделе [Проблемы, связанные с приоритетами потоков](#thread-priority-pitfalls).</span><span class="sxs-lookup"><span data-stu-id="7769e-638">This topic is discussed more fully in "[Thread Priority Pitfalls](#thread-priority-pitfalls)".</span></span>

<span data-ttu-id="7769e-639">Основная проблема возникает, когда поток с более низким приоритетом владеет семафором, требуемым потоку с более высоким приоритетом.</span><span class="sxs-lookup"><span data-stu-id="7769e-639">The basic problem results from a situation in which a lower-priority thread has a semaphore that a higher priority thread needs.</span></span> <span data-ttu-id="7769e-640">Сама по себе эта ситуация является нормальной.</span><span class="sxs-lookup"><span data-stu-id="7769e-640">This in itself is normal.</span></span> <span data-ttu-id="7769e-641">Однако потоки с промежуточными приоритетами могут привести к инверсии приоритета на неопределенно долгий срок.</span><span class="sxs-lookup"><span data-stu-id="7769e-641">However, threads with priorities in between them may cause the priority inversion to last a nondeterministic amount of time.</span></span> <span data-ttu-id="7769e-642">Чтобы устранить эту проблему, можно тщательно выбирать приоритет потоков, использовать порог вытеснения и временно повышать приоритет потока, владеющего ресурсом, до уровня потока с более высоким приоритетом.</span><span class="sxs-lookup"><span data-stu-id="7769e-642">This can be handled through careful selection of thread priorities, using preemption-threshold, and temporarily raising the priority of the thread that owns the resource to that of the high priority thread.</span></span>

## <a name="mutexes"></a><span data-ttu-id="7769e-643">Mutexes</span><span class="sxs-lookup"><span data-stu-id="7769e-643">Mutexes</span></span>

<span data-ttu-id="7769e-644">Помимо семафоров ThreadX также предоставляет объект "мьютекс".</span><span class="sxs-lookup"><span data-stu-id="7769e-644">In addition to semaphores, ThreadX also provides a mutex object.</span></span> <span data-ttu-id="7769e-645">Мьютекс по сути является двоичным семафором. Это значит, что в каждый момент времени мьютексом может владеть только один поток.</span><span class="sxs-lookup"><span data-stu-id="7769e-645">A mutex is basically a binary semaphore, which means that only one thread can own a mutex at a time.</span></span> <span data-ttu-id="7769e-646">Кроме того, один и тот же поток может успешно выполнить операцию Get с принадлежащим ему мьютексом несколько раз, а точнее — 4 294 967 295 раз.</span><span class="sxs-lookup"><span data-stu-id="7769e-646">In addition, the same thread may perform a successful mutex get operation on an owned mutex multiple times, 4,294,967,295 to be exact.</span></span> <span data-ttu-id="7769e-647">Существуют две операции с объектом "мьютекс": ***tx_mutex_get** _ и _*_tx_mutex_put_\*\*.</span><span class="sxs-lookup"><span data-stu-id="7769e-647">There are two operations on the mutex object: ***tx_mutex_get** _ and _*_tx_mutex_put_\*\*.</span></span> <span data-ttu-id="7769e-648">Операция Get позволяет получить мьютекс, не принадлежащий другому потоку, в то время как операция Put освобождает ранее полученный мьютекс.</span><span class="sxs-lookup"><span data-stu-id="7769e-648">The get operation obtains a mutex not owned by another thread, while the put operation releases a previously obtained mutex.</span></span> <span data-ttu-id="7769e-649">Чтобы поток освободил мьютекс, количество операций Put должно равняться числу предыдущих операций Get.</span><span class="sxs-lookup"><span data-stu-id="7769e-649">For a thread to release a mutex, the number of put operations must equal the number of prior get operations.</span></span>

<span data-ttu-id="7769e-650">Каждый мьютекс является общедоступным ресурсом.</span><span class="sxs-lookup"><span data-stu-id="7769e-650">Each mutex is a public resource.</span></span> <span data-ttu-id="7769e-651">В ThreadX нет ограничений на использование мьютексов.</span><span class="sxs-lookup"><span data-stu-id="7769e-651">ThreadX places no constraints on how mutexes are used.</span></span>

<span data-ttu-id="7769e-652">Мьютексы ThreadX используются исключительно для *взаимного исключения*.</span><span class="sxs-lookup"><span data-stu-id="7769e-652">ThreadX mutexes are used solely for *mutual exclusion*.</span></span> <span data-ttu-id="7769e-653">В отличие от семафоров со счетчиком, мьютексы не используются для уведомления о событиях.</span><span class="sxs-lookup"><span data-stu-id="7769e-653">Unlike counting semaphores, mutexes have no use as a method for event notification.</span></span>

### <a name="mutex-mutual-exclusion"></a><span data-ttu-id="7769e-654">Взаимное исключение мьютексов</span><span class="sxs-lookup"><span data-stu-id="7769e-654">Mutex Mutual Exclusion</span></span>

<span data-ttu-id="7769e-655">Как уже было сказано в разделе о семафорах со счетчиком, взаимное исключение используется при управлении доступом потоков к определенным областям приложения (также называемым *критическими разделами* или *ресурсами приложения*).</span><span class="sxs-lookup"><span data-stu-id="7769e-655">Similar to the discussion in the counting semaphore section, mutual exclusion pertains to controlling the access of threads to certain application areas (also called *critical sections* or *application resources*).</span></span> <span data-ttu-id="7769e-656">Если мьютекс ThreadX доступен, то его счетчик владения равен 0.</span><span class="sxs-lookup"><span data-stu-id="7769e-656">When available, a ThreadX mutex will have an ownership count of 0.</span></span> <span data-ttu-id="7769e-657">После получения мьютекса потоком его счетчик владения увеличивается на единицу для каждой успешной операции Get, выполненной с мьютексом, и уменьшается для каждой успешной операции Put.</span><span class="sxs-lookup"><span data-stu-id="7769e-657">After the mutex is obtained by a thread, the ownership count is incremented once for every successful get operation performed on the mutex and decremented for every successful put operation.</span></span>

### <a name="creating-mutexes"></a><span data-ttu-id="7769e-658">Создание мьютексов</span><span class="sxs-lookup"><span data-stu-id="7769e-658">Creating Mutexes</span></span>

<span data-ttu-id="7769e-659">Мьютексы ThreadX создаются во время инициализации или выполнения потоками приложения.</span><span class="sxs-lookup"><span data-stu-id="7769e-659">ThreadX mutexes are created either during initialization or during run-time by application threads.</span></span> <span data-ttu-id="7769e-660">Начальным состоянием мьютекса всегда является состояние доступности.</span><span class="sxs-lookup"><span data-stu-id="7769e-660">The initial condition of a mutex is always "available."</span></span> <span data-ttu-id="7769e-661">При создании мьютекса можно также выбрать функцию *наследования приоритета*.</span><span class="sxs-lookup"><span data-stu-id="7769e-661">A mutex may also be created with *priority inheritance* selected.</span></span>

### <a name="thread-suspension"></a><span data-ttu-id="7769e-662">Приостановка потока</span><span class="sxs-lookup"><span data-stu-id="7769e-662">Thread Suspension</span></span>

<span data-ttu-id="7769e-663">Потоки приложения могут быть приостановлены при попытке выполнить операцию Get с мьютексом, уже принадлежащим другому потоку.</span><span class="sxs-lookup"><span data-stu-id="7769e-663">Application threads can suspend while attempting to perform a get operation on a mutex already owned by another thread.</span></span>

<span data-ttu-id="7769e-664">После того как поток-владелец выполнит то же количество операций Put, будет выполнена операция Get приостановленного потока, который получит мьютекс, и этот поток возобновится.</span><span class="sxs-lookup"><span data-stu-id="7769e-664">After the same number of put operations are performed by the owning thread, the suspended thread's get operation is performed, giving it ownership of the mutex, and the thread is resumed.</span></span> <span data-ttu-id="7769e-665">Если на одном мьютексе приостанавливается несколько потоков, они возобновляются в том же порядке, в котором были приостановлены (FIFO).</span><span class="sxs-lookup"><span data-stu-id="7769e-665">If multiple threads are suspended on the same mutex, they are resumed in the same order they were suspended (FIFO).</span></span>

<span data-ttu-id="7769e-666">Однако если во время создания мьютекса было выбрано наследование приоритета, возобновление автоматически выполняется по приоритету.</span><span class="sxs-lookup"><span data-stu-id="7769e-666">However, priority resumption is done automatically if the mutex priority inheritance was selected during creation.</span></span> <span data-ttu-id="7769e-667">Кроме того, возможно возобновление по приоритету, если приложение вызовет ***tx_mutex_prioritize*** перед вызовом операции Put с мьютексом, которая прекращает приостановку потоков.</span><span class="sxs-lookup"><span data-stu-id="7769e-667">Priority resumption is also possible if the application calls ***tx_mutex_prioritize*** prior to the mutex put call that lifts thread suspension.</span></span> <span data-ttu-id="7769e-668">Служба назначения приоритетов для мьютекса помещает поток с наибольшим приоритетом в начало списка приостановки, оставляя прочие приостановленные потоки в том же порядке по принципу FIFO.</span><span class="sxs-lookup"><span data-stu-id="7769e-668">The mutex prioritize service places the highest priority thread at the front of the suspension list, while leaving all other suspended threads in the same FIFO order.</span></span>

### <a name="run-time-mutex-performance-information"></a><span data-ttu-id="7769e-669">Сведения о производительности мьютексов во время выполнения</span><span class="sxs-lookup"><span data-stu-id="7769e-669">Run-time Mutex Performance Information</span></span>

<span data-ttu-id="7769e-670">ThreadX предоставляет дополнительные сведения о производительности мьютексов во время выполнения.</span><span class="sxs-lookup"><span data-stu-id="7769e-670">ThreadX provides optional run-time mutex performance information.</span></span> <span data-ttu-id="7769e-671">Если при сборке приложения и библиотеки ThreadX был определен параметр **TX_MUTEX_ENABLE_PERFORMANCE_INFO**, ThreadX собирает следующую информацию.</span><span class="sxs-lookup"><span data-stu-id="7769e-671">If the ThreadX library and application is built with **TX_MUTEX_ENABLE_PERFORMANCE_INFO** defined, ThreadX accumulates the following information.</span></span>

<span data-ttu-id="7769e-672">Общее число (для всей системы):</span><span class="sxs-lookup"><span data-stu-id="7769e-672">Total number for the overall system:</span></span>

- <span data-ttu-id="7769e-673">операций Put с мьютексом;</span><span class="sxs-lookup"><span data-stu-id="7769e-673">mutex puts</span></span>

- <span data-ttu-id="7769e-674">операций Get с мьютексом;</span><span class="sxs-lookup"><span data-stu-id="7769e-674">mutex gets</span></span>

- <span data-ttu-id="7769e-675">приостановок при выполнении операций Get с мьютексом;</span><span class="sxs-lookup"><span data-stu-id="7769e-675">mutex get suspensions</span></span>

- <span data-ttu-id="7769e-676">превышений времени ожидания при выполнении операций Get с мьютексом;</span><span class="sxs-lookup"><span data-stu-id="7769e-676">mutex get timeouts</span></span>

- <span data-ttu-id="7769e-677">инверсий приоритета из-за мьютекса;</span><span class="sxs-lookup"><span data-stu-id="7769e-677">mutex priority inversions</span></span>

- <span data-ttu-id="7769e-678">наследований приоритета по мьютексам.</span><span class="sxs-lookup"><span data-stu-id="7769e-678">mutex priority inheritances</span></span>

<span data-ttu-id="7769e-679">Общее число (для каждого мьютекса):</span><span class="sxs-lookup"><span data-stu-id="7769e-679">Total number for each mutex:</span></span>

  - <span data-ttu-id="7769e-680">операций Put с мьютексом;</span><span class="sxs-lookup"><span data-stu-id="7769e-680">mutex puts</span></span>

  - <span data-ttu-id="7769e-681">операций Get с мьютексом;</span><span class="sxs-lookup"><span data-stu-id="7769e-681">mutex gets</span></span>

  - <span data-ttu-id="7769e-682">приостановок при выполнении операций Get с мьютексом;</span><span class="sxs-lookup"><span data-stu-id="7769e-682">mutex get suspensions</span></span>

  - <span data-ttu-id="7769e-683">превышений времени ожидания при выполнении операций Get с мьютексом;</span><span class="sxs-lookup"><span data-stu-id="7769e-683">mutex get timeouts</span></span>

  - <span data-ttu-id="7769e-684">инверсий приоритета из-за мьютекса;</span><span class="sxs-lookup"><span data-stu-id="7769e-684">mutex priority inversions</span></span>

  - <span data-ttu-id="7769e-685">наследований приоритета по мьютексам.</span><span class="sxs-lookup"><span data-stu-id="7769e-685">mutex priority inheritances</span></span>

<span data-ttu-id="7769e-686">Эти сведения можно получить во время выполнения с помощью служб ***tx_mutex_performance_info_get** _ и _*_tx_mutex_performance_system_info_get_\*.</span><span class="sxs-lookup"><span data-stu-id="7769e-686">This information is available at run-time through the services ***tx_mutex_performance_info_get** _ and _*_tx_mutex_performance_system_info_get_\*\*.</span></span> <span data-ttu-id="7769e-687">Сведения о производительности мьютексов удобно использовать, чтобы определить, правильно ли работает приложение.</span><span class="sxs-lookup"><span data-stu-id="7769e-687">Mutex performance information is useful in determining if the application is behaving properly.</span></span> <span data-ttu-id="7769e-688">Они также полезны для оптимизации приложения.</span><span class="sxs-lookup"><span data-stu-id="7769e-688">It is also useful in optimizing the application.</span></span> <span data-ttu-id="7769e-689">Например, относительно частое превышение времени ожидания операций Get с мьютексом позволяет предположить, что другие потоки удерживают ресурсы слишком долго.</span><span class="sxs-lookup"><span data-stu-id="7769e-689">For example, a relatively high number of "mutex get timeouts" might suggest that other threads are holding resources too long.</span></span>

### <a name="mutex-control-block-tx_mutex"></a><span data-ttu-id="7769e-690">TX_MUTEX: блок управления мьютекса</span><span class="sxs-lookup"><span data-stu-id="7769e-690">Mutex Control Block TX_MUTEX</span></span>

<span data-ttu-id="7769e-691">Характеристики каждого мьютекса находятся в его блоке управления.</span><span class="sxs-lookup"><span data-stu-id="7769e-691">The characteristics of each mutex are found in its control block.</span></span> <span data-ttu-id="7769e-692">Он содержит такие сведения, как текущий счетчик владений мьютексом, а также указатель на поток, владеющий мьютексом.</span><span class="sxs-lookup"><span data-stu-id="7769e-692">It contains information such as the current mutex ownership count along with the pointer of the thread that owns the mutex.</span></span> <span data-ttu-id="7769e-693">Эта структура определена в файле ***tx_api.h***.</span><span class="sxs-lookup"><span data-stu-id="7769e-693">This structure is defined in the ***tx_api.h*** file.</span></span> <span data-ttu-id="7769e-694">Блоки управления мьютекса могут размещаться в любом месте в памяти, но чаще всего они определяются вне области какой-либо функции, благодаря чему функционируют как глобальная структура.</span><span class="sxs-lookup"><span data-stu-id="7769e-694">Mutex control blocks can be located anywhere in memory, but it is most common to make the control block a global structure by defining it outside the scope of any function.</span></span>

### <a name="deadly-embrace"></a><span data-ttu-id="7769e-695">Взаимная блокировка</span><span class="sxs-lookup"><span data-stu-id="7769e-695">Deadly Embrace</span></span>

<span data-ttu-id="7769e-696">Одной из наиболее интересных и опасных проблем, связанных с владением мьютексами, является *взаимная блокировка*.</span><span class="sxs-lookup"><span data-stu-id="7769e-696">One of the most interesting and dangerous pitfalls associated with mutex ownership is the *deadly embrace*.</span></span> <span data-ttu-id="7769e-697">Взаимная блокировка (или *взаимоблокировка*) — это ситуация, в которой два или более потоков бессрочно приостанавливаются при попытке получить мьютекс, который принадлежит другим потокам.</span><span class="sxs-lookup"><span data-stu-id="7769e-697">A deadly embrace, or *deadlock*, is a condition where two or more threads are suspended indefinitely while attempting to get a mutex already owned by the other threads.</span></span> <span data-ttu-id="7769e-698">Особенности *взаимной блокировки*, а также способы ее предотвращения в полной мере относятся и к объекту "мьютекс".</span><span class="sxs-lookup"><span data-stu-id="7769e-698">The discussion of *deadly embrace* and its remedies are completely valid for the mutex object as well.</span></span>

### <a name="priority-inversion"></a><span data-ttu-id="7769e-699">Инверсия приоритета</span><span class="sxs-lookup"><span data-stu-id="7769e-699">Priority Inversion</span></span>

<span data-ttu-id="7769e-700">Как упоминалось ранее, основная проблема, связанная со взаимным исключением, — это инверсия приоритета.</span><span class="sxs-lookup"><span data-stu-id="7769e-700">As mentioned previously, a major pitfall associated with mutual exclusion is priority inversion.</span></span> <span data-ttu-id="7769e-701">Эта тема более подробно рассмотрена в разделе [Проблемы, связанные с приоритетами потоков](#thread-priority-pitfalls).</span><span class="sxs-lookup"><span data-stu-id="7769e-701">This topic is discussed more fully in "[Thread Priority Pitfalls](#thread-priority-pitfalls)".</span></span>

<span data-ttu-id="7769e-702">Основная проблема возникает, когда поток с более низким приоритетом владеет семафором, требуемым потоку с более высоким приоритетом.</span><span class="sxs-lookup"><span data-stu-id="7769e-702">The basic problem results from a situation in which a lower priority thread has a semaphore that a higher priority thread needs.</span></span> <span data-ttu-id="7769e-703">Сама по себе эта ситуация является нормальной.</span><span class="sxs-lookup"><span data-stu-id="7769e-703">This in itself is normal.</span></span> <span data-ttu-id="7769e-704">Однако потоки с промежуточными приоритетами могут привести к инверсии приоритета на неопределенно долгий срок.</span><span class="sxs-lookup"><span data-stu-id="7769e-704">However, threads with priorities in between them may cause the priority inversion to last a nondeterministic amount of time.</span></span> <span data-ttu-id="7769e-705">В отличие от семафоров, рассмотренных ранее, объект "мьютекс" ThreadX позволяет использовать необязательное *наследование приоритета*.</span><span class="sxs-lookup"><span data-stu-id="7769e-705">Unlike semaphores discussed previously, the ThreadX mutex object has optional *priority inheritance*.</span></span> <span data-ttu-id="7769e-706">Основная идея наследования приоритета заключается в том, что приоритет потока с более низким приоритетом временно поднимается до уровня потока с более высоким приоритетом, которому нужен мьютекс, принадлежащий потоку с более низким приоритетом.</span><span class="sxs-lookup"><span data-stu-id="7769e-706">The basic idea behind priority inheritance is that a lower priority thread has its priority raised temporarily to the priority of a high priority thread that wants the same mutex owned by the lower priority thread.</span></span> <span data-ttu-id="7769e-707">Когда поток с более низким приоритетом освобождает мьютекс, его исходный приоритет восстанавливается и поток с более высоким приоритетом получает мьютекс.</span><span class="sxs-lookup"><span data-stu-id="7769e-707">When the lower priority thread releases the mutex, its original priority is then restored and the higher priority thread is given ownership of the mutex.</span></span> <span data-ttu-id="7769e-708">Эта функция устраняет недетерминированную инверсию приоритета, сводя время инверсии ко времени, в течение которого поток с более низким приоритетом удерживает мьютекс.</span><span class="sxs-lookup"><span data-stu-id="7769e-708">This feature eliminates nondeterministic priority inversion by bounding the amount of inversion to the time the lower priority thread holds the mutex.</span></span> <span data-ttu-id="7769e-709">Разумеется, методики устранения недетерминированной инверсии приоритета, описанные ранее в этой главе, также действенны и для мьютексов.</span><span class="sxs-lookup"><span data-stu-id="7769e-709">Of course, the techniques discussed earlier in this chapter to handle nondeterministic priority inversion are also valid with mutexes as well.</span></span>

## <a name="event-flags"></a><span data-ttu-id="7769e-710">Флаги событий</span><span class="sxs-lookup"><span data-stu-id="7769e-710">Event Flags</span></span>

<span data-ttu-id="7769e-711">Флаги событий предоставляют мощный инструмент для синхронизации потоков.</span><span class="sxs-lookup"><span data-stu-id="7769e-711">Event flags provide a powerful tool for thread synchronization.</span></span> <span data-ttu-id="7769e-712">Каждый флаг события представлен одним битом.</span><span class="sxs-lookup"><span data-stu-id="7769e-712">Each event flag is represented by a single bit.</span></span> <span data-ttu-id="7769e-713">Флаги событий упорядочены в группы по 32 флага.</span><span class="sxs-lookup"><span data-stu-id="7769e-713">Event flags are arranged in groups of 32.</span></span> <span data-ttu-id="7769e-714">Потоки могут обрабатывать все 32 флага событий в группе одновременно.</span><span class="sxs-lookup"><span data-stu-id="7769e-714">Threads can operate on all 32 event flags in a group at the same time.</span></span> <span data-ttu-id="7769e-715">Для задания событий используется служба ***tx_event_flags_set** _, а для получения — служба _*_tx_event_flags_get_\*\*.</span><span class="sxs-lookup"><span data-stu-id="7769e-715">Events are set by ***tx_event_flags_set** _ and are retrieved by _*_tx_event_flags_get_\*\*.</span></span>

<span data-ttu-id="7769e-716">Установка флагов событий выполняется с помощью логической операции "И" или "ИЛИ" с текущими флагами событий и новыми флагами событий.</span><span class="sxs-lookup"><span data-stu-id="7769e-716">Setting event flags is done with a logical AND/OR operation between the current event flags and the new event flags.</span></span> <span data-ttu-id="7769e-717">Тип логической операции ("И" или "ИЛИ") задается в вызове ***tx_event_flags_set***.</span><span class="sxs-lookup"><span data-stu-id="7769e-717">The type of logical operation (either an AND or OR) is specified in the ***tx_event_flags_set*** call.</span></span>

<span data-ttu-id="7769e-718">Аналогичные логические операции применяются для получения флагов событий.</span><span class="sxs-lookup"><span data-stu-id="7769e-718">There are similar logical options for retrieval of event flags.</span></span> <span data-ttu-id="7769e-719">Запрос Get может указывать, что требуются все указанные флаги событий (логическое "И").</span><span class="sxs-lookup"><span data-stu-id="7769e-719">A get request can specify that all specified event flags are required (a logical AND).</span></span>

<span data-ttu-id="7769e-720">Кроме того, запрос Get может указывать, что соответствовать запросу будет любой из указанных флагов событий (логическое "ИЛИ").</span><span class="sxs-lookup"><span data-stu-id="7769e-720">Alternatively, a get request can specify that any of the specified event flags will satisfy the request (a logical OR).</span></span> <span data-ttu-id="7769e-721">Тип логической операции для получения флагов событий указывается в вызове ***tx_event_flags_get***.</span><span class="sxs-lookup"><span data-stu-id="7769e-721">The type of logical operation associated with event flags retrieval is specified in the ***tx_event_flags_get*** call.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="7769e-722">*Флаги событий, которые соответствуют запросу Get, расходуются, т. е. им присваивается значение 0, если в запросе указан параметр* **TX_OR_CLEAR** *или* **TX_AND_CLEAR** *.*</span><span class="sxs-lookup"><span data-stu-id="7769e-722">*Event flags that satisfy a get request are consumed, i.e., set to zero, if* **TX_OR_CLEAR** *or* **TX_AND_CLEAR** *are specified by the request.*</span></span>

<span data-ttu-id="7769e-723">Каждая группа флагов событий является общедоступным ресурсом.</span><span class="sxs-lookup"><span data-stu-id="7769e-723">Each event flags group is a public resource.</span></span> <span data-ttu-id="7769e-724">В ThreadX нет ограничений на использование групп флагов событий.</span><span class="sxs-lookup"><span data-stu-id="7769e-724">ThreadX places no constraints on how event flags groups are used.</span></span>

### <a name="creating-event-flags-groups"></a><span data-ttu-id="7769e-725">Создание групп флагов событий</span><span class="sxs-lookup"><span data-stu-id="7769e-725">Creating Event Flags Groups</span></span>

<span data-ttu-id="7769e-726">Группы флагов событий создаются во время инициализации или во время выполнения потоками приложения.</span><span class="sxs-lookup"><span data-stu-id="7769e-726">Event flags groups are created either during initialization or during run-time by application threads.</span></span> <span data-ttu-id="7769e-727">Во время создания все флаги событий в группе имеют значение 0.</span><span class="sxs-lookup"><span data-stu-id="7769e-727">At the time of their creation, all event flags in the group are set to zero.</span></span> <span data-ttu-id="7769e-728">Количество групп флагов событий в приложении не ограничено.</span><span class="sxs-lookup"><span data-stu-id="7769e-728">There is no limit on the number of event flags groups in an application.</span></span>

### <a name="thread-suspension"></a><span data-ttu-id="7769e-729">Приостановка потока</span><span class="sxs-lookup"><span data-stu-id="7769e-729">Thread Suspension</span></span>

<span data-ttu-id="7769e-730">Потоки приложения могут быть приостановлены при попытке получить какое-либо логическое сочетание флагов событий из группы.</span><span class="sxs-lookup"><span data-stu-id="7769e-730">Application threads can suspend while attempting to get any logical combination of event flags from a group.</span></span> <span data-ttu-id="7769e-731">После установки флага события проверяются запросы Get всех приостановленных потоков.</span><span class="sxs-lookup"><span data-stu-id="7769e-731">After an event flag is set, the get requests of all suspended threads are reviewed.</span></span> <span data-ttu-id="7769e-732">Все потоки, у которых уже имеются необходимые флаги событий, возобновляются.</span><span class="sxs-lookup"><span data-stu-id="7769e-732">All the threads that now have the required event flags are resumed.</span></span>

> [!NOTE]
> <span data-ttu-id="7769e-733">*Все приостановленные потоки в группе флагов событий проверяются при установке флагов событий. Это, конечно, приводит к дополнительным издержкам. Поэтому рекомендуется ограничить количество потоков, использующих одну группу флагов событий, до разумных пределов.*</span><span class="sxs-lookup"><span data-stu-id="7769e-733">*All suspended threads on an event flag group are reviewed when its event flags are set. This, of course, introduces additional overhead. Therefore, it is good practice to limit the number of threads using the same event flag group to a reasonable number.*</span></span>

### <a name="event-flags-set-notification"></a><span data-ttu-id="7769e-734">Уведомление об установке флагов событий</span><span class="sxs-lookup"><span data-stu-id="7769e-734">Event Flags Set Notification</span></span>

<span data-ttu-id="7769e-735">Некоторые приложения могут использовать преимущества уведомлений о каждой установке флага события.</span><span class="sxs-lookup"><span data-stu-id="7769e-735">Some applications may find it advantageous to be notified whenever an event flag is set.</span></span> <span data-ttu-id="7769e-736">ThreadX обеспечивает эту возможность с помощью службы ***tx_event_flags_set_notify***.</span><span class="sxs-lookup"><span data-stu-id="7769e-736">ThreadX provides this ability through the ***tx_event_flags_set_notify*** service.</span></span> <span data-ttu-id="7769e-737">Эта служба регистрирует указанную функцию уведомления приложения для заданной группы флагов событий.</span><span class="sxs-lookup"><span data-stu-id="7769e-737">This service registers the supplied application notification function with the specified event flags group.</span></span> <span data-ttu-id="7769e-738">После чего ThreadX будет вызывать эту функцию уведомления приложения всякий раз, когда в группе будет установлен флаг события.</span><span class="sxs-lookup"><span data-stu-id="7769e-738">ThreadX will subsequently invoke this application notification function whenever an event flag in the group is set.</span></span> <span data-ttu-id="7769e-739">Конкретная обработка в функции уведомления приложения определяется самим приложением. Однако обычно она включает в себя возобновление соответствующего потока для обработки нового флага события.</span><span class="sxs-lookup"><span data-stu-id="7769e-739">The exact processing within the application notification function is determined by the application, but it typically consists of resuming the appropriate thread for processing the new event flag.</span></span>

### <a name="event-flags-event-chainingtrade"></a><span data-ttu-id="7769e-740">Event-chaining&trade; для флагов событий</span><span class="sxs-lookup"><span data-stu-id="7769e-740">Event Flags Event chaining&trade;</span></span>

<span data-ttu-id="7769e-741">Возможности уведомлений в ThreadX можно использовать для объединения различных событий синхронизации в цепочку.</span><span class="sxs-lookup"><span data-stu-id="7769e-741">The notification capabilities in ThreadX can be used to "chain" various synchronization events together.</span></span> <span data-ttu-id="7769e-742">Обычно это удобно, когда один поток должен обрабатывать несколько событий синхронизации.</span><span class="sxs-lookup"><span data-stu-id="7769e-742">This is typically useful when a single thread must process multiple synchronization events.</span></span>

<span data-ttu-id="7769e-743">Например, вместо того чтобы приостанавливать отдельные потоки для сообщения очереди, флагов событий или семафора, приложение может зарегистрировать подпрограмму уведомления для каждого объекта.</span><span class="sxs-lookup"><span data-stu-id="7769e-743">For example, instead of having separate threads suspend for a queue message, event flags, and a semaphore, the application can register a notification routine for each object.</span></span> <span data-ttu-id="7769e-744">Тогда при вызове эта подпрограмма уведомления приложения сможет возобновить работу одного потока, который сможет опросить каждый объект, чтобы найти и обработать новое событие.</span><span class="sxs-lookup"><span data-stu-id="7769e-744">When invoked, the application notification routine can then resume a single thread, which can interrogate each object to find and process the new event.</span></span>

<span data-ttu-id="7769e-745">Как правило, *цепочки событий* позволяют уменьшить количество потоков, временные затраты и требования к ОЗУ.</span><span class="sxs-lookup"><span data-stu-id="7769e-745">In general, *event-chaining* results in fewer threads, less overhead, and smaller RAM requirements.</span></span> <span data-ttu-id="7769e-746">Они также предоставляют очень гибкий механизм для соблюдения требований синхронизации в более сложных системах.</span><span class="sxs-lookup"><span data-stu-id="7769e-746">It also provides a highly flexible mechanism to handle synchronization requirements of more complex systems.</span></span>

### <a name="run-time-event-flags-performance-information"></a><span data-ttu-id="7769e-747">Сведения о производительности флагов событий во время выполнения</span><span class="sxs-lookup"><span data-stu-id="7769e-747">Run-time Event Flags Performance Information</span></span>

<span data-ttu-id="7769e-748">ThreadX предоставляет дополнительные сведения о производительности флагов событий во время выполнения.</span><span class="sxs-lookup"><span data-stu-id="7769e-748">ThreadX provides optional run-time event flags performance information.</span></span> <span data-ttu-id="7769e-749">Если при сборке приложения и библиотеки ThreadX был определен параметр **TX_EVENT_FLAGS_ENABLE_PERFORMANCE_INFO**, ThreadX собирает следующую информацию.</span><span class="sxs-lookup"><span data-stu-id="7769e-749">If the ThreadX library and application is built with **TX_EVENT_FLAGS_ENABLE_PERFORMANCE_INFO** defined, ThreadX accumulates the following information.</span></span>

<span data-ttu-id="7769e-750">Общее число (для всей системы):</span><span class="sxs-lookup"><span data-stu-id="7769e-750">Total number for the overall system:</span></span>

  - <span data-ttu-id="7769e-751">установок флагов событий;</span><span class="sxs-lookup"><span data-stu-id="7769e-751">event flags sets</span></span>

  - <span data-ttu-id="7769e-752">получений флагов событий;</span><span class="sxs-lookup"><span data-stu-id="7769e-752">event flags gets</span></span>

  - <span data-ttu-id="7769e-753">приостановок из-за получения флагов событий;</span><span class="sxs-lookup"><span data-stu-id="7769e-753">event flags get suspensions</span></span>

  - <span data-ttu-id="7769e-754">превышений времени ожидания получения флагов событий.</span><span class="sxs-lookup"><span data-stu-id="7769e-754">event flags get timeouts</span></span>

<span data-ttu-id="7769e-755">Общее число (для каждой группы флагов событий):</span><span class="sxs-lookup"><span data-stu-id="7769e-755">Total number for each event flags group:</span></span>

  - <span data-ttu-id="7769e-756">установок флагов событий;</span><span class="sxs-lookup"><span data-stu-id="7769e-756">event flags sets</span></span>

  - <span data-ttu-id="7769e-757">получений флагов событий;</span><span class="sxs-lookup"><span data-stu-id="7769e-757">event flags gets</span></span>

  - <span data-ttu-id="7769e-758">приостановок из-за получения флагов событий;</span><span class="sxs-lookup"><span data-stu-id="7769e-758">event flags get suspensions</span></span>

  - <span data-ttu-id="7769e-759">превышений времени ожидания получения флагов событий.</span><span class="sxs-lookup"><span data-stu-id="7769e-759">event flags get timeouts</span></span>

<span data-ttu-id="7769e-760">Эти сведения можно получить во время выполнения с помощью служб ***tx_event_flags_performance_info_get** _ и _*_tx_event_flags_performance_system_info_get_\*_.</span><span class="sxs-lookup"><span data-stu-id="7769e-760">This information is available at run-time through the services ***tx_event_flags_performance_info_get** _ and _*_tx_event_flags_performance_system_info_get_\*_.</span></span> <span data-ttu-id="7769e-761">С помощью сведений о производительности флагов событий удобно определять, правильно ли работает приложение.</span><span class="sxs-lookup"><span data-stu-id="7769e-761">The performance information of event flags is useful in determining if the application is behaving properly.</span></span> <span data-ttu-id="7769e-762">Они также полезны для оптимизации приложения.</span><span class="sxs-lookup"><span data-stu-id="7769e-762">It is also useful in optimizing the application.</span></span> <span data-ttu-id="7769e-763">Например, относительно частое превышение времени ожидания для службы _ *_tx_event_flags_get_*\* позволяет предположить, что задано слишком короткое время ожидания приостановки для флагов событий.</span><span class="sxs-lookup"><span data-stu-id="7769e-763">For example, a relatively high number of timeouts on the _ *_tx_event_flags_get_*\* service might suggest that the event flags suspension timeout is too short.</span></span>

### <a name="event-flags-group-control-block-tx_event_flags_group"></a><span data-ttu-id="7769e-764">TX_EVENT_FLAGS_GROUP: блок управления группы флагов событий</span><span class="sxs-lookup"><span data-stu-id="7769e-764">Event Flags Group Control Block TX_EVENT_FLAGS_GROUP</span></span>

<span data-ttu-id="7769e-765">Характеристики каждой группы флагов событий находятся в ее блоке управления.</span><span class="sxs-lookup"><span data-stu-id="7769e-765">The characteristics of each event flags group are found in its control block.</span></span> <span data-ttu-id="7769e-766">Он содержит такие сведения, как текущие параметры флагов событий и количество потоков, приостановленных для событий.</span><span class="sxs-lookup"><span data-stu-id="7769e-766">It contains information such as the current event flags settings and the number of threads suspended for events.</span></span> <span data-ttu-id="7769e-767">Эта структура определена в файле ***tx_api.h***.</span><span class="sxs-lookup"><span data-stu-id="7769e-767">This structure is defined in the ***tx_api.h*** file.</span></span>

<span data-ttu-id="7769e-768">Блоки управления группы событий могут размещаться в любом месте в памяти, но чаще всего они определяются вне области какой-либо функции, благодаря чему функционируют как глобальная структура.</span><span class="sxs-lookup"><span data-stu-id="7769e-768">Event group control blocks can be located anywhere in memory, but it is most common to make the control block a global structure by defining it outside the scope of any function.</span></span>

### <a name="memory-block-pools"></a><span data-ttu-id="7769e-769">Пулы блоков памяти</span><span class="sxs-lookup"><span data-stu-id="7769e-769">Memory Block Pools</span></span>

<span data-ttu-id="7769e-770">Быстрое и детерминированное выделение памяти — вечная проблема в приложениях реального времени.</span><span class="sxs-lookup"><span data-stu-id="7769e-770">Allocating memory in a fast and deterministic manner is always a challenge in real-time applications.</span></span> <span data-ttu-id="7769e-771">Ввиду этого ThreadX предоставляет возможность создать и администрировать несколько пулов блоков памяти фиксированного размера.</span><span class="sxs-lookup"><span data-stu-id="7769e-771">With this in mind, ThreadX provides the ability to create and manage multiple pools of fixed-size memory blocks.</span></span>

<span data-ttu-id="7769e-772">Так как пулы блоков памяти состоят из блоков фиксированного размера, проблемы фрагментации никогда не возникают.</span><span class="sxs-lookup"><span data-stu-id="7769e-772">Because memory block pools consist of fixed-size blocks, there are never any fragmentation problems.</span></span> <span data-ttu-id="7769e-773">Конечно, фрагментация приводит к поведению, которое, по сути, является недетерминированным.</span><span class="sxs-lookup"><span data-stu-id="7769e-773">Of course, fragmentation causes behavior that is inherently nondeterministic.</span></span> <span data-ttu-id="7769e-774">Кроме того, время, затрачиваемое на выделение и освобождение блока памяти фиксированного размера, сравнимо с простым управлением с помощью связанного списка.</span><span class="sxs-lookup"><span data-stu-id="7769e-774">In addition, the time required to allocate and free a fixed-size memory block is comparable to that of simple linked-list manipulation.</span></span> <span data-ttu-id="7769e-775">Более того, выделение и освобождение блока памяти выполняется на уровне заголовка списка доступных ресурсов.</span><span class="sxs-lookup"><span data-stu-id="7769e-775">Furthermore, memory block allocation and de-allocation is done at the head of the available list.</span></span> <span data-ttu-id="7769e-776">Это обеспечивает самую быструю обработку связанного списка и позволяет хранить наиболее востребованный блок памяти в кэше.</span><span class="sxs-lookup"><span data-stu-id="7769e-776">This provides the fastest possible linked list processing and might help keep the actual memory block in cache.</span></span>

<span data-ttu-id="7769e-777">Отсутствие гибкости — основной недостаток пулов блоков памяти фиксированного размера.</span><span class="sxs-lookup"><span data-stu-id="7769e-777">Lack of flexibility is the main drawback of fixed-size memory pools.</span></span> <span data-ttu-id="7769e-778">Размер блока пула должен быть достаточно большим, чтобы выполнять требования к памяти для пользователей в наиболее пессимистичных сценариях.</span><span class="sxs-lookup"><span data-stu-id="7769e-778">The block size of a pool must be large enough to handle the worst case memory requirements of its users.</span></span> <span data-ttu-id="7769e-779">Разумеется, память может расходоваться впустую, если к одному пулу отправляется много запросов на память разного размера.</span><span class="sxs-lookup"><span data-stu-id="7769e-779">Of course, memory may be wasted if many different size memory requests are made to the same pool.</span></span> <span data-ttu-id="7769e-780">Возможное решение — создание нескольких пулов блоков памяти, содержащих блоки памяти разного размера.</span><span class="sxs-lookup"><span data-stu-id="7769e-780">A possible solution is to make several different memory block pools that contain different sized memory blocks.</span></span>

<span data-ttu-id="7769e-781">Каждый пул блоков памяти является общедоступным ресурсом.</span><span class="sxs-lookup"><span data-stu-id="7769e-781">Each memory block pool is a public resource.</span></span> <span data-ttu-id="7769e-782">В ThreadX нет ограничений на использование пулов.</span><span class="sxs-lookup"><span data-stu-id="7769e-782">ThreadX places no constraints on how pools are used.</span></span>

### <a name="creating-memory-block-pools"></a><span data-ttu-id="7769e-783">Создание пулов блоков памяти</span><span class="sxs-lookup"><span data-stu-id="7769e-783">Creating Memory Block Pools</span></span>

<span data-ttu-id="7769e-784">Пулы блоков памяти создаются во время инициализации или во время выполнения потоками приложения.</span><span class="sxs-lookup"><span data-stu-id="7769e-784">Memory block pools are created either during initialization or during run-time by application threads.</span></span> <span data-ttu-id="7769e-785">Количество пулов блоков памяти в приложении не ограничено.</span><span class="sxs-lookup"><span data-stu-id="7769e-785">There is no limit on the number of memory block pools in an application.</span></span>

### <a name="memory-block-size"></a><span data-ttu-id="7769e-786">Размер блока памяти</span><span class="sxs-lookup"><span data-stu-id="7769e-786">Memory Block Size</span></span>

<span data-ttu-id="7769e-787">Как упоминалось ранее, пулы блоков памяти содержат несколько блоков фиксированного размера.</span><span class="sxs-lookup"><span data-stu-id="7769e-787">As mentioned earlier, memory block pools contain a number of fixed-size blocks.</span></span> <span data-ttu-id="7769e-788">Размер блока в байтах указывается во время создания пула.</span><span class="sxs-lookup"><span data-stu-id="7769e-788">The block size, in bytes, is specified during creation of the pool.</span></span>

> [!NOTE]
> <span data-ttu-id="7769e-789">*ThreadX добавляет к каждому блоку памяти в пуле небольшой объем служебных данных (размер указателя C). Кроме того, ThreadX может заполнять блок, чтобы сохранить его размер для выравнивания начала каждого блока памяти.*</span><span class="sxs-lookup"><span data-stu-id="7769e-789">*ThreadX adds a small amount of overhead—the size of a C pointer—to each memory block in the pool. In addition, ThreadX might have to pad the block size to keep the beginning of each memory block on proper alignment.*</span></span>

### <a name="pool-capacity"></a><span data-ttu-id="7769e-790">Емкость пула</span><span class="sxs-lookup"><span data-stu-id="7769e-790">Pool Capacity</span></span>

<span data-ttu-id="7769e-791">Количество блоков памяти в пуле зависит от размера блока и общего числа байтов в области памяти, указанной во время создания.</span><span class="sxs-lookup"><span data-stu-id="7769e-791">The number of memory blocks in a pool is a function of the block size and the total number of bytes in the memory area supplied during creation.</span></span> <span data-ttu-id="7769e-792">Емкость пула вычисляется путем деления размера блока (с учетом заполнения и байтов служебных данных указателей) на общее число байтов в указанной области памяти.</span><span class="sxs-lookup"><span data-stu-id="7769e-792">The capacity of a pool is calculated by dividing the block size (including padding and the pointer overhead bytes) into the total number of bytes in the supplied memory area.</span></span>

### <a name="pools-memory-area"></a><span data-ttu-id="7769e-793">Область памяти пула</span><span class="sxs-lookup"><span data-stu-id="7769e-793">Pool's Memory Area</span></span>

<span data-ttu-id="7769e-794">Как упоминалось ранее, область памяти пула блоков указывается во время создания.</span><span class="sxs-lookup"><span data-stu-id="7769e-794">As mentioned before, the memory area for the block pool is specified during creation.</span></span> <span data-ttu-id="7769e-795">Как и в случае с другими областями памяти в ThreadX, она может находиться в любом месте адресного пространства целевого оборудования.</span><span class="sxs-lookup"><span data-stu-id="7769e-795">Like other memory areas in ThreadX, it can be located anywhere in the target's address space.</span></span>

<span data-ttu-id="7769e-796">Это важная функция ввиду значительной гибкости, которую она обеспечивает.</span><span class="sxs-lookup"><span data-stu-id="7769e-796">This is an important feature because of the considerable flexibility it provides.</span></span> <span data-ttu-id="7769e-797">Например, предположим, что у продукта взаимодействия имеется высокоскоростная область памяти для операций ввода-вывода.</span><span class="sxs-lookup"><span data-stu-id="7769e-797">For example, suppose that a communication product has a highspeed memory area for I/O.</span></span> <span data-ttu-id="7769e-798">Этой областью памяти будет легко управлять, если создать в ней пул блоков памяти ThreadX.</span><span class="sxs-lookup"><span data-stu-id="7769e-798">This memory area is easily managed by making it into a ThreadX memory block pool.</span></span>

### <a name="thread-suspension"></a><span data-ttu-id="7769e-799">Приостановка потока</span><span class="sxs-lookup"><span data-stu-id="7769e-799">Thread Suspension</span></span>

<span data-ttu-id="7769e-800">Потоки приложения могут быть приостановлены при ожидании блока памяти из пустого пула.</span><span class="sxs-lookup"><span data-stu-id="7769e-800">Application threads can suspend while waiting for a memory block from an empty pool.</span></span> <span data-ttu-id="7769e-801">Когда блок возвращается в пул, приостановленный поток получает этот блок и возобновляет выполнение.</span><span class="sxs-lookup"><span data-stu-id="7769e-801">When a block is returned to the pool, the suspended thread is given this block and the thread is resumed.</span></span>

<span data-ttu-id="7769e-802">Если на одном пуле блоков памяти приостанавливается несколько потоков, они возобновляются в том же порядке, в котором были приостановлены (FIFO).</span><span class="sxs-lookup"><span data-stu-id="7769e-802">If multiple threads are suspended on the same memory block pool, they are resumed in the order they were suspended (FIFO).</span></span>

<span data-ttu-id="7769e-803">Однако также возможно возобновление по приоритету, если приложение вызовет ***tx_block_pool_prioritize*** перед вызовом освобождения блока, который прекращает приостановку потоков.</span><span class="sxs-lookup"><span data-stu-id="7769e-803">However, priority resumption is also possible if the application calls ***tx_block_pool_prioritize*** prior to the block release call that lifts thread suspension.</span></span> <span data-ttu-id="7769e-804">Служба назначения приоритетов для пула блоков помещает поток с наибольшим приоритетом в начало списка приостановки, оставляя прочие приостановленные потоки в том же порядке по принципу FIFO.</span><span class="sxs-lookup"><span data-stu-id="7769e-804">The block pool prioritize service places the highest priority thread at the front of the suspension list, while leaving all other suspended threads in the same FIFO order.</span></span>

### <a name="run-time-block-pool-performance-information"></a><span data-ttu-id="7769e-805">Сведения о производительности пула блоков во время выполнения</span><span class="sxs-lookup"><span data-stu-id="7769e-805">Run-time Block Pool Performance Information</span></span>

<span data-ttu-id="7769e-806">ThreadX предоставляет дополнительные сведения о производительности пула блоков во время выполнения.</span><span class="sxs-lookup"><span data-stu-id="7769e-806">ThreadX provides optional run-time block pool performance information.</span></span> <span data-ttu-id="7769e-807">Если при сборке приложения и библиотеки ThreadX был определен параметр **TX_BLOCK_POOL_ENABLE_PERFORMANCE_INFO**, ThreadX собирает следующую информацию.</span><span class="sxs-lookup"><span data-stu-id="7769e-807">If the ThreadX library and application is built with **TX_BLOCK_POOL_ENABLE_PERFORMANCE_INFO** defined, ThreadX accumulates the following information.</span></span>

<span data-ttu-id="7769e-808">Общее число (для всей системы):</span><span class="sxs-lookup"><span data-stu-id="7769e-808">Total number for the overall system:</span></span>

  - <span data-ttu-id="7769e-809">выделенных блоков;</span><span class="sxs-lookup"><span data-stu-id="7769e-809">blocks allocated</span></span>

  - <span data-ttu-id="7769e-810">освобожденных блоков;</span><span class="sxs-lookup"><span data-stu-id="7769e-810">blocks released</span></span>

  - <span data-ttu-id="7769e-811">приостановок из-за выделения;</span><span class="sxs-lookup"><span data-stu-id="7769e-811">allocation suspensions</span></span>

  - <span data-ttu-id="7769e-812">превышений времени ожидания выделения.</span><span class="sxs-lookup"><span data-stu-id="7769e-812">allocation timeouts</span></span>

<span data-ttu-id="7769e-813">Общее число (для каждого пула блоков):</span><span class="sxs-lookup"><span data-stu-id="7769e-813">Total number for each block pool:</span></span>

  - <span data-ttu-id="7769e-814">выделенных блоков;</span><span class="sxs-lookup"><span data-stu-id="7769e-814">blocks allocated</span></span>

  - <span data-ttu-id="7769e-815">освобожденных блоков;</span><span class="sxs-lookup"><span data-stu-id="7769e-815">blocks released</span></span>

  - <span data-ttu-id="7769e-816">приостановок из-за выделения;</span><span class="sxs-lookup"><span data-stu-id="7769e-816">allocation suspensions</span></span>

  - <span data-ttu-id="7769e-817">превышений времени ожидания выделения.</span><span class="sxs-lookup"><span data-stu-id="7769e-817">allocation timeouts</span></span>

<span data-ttu-id="7769e-818">Эти сведения можно получить во время выполнения с помощью служб ***tx_block_pool_performance_info_get** _ и _*_tx_block_pool_performance_system_info_get_\*\*.</span><span class="sxs-lookup"><span data-stu-id="7769e-818">This information is available at run-time through the services ***tx_block_pool_performance_info_get** _ and _*_tx_block_pool_performance_system_info_get_\*\*.</span></span> <span data-ttu-id="7769e-819">Сведения о производительности пулов блоков удобно использовать, чтобы определить, правильно ли работает приложение.</span><span class="sxs-lookup"><span data-stu-id="7769e-819">Block pool performance information is useful in determining if the application is behaving properly.</span></span> <span data-ttu-id="7769e-820">Они также полезны для оптимизации приложения.</span><span class="sxs-lookup"><span data-stu-id="7769e-820">It is also useful in optimizing the application.</span></span> <span data-ttu-id="7769e-821">Например, относительно частая приостановка из-за выделения блоков может означать, что пул блоков слишком мал.</span><span class="sxs-lookup"><span data-stu-id="7769e-821">For example, a relatively high number of "allocation suspensions" might suggest that the block pool is too small.</span></span>

### <a name="memory-block-pool-control-block-tx_block_pool"></a><span data-ttu-id="7769e-822">TX_BLOCK_POOL: блок управления пула блоков памяти</span><span class="sxs-lookup"><span data-stu-id="7769e-822">Memory Block Pool Control Block TX_BLOCK_POOL</span></span>

<span data-ttu-id="7769e-823">Характеристики каждого пула блоков памяти находятся в его блоке управления.</span><span class="sxs-lookup"><span data-stu-id="7769e-823">The characteristics of each memory block pool are found in its control block.</span></span> <span data-ttu-id="7769e-824">Он содержит такие сведения, как количество доступных блоков памяти и размер блока памяти в пуле.</span><span class="sxs-lookup"><span data-stu-id="7769e-824">It contains information such as the number of memory blocks available and the memory pool block size.</span></span> <span data-ttu-id="7769e-825">Эта структура определена в файле ***tx_api.h***.</span><span class="sxs-lookup"><span data-stu-id="7769e-825">This structure is defined in the ***tx_api.h*** file.</span></span>

<span data-ttu-id="7769e-826">Блоки управления пула могут размещаться в любом месте в памяти, но чаще всего они определяются вне области какой-либо функции, благодаря чему функционируют как глобальная структура.</span><span class="sxs-lookup"><span data-stu-id="7769e-826">Pool control blocks can also be located anywhere in memory, but it is most common to make the control block a global structure by defining it outside the scope of any function.</span></span>

### <a name="overwriting-memory-blocks"></a><span data-ttu-id="7769e-827">Перезапись блоков памяти</span><span class="sxs-lookup"><span data-stu-id="7769e-827">Overwriting Memory Blocks</span></span>

<span data-ttu-id="7769e-828">Важно убедиться, чтобы пользователь выделенного блока памяти не выполнял запись за его пределами.</span><span class="sxs-lookup"><span data-stu-id="7769e-828">It is important to ensure that the user of an allocated memory block does not write outside its boundaries.</span></span> <span data-ttu-id="7769e-829">В противном случае происходит повреждение соседней (обычно следующей) области памяти.</span><span class="sxs-lookup"><span data-stu-id="7769e-829">If this happens, corruption occurs in an adjacent (usually subsequent) memory area.</span></span> <span data-ttu-id="7769e-830">Результаты непредсказуемы и часто являются неустранимыми для приложения.</span><span class="sxs-lookup"><span data-stu-id="7769e-830">The results are unpredictable and often fatal to the application.</span></span>

## <a name="memory-byte-pools"></a><span data-ttu-id="7769e-831">Пулы байтов памяти</span><span class="sxs-lookup"><span data-stu-id="7769e-831">Memory Byte Pools</span></span>

<span data-ttu-id="7769e-832">Пулы байтов памяти ThreadX похожи на стандартные кучи C.</span><span class="sxs-lookup"><span data-stu-id="7769e-832">ThreadX memory byte pools are similar to a standard C heap.</span></span> <span data-ttu-id="7769e-833">В отличие от стандартной кучи C, можно использовать несколько пулов байтов памяти.</span><span class="sxs-lookup"><span data-stu-id="7769e-833">Unlike the standard C heap, it is possible to have multiple memory byte pools.</span></span> <span data-ttu-id="7769e-834">Кроме того, потоки могут быть приостановлены на пуле до тех пор, пока не будет доступен запрошенный объем памяти.</span><span class="sxs-lookup"><span data-stu-id="7769e-834">In addition, threads can suspend on a pool until the requested memory is available.</span></span>

<span data-ttu-id="7769e-835">Выделение памяти из пулов байтов памяти похоже на традиционные вызовы \***malloc** _, которые содержат требуемый объем памяти (в байтах).</span><span class="sxs-lookup"><span data-stu-id="7769e-835">Allocations from memory byte pools are similar to traditional \***malloc** _ calls, which include the amount of memory desired (in bytes).</span></span> <span data-ttu-id="7769e-836">Память выделяется из пула по принципу _first-fit\* (первый подходящий), т. е. используется первый свободный блок памяти, соответствующий запросу.</span><span class="sxs-lookup"><span data-stu-id="7769e-836">Memory is allocated from the pool in a _first-fit\* manner; i.e., the first free memory block that satisfies the request is used.</span></span> <span data-ttu-id="7769e-837">Избыточная память из этого блока преобразовывается в новый блок и возвращается в список свободной памяти.</span><span class="sxs-lookup"><span data-stu-id="7769e-837">Excess memory from this block is converted into a new block and placed back in the free memory list.</span></span> <span data-ttu-id="7769e-838">Этот процесс называется *фрагментацией*.</span><span class="sxs-lookup"><span data-stu-id="7769e-838">This process is called *fragmentation*.</span></span>

<span data-ttu-id="7769e-839">Смежные свободные блоки памяти *объединяются* вместе при последующем поиске для выделения свободного блока памяти достаточно большого объема.</span><span class="sxs-lookup"><span data-stu-id="7769e-839">Adjacent free memory blocks are *merged* together during a subsequent allocation search for a large enough free memory block.</span></span> <span data-ttu-id="7769e-840">Этот процесс называется *дефрагментацией*.</span><span class="sxs-lookup"><span data-stu-id="7769e-840">This process is called *defragmentation*.</span></span>

<span data-ttu-id="7769e-841">Каждый пул байтов памяти является общедоступным ресурсом.</span><span class="sxs-lookup"><span data-stu-id="7769e-841">Each memory byte pool is a public resource.</span></span> <span data-ttu-id="7769e-842">В ThreadX нет ограничений на использование пулов, за исключением того, что службы управления байтами памяти невозможно вызывать из подпрограмм ISR.</span><span class="sxs-lookup"><span data-stu-id="7769e-842">ThreadX places no constraints on how pools are used, except that memory byte services cannot be called from ISRs.</span></span>

### <a name="creating-memory-byte-pools"></a><span data-ttu-id="7769e-843">Создание пулов байтов памяти</span><span class="sxs-lookup"><span data-stu-id="7769e-843">Creating Memory Byte Pools</span></span>

<span data-ttu-id="7769e-844">Пулы байтов памяти создаются во время инициализации или во время выполнения потоками приложения.</span><span class="sxs-lookup"><span data-stu-id="7769e-844">Memory byte pools are created either during initialization or during run-time by application threads.</span></span> <span data-ttu-id="7769e-845">Количество пулов байтов памяти в приложении не ограничено.</span><span class="sxs-lookup"><span data-stu-id="7769e-845">There is no limit on the number of memory byte pools in an application.</span></span>

### <a name="pool-capacity"></a><span data-ttu-id="7769e-846">Емкость пула</span><span class="sxs-lookup"><span data-stu-id="7769e-846">Pool Capacity</span></span>

<span data-ttu-id="7769e-847">Число доступных для выделения байтов в пуле байтов памяти немного меньше значения, указанного во время создания.</span><span class="sxs-lookup"><span data-stu-id="7769e-847">The number of allocatable bytes in a memory byte pool is slightly less than what was specified during creation.</span></span> <span data-ttu-id="7769e-848">Это связано с тем, что для управления областью свободной памяти используются служебные данные.</span><span class="sxs-lookup"><span data-stu-id="7769e-848">This is because management of the free memory area introduces some overhead.</span></span> <span data-ttu-id="7769e-849">Каждый свободный блок памяти в пуле требует служебных данных, необходимых для хранения двух указателей C.</span><span class="sxs-lookup"><span data-stu-id="7769e-849">Each free memory block in the pool requires the equivalent of two C pointers of overhead.</span></span> <span data-ttu-id="7769e-850">Кроме того, пул создается с двумя блоками: большим свободным блоком и небольшим постоянным блоком, выделенным в конце области памяти.</span><span class="sxs-lookup"><span data-stu-id="7769e-850">In addition, the pool is created with two blocks, a large free block and a small permanently allocated block at the end of the memory area.</span></span> <span data-ttu-id="7769e-851">Этот выделенный блок используется для повышения производительности алгоритма выделения.</span><span class="sxs-lookup"><span data-stu-id="7769e-851">This allocated block is used to improve performance of the allocation algorithm.</span></span> <span data-ttu-id="7769e-852">Он устраняет необходимость постоянно проверять конец области пула во время объединения.</span><span class="sxs-lookup"><span data-stu-id="7769e-852">It eliminates the need to continuously check for the end of the pool area during merging.</span></span>

<span data-ttu-id="7769e-853">Во время выполнения объем служебных данных в пуле обычно увеличивается.</span><span class="sxs-lookup"><span data-stu-id="7769e-853">During run-time, the amount of overhead in the pool typically increases.</span></span> <span data-ttu-id="7769e-854">При выделении блоков с нечетным числом байтов они заполняются, чтобы обеспечить правильное выравнивание следующего блока памяти.</span><span class="sxs-lookup"><span data-stu-id="7769e-854">Allocations of an odd number of bytes are padded to ensure proper alignment of the next memory block.</span></span> <span data-ttu-id="7769e-855">Кроме того, объем служебных данных увеличивается по мере того, как пул становится более фрагментированным.</span><span class="sxs-lookup"><span data-stu-id="7769e-855">In addition, overhead increases as the pool becomes more fragmented.</span></span>

### <a name="pools-memory-area"></a><span data-ttu-id="7769e-856">Область памяти пула</span><span class="sxs-lookup"><span data-stu-id="7769e-856">Pool's Memory Area</span></span>

<span data-ttu-id="7769e-857">Область памяти для пула байтов памяти задается во время его создания.</span><span class="sxs-lookup"><span data-stu-id="7769e-857">The memory area for a memory byte pool is specified during creation.</span></span> <span data-ttu-id="7769e-858">Как и в случае с другими областями памяти в ThreadX, она может находиться в любом месте адресного пространства целевого оборудования.</span><span class="sxs-lookup"><span data-stu-id="7769e-858">Like other memory areas in ThreadX, it can be located anywhere in the target's address space.</span></span> <span data-ttu-id="7769e-859">Это важная функция ввиду значительной гибкости, которую она обеспечивает.</span><span class="sxs-lookup"><span data-stu-id="7769e-859">This is an important feature because of the considerable flexibility it provides.</span></span> <span data-ttu-id="7769e-860">Например, если целевое оборудование оснащено областями высокоскоростной и низкоскоростной памяти, то пользователь может управлять выделением памяти в обеих этих областях, создавая пулы в каждой из них.</span><span class="sxs-lookup"><span data-stu-id="7769e-860">For example, if the target hardware has a high-speed memory area and a low-speed memory area, the user can manage memory allocation for both areas by creating a pool in each of them.</span></span>

### <a name="thread-suspension"></a><span data-ttu-id="7769e-861">Приостановка потока</span><span class="sxs-lookup"><span data-stu-id="7769e-861">Thread Suspension</span></span>

<span data-ttu-id="7769e-862">Потоки приложения могут быть приостановлены при ожидании байтов памяти из пула.</span><span class="sxs-lookup"><span data-stu-id="7769e-862">Application threads can suspend while waiting for memory bytes from a pool.</span></span> <span data-ttu-id="7769e-863">Когда становится доступна достаточно большая непрерывная область памяти, она выделяется приостановленным потокам, которые ее запросили, и они возобновляются.</span><span class="sxs-lookup"><span data-stu-id="7769e-863">When sufficient contiguous memory becomes available, the suspended threads are given their requested memory and the threads are resumed.</span></span>

<span data-ttu-id="7769e-864">Если на одном пуле байтов памяти приостанавливается несколько потоков, они получают память (возобновляются) в том же порядке, в котором были приостановлены (FIFO).</span><span class="sxs-lookup"><span data-stu-id="7769e-864">If multiple threads are suspended on the same memory byte pool, they are given memory (resumed) in the order they were suspended (FIFO).</span></span>

<span data-ttu-id="7769e-865">Однако также возможно возобновление по приоритету, если приложение вызовет ***tx_byte_pool_prioritize*** перед вызовом освобождения байтов, который прекращает приостановку потоков.</span><span class="sxs-lookup"><span data-stu-id="7769e-865">However, priority resumption is also possible if the application calls ***tx_byte_pool_prioritize*** prior to the byte release call that lifts thread suspension.</span></span> <span data-ttu-id="7769e-866">Служба назначения приоритетов для пула байтов помещает поток с наибольшим приоритетом в начало списка приостановки, оставляя прочие приостановленные потоки в том же порядке по принципу FIFO.</span><span class="sxs-lookup"><span data-stu-id="7769e-866">The byte pool prioritize service places the highest priority thread at the front of the suspension list, while leaving all other suspended threads in the same FIFO order.</span></span>

### <a name="run-time-byte-pool-performance-information"></a><span data-ttu-id="7769e-867">Сведения о производительности пула байтов во время выполнения</span><span class="sxs-lookup"><span data-stu-id="7769e-867">Run-time Byte Pool Performance Information</span></span>

<span data-ttu-id="7769e-868">ThreadX предоставляет дополнительные сведения о производительности пула байтов во время выполнения.</span><span class="sxs-lookup"><span data-stu-id="7769e-868">ThreadX provides optional run-time byte pool performance information.</span></span> <span data-ttu-id="7769e-869">Если при сборке приложения и библиотеки ThreadX был определен параметр ***TX_BYTE_POOL_ENABLE_PERFORMANCE_INFO***, ThreadX собирает следующую информацию.</span><span class="sxs-lookup"><span data-stu-id="7769e-869">If the ThreadX library and application is built with ***TX_BYTE_POOL_ENABLE_PERFORMANCE_INFO*** defined, ThreadX accumulates the following information.</span></span>

<span data-ttu-id="7769e-870">Общее число (для всей системы):</span><span class="sxs-lookup"><span data-stu-id="7769e-870">Total number for the overall system:</span></span>

  - <span data-ttu-id="7769e-871">выделений памяти;</span><span class="sxs-lookup"><span data-stu-id="7769e-871">allocations</span></span>

  - <span data-ttu-id="7769e-872">выпуски</span><span class="sxs-lookup"><span data-stu-id="7769e-872">releases</span></span>

  - <span data-ttu-id="7769e-873">искомых фрагментов;</span><span class="sxs-lookup"><span data-stu-id="7769e-873">fragments searched</span></span>

  - <span data-ttu-id="7769e-874">объединенных фрагментов;</span><span class="sxs-lookup"><span data-stu-id="7769e-874">fragments merged</span></span>

  - <span data-ttu-id="7769e-875">созданных фрагментов;</span><span class="sxs-lookup"><span data-stu-id="7769e-875">fragments created</span></span>

  - <span data-ttu-id="7769e-876">приостановок из-за выделения;</span><span class="sxs-lookup"><span data-stu-id="7769e-876">allocation suspensions</span></span>

  - <span data-ttu-id="7769e-877">превышений времени ожидания выделения.</span><span class="sxs-lookup"><span data-stu-id="7769e-877">allocation timeouts</span></span>

<span data-ttu-id="7769e-878">Общее число (для каждого пула байтов):</span><span class="sxs-lookup"><span data-stu-id="7769e-878">Total number for each byte pool:</span></span>

  - <span data-ttu-id="7769e-879">выделений памяти;</span><span class="sxs-lookup"><span data-stu-id="7769e-879">allocations</span></span>

  - <span data-ttu-id="7769e-880">выпуски</span><span class="sxs-lookup"><span data-stu-id="7769e-880">releases</span></span>

  - <span data-ttu-id="7769e-881">искомых фрагментов;</span><span class="sxs-lookup"><span data-stu-id="7769e-881">fragments searched</span></span>

  - <span data-ttu-id="7769e-882">объединенных фрагментов;</span><span class="sxs-lookup"><span data-stu-id="7769e-882">fragments merged</span></span>

  - <span data-ttu-id="7769e-883">созданных фрагментов;</span><span class="sxs-lookup"><span data-stu-id="7769e-883">fragments created</span></span>

  - <span data-ttu-id="7769e-884">приостановок из-за выделения;</span><span class="sxs-lookup"><span data-stu-id="7769e-884">allocation suspensions</span></span>

  - <span data-ttu-id="7769e-885">превышений времени ожидания выделения.</span><span class="sxs-lookup"><span data-stu-id="7769e-885">allocation timeouts</span></span>

<span data-ttu-id="7769e-886">Эти сведения можно получить во время выполнения с помощью служб **tx_byte_pool_performance_info_get** и _tx_byte_pool_performance_system_info_get_.</span><span class="sxs-lookup"><span data-stu-id="7769e-886">This information is available at run-time through the services ***tx_byte_pool_performance_info_get** _ and _*_tx_byte_pool_performance_system_info_get_\*\*.</span></span> <span data-ttu-id="7769e-887">Сведения о производительности пулов байтов удобно использовать, чтобы определить, правильно ли работает приложение.</span><span class="sxs-lookup"><span data-stu-id="7769e-887">Byte pool performance information is useful in determining if the application is behaving properly.</span></span> <span data-ttu-id="7769e-888">Они также полезны для оптимизации приложения.</span><span class="sxs-lookup"><span data-stu-id="7769e-888">It is also useful in optimizing the application.</span></span> <span data-ttu-id="7769e-889">Например, относительно частая приостановка из-за выделения памяти может означать, что пул байтов слишком мал.</span><span class="sxs-lookup"><span data-stu-id="7769e-889">For example, a relatively high number of "allocation suspensions" might suggest that the byte pool is too small.</span></span>

### <a name="memory-byte-pool-control-block-tx_byte_pool"></a><span data-ttu-id="7769e-890">TX_BYTE_POOL: блок управления пула байтов памяти</span><span class="sxs-lookup"><span data-stu-id="7769e-890">Memory Byte Pool Control Block TX_BYTE_POOL</span></span>

<span data-ttu-id="7769e-891">Характеристики каждого пула байтов памяти находятся в его блоке управления.</span><span class="sxs-lookup"><span data-stu-id="7769e-891">The characteristics of each memory byte pool are found in its control block.</span></span> <span data-ttu-id="7769e-892">Он содержит полезную информацию, например количество доступных байтов в пуле.</span><span class="sxs-lookup"><span data-stu-id="7769e-892">It contains useful information such as the number of available bytes in the pool.</span></span> <span data-ttu-id="7769e-893">Эта структура определена в файле ***tx_api.h***.</span><span class="sxs-lookup"><span data-stu-id="7769e-893">This structure is defined in the ***tx_api.h*** file.</span></span>

<span data-ttu-id="7769e-894">Блоки управления пула могут размещаться в любом месте в памяти, но чаще всего они определяются вне области какой-либо функции, благодаря чему функционируют как глобальная структура.</span><span class="sxs-lookup"><span data-stu-id="7769e-894">Pool control blocks can also be located anywhere in memory, but it is most common to make the control block a global structure by defining it outside the scope of any function.</span></span>

### <a name="nondeterministic-behavior"></a><span data-ttu-id="7769e-895">Недетерминированное поведение</span><span class="sxs-lookup"><span data-stu-id="7769e-895">Nondeterministic Behavior</span></span>

<span data-ttu-id="7769e-896">Хотя пулы байтов памяти обеспечивают наиболее гибкое выделение памяти, они также могут быть подвержены недетерминированному поведению.</span><span class="sxs-lookup"><span data-stu-id="7769e-896">Although memory byte pools provide the most flexible memory allocation, they also suffer from somewhat nondeterministic behavior.</span></span> <span data-ttu-id="7769e-897">Например, пул байтов памяти может содержать 2000 байт доступной памяти, но не соответствовать запросу на выделение 1000 байт.</span><span class="sxs-lookup"><span data-stu-id="7769e-897">For example, a memory byte pool may have 2,000 bytes of memory available but may not be able to satisfy an allocation request of 1,000 bytes.</span></span> <span data-ttu-id="7769e-898">Это связано с тем, что количество расположенных подряд свободных байтов не гарантируется.</span><span class="sxs-lookup"><span data-stu-id="7769e-898">This is because there are no guarantees on how many of the free bytes are contiguous.</span></span> <span data-ttu-id="7769e-899">Даже если существует свободный блок размером в 1000 байт, не гарантируется время его поиска.</span><span class="sxs-lookup"><span data-stu-id="7769e-899">Even if a 1,000 byte free block exists, there are no guarantees on how long it might take to find the block.</span></span> <span data-ttu-id="7769e-900">Вполне возможно, что для поиска блока в 1000 байт потребуется выполнить поиск по всему пулу памяти.</span><span class="sxs-lookup"><span data-stu-id="7769e-900">It is completely possible that the entire memory pool would need to be searched to find the 1,000 byte block.</span></span>

> [!TIP]
> <span data-ttu-id="7769e-901">*В результате недетерминированного поведения пулов байтов памяти, как правило, рекомендуется избегать использования служб байтов памяти в тех областях, где требуется детерминированное поведение в реальном времени. Многие приложения предварительно распределяют требуемую память во время инициализации или настройки времени выполнения.*</span><span class="sxs-lookup"><span data-stu-id="7769e-901">*As a result of the nondeterministic behavior of memory byte pools, it is generally good practice to avoid using memory byte services in areas where deterministic, real-time behavior is required. Many applications pre-allocate their required memory during initialization or run-time configuration.*</span></span>

### <a name="overwriting-memory-blocks"></a><span data-ttu-id="7769e-902">Перезапись блоков памяти</span><span class="sxs-lookup"><span data-stu-id="7769e-902">Overwriting Memory Blocks</span></span>

<span data-ttu-id="7769e-903">Важно проследить, чтобы пользователь выделенной памяти не выполнял запись за ее пределами.</span><span class="sxs-lookup"><span data-stu-id="7769e-903">It is important to ensure that the user of allocated memory does not write outside its boundaries.</span></span> <span data-ttu-id="7769e-904">В противном случае происходит повреждение соседней (обычно следующей) области памяти.</span><span class="sxs-lookup"><span data-stu-id="7769e-904">If this happens, corruption occurs in an adjacent (usually subsequent) memory area.</span></span> <span data-ttu-id="7769e-905">Результаты непредсказуемы и часто могут приводить к неустранимым последствиям при выполнении программы.</span><span class="sxs-lookup"><span data-stu-id="7769e-905">The results are unpredictable and often catastrophic for program execution.</span></span>

## <a name="application-timers"></a><span data-ttu-id="7769e-906">Таймеры приложения</span><span class="sxs-lookup"><span data-stu-id="7769e-906">Application Timers</span></span>

<span data-ttu-id="7769e-907">Быстрое реагирование на асинхронные внешние события является самой важной функцией внедренных приложений реального времени.</span><span class="sxs-lookup"><span data-stu-id="7769e-907">Fast response to asynchronous external events is the most important function of real-time, embedded applications.</span></span> <span data-ttu-id="7769e-908">Однако многие из этих приложений должны также выполнять определенные действия через предопределенные интервалы времени.</span><span class="sxs-lookup"><span data-stu-id="7769e-908">However, many of these applications must also perform certain activities at predetermined intervals of time.</span></span>

<span data-ttu-id="7769e-909">Таймеры приложения ThreadX дают приложениям возможность выполнять функции приложения C через определенные интервалы времени.</span><span class="sxs-lookup"><span data-stu-id="7769e-909">ThreadX application timers provide applications with the ability to execute application C functions at specific intervals of time.</span></span> <span data-ttu-id="7769e-910">Таймер приложения также может истекать только один раз.</span><span class="sxs-lookup"><span data-stu-id="7769e-910">It is also possible for an application timer to expire only once.</span></span> <span data-ttu-id="7769e-911">Этот тип таймера называется *одноразовым*, а таймеры с повторяющимся интервалом называются *периодическими*.</span><span class="sxs-lookup"><span data-stu-id="7769e-911">This type of timer is called a *one-shot timer*, while repeating interval timers are called *periodic timers*.</span></span>

<span data-ttu-id="7769e-912">Каждый таймер приложения является общедоступным ресурсом.</span><span class="sxs-lookup"><span data-stu-id="7769e-912">Each application timer is a public resource.</span></span> <span data-ttu-id="7769e-913">В ThreadX нет ограничений на использование таймеров приложения.</span><span class="sxs-lookup"><span data-stu-id="7769e-913">ThreadX places no constraints on how application timers are used.</span></span>

### <a name="timer-intervals"></a><span data-ttu-id="7769e-914">Интервалы таймера</span><span class="sxs-lookup"><span data-stu-id="7769e-914">Timer Intervals</span></span>

<span data-ttu-id="7769e-915">В ThreadX интервалы времени измеряются периодическими прерываниями таймера.</span><span class="sxs-lookup"><span data-stu-id="7769e-915">In ThreadX time intervals are measured by periodic timer interrupts.</span></span> <span data-ttu-id="7769e-916">Каждое прерывание таймера называется его *тактом*.</span><span class="sxs-lookup"><span data-stu-id="7769e-916">Each timer interrupt is called a timer *tick*.</span></span> <span data-ttu-id="7769e-917">Фактическое время между тактами таймера задается приложением, но для большинства реализаций нормой является 10 мс.</span><span class="sxs-lookup"><span data-stu-id="7769e-917">The actual time between timer ticks is specified by the application, but 10ms is the norm for most implementations.</span></span> <span data-ttu-id="7769e-918">Конфигурация периодического таймера обычно находится в файле сборки ***tx_initialize_low_level***.</span><span class="sxs-lookup"><span data-stu-id="7769e-918">The periodic timer setup is typically found in the ***tx_initialize_low_level*** assembly file.</span></span>

<span data-ttu-id="7769e-919">Стоит упомянуть, что для функционирования таймеров приложения базовое оборудование должно иметь возможность создавать периодические прерывания.</span><span class="sxs-lookup"><span data-stu-id="7769e-919">It is worth mentioning that the underlying hardware must have the ability to generate periodic interrupts for application timers to function.</span></span> <span data-ttu-id="7769e-920">В некоторых случаях процессор имеет встроенную функцию периодических прерываний.</span><span class="sxs-lookup"><span data-stu-id="7769e-920">In some cases, the processor has a built-in periodic interrupt capability.</span></span> <span data-ttu-id="7769e-921">Если в процессоре нет такой функции, на плате пользователя должно быть периферийное устройство, которое может создавать периодические прерывания.</span><span class="sxs-lookup"><span data-stu-id="7769e-921">If the processor doesn't have this ability, the user's board must have a peripheral device that can generate periodic interrupts.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="7769e-922">*ThreadX может работать даже без источника периодических прерываний. Однако в этом случае вся обработка, связанная с таймерами, отключается. Это касается временных срезов, времени ожидания приостановки и служб таймеров.*</span><span class="sxs-lookup"><span data-stu-id="7769e-922">*ThreadX can still function even without a periodic interrupt source. However, all timer-related processing is then disabled. This includes timeslicing, suspension time-outs, and timer services.*</span></span>

### <a name="timer-accuracy"></a><span data-ttu-id="7769e-923">Точность таймера</span><span class="sxs-lookup"><span data-stu-id="7769e-923">Timer Accuracy</span></span>

<span data-ttu-id="7769e-924">Срок действия таймеров задается в тактах.</span><span class="sxs-lookup"><span data-stu-id="7769e-924">Timer expirations are specified in terms of ticks.</span></span> <span data-ttu-id="7769e-925">Указанное значение срока действия уменьшается на единицу на каждом такте таймера.</span><span class="sxs-lookup"><span data-stu-id="7769e-925">The specified expiration value is decreased by one on each timer tick.</span></span> <span data-ttu-id="7769e-926">Так как таймер приложения может быть включен непосредственно перед прерыванием (или тактом) таймера, его фактический срок действия может быть меньше на один такт.</span><span class="sxs-lookup"><span data-stu-id="7769e-926">Because an application timer could be enabled just prior to a timer interrupt (or timer tick), the actual expiration time could be up to one tick early.</span></span>

<span data-ttu-id="7769e-927">Если частота тактов таймера равна 10 мс, то срок действия таймера приложения может истечь на 10 мс раньше.</span><span class="sxs-lookup"><span data-stu-id="7769e-927">If the timer tick rate is 10ms, application timers may expire up to 10ms early.</span></span> <span data-ttu-id="7769e-928">Это более важно для таймеров с тактом в 10 мс, чем для таймеров с тактом в 1 с.</span><span class="sxs-lookup"><span data-stu-id="7769e-928">This is more significant for 10ms timers than 1 second timers.</span></span> <span data-ttu-id="7769e-929">Разумеется, увеличение частоты прерываний таймера уменьшает эту погрешность.</span><span class="sxs-lookup"><span data-stu-id="7769e-929">Of course, increasing the timer interrupt frequency decreases this margin of error.</span></span>

### <a name="timer-execution"></a><span data-ttu-id="7769e-930">Выполнение таймера</span><span class="sxs-lookup"><span data-stu-id="7769e-930">Timer Execution</span></span>

<span data-ttu-id="7769e-931">Таймеры приложения выполняются в том порядке, в котором они становятся активными.</span><span class="sxs-lookup"><span data-stu-id="7769e-931">Application timers execute in the order they become active.</span></span> <span data-ttu-id="7769e-932">Например, если были созданы три таймера с одинаковым значением срока действия и они были активированы, то их соответствующие функции срока действия гарантированно будут выполняться в порядке активации.</span><span class="sxs-lookup"><span data-stu-id="7769e-932">For example, if three timers are created with the same expiration value and activated, their corresponding expiration functions are guaranteed to execute in the order they were activated.</span></span>

### <a name="creating-application-timers"></a><span data-ttu-id="7769e-933">Создание таймеров приложения</span><span class="sxs-lookup"><span data-stu-id="7769e-933">Creating Application Timers</span></span>

<span data-ttu-id="7769e-934">Таймеры приложения создаются во время инициализации или во время выполнения потоками приложения.</span><span class="sxs-lookup"><span data-stu-id="7769e-934">Application timers are created either during initialization or during run-time by application threads.</span></span> <span data-ttu-id="7769e-935">Количество таймеров приложения в приложении не ограничено.</span><span class="sxs-lookup"><span data-stu-id="7769e-935">There is no limit on the number of application timers in an application.</span></span>

### <a name="run-time-application-timer-performance-information"></a><span data-ttu-id="7769e-936">Сведения о производительности таймера приложения во время выполнения</span><span class="sxs-lookup"><span data-stu-id="7769e-936">Run-time Application Timer Performance Information</span></span>

<span data-ttu-id="7769e-937">ThreadX предоставляет дополнительные сведения о производительности таймеров приложения во время выполнения.</span><span class="sxs-lookup"><span data-stu-id="7769e-937">ThreadX provides optional run-time application timer performance information.</span></span> <span data-ttu-id="7769e-938">Если при сборке библиотеки и приложения ThreadX был определен параметр **TX_TIMER_ENABLE_PERFORMANCE_INFO**, ThreadX собирает следующую информацию.</span><span class="sxs-lookup"><span data-stu-id="7769e-938">If the ThreadX library and application are built with **TX_TIMER_ENABLE_PERFORMANCE_INFO** defined, ThreadX accumulates the following information.</span></span>

<span data-ttu-id="7769e-939">Общее число (для всей системы):</span><span class="sxs-lookup"><span data-stu-id="7769e-939">Total number for the overall system:</span></span>

- <span data-ttu-id="7769e-940">активаций;</span><span class="sxs-lookup"><span data-stu-id="7769e-940">activations</span></span>

- <span data-ttu-id="7769e-941">деактиваций;</span><span class="sxs-lookup"><span data-stu-id="7769e-941">deactivations</span></span>

- <span data-ttu-id="7769e-942">повторных активаций (периодические таймеры);</span><span class="sxs-lookup"><span data-stu-id="7769e-942">reactivations (periodic timers)</span></span>

- <span data-ttu-id="7769e-943">expirations</span><span class="sxs-lookup"><span data-stu-id="7769e-943">expirations</span></span>

- <span data-ttu-id="7769e-944">корректировок срока действия.</span><span class="sxs-lookup"><span data-stu-id="7769e-944">expiration adjustments</span></span>

<span data-ttu-id="7769e-945">Общее число (для каждого таймера приложения):</span><span class="sxs-lookup"><span data-stu-id="7769e-945">Total number for each application timer:</span></span>

- <span data-ttu-id="7769e-946">активаций;</span><span class="sxs-lookup"><span data-stu-id="7769e-946">activations</span></span>

- <span data-ttu-id="7769e-947">деактиваций;</span><span class="sxs-lookup"><span data-stu-id="7769e-947">deactivations</span></span>

- <span data-ttu-id="7769e-948">повторных активаций (периодические таймеры);</span><span class="sxs-lookup"><span data-stu-id="7769e-948">reactivations (periodic timers)</span></span>

- <span data-ttu-id="7769e-949">expirations</span><span class="sxs-lookup"><span data-stu-id="7769e-949">expirations</span></span>

- <span data-ttu-id="7769e-950">корректировок срока действия.</span><span class="sxs-lookup"><span data-stu-id="7769e-950">expiration adjustments</span></span>

<span data-ttu-id="7769e-951">Эти сведения можно получить во время выполнения с помощью служб ***tx_timer_performance_info_get** _ и _*_tx_timer_performance_system_info_get_\*\*.</span><span class="sxs-lookup"><span data-stu-id="7769e-951">This information is available at run-time through the services ***tx_timer_performance_info_get** _ and _*_tx_timer_performance_system_info_get_\*\*.</span></span> <span data-ttu-id="7769e-952">Сведения о производительности таймеров приложения удобно использовать, чтобы определить, правильно ли работает приложение.</span><span class="sxs-lookup"><span data-stu-id="7769e-952">Application Timer performance information is useful in determining if the application is behaving properly.</span></span> <span data-ttu-id="7769e-953">Они также полезны для оптимизации приложения.</span><span class="sxs-lookup"><span data-stu-id="7769e-953">It is also useful in optimizing the application.</span></span>

### <a name="application-timer-control-block-tx_timer"></a><span data-ttu-id="7769e-954">TX_TIMER: блок управления таймера приложения</span><span class="sxs-lookup"><span data-stu-id="7769e-954">Application Timer Control Block TX_TIMER</span></span>

<span data-ttu-id="7769e-955">Характеристики каждого таймера приложения находятся в его блоке управления.</span><span class="sxs-lookup"><span data-stu-id="7769e-955">The characteristics of each application timer are found in its control block.</span></span> <span data-ttu-id="7769e-956">Он содержит полезную информацию, например 32-разрядное обозначение срока действия.</span><span class="sxs-lookup"><span data-stu-id="7769e-956">It contains useful information such as the 32-bit expiration identification value.</span></span> <span data-ttu-id="7769e-957">Эта структура определена в файле ***tx_api.h***.</span><span class="sxs-lookup"><span data-stu-id="7769e-957">This structure is defined in the ***tx_api.h*** file.</span></span>

<span data-ttu-id="7769e-958">Блоки управления таймера приложения могут размещаться в любом месте в памяти, но чаще всего они определяются вне области какой-либо функции, благодаря чему функционируют как глобальная структура.</span><span class="sxs-lookup"><span data-stu-id="7769e-958">Application timer control blocks can be located anywhere in memory, but it is most common to make the control block a global structure by defining it outside the scope of any function.</span></span>

### <a name="excessive-timers"></a><span data-ttu-id="7769e-959">Избыточные таймеры</span><span class="sxs-lookup"><span data-stu-id="7769e-959">Excessive Timers</span></span>

<span data-ttu-id="7769e-960">По умолчанию таймеры приложения выполняются в скрытом системном потоке, который запускается с нулевым приоритетом, что обычно выше приоритета любого потока приложения.</span><span class="sxs-lookup"><span data-stu-id="7769e-960">By default, application timers execute from within a hidden system thread that runs at priority zero, which is typically higher than any application thread.</span></span> <span data-ttu-id="7769e-961">Поэтому обработка внутри таймеров приложения должна быть минимальной.</span><span class="sxs-lookup"><span data-stu-id="7769e-961">Because of this, processing inside application timers should be kept to a minimum.</span></span>

<span data-ttu-id="7769e-962">Важно также по возможности избегать использования таймеров, срок действия которых истекает на каждом такте таймера.</span><span class="sxs-lookup"><span data-stu-id="7769e-962">It is also important to avoid, whenever possible, timers that expire every timer tick.</span></span> <span data-ttu-id="7769e-963">Такая ситуация может привести к генерированию чрезмерного количества служебных данных в приложении.</span><span class="sxs-lookup"><span data-stu-id="7769e-963">Such a situation might induce excessive overhead in the application.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="7769e-964">*Как упоминалось ранее, таймеры приложения выполняются из скрытого системного потока. Поэтому важно не указывать приостановку каких-либо вызовов службы ThreadX, выполняемых в функции срока действия таймера приложения.*</span><span class="sxs-lookup"><span data-stu-id="7769e-964">*As mentioned previously, application timers are executed from a hidden system thread. It is, therefore, important not to select suspension on any ThreadX service calls made from within the application timer's expiration function.*</span></span>

## <a name="relative-time"></a><span data-ttu-id="7769e-965">Относительное время</span><span class="sxs-lookup"><span data-stu-id="7769e-965">Relative Time</span></span>

<span data-ttu-id="7769e-966">В дополнение к ранее упомянутым таймерам приложения ThreadX предоставляет один постоянно увеличивающийся 32-разрядный счетчик тактов.</span><span class="sxs-lookup"><span data-stu-id="7769e-966">In addition to the application timers mentioned previously, ThreadX provides a single continuously incrementing 32-bit tick counter.</span></span> <span data-ttu-id="7769e-967">Значение счетчика тактов, или *времени*, увеличивается на единицу при каждом прерывании таймера.</span><span class="sxs-lookup"><span data-stu-id="7769e-967">The tick counter or *time* is increased by one on each timer interrupt.</span></span>

<span data-ttu-id="7769e-968">Приложение может считывать или устанавливать этот 32-разрядный счетчик с помощью вызовов ***tx_time_get** _ и _*_tx_time_set_\*\* соответственно.</span><span class="sxs-lookup"><span data-stu-id="7769e-968">The application can read or set this 32-bit counter through calls to ***tx_time_get** _ and _*_tx_time_set_\*\*, respectively.</span></span> <span data-ttu-id="7769e-969">Использование этого счетчика тактов полностью определяется приложением.</span><span class="sxs-lookup"><span data-stu-id="7769e-969">The use of this tick counter is determined completely by the application.</span></span> <span data-ttu-id="7769e-970">Он не используется внутри ThreadX.</span><span class="sxs-lookup"><span data-stu-id="7769e-970">It is not used internally by ThreadX.</span></span>

## <a name="interrupts"></a><span data-ttu-id="7769e-971">Прерывания</span><span class="sxs-lookup"><span data-stu-id="7769e-971">Interrupts</span></span>

<span data-ttu-id="7769e-972">Быстрое реагирование на асинхронные события — фундаментальная функция внедренных приложений реального времени.</span><span class="sxs-lookup"><span data-stu-id="7769e-972">Fast response to asynchronous events is the principal function of real-time, embedded applications.</span></span> <span data-ttu-id="7769e-973">Приложение узнает о таком событии с помощью аппаратных прерываний.</span><span class="sxs-lookup"><span data-stu-id="7769e-973">The application knows such an event is present through hardware interrupts.</span></span>

<span data-ttu-id="7769e-974">Прерывание является асинхронным изменением в работе процессора.</span><span class="sxs-lookup"><span data-stu-id="7769e-974">An interrupt is an asynchronous change in processor execution.</span></span> <span data-ttu-id="7769e-975">Как правило, когда происходит прерывание, процессор *прерываний* сохраняет небольшую часть текущей операции в стеке и передает управление соответствующему вектору прерывания.</span><span class="sxs-lookup"><span data-stu-id="7769e-975">Typically, when an interrupt occurs, the *Interrupts* processor saves a small portion of the current execution on the stack and transfers control to the appropriate interrupt vector.</span></span> <span data-ttu-id="7769e-976">Вектор прерывания — это, собственно, адрес подпрограммы, отвечающей за обработку конкретного типа прерывания.</span><span class="sxs-lookup"><span data-stu-id="7769e-976">The interrupt vector is basically just the address of the routine responsible for handling the specific type interrupt.</span></span> <span data-ttu-id="7769e-977">Точная процедура обработки прерываний зависит от конкретного процессора.</span><span class="sxs-lookup"><span data-stu-id="7769e-977">The exact interrupt handling procedure is processor specific.</span></span>

### <a name="interrupt-control"></a><span data-ttu-id="7769e-978">Управление прерываниями</span><span class="sxs-lookup"><span data-stu-id="7769e-978">Interrupt Control</span></span>

<span data-ttu-id="7769e-979">Служба ***tx_interrupt_control*** позволяет приложениям включать и отключать прерывания.</span><span class="sxs-lookup"><span data-stu-id="7769e-979">The ***tx_interrupt_control*** service allows applications to enable and disable interrupts.</span></span> <span data-ttu-id="7769e-980">Эта служба возвращает предыдущее состояние включения или отключения прерываний.</span><span class="sxs-lookup"><span data-stu-id="7769e-980">The previous interrupt enable/disable posture is returned by this service.</span></span> <span data-ttu-id="7769e-981">Важно упомянуть, что управление прерываниями влияет только на сегмент программы, выполняемый в данный момент.</span><span class="sxs-lookup"><span data-stu-id="7769e-981">It is important to mention that interrupt control only affects the currently executing program segment.</span></span> <span data-ttu-id="7769e-982">Например, если поток отключает прерывания, то они остаются отключенными только во время выполнения этого потока.</span><span class="sxs-lookup"><span data-stu-id="7769e-982">For example, if a thread disables interrupts, they only remain disabled during execution of that thread.</span></span>

> [!NOTE]
> <span data-ttu-id="7769e-983">*Немаскируемое прерывание (NMI) — это прерывание, которое не может быть отключено оборудованием. Такое прерывание может использоваться приложениями ThreadX. Однако подпрограмме обработки NMI приложения запрещено использовать управление контекстом и какие-либо службы API в ThreadX.*</span><span class="sxs-lookup"><span data-stu-id="7769e-983">*A Non-Maskable Interrupt (NMI) is an interrupt that cannot be disabled by the hardware. Such an interrupt may be used by ThreadX applications. However, the application's NMI handling routine is not allowed to use ThreadX context management or any API services.*</span></span>

### <a name="threadx-managed-interrupts"></a><span data-ttu-id="7769e-984">Управляемые прерывания ThreadX</span><span class="sxs-lookup"><span data-stu-id="7769e-984">ThreadX Managed Interrupts</span></span>

<span data-ttu-id="7769e-985">ThreadX предоставляет приложениям полное управление прерываниями.</span><span class="sxs-lookup"><span data-stu-id="7769e-985">ThreadX provides applications with complete interrupt management.</span></span> <span data-ttu-id="7769e-986">Это включает в себя сохранение и восстановление контекста прерванного выполнения.</span><span class="sxs-lookup"><span data-stu-id="7769e-986">This management includes saving and restoring the context of the interrupted execution.</span></span> <span data-ttu-id="7769e-987">Кроме того, ThreadX позволяет вызывать определенные службы из подпрограмм обработки прерываний (ISR).</span><span class="sxs-lookup"><span data-stu-id="7769e-987">In addition, ThreadX allows certain services to be called from within Interrupt Service Routines (ISRs).</span></span> <span data-ttu-id="7769e-988">Ниже приведен список служб ThreadX, которые можно запускать из подпрограмм ISR.</span><span class="sxs-lookup"><span data-stu-id="7769e-988">The following is a list of ThreadX services allowed from application ISRs.</span></span>

```c
tx_block_allocate
tx_block_pool_info_get tx_block_pool_prioritize
tx_block_pool_performance_info_get
tx_block_pool_performance_system_info_get tx_block_release
tx_byte_pool_info_get tx_byte_pool_performance_info_get
tx_byte_pool_performance_system_info_get
tx_byte_pool_prioritize tx_event_flags_info_get
tx_event_flags_get tx_event_flags_set
tx_event_flags_performance_info_get
tx_event_flags_performance_system_info_get
tx_event_flags_set_notify tx_interrupt_control
tx_mutex_performance_info_get
tx_mutex_performance_system_info_get tx_queue_front_send
tx_queue_info_get tx_queue_performance_info_get
tx_queue_performance_system_info_get tx_queue_prioritize
tx_queue_receive tx_queue_send tx_semaphore_get
tx_queue_send_notify tx_semaphore_ceiling_put
tx_semaphore_info_get tx_semaphore_performance_info_get
tx_semaphore_performance_system_info_get
tx_semaphore_prioritize tx_semaphore_put tx_thread_identify
tx_semaphore_put_notify tx_thread_entry_exit_notify
tx_thread_info_get tx_thread_resume
tx_thread_performance_info_get
tx_thread_performance_system_info_get
tx_thread_stack_error_notify tx_thread_wait_abort tx_time_get
tx_time_set tx_timer_activate tx_timer_change
tx_timer_deactivate tx_timer_info_get
tx_timer_performance_info_get
tx_timer_performance_system_info_get
```

> [!IMPORTANT]
> <span data-ttu-id="7769e-989">*Приостановка из подпрограмм ISR запрещена. Следовательно, параметр **wait_option** для всех вызовов служб ThreadX, выполняемых из ISR, должен иметь значение **TX_NO_WAIT**.*</span><span class="sxs-lookup"><span data-stu-id="7769e-989">*Suspension is not allowed from ISRs. Therefore, the **wait_option** parameter for all ThreadX service calls made from an ISR must be set to **TX_NO_WAIT**.*</span></span>

### <a name="isr-template"></a><span data-ttu-id="7769e-990">Шаблон ISR</span><span class="sxs-lookup"><span data-stu-id="7769e-990">ISR Template</span></span>

<span data-ttu-id="7769e-991">Для управления прерываниями приложения в начале и в конце подпрограмм ISR этого приложения следует вызывать несколько служебных программ ThreadX.</span><span class="sxs-lookup"><span data-stu-id="7769e-991">To manage application interrupts, several ThreadX utilities must be called in the beginning and end of application ISRs.</span></span> <span data-ttu-id="7769e-992">Формат обработки прерываний зависит от используемых портов.</span><span class="sxs-lookup"><span data-stu-id="7769e-992">The exact format for interrupt handling varies between ports.</span></span>

<span data-ttu-id="7769e-993">Ниже приведен небольшой сегмент кода, типичный для большинства управляемых подпрограмм ISR в ThreadX.</span><span class="sxs-lookup"><span data-stu-id="7769e-993">The following small code segment is typical of most ThreadX managed ISRs.</span></span> <span data-ttu-id="7769e-994">В большинстве случаев эта обработка выполняется на языке ассемблера.</span><span class="sxs-lookup"><span data-stu-id="7769e-994">In most cases, this processing is in assembly language.</span></span>

```c
_application_ISR_vector_entry:

; Save context and prepare for

; ThreadX use by calling the ISR

; entry function.

CALL _tx_thread_context_save

; The ISR can now call ThreadX

; services and its own C functions

; When the ISR is finished, context

; is restored (or thread preemption)

; by calling the context restore ; function. Control does not return!

JUMP _tx_thread_context_restore
```

### <a name="high-frequency-interrupts"></a><span data-ttu-id="7769e-995">Высокочастотные прерывания</span><span class="sxs-lookup"><span data-stu-id="7769e-995">High-frequency Interrupts</span></span>

<span data-ttu-id="7769e-996">Некоторые прерывания происходят с такой высокой частотой, что сохранение и восстановление полного контекста при каждом прерывании требует чрезмерной пропускной способности для обработки.</span><span class="sxs-lookup"><span data-stu-id="7769e-996">Some interrupts occur at such a high frequency that saving and restoring full context upon each interrupt would consume excessive processing bandwidth.</span></span> <span data-ttu-id="7769e-997">В таких случаях для приложения обычно используется небольшая подпрограмма ISR на языке ассемблера, которая выполняет ограниченную обработку большинства этих высокочастотных прерываний.</span><span class="sxs-lookup"><span data-stu-id="7769e-997">In such cases, it is common for the application to have a small assembly language ISR that does a limited amount of processing for a majority of these high-frequency interrupts.</span></span>

<span data-ttu-id="7769e-998">В какой-то момент времени этой небольшой подпрограмме ISR может потребоваться взаимодействовать с ThreadX.</span><span class="sxs-lookup"><span data-stu-id="7769e-998">After a certain point in time, the small ISR may need to interact with ThreadX.</span></span> <span data-ttu-id="7769e-999">Для этого вызываются функции входа и выхода, описанные в приведенном выше шаблоне.</span><span class="sxs-lookup"><span data-stu-id="7769e-999">This is accomplished by calling the entry and exit functions described in the above template.</span></span>

### <a name="interrupt-latency"></a><span data-ttu-id="7769e-1000">Задержка прерываний</span><span class="sxs-lookup"><span data-stu-id="7769e-1000">Interrupt Latency</span></span>

<span data-ttu-id="7769e-1001">ThreadX блокирует прерывания на короткий период времени.</span><span class="sxs-lookup"><span data-stu-id="7769e-1001">ThreadX locks out interrupts over brief periods of time.</span></span> <span data-ttu-id="7769e-1002">Максимальный период отключения прерываний зависит от времени, необходимого для сохранения или восстановления контекста потока.</span><span class="sxs-lookup"><span data-stu-id="7769e-1002">The maximum amount of time interrupts are disabled is on the order of the time required to save or restore a thread's context.</span></span>
