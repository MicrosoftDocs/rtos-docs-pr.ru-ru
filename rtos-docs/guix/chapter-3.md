---
title: Глава 3. Обзор функций GUIX
description: В этой главе приведен обзор функций высокопроизводительного продукта с пользовательским интерфейсом GUIX.
author: philmea
ms.author: philmea
ms.date: 05/19/2020
ms.topic: article
ms.service: rtos
ms.openlocfilehash: 2a53da048b18d35b6b15a4ad8d4138e1a2acd4e8
ms.sourcegitcommit: 95f4ae0842a486fec8f10d1480203695faa9592d
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 06/09/2021
ms.locfileid: "111875258"
---
# <a name="chapter-3---functional-overview-of-guix"></a>Глава 3. Обзор функций GUIX

В этой главе приведен обзор функций высокопроизводительного продукта с пользовательским интерфейсом GUIX. 

## <a name="execution-overview"></a>Общие сведения о выполнении

В GUIX реализована управляемая событиями модель программирования. Это означает, что работа платформы GUIX преимущественно определяется поступлением событий, отправленных в очередь событий GUIX. Обработка этих событий происходит в контексте потока GUIX, который представляет собой поток ThreadX, созданный во время инициализации системы GUIX.

Приложения GUIX определяют пользовательский интерфейс путем вызова функций API GUIX для создания окон и дочерних мини-приложений, а также позволяют настроить внешний вид этих мини-приложений путем вызова дополнительных функций API, используемых для определения цветов, стилей, шрифтов и других атрибутов каждого окна или типа мини-приложения. Если вы используете GUIX Studio для создания внешнего вида экранов пользовательского интерфейса, большую часть этой работы, связанной с вызовом функций API GUIX для создания представления, выполняет за вас приложение GUIX Studio.

Приложения GUIX взаимодействуют с системным пользователем и внешней бизнес-логикой, обрабатывая события, полученные из очереди событий GUIX.
Эти события обычно создаются с помощью мини-приложений GUIX, но они также могут создаваться внешними потоками. При нажатии стандартной кнопки GUIX в родительское окно кнопки отправляется событие. При нажатии этой кнопки приложение предоставляет обработчик события нажатия кнопки.

Дополнительные потоки GUIX часто создаются для таких компонентов, как драйверы ввода. Типичный драйвер ввода на сенсорном экране выполняется как отдельный поток (внешний для основного потока GUIX). Драйвер сенсорного ввода отправляет сенсорную информацию в поток GUIX путем отправления событий в очередь событий GUIX.

Так как для многих операций с пользовательскими интерфейсами, например для анимации, необходима точная информация о времени, в GUIX также реализован простой и удобный в использовании интерфейс таймера. Этот интерфейс таймера создан на основе службы таймера ThreadX и настраивается автоматически при запуске системы.

Большая часть программного обеспечения GUIX не имеет каких-либо зависимостей оборудования. Для платформы необходимы драйверы ввода и графические драйверы оборудования. Сведения о реализации этих драйверов оборудования содержатся в главе 5.

## <a name="initialization"></a>Инициализация 

Службу ***gx_system_initialize*** необходимо вызывать до вызова любой другой службы GUIX. Инициализацию системы GUIX можно вызвать с помощью подпрограммы ***tx_application_define*** ThreadX (контекст инициализации) или с помощью потоков приложения. Функция ***gx_system_initialize*** создает очередь событий GUIX, инициализирует устройство таймера GUIX, создает главный системный поток GUIX и инициализирует различные структуры данных, поддерживаемые GUIX во время выполнения приложения.

После возвращения ***gx_system_initialize*** приложение готово для создания экранов, холстов, окон, мини-приложений, а также настройки свойств всех объектов GUIX. Большую часть API для создания объектов GUIX можно вызывать с помощью ***tx_application_define*** или потоков приложения.

## <a name="application-interface-calls"></a>Вызовы интерфейса приложения 

Вызовы из приложения в большинстве случаев выполняются с помощью ***tx_application_define*** (контекст инициализации) или потоков приложения. Чтобы определить, какой контекст можно использовать для вызовов, ознакомьтесь с разделом о соответствующих разрешениях для каждого API GUIX в главе 4.

В большинстве случаев обработка ресурсоемких действий выполняется с использованием внутреннего потока GUIX, включая обработку всех событий и операции рисования для мини-приложений и окон.

Функции API GUIX можно вызывать из любого потока в любое время.
Как правило, лучше использовать архитектуру, которая позволяет отделить критически важную бизнес-логику от логики пользовательского интерфейса. Так как операции рисования с использованием пользовательского интерфейса иногда могут занимать много времени в зависимости от размера экрана и производительности ЦП, обычно нежелательно, чтобы критически важные потоки откладывались, ожидая завершения операции рисования.

## <a name="internal-guix-thread"></a>Внутренний поток GUIX 

Как уже упоминалось, в GUIX есть внутренний поток, который выполняет основную часть обработки данных для графического пользовательского интерфейса. Этот поток создается программным обеспечением приложения путем вызова ***gx_system_initialize** _, а затем — _*_gx_system_start_**.

Приоритет внутреннего потока GUIX определяется с помощью `#define GX_SYSTEM_THREAD_PRIORITY`. По умолчанию это значение равно 16 (средний приоритет), но его можно изменить, указав это значение в файле заголовка gx_port.h или gx_user.h и переопределив значение по умолчанию.

Интервал времени потока GUIX аналогичным образом определяется с помощью параметра `#define GX_SYSTEM_THREAD_TIMESLICE`, значение которого по умолчанию равно 10 мс.

Размер стека системного потока определяется с помощью параметра `#define GX_THREAD_STACK_SIZE`, который находится в файле заголовка ***gx_port.h***, но его также можно переопределить, указав это значение в файле заголовка gx_user.h.

Цикл выполнения внутреннего потока GUIX состоит из трех действий.
Сначала GUIX извлекает события из очереди событий GUIX и отправляет эти события для обработки с помощью окон и мини-приложений GUIX. Как правило, события отправляются в очередь событий GUIX с помощью периодических таймеров, устройств ввода, таких как сенсорный экран или клавиатура, а также с помощью мини-приложений GUIX, которые обрабатывают данные, введенные пользователем. Далее после обработки всех событий GUIX определяет, требуется ли обновление экрана. Если да, выполняется обработка для обновления графических данных дисплея, в основном путем вызова функций рисования для тех окон и мини-приложений, которые помечены как "грязные". Наконец, GUIX блокирует поток GUIX до тех пор, пока не поступят новые события ввода.

## <a name="event-processing"></a>Обработка событий 

События сенсорного ввода или ввода с помощью пера обрабатываются путем определения самого верхнего окна или мини-приложения под пиксельной позицией сенсорного ввода или ввода с помощью пера и вызова соответствующей функции обработки событий окна или мини-приложения. Если мини-приложение распознает события ввода с помощью пера, оно обработает событие соответствующим образом для этого типа мини-приложения. В противном случае самое верхнее мини-приложение передаст событие сенсорного ввода или ввода с помощью пера родительскому элементу мини-приложения для обработки. Такая передача события вверх по цепочке продолжается до тех пор, пока событие не будет обработано или не поступит в корневое окно, после чего оно отменяется.

События клавиатуры отправляются в окно или мини-приложение с фокусом ввода. Состояние фокуса ввода сохраняется с помощью компонента gx_system GUIX.

События таймера всегда отправляются в окно или мини-приложение, в которых есть таймер для обработки.

Внутренне созданные события, такие как события нажатия кнопки или изменения значения ползунка, всегда отправляются в родительский элемент мини-приложения, создающего событие. Если родительский элемент не обрабатывает событие, оно передается вверх по цепочке аналогично событиям сенсорного ввода или ввода с помощью пера.

## <a name="drawing"></a>Рисование 

После завершения обработки событий внутренний поток GUIX определяет, требуется ли обновление данных дисплея. Если да, вызываются функции рисования для соответствующего окна и мини-приложения. После завершения рисования внутренний поток GUIX просто ждет в очереди событий следующего события GUIX для обработки.

В GUIX реализована концепция *"грязных" областей*, которые необходимо перерисовать для каждого мини-приложения и холста. Мини-приложение может выполнять операцию рисования только в тех областях, которые ранее были помечены как "грязные". При вызове функции рисования в мини-приложении все операции рисования обрезаются внутренне до ранее определенного "грязного" прямоугольника.
Попытки рисования за пределами этой области игнорируются.

Мини-приложения и окна помечаются как "грязные" путем вызова функции API ***gx_system_dirty_mark***. Эта функция помечает все мини-приложение или окно, как требующее перерисовки. Вторую функцию (***gx_system_dirty_partial_add***) можно вызвать в качестве альтернативы, чтобы пометить только часть окна или мини-приложения как "грязную".

Эта модель пометки мини-приложений как "грязных", а также перерисовки этих мини-приложений только после обработки всех событий ввода называется *отложенным рисованием*. Алгоритм отложенного рисования GUIX и обслуживание "грязных" списков предназначены для повышения эффективности операций рисования. Так как операции рисования обычно требуют больших затрат, GUIX делает все возможное для предотвращения ненужных операций рисования.

Рисование выполняется на *холсте* GUIX. Холст — это область памяти для хранения графических данных. Холст может (не) быть напрямую связан с аппаратным буфером кадров в зависимости от архитектуры системы и ограничений памяти. Перед выполнением операции рисования холст необходимо сначала открыть, вызвав функцию API ***gx_canvas_drawing_initiate***. Этот API готовит холст для рисования и установки текущего *контекста рисования*. Когда GUIX выполняет системное обновление холста, холст открывается для операции рисования и контекста рисования, который устанавливается до вызова API рисования на уровне мини-приложения. Поэтому мини-приложениям не нужно инициировать операцию рисования на холсте в функции рисования мини-приложения.

Но если приложению необходимо немедленно выполнить операцию рисования на холсте за пределами потока стандартного алгоритма отложенного рисования GUIX, приложение должно напрямую вызвать ***gx_canvas_drawing_initiate*** перед вызовом любых других функций API рисования, а также вызвать ***gx_canvas_drawing_complete*** после завершения операции немедленного рисования.

## <a name="user-input"></a>Ввод данных пользователем 

GUIX поддерживает сенсорный экран, мышь и клавиатуру с предопределенными типами событий. Можно использовать дополнительные устройства ввода, определив пользовательские типы событий или сопоставив пользовательское устройство ввода с предопределенными типами событий.

Действия, связанные с этими устройствами, преобразуются в события, обрабатываемые внутренним потоком GUIX. Программное обеспечение на уровне драйверов, созданное для поддержки сенсорного экрана, должно подготовить и отослать в очередь событий GUIX события операций перемещения пера вниз, вверх и перетаскивания. Аналогичным образом драйвер ввода для клавиатуры должен создавать события ввода с помощью нажатия и отпускания клавиш.

## <a name="modal-dialog-execution"></a>Выполнение модального диалогового окна 

Выполнение модального диалогового окна означает предоставление пользователю окна, которое должно быть закрыто каким-либо образом, прежде чем другие окна или мини-приложения GUIX смогут получать данные, введенные пользователем. Модальные диалоговые окна захватывают все данные, введенные пользователем, во время отображения диалогового окна, независимо от расположения событий сенсорного ввода или ввода с помощью мыши относительно оси x, y.

Модальные диалоговые окна запускаются программным обеспечением приложения путем создания окна обычным способом с помощью вызова ***gx_window_create***, а затем вызова функции API GUIX ***gx_window_execute.***

При вызове функции ***gx_window_execute*** GUIX входит в локальный цикл обработки события. Функция ***gx_window_execute*** не возвращается к вызывающему объекту до тех пор, пока диалоговое окно не закроется с помощью либо ввода данных пользователем, либо вызова ***gx_window_close***. По этой причине очень важно вызывать функцию ***gx_window_execute*** только из внутреннего потока GUIX.

## <a name="periodic-processing"></a>Периодическая обработка 

Чтобы обеспечить необходимые эффекты отображения, анимацию спрайта и поддержку периодических запросов приложения, в GUIX используется один таймер ThreadX. Этот единственный таймер используется для выполнения всех операций GUIX, связанных со временем. По умолчанию для параметра частоты внутренней обработки данных таймера GUIX задано значение 20 мс с помощью константы **GX_SYSTEM_TIMER_MS**, которая определена в **_gx_api.h_**, если эта константа не определена ранее в заголовке gx_port.h или gx_user.h. Частоту по умолчанию можно изменить в приложении с помощью параметра компиляции при создании библиотеки GUIX или путем явного переопределения в ***gx_user.h***.

> [!IMPORTANT]
> Обратите внимание, что частота таймера GUIX выражена в тактах таймера ОСРВ и определяется константой **GX_SYSTEM_TIMER_TICKS**. Значение **GX_SYSTEM_TIMER_TICKS** вычисляется с помощью **GX_SYSTEM_TIMER_MS** и **TX_TIMER_TICKS_PER_SECOND**. Пользователь может повторно определить любое из этих значений в ***gx_port.h** _ или _ *_gx_user.h_**, чтобы настроить частоту и разрешение таймера GUIX.

## <a name="display-driver"></a>Драйвер дисплея 

Драйверы дисплея предоставляют набор функций рисования для основного кода GUIX. Реализация каждой из этих функций рисования определяется драйвером. Для реализации используется аппаратное ускорение, если это возможно. Обычно функция рисования записывает пиксельные данные в буфер памяти, который может быть физическим буфером кадров или вторичным буфером в зависимости от архитектуры драйвера. Во многих драйверах реализована двойная буферизация с помощью двух буферов кадров. Эти буферы переключаются путем вызова функции переключения буфера. GUIX вызывает эти функции внутренне в нужное время. Для систем с ограниченным объемом памяти функции рисования могут записывать данные только в один буфер кадров памяти.

GUIX предоставляет реализации программного обеспечения по умолчанию для каждой низкоуровневой функции рисования на каждом поддерживаемом уровне глубины цвета и формата. Эти функции вызываются с помощью указателей функций, которые хранятся в структуре **GX_DISPLAY**. При создании драйверов оборудования, как правило, они перезаписывают некоторые из этих указателей функций функциями, которые относятся к целевому оборудованию.

Типичный аппаратный драйвер дисплея реализуется путем создания драйвера дисплея GUIX по умолчанию для необходимых глубины цвета и формата.
Затем аппаратный драйвер заменяет эти функции, которые необходимо оптимизировать или настроить для конкретной реализации оборудования.

GUIX поддерживает пиксельные цветовые форматы в диапазоне от 1 бит/пкс (монохромный) до 32 бит/пкс (a:r:g:b). GUIX также поддерживает множество вариантов в рамках каждой широкой категории глубины цвета, например порядок байтов r:g:b и b:g:r, форматы упакованных пикселей и пикселей с сопоставлением слов, а также альфа-каналы. Сейчас поддерживается 25 различных форматов цвета, но этот список пополняется, так как поставщики оборудования предоставляют новые варианты.

## <a name="display-memory-architectures"></a>Архитектуры памяти для дисплея

Различные аппаратные целевые объекты и дисплеи используют различные архитектуры памяти дисплея в зависимости от ограничений для памяти на основе требований относительно целевых объектов и функций приложения. Мы рассмотрим некоторые используемые архитектуры памяти и кратко опишем каждую из них.

Модель 1. Нет буфера кадров, графические данные хранятся во внешнем GRAM:

![Нет буфера кадров, графические данные хранятся во внешнем GRAM](./media/guix/user-guide/no-frame-buffer.png)

В приведенной выше модели нет памяти для буфера кадров в модуле локальной памяти для ЦП. Все графические данные хранятся во внешнем GRAM, встроенном в сам дисплей. Интерфейс внешнего GRAM может быть параллельным или последовательным. Этот тип архитектуры имеет очень низкий уровень затрат. Однако при обновлении графических данных могут происходить прерывания операций.

Модель 2. Один локальный буфер кадров:

![Один локальный буфер кадров](./media/guix/user-guide/one-local-frame-buffer.png)

В этой модели память для графических данных выделяется из ОЗУ, которое напрямую доступно для ЦП. Для повторной передачи графических данных (вместе с сигналами времени) из локальной памяти на дисплей необходимо наличие выделенного оборудования. Эта модель отличается от модели 1 тем, что графическая память является блоком локальной памяти SRAM или DRAM, доступной для ЦП. Это может быть та же память, в которой используются переменные стека и программы.

Модель 3. Локальный буфер кадров и внешнее устройство GRAM:

![Локальный буфер кадров и внешнее устройство GRAM](./media/guix/user-guide/local-frame-buffer-external-gram.png)

Модель 3 — это сочетание первых двух моделей. В этой модели достаточно локальной памяти для одного буфера кадров. Кроме того, устройство отображения предоставляет внешнее устройство GRAM и автоматически обновляется с помощью данных GRAM. В этой архитектуре повышена эффективность обновления, так как можно передать измененную часть локального буфера кадров во внешнее устройство GRAM с помощью одного блока, часто — с использованием каналов DMA. Эта модель также позволяет устранить прерывания выполнения операций и мерцание, которые могут наблюдаться в одной из предыдущих двух моделей, так как только заполненное графическое содержимое копируется во внешнее устройство GRAM.

Модель 4. "Пинг-понговые" буферы кадров:

!["Пинг-понговые" буферы кадров](./media/guix/user-guide/ping-pong-frame-buffers.png)

В модели 4 достаточно памяти для двух локальных буферов кадров. В этом случае GUIX использует один буфер кадров в качестве активного, а другой — в качестве рабочего. Для выполнения операции обновления отображения или операции рисования используется рабочий буфер. По завершении операции рисования буферы переключаются: рабочий буфер переключается в режим активного буфера, а активный буфер — в режим рабочего буфера. Эта модель также позволяет устранить мерцание отображения и прерывание выполнения операций, которые могут наблюдаться при использовании системы с одним буфером.

Модель 5. "Пинг-понговые" буферы с использованием компоновки холстов:

!["Пинг-понговые" буферы с использованием компоновки холстов](./media/guix/user-guide/ping-pong-buffers-canvas-composting.png)

В модели 5 можно создать любое количество холстов с учетом ограничений доступной памяти. Холсты можно накладывать друг на друга или смешивать в соответствии с настройками приложения, чтобы создать составной холст. Если после операции обновления экрана создан составной элемент, активные и рабочие составные буферы переключаются в режим, идентичный стандартной архитектуре "пинг-понговых" буферов. В модели 5 добавляется возможность выполнения операций исчезания и смешения отображения экрана. При этом выполняется смешение холстов в составной элемент окончательных выходных данных.

Модель 6. Компоновка холстов с использованием внешнего устройства GRAM:

![Компоновка холстов с использованием внешнего устройства GRAM](./media/guix/user-guide/canvas-compositing-external-gram.png)

Модель 6 незначительно отличается от модели 5. Для нее требуется только один составной буфер, который передается во внешнее устройство GRAM. Эта модель также поддерживает полное смешение отображений экрана и их наложение друг на друга.

## <a name="string-encoding"></a>Кодирование строк 

GUIX по умолчанию поддерживает кодирование строк в формате UTF8. Поддержку кодирования строк в формате UTF8 можно отключить, определив **GX_DISABLE_UTF8_SUPPORT** в файле заголовка ***gx_user.h***. Если кодирование в формате UTF8 отключено, GUIX использует внутренним образом только стандартное 8-разрядное кодирование ASCII и кодировку символов кодовой страницы Latin-1. В результате отключения кодирования строк в формате UTF8 используется немного меньший объем занимаемой памяти библиотеки GUIX и незначительно ускоряются операции среды выполнения для функций обработки строк и отрисовки текста.

Кодирование строк в формате UTF8 имеет следующие признаки:

  - Для строк ASCII необходимо не больше дискового пространства, чем для стандартного 7-разрядного кодирования ASCII.

  - Большинство строковых функций ANSI-C поддерживают кодирование строк в формате UTF8 без модификации.

С помощью кодирования строк UTF8 можно представить любые активные кодировки, в том числе Кандзи.

### <a name="static-and-dynamic-strings"></a>Статические и динамические строки 

Строки, назначенные для мини-приложений GUIX, которые поддерживают отображение текста, могут быть статически определенными строковыми константами (обычно помещаются в постоянное хранилище в качестве таблицы строк GUIX, как описано ниже) или динамически определенными строками (строки, созданные во время выполнения с помощью таких служб, как ***sprintf** _ или _*_gx_utility_ltoa_**).

Примерами динамических строк может быть значение, отображаемое в виде числа в мини-приложении для запросов GUIX, или строка даты и времени, динамически форматируемая в зависимости от расположения пользователя и настроек формата. При создании строк в среде выполнения, которые будут назначены мини-приложениям GUIX (например, **GX_PROMPT** или **GX_TEXT_BUTTON**), необходимо либо статически выделить хранилище для этих строк, созданных в среде выполнения (т. е.
глобальных массивов символов), либо определить и установить функцию выделения динамической памяти, а также использовать стиль **GX_STYLE_TEXT_COPY**. При этом мини-приложения получают команду создать частную копию назначенных текстовых строк.

Использование временного хранилища (например, автоматического массива символов) для хранения динамически созданной строки и последующего назначения этой строки мини-приложению, не имеющему стиля **GX_STYLE_TEXT_COPY**, считается ошибкой программирования. Если этот стиль не включен, мини-приложение просто копирует соответствующий указатель строки. При этом данные строк должны быть статически выделены. В противном случае указатель строки мини-приложения указывает на лишние данные, что приводят к непредсказуемым результатам.

### <a name="passing-gx_string-arguments"></a>Передача аргументов GX_STRING 

Функции API GUIX, которые принимают параметр GX_STRING, всегда проверяют, соответствует ли длина строки, которую указывает поле **GX_STRING.gx_string_ptr**, значению поля **GX_STRING.gx_string_length**. Если два поля не согласованы, возвращается ошибка **GX_INVALID_STRING_LENGTH**, а вызванный API возвращается обратно, не принимая назначение строки.

Из соображений безопасности в программном обеспечении GUIX никогда внутренне не используются стандартные строковые функции C, такие как ***strlen** _ или _*_strcpy_**. Известно, что эти функции подвержены атакам злоумышленников во время динамического получения данных строк, что часто происходит в подключенных приложениях.

В выпусках библиотеки GUIX, предшествующих выпуску 5.6, определены функции API, которые принимали `GX_CONST GX_CHAR *text` в качестве параметра. Эти функции (по-прежнему поддерживаются для обратной совместимости) устарели и заменены предпочтительными функциями API, которые принимают `GX_CONST GX_STRING *string` в качестве входного параметра.

По умолчанию включается нерекомендуемый API обработки текста, что позволяет успешно выполнять сборку всех ранее написанных приложений с использованием последних обновлений для библиотеки GUIX. Чтобы отключить нерекомендуемый API обработки текста, необходимо добавить определение **GX_DISABLE_DEPRECATED_STRING_API** в файл заголовка **_gx_user.h_ *_. Все новые приложения должны определить _* GX_DISABLE_DEPRECATED_STRING_API** и использовать только функции API замены. Во всех выходных файлах, созданных в GUIX Studio для выпуска библиотеки GUIX версии 5.6 или более поздней, используются только функции API для замены.

В указанной ниже таблице перечислены имена устаревших и новых функций API для замены.

| **Имя нерекомендуемой функции**              | **Заменено на**                              |
| ------------------------------------------ | ----------------------------------------------- |
| gx_binres_language_table_load          | gx_binres_language_table_load_ext          |
| gx_canvas_rotated_text_draw            | gx_canvas_rotated_text_draw_ext            |
| gx_canvas_text_draw                     | gx_canvas_text_draw_ext                     |
| gx_context_string_get                   | gx_context_string_get_ext                   |
| gx_display_language_table_get          | gx_display_language_table_get_ext          |
| gx_display_language_table_set          | gx_display_language_table_set_ext          |
| gx_display_string_get                   | gx_display_string_get_ext                   |
| gx_display_string_table_get            | gx_display_string_table_get_ext            |
| gx_multi_line_text_button_text_set   | gx_multi_line_text_button_text_set_ext   |
| gx_multi_line_text_input_char_insert | gx_multi_line_text_input_char_insert_ext |
| gx_multi_line_text_input_text_set    | gx_multi_line_text_input_text_set_ext    |
| gx_multi_line_text_view_text_set     | gx_multi_line_text_view_text_set_ext     |
| gx_prompt_text_get                      | gx_prompt_text_get_ext                      |
| gx_prompt_text_set                      | gx_prompt_text_set_ext                      |
| gx_single_line_text_input_text_set   | gx_single_line_text_input_text_set_ext   |
| gx_system_string_width_get             | gx_system_string_width_get_ext             |
| gx_system_version_string_get           | gx_system_version_string_get_ext           |
| gx_text_button_text_get                | gx_text_button_text_get_ext                |
| gx_text_button_text_set                | gx_text_button_text_set_ext                |
| gx_text_scroll_wheel_callback_set     | gx_text_scroll_wheel_callback_set_ext     |
| gx_utility_string_to_alphamap          | gx_utility_string_to_alphamap_ext          |
| gx_widget_string_get                    | gx_widget_string_get_ext                    |
| gx_widget_text_blend                    | gx_widget_text_blend_ext                    |
| gx_widget_text_draw                     | gx_widget_text_draw_ext                     |

### <a name="guix-string-table"></a>Таблица строк GUIX 

Таблица строк и ресурсы строк GUIX регистрируются с использованием экземпляра дисплея GUIX.

Для каждого дисплея в системе с несколькими дисплеями предусмотрена собственная строковая таблица и можно использовать собственный выбранный язык. Другие типы ресурсов GUIX (цвета, шрифты и пиксельные карты) также хранятся в компоненте дисплея GUIX, так как эти типы ресурсов уникальны для каждого формата цвета и глубины цвета отображения.

Хотя таблицу строк приложения можно создать вручную, чаще всего таблица строк отображения определяется с помощью приложения GUIX Studio как часть файла ресурсов проекта. Доступные языки также определяются в файле заголовка ресурса. Таблица строк отображения — это таблица с несколькими столбцами, содержащая указатели на строки приложения. Каждый столбец таблицы строк представляет один язык, поддерживаемый приложением.
Если приложение поддерживает только один язык, например английский, в таблице строк будет только один столбец. Поддержку других языков можно также добавить в любое время, не изменяя программное обеспечение приложения.

Активная таблица строк назначается путем вызова функции API ***gx_display_string_table_set***. Эта функция вызывается автоматически с помощью созданного в GUIX Studio кода запуска, но ее также можно вызвать напрямую с помощью приложения, чтобы изменить активную таблицу строк.

Активный язык назначается путем вызова функции API ***gx_display_active_language_set***. Эта функция определяет, какой столбец таблицы строк отображения является активным.

При вызове этой функции во все видимые мини-приложения GUIX отправляется событие **GX_EVENT_LANGUAGE_CHANGE**, что позволяет обновить их для отображения новых активных данных строк.

Мини-приложения и программное обеспечение приложений разрешают статически определенные строки, используя значения идентификаторов строк и функции API ***gx_display_string_get_ext*** или ***gx_widget_string_get_ext***. Эти функции возвращают элемент **GX_STRING**, связанный с соответствующим идентификатором строки и текущим активным языком.

### <a name="bi-directional-text-display"></a>Двунаправленное отображение текста 

GUIX предусматривает две стратегии поддержки двунаправленного отображения текста.

Первая возможность — изменение порядка двунаправленного текста с помощью приложения GUIX Studio. При использовании этой возможности GUIX Studio создает двунаправленный текст в выходном файле, используя соответствующий порядок отображения. Это решение никак не влияет на производительность среды выполнения, и для него не требуются никакие добавления в библиотеку среды выполнения GUIX. Чтобы с помощью GUIX Studio создать двунаправленные текстовые строки в порядке отображения, следует установить флажок **Generate Bidi Text in Display Order** (Создать двунаправленный текст в порядке отображения) в диалоговом окне конфигурации языков GUIX Studio:

![Настройка языков](./media/guix/user-guide/configure-languages.png)

При выборе этих параметров в созданном файле ресурсов будут содержаться двунаправленные строки, созданные в порядке отображения. При этом в библиотеке среды выполнения GUIX не требуется выполнять дополнительную обработку.

Вторая возможность заключается в изменении порядка двунаправленного текста в среде выполнения. Эта возможность поддерживается для приложений, которым необходимо обрабатывать двунаправленные текстовые строки, определенные динамически и не созданные приложением GUIX Studio. В этом случае библиотека среды выполнения GUIX изменяет порядок двунаправленного текста перед рисованием каждой текстовой строки. Это решение может сказаться на производительности среды выполнения и операциях памяти. Для процесса изменения порядка двунаправленного текста должен быть доступным достаточный объем динамической памяти. Для этого решения необходимо определить условный элемент GX_DYNAMIC_BIDI_TEXT_SUPPORT при создании библиотеки GUIX. Для включения или отключения поддержки двунаправленного текста в среде выполнения используются две функции API: ***gx_system_bidi_text_enable*** и ***gx_system_bidi_text_disable***.

Для создания двунаправленного текста в порядке отображения не следует использовать обе возможности **GX_DYNAMIC_BIDI_TEXT_SUPPORT** и настраивать GUIX Studio. Для обработки двунаправленной текстовой строки необходимо выбрать какую-то одну стратегию из двух.

## <a name="memory-usage"></a>Использование памяти 

GUIX размещается в памяти вместе с приложением. В результате использование статической памяти (или фиксированной памяти) в GUIX зависит от используемых средств разработки (например, компилятора, компоновщика и указателя). Использование динамической памяти (или памяти во время выполнения) контролируется непосредственно приложением.

### <a name="static-memory-usage"></a>Использование статической памяти 

Большинство средств разработки разделяют представление программы приложения на пять основных областей: *инструкция*, *константа*, *инициализированные данные*, *неинициализированные данные* и *стек потоков GUIX*.  На рисунке ниже показана одна возможная структура этих областей памяти:

![Организация памяти](./media/guix/user-guide/memory-area-example.png)

Важно учитывать, что это только пример. Структура фактической статической памяти зависит от используемых процессора, средств разработки, базового оборудования и самого приложения.

В области инструкций содержатся все инструкции процессора для программы. Эта область часто расположена в ПЗУ.

Область констант содержит различные скомпилированные константы, которые в GUIX имеют параметры по умолчанию и все ресурсы приложения (изображения, строки, шрифты и цвета). Кроме того, эта область содержит начальную копию области инициализированных данных. В процессе инициализации в компиляторе эта часть области констант используется для настройки глобальных инициализированных данных в ОЗУ. Область констант обычно является самой большой, следует за областью инструкций и часто размещается в ПЗУ.

Для пиксельных карт и шрифтов GUIX обычно требуются большие объемы постоянного хранилища данных. Эти области с большим объемом статических данных обычно хранятся в ПЗУ или FLASH.

Стек потока GUIX определяется в области неинициализированных данных (как глобальная переменная) в файле ***gx_system.h*** следующим образом:

```C
_gx_system_thread_stack[GX_THREAD_STACK_SIZE];
```

Элемент **GX_THREAD_STACK_SIZE** определен в **_gx_port.h_**, но может быть переопределен в приложении путем определения этого символа в файле заголовка ***gx_user.h*** или с помощью параметров проекта либо параметров командной строки. Размер стека должен быть достаточным для обработки самых сложных событий и вложенных вызовов рисования.

### <a name="dynamic-memory-usage"></a>Использование динамической памяти 

Как упоминалось ранее, использование динамической памяти контролируется непосредственно приложением. Блоки управления и память, связанные с холстами и т. д., можно разместить в любом месте в целевой области памяти. Это важная возможность, так как она упрощает использование различных типов физической памяти во время выполнения.

Например, предположим, что целевое аппаратное окружение использует как быстродействующую, так и медленнодействующую память. Если приложению требуется дополнительная производительность для рисования, память холста можно поместить в область быстродействующей памяти, чтобы повысить производительность.

Для нескольких необязательных служб и возможностей GUIX требуется механизм распределения динамической памяти среды выполнения, который обычно называется кучей. Эти службы и возможности являются необязательными, и многие приложения GUIX не используют кучу и не определяют механизм распределения памяти среды выполнения.

Если планируется использовать службы, для которых требуется распределение памяти среды выполнения, необходимо установить функции, которые GUIX будет вызывать, когда понадобится динамически распределить или освободить память. Эти функции можно реализовать по своему усмотрению. Даже в данном случае расположение пула динамической памяти контролируется приложением. Для установки поддержки распределения динамической памяти приложению необходимо вызвать службу API ***gx_system_memory_allocator_set*** во время запуска программы, чтобы определить службы распределения и освобождения памяти. Полный пример см. в документации по этому API.

К службам GUIX, для которых необходимо использовать службу распределения и отмены распределения памяти, относятся:

  - загрузка двоичных ресурсов из внешнего хранилища в среду выполнения GUIX;

  - декодер изображений JPEG для среды выполнения программного обеспечения;

  - декодер изображений PNG для среды выполнения программного обеспечения;

  - использование текстовых мини-приложений с GX_STYLE_TEXT_COPY;

  - служебные функции изменения размера и поворота пиксельной карты для среды выполнения;
  - выделение блока управления экраном и мини-приложением для среды выполнения.

В небольших приложениях ресурсы GUIX обычно компилируются и статически связываются как часть образа приложения. При этом установка двоичных ресурсов не требуется. Двоичные ресурсы позволяют приложению устанавливать в среде выполнения ресурсы (шрифты, изображения, языки), загруженные из определенного места хранения, например из устройства флэш-памяти или с помощью URL-адреса.

Декодеры JPEG и PNG для среды выполнения являются дополнительными компонентами. Большинство приложений GUIX позволяют средству GUIX Studio предварительно декодировать все необходимые файлы изображений и хранить их как собственные ресурсы данных пиксельных карт GUIX. Эти службы обеспечивают полноту возможностей приложений, которым требуется преобразование изображений JPEG и (или) PNG в формат пиксельных карт во время выполнения.

**GX_STYLE_TEXT_COPY** позволяет пользователю указать, что в конкретном мини-приложении или мини-приложениях будет храниться собственная частная копия динамически назначенного текста. Перед использованием этого параметра необходимо установить механизм распределения памяти. Если этот флаг стиля **<span class="underline">не</span>** указан при создании мини-приложения текстового типа, приложение должно выделить статические области хранения для всех динамически созданных и назначенных текстовых строк. В этом случае автоматические переменные не следует использовать для хранения данных строк, созданных в среде выполнения. Если включен стиль **GX_STYLE_TEXT_COPY**, для хранения строковых данных, назначенных мини-приложениям GUIX, можно использовать автоматические переменные, так как каждое мини-приложение создает собственную копию назначенного текста.

Служебные функции изменения размера и поворота пиксельных карт возвращают полученную преобразованную пиксельную карту как новую пиксельную карту, доступную для приложения.
Для хранения блоков данных пиксельных карт, созданных в среде выполнения (если соответствующие службы используются), необходим достаточный объем динамической памяти.

Наконец, блоки управления для экранов и мини-приложений GUIX можно выделить статически или динамически. Как правило, в небольших приложениях все экраны приложения создаются во время запуска программы, а также используются статически выделенные блоки управления. В больших приложениях, как правило, элементы управления экрана и дочерних мини-приложений создаются динамически по мере необходимости. Динамически выделенные блоки управления указываются путем установки флажка **Runtime Allocate** (Выделить во время выполнения) в представлении свойств GUIX Studio или путем передачи флага стиля **GX_STYLE_DYNAMICALLY_ALLOCATED** при создании мини-приложения с помощью стандартного API. Для использования динамически выделенных блоков управления мини-приложений требуется определить службы распределения и отмены распределения памяти, как описано выше.

## <a name="guix-components"></a>Компоненты GUIX 

API GUIX разделяются на несколько базовых групп, которые соответствуют фундаментальным компонентам системы GUIX. К основным компонентам относятся:

| Компоненты  | Описание  |
| ---------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| GX_SYSTEM  | Системный компонент GUIX, отвечающий за инициализацию, события, таймеры, таблицы строк и управление видимой иерархией мини-приложений.                                                                                                                                                                                                                                                                      |
| GX_CANVAS  | Область рисования. Холст может быть тонкой абстракцией аппаратного буфера кадров или чистым холстом памяти. Тип холста определяется параметрами, передаваемыми в функцию API gx_canvas_create.                                                                                                                                                                                   |
| GX_CONTEXT | Компонент контекста рисования. Контекст рисования содержит сведения об экране, холсте, кисти и области обрезки для текущих операций рисования.                                                                                                                                                                                                                                      |
| GX_DISPLAY | Предоставляет API и реализации на уровне драйверов, позволяющие приложению и мини-приложениям GUIX выполнять рисование на холсте. GX_DISPLAY реализован для соответствующего преобразования графики на каждом холсте с помощью необходимого цветового формата холста. Компонент GX_DISPLAY также управляет ресурсами (цветами, шрифтами и пиксельными картами) для мини-приложений при рисовании на холстах, связанных с каждым дисплеем. |
| GX_WIDGET  | Базовый видимый объект мини-приложения и связанные API. Все типы мини-приложений GUIX созданы на основе базового типа GX_WIDGET или являются его производными.                                                                                                                                                                                                                                                                      |
| GX_UTILITY | В эту группу входят служебные функции для работы с прямоугольниками, функции для преобразования строк и не соответствующие стандарту ANSI математические функции.                                                                                                                                                                                                                                                         |

Помимо этих основных компонентов GUIX содержит API, уникальные для каждого типа мини-приложения в библиотеке. Эти API описаны в главе 4 этого руководства пользователя ("Описание служб GUIX").

## <a name="guix-system-component"></a>Системный компонент GUIX

Системный компонент GUIX предоставляет несколько глобальных служб для приложения пользовательского интерфейса. К этим службам относятся службы *инициализации, управления событиями, управления отображением, управления ресурсами, управления таймером* и *управления мини-приложениями*. Каждая служба важна для организации работы элементов программы приложения. Эти службы более подробно описаны в указанных ниже подразделах.

### <a name="initialization"></a>Инициализация 

Инициализация GUIX выполняется в приложении путем вызова службы ***gx_system_initialize***, которая может быть вызвана приложением из подпрограммы ***tx_application_define*** ThreadX (контекст инициализации) или из потоков приложения. Функция ***gx_system_initialize*** инициализирует все глобальные структуры данных GUIX и создает системный мьютекс, очередь событий, таймер и поток GUIX. После возвращения ***gx_system_initialize*** приложение может использовать GUIX.

### <a name="thread-processing"></a>Обработка потоков 

Внутренний поток GUIX, созданный во время инициализации, выполняет большую часть операций обработки в GUIX. При обработке в этом потоке сначала завершается любая дополнительная инициализация, необходимая для базового драйвера дисплея. После завершения этой процедуры поток GUIX входит в цикл, в котором сначала обрабатываются все события в очереди событий GUIX, а затем при необходимости обновляется экран. При обновлении экрана выполняются необходимые функции рисования GUIX, исходя из того, что является видимым и помечено как "грязный" элемент, который необходимо перерисовать. Если событий нет и обновление дисплея не требуется, поток GUIX приостанавливает работу, ожидая прибытия следующего события GUIX.

### <a name="rtos-binding"></a>Привязка ОСРВ 

Для системного компонента GUIX по умолчанию настроено использование операционной системы ThreadX в режиме реального времени для таких служб, как службы потоков, службы очередей событий и службы таймера. GUIX можно легко перенести в другие операционные системы с помощью директивы препроцессора GX_DISABLE_THREADX_BINDING и путем повторной сборки библиотеки GUIX. В этом случае зависимости ThreadX удаляются из исходного кода GUIX, что позволяет разработчику приложения реализовать необходимые службы операционной системы с помощью ОСРВ целевой системы. [Приложение F. Службы привязки ОСРВ для GUIX](appendix-f.md) содержит описание служб, которые необходимо реализовать для переноса GUIX в операционную систему, отличную от операционной системы ThreadX.

### <a name="multithread-safety"></a>Безопасность многопоточности 

API GUIX доступен из контекста потока GUIX, а также других потоков приложения. Потоки приложения могут взаимодействовать с потоком GUIX через доступ к общим переменным, а также отправляя и получая данные событий и используя функции API GUIX. GUIX использует внутренний мьютекс ThreadX для защиты ресурсов с несколькими потоками. Кроме того, GUIX предотвращает изменение внутренней структуры видимых мини-приложений после начала операции обновления экрана. API, которые могут изменить дерево видимых объектов, блокируются во время выполнения операций рисования и запускаются после завершения обновления экрана.

### <a name="system-timers"></a>Системные таймеры 

GUIX предоставляет для приложения периодические таймеры, которые часто используются для периодического обновления данных, отображаемых в окнах GUIX. Для этого используется периодический таймер ThreadX, который также позволяет реализовать эффекты GUIX на уровне системы, такие как исчезание или появление экрана и т. д.

Приложение может создавать таймеры и использовать то же средство таймера, которое используется внутренним образом в GUIX. Разумеется, приложение может также создавать и использовать таймеры ThreadX, если это необходимо. Преимущество таймеров GUIX заключается в том, что они очень просты в использовании и предварительно настроены для работы в управляемой событиями системе обработки данных GUIX.

Чтобы создать и запустить таймер GUIX, приложение должно вызвать функцию ***gx_system_timer_start***. Параметры этой функции включают в себя указатель на вызывающее мини-приложение, идентификатор таймера (позволяющий одному мини-приложению запустить много таймеров), а также начальное значение и значение перепланирования времени ожидания. Если значение перепланирования времени ожидания равно 0, таймер выполняется только один раз и удаляется из списка активных таймеров по истечении срока его действия.

После запуска таймер GUIX отправляет события GX_EVENT_TIMEOUT владельцу таймера один раз или периодически — в зависимости от значения перепланирования таймера. Таймер GUIX можно остановить, вызвав функцию API ***gx_system_timer_stop***.

### <a name="pen-speed-configuration"></a>Конфигурация скорости пера 

Системный компонент GUIX содержит сведения о конфигурации, связанные с отслеживанием скорости пера. GUIX внутренним образом создает события **GX_EVENT_VERTICAL_FLICK** и **GX_EVENT_HORIZONTAL_FLICK** в зависимости от скорости и расстояния событий PEN_DOWN, созданных драйвером сенсорного ввода, если таковые имеются. Приложение может настроить минимальные расстояние и скорость, необходимые для активации этих созданных внутренним образом событий, используя функцию API **_gx_system_pen_configure_**.

### <a name="screen-stack"></a>Стек экрана 

Системный компонент GUIX предоставляет службы, связанные со стеком экрана GUIX, который является дополнительной возможностью, поддерживающей виртуальный стек мини-приложения для отправки, извлечения и получения экранов приложением в среде выполнения. Стек экрана используется для управления сложными системами меню, когда маршрут, по которому пользователь может перейти в различные состояния в системе меню, варьируется. К предыдущему состоянию в системе меню можно легко вернуться, сначала отправив предыдущее состояние экрана, а затем отобразив новый экран и разрешив новому экрану извлечь предыдущее состояние из стека экрана при закрытом текущем экране.

### <a name="clipboard-maintenance"></a>Обслуживание буфера обмена 

GUIX поддерживает буфер обмена для копирования и вставки текста во время выполнения. Эта поддержка предоставляется системным компонентом GUIX.

### <a name="dirty-list-maintenance"></a>Поддержка "грязных" списков 

GUIX поддерживает список "грязных" мини-приложений (видимые мини-приложения, которые необходимо перерисовать из-за изменений состояния, или мини-приложения, ставшие вновь видимыми). Этот "грязный" список улучшает производительность рисования, позволяя GUIX выполнить операцию обновления холста для отображения всех текущих изменений состояния пользовательского интерфейса вместо обновления холста при каждом изменении пользовательского интерфейса.
Этот "грязный" список также поддерживается системным компонентом GUIX.

### <a name="animation-control-block-pool"></a>Пул блоков управления анимацией 

Приложениям часто необходимо выполнять несколько последовательностей анимации и, как правило, в параллельном режиме. GUIX поддерживает пул блоков управления анимацией, которые приложение может выделить и использовать. Это устраняет в приложении необходимость статического определения этих блоков управления и позволяет повторно использовать их в разное время, вместо того чтобы определять уникальный блок управления для каждой анимации, которая определяется приложением. Пул блоков управления анимацией также поддерживается системным компонентом GUIX.

### <a name="system-error-handling"></a>Обработка системных ошибок 

Обработчик системных ошибок GUIX предназначен для того, чтобы помочь приложению найти внутренние системные ошибки в GUIX, которые сложнее определить с точки зрения API. При возникновении системной ошибки в GUIX вызывается внутренняя функция ***_gx_system_error_process***. Эта функция сохраняет указанный код ошибки и увеличивает общее количество обнаруженных системных ошибок. Переменные системных ошибок определены следующим образом:

UINT **_gx_system_last_error**;

ULONG **_gx_system_error_count**;

Если приложение GUIX работает некорректно, необходимо проверить переменную количества ошибок в отладчике. Если этот параметр настроен, устранить проблему можно, задав точку останова в функции ***_gx_system_error_process*** и проверив, откуда и когда выполнялся соответствующий вызов.

## <a name="guix-canvas-component"></a>Компонент холста GUIX

Компонент холста отвечает за обработку всех данных, связанных с холстом. Холст по сути является виртуальным буфером кадров. Чтобы создать графические выходные данные, приложению необходимо создать по крайней мере один холст.
Как правило, для каждого физического дисплея, поддерживаемого системой, создается по крайней мере один холст.

Все операции рисования GUIX выполняются на холсте. В более простых системах или системах с ограниченной памятью обычно используется только один холст, который может быть напрямую связан с видимым буфером кадров. В системах с большим объемом памяти и повышенными графическими требованиями может понадобиться несколько холстов. Использование нескольких холстов для одного дисплея позволяет применять такие функции, как эффект исчезания или появления экрана и окна.
Используется один из двух основных типов холстов: простой или управляемый.

Простой холст — это область рисования за пределами экрана, используемая приложением.
GUIX ничего не выполняет напрямую на простом холсте, но приложение может использовать простой холст для отображения сложного рисунка в буфере за пределами экрана, а затем использовать этот буфер для обновления видимого холста при необходимости.

Управляемый холст автоматически отображается в аппаратном буфере кадров с помощью GUIX. Управляемый холст добавляется при создании составного холста для систем с достаточным объемом памяти для поддержки нескольких управляемых холстов. Управляемые холсты имеют Z-порядок, который поддерживается GUIX. На всех управляемых холстах применяется возможность обрезания представлений.

Холст отличается от буфера кадров тем, что он является более универсальным. В системах с ограниченным объемом памяти может использоваться только один холст, а память для этого холста может быть памятью видимого буфера кадров. Но в более сложных системах, поддерживающих более сложные графические наложения и несколько холстов, для управляемых холстов выделяются собственные области памяти, которые отличаются от памяти аппаратного буфера кадров.
Эти управляемые холсты преобразовываются в видимый буфер кадров во время операции обновления буфера кадров или переключения режима.

Для оборудования, поддерживающего несколько графических слоев, например несколько наложенных буферов кадров, приложение может привязать один или несколько холстов к аппаратным графическим слоям с помощью API ***gx_canvas_hardware_layer_bind***. Эта служба информирует холст о том, что он связан с конкретным аппаратным графическим слоем. После связывания холст попытается использовать аппаратную поддержку для обеспечения видимости холста (т. е. gx_canvas_show, gx_canvas_hide), альфа-смешения холстов (т. е. ***gx_canvas_alpha_set***) и смещения холста в пределах дисплея (***gx_canvas_offset_set***).

Для архитектур, отличных от простейшей организации с одним холстом или одним буфером кадров, размер холста определяется приложением и может отличаться от фиксированного размера буфера кадров.
Кроме того, для этого может использоваться смещение, выбранное приложением. Другие сведения, например сведения о Z-порядке, сохраняются на холсте. После завершения рисования на холсте содержимое холста передается на физический дисплей с помощью драйвера дисплея. В некоторых системах, в которых недостаточно памяти для отдельных областей памяти холста и буфера кадров, обновление холста выполняется непосредственно на физическом дисплее с помощью драйвера дисплея.

### <a name="canvas-creation"></a>Создание холста 

Объект холста можно создать во время инициализации или в любое время при выполнении потоков приложения. Количество объектов холста, которые может создать приложение, не ограничено. Тем не менее большинство приложений создает только один объект холста для всех операций рисования GUIX.

### <a name="canvas-control-block"></a>Блок управления холстом 

Характеристики каждого объекта холста находятся в блоке управления **GX_CANVAS** и определены в **_gx_api.h_**. Память, необходимая для объекта холста, предоставляется приложением и может находиться в любом месте в памяти. Однако чаще всего блок управления объектами холста и область рисования становятся глобальной структурой путем их определения вне области какой-либо функции.

### <a name="canvas-alpha-channel"></a>Альфа-канал холста

GUIX поддерживает альфа-смешение цветов переднего плана и фона на многих уровнях (включая альфа-канал растрового изображения, который определяет коэффициент смешения на пиксель, альфа-кисть, которая определяет коэффициент смешения для кисти (16 бит/пкс и глубину цвета более высокого уровня), а также альфа-холст, который определяет коэффициент смешения для холста наложения).

Альфа-фактор холста используется при наличии нескольких холстов, объединенных для отображения в буфере кадров. Если используется Z-порядок холста, когда холст находится над другими холстами, можно задать альфа-фактор холста для смешения холста с теми холстами, которые находятся за ним. Быстро изменяя альфа-фактор холста, можно создать эффекты "исчезания" экрана, но его можно также использовать различными способами.

Если холст привязан к аппаратному графическому слою с использованием gx_canvas_hardware_layer_bind(), GUIX попытается выполнить альфа-смешение холстов с помощью аппаратной поддержки, минимизируя нагрузку на программное обеспечение, связанную со смешением холста наложения.

Альфа-факторы могут иметь значение в диапазоне от 0 до 255, где значение 0 означает, что пиксель является полностью прозрачным, а значения больше 0 означают увеличение альфа-фактора холста и понижение уровня прозрачности (поддерживается только для драйверов экрана с 16 бит/пкс и выше, если не предоставляется аппаратная поддержка для смешения холстов).

### <a name="canvas-offset"></a>Смещение холста 

Холст может быть смещен в видимом буфере кадров путем вызова службы API ***gx_canvas_offset_set***. Смещения холстов позволяют реализовать анимации спрайта. Если холст связан с аппаратным графическим слоем с помощью вызова функции API ***gx_canvas_hardware_layer_bind***, GUIX попытается изменить смещение холста, используя аппаратную поддержку, чтобы уменьшить нагрузку на программное обеспечение, связанную со сдвигом позиции холста.

### <a name="canvas-drawing"></a>Рисование на холсте 

Компонент холста GUIX предоставляет приложению полный API для рисования. Перед вызовом API рисования, таких как ***gx_canvas_line_draw*** или ***gx_canvas_pixelmap_draw***, необходимо открыть целевой холст для рисования путем вызова функции API ***gx_canvas_drawing_initiate***. Эта функция готовит холст для рисования и создает ***контекст рисования***.

API рисования, которые визуализируются на холсте, например ***gx_canvas_line_draw** _ или _*_gx_canvas_text_draw_*_, используют параметры в текущей кисти контекста рисования для определения стиля линий, ширины и цветов. Эти параметры кисти можно изменить путем вызова _*_gx_context_brush_define_*_, _*_gx_context_brush_set_**, ***gx_context_brush_style_set**_ и аналогичных функций API после установки контекста рисования с помощью вызова _*_gx_canvas_drawing_initiate_**.

Когда GUIX вызывает функции рисования окна и мини-приложения в рамках операции отложенного обновления холста, целевой холст открывается для рисования перед вызовом функций рисования для мини-приложения. Поэтому для стандартных функций рисования мини-приложения не нужно открывать целевой холст, так как это уже выполнено.

В некоторых случаях приложению может потребоваться немедленно выполнить рисование на холсте. В этом случае приложение может выполнить указанные ниже действия.

1. Вызовите функцию API ***gx_canvas_drawing_initiate***, передав целевой холст и прямоугольник на холсте, на котором приложение выполняет операцию рисования. 

2. Вызовите любое количество API рисования холста, чтобы выполнить нужную операцию рисования.

3. Вызовите функцию API ***gx_canvas_drawing_complete***, чтобы сообщить о завершении рисования. При этом холст записывается в видимый буфер кадров и (или) активируется операция переключения буфера в зависимости от архитектуры системной памяти.

### <a name="drawing-apis"></a>API рисования 

Существует несколько основных примитивов рисования, которые необходимы GUIX для рисования всех визуальных элементов на экране. Эти API рисования также могут быть вызваны программным обеспечением приложения, как правило, в рамках выполнения пользовательской функции рисования мини-приложения. Эти API рисования на холсте GUIX выполняют проверку параметров и операции обрезки, а затем передают координаты обрезанного рисунка драйверу дисплея для реализации рисования на основе оборудования и цветного формата. Эти функции API рисования определяются следующим образом:

- gx_canvas_alpha_set
- gx_canvas_arc_draw
- gx_canvas_block_move
- gx_canvas_circle_draw
- gx_canvas_ellipse_draw
- gx_canvas_glyphs_draw
- gx_canvas_hardware_layer_bind
- gx_canvas_hide
- gx_canvas_line_draw
- gx_canvas_offset_set
- gx_canvas_pie_draw
- gx_canvas_pixel_draw
- gx_canvas_pixelmap_blend
- gx_canvas_pixelmap_rotate
- gx_canvas_pixelmap_tile
- gx_canvas_polygon_draw
- gx_canvas_rectangle_draw
- gx_canvas_rotated_text_draw
- gx_canvas_shift
- gx_canvas_show
- gx_canvas_text_draw

API рисования вызывается с помощью API холста GUIX, а все операции рисования выполняются с помощью функций API gx_canvas_*. Рисование выполняется с помощью текущей кисти в текущем контексте рисования. Для любой указанной выше функции рисования фигур можно создать контур, выполнить сплошную заливку цветом или выполнить заполнение пиксельной картой в соответствии с определением текущей кисти. Для изменения ширины, цвета или заливки контура фигуры используйте функции API gx_context_brush_*, чтобы определить кисть в текущем контексте рисования.

Указанные выше API рисования на уровне приложения не выполняют фактическое рисование на холсте. Вместо этого они проверяют параметры вызывающего элемента перед вызовом функции рисования на уровне драйвера дисплея. Функция рисования на уровне драйвера по сути записывает пиксельные данные в память холста.

GUIX предоставляет стоковые или универсальные функции рисования драйверов дисплея для различной глубины цвета, включая 1, 2, 4, 8, 16, 24 и 32 бит на пиксель (бит/пкс). В некоторых случаях реализация программного рисования по умолчанию заменяется реализациями с аппаратным ускорением для тех аппаратных целевых объектов, которые предоставляют ускоритель для двухмерного рисования.

### <a name="color-depth"></a>Глубина цвета 

GUIX поддерживает глубину цвета до 32 бит/пкс, а также монохромную шкалу и оттенки серого. Тип поддержки глубины цвета в основном определяется возможностями базового физического дисплея, а также влияет на необходимый объем памяти для области рисования холста. Ниже приведен список поддержки глубины цвета, а также краткое описание вариаций в рамках данной глубины цвета.

| Формат&nbsp;цвета       | Описание                                                                                                   |
| ------------------ | -------------------------------------------------------------------------------------------------------------------------------- |
| 1-битный, монохромный   | Формат упаковки — 1 бит на пиксель.                                                                                                   |
| 2-битный, оттенки серого    | 4 уровня серого, упаковка — четыре пикселя на байт.                                                                                      |
| 4-битный, оттенки серого    | 16 уровней серого, упаковка — два пикселя на байт.                                                                                      |
| 4-битный цвет        | Плоская организация памяти в формате VGA.                                                                                         |
| 8-битный, оттенки серого    | 256 уровней серого                                                                                                                  |
| 8-битный режим палитры | 1 байт на пиксель, используется в качестве индекса палитры                                                                                           |
| 8-битный режим r:g:b   | Реже используемый формат 2:3:2 r:g:b.                                                                                         |
| 16-разрядный             | Для каждого пикселя требуется два байта. Порядок байтов может быть r:g:b или b:g:r. Обычно используется структура 5:6:5, но также может использоваться структура 5:5:5 или 4:4:4:4 a:r:g:b. |
| 24-битный             | Для каждого пикселя требуется 3 (упакованный формат) или 4 (распакованный формат) байта. Может использоваться порядок байтов r:g:b или b:g:r в соответствии с требованиями оборудования. |
| 32-разрядная система             | Для каждого пикселя требуется 4 байта и альфа-канал. Может использоваться порядок байтов a:r:g:b или b:g:r:a, определяется оборудованием.              |

### <a name="mouse-support"></a>Поддержка мыши 

GUIX поддерживает рисование курсором мыши на любом холсте. Курсором мыши можно рисовать, используя программное обеспечение или поддержку аппаратного наложения курсора. В любом случае при рисовании программным или аппаратным курсором мыши используется один и тот же API, предоставляемый приложению, связанному с поддержкой курсора мыши.

Поддержка мыши GUIX включена только в том случае, если элемент `#define GX_MOUSE_SUPPORT` определен в файле заголовка gx_user.h перед сборкой библиотеки GUIX.

Приложение должно определить курсор мыши и гиперобъект с помощью функции API ***gx_canvas_mouse_define***. Этот API принимает указатель для холста, на котором должно быть нарисовано изображение курсора, а также указатель для структуры **GX_MOUSE_CURSOR_INFO**, что определяет изображение курсора мыши и гиперобъект изображения мыши относительно левого верхнего угла изображения.

## <a name="guix-display-component"></a>Компонент дисплея GUIX 

Компонент дисплея является фундаментальным в GUIX, так как он управляет обработкой данных всех объектов дисплея, которые содержат холсты, мини-приложения и окна (несколько или по одному). Компонент дисплея также взаимодействует с базовым аппаратным драйвером экрана, связанным с каждым дисплеем, с помощью ряда указателей функций.

### <a name="display-creation"></a>Создание дисплея 

Объект дисплея можно создать во время инициализации или в любое время при выполнении потоков приложения. Обычно приложение создает один объект дисплея для управления каждым физическим экраном. Если GUIX Studio используется для определения приложения и физических дисплеев, необходимо использовать функцию API gx_studio_display_configure для создания и инициализации каждого из дисплеев.

### <a name="display-control-block"></a>Блок управления для дисплея 

Характеристики каждого объекта дисплея находятся в блоке управления ***GX_DISPLAY** _ и определены в _*_gx_api.h_**. Память, необходимая для объекта дисплея, предоставляется приложением и может находиться в любом месте в памяти. Однако чаще всего блок управления дисплеем становится глобальной структурой путем его определения вне области какой-либо функции.

### <a name="resource-management"></a>Управление ресурсами 

Ресурсы — это компоненты пользовательского интерфейса, необходимые для приложения, но они не являются кодом приложения. Ресурсы — это данные приложений, которые обычно определяются статически. К типам ресурсов относятся пиксельные карты, шрифты, цвета и строки. Эти ресурсы можно изменить в любое время (как правило, не изменяя программное обеспечение приложения). Важно хранить ресурсы и ссылки на ресурсы отдельно от программного обеспечения приложения. Это позволяет изменять внешний вид пользовательского интерфейса без изменения кода приложения, так как при изменениях программного обеспечения приложения обычно необходимы повторное тестирование и проверки этого программного обеспечения.

Модуль ***дисплея*** GUIX предоставляет средства управления для всех ресурсов, зависящих от глубины цвета и формата дисплея. Эти средства также обеспечивают поддержку активной таблицы пиксельных карт, активных таблиц шрифтов и активных таблиц цветов. Ресурс таблицы строк сохраняется в системном модуле GUIX, так как обычно не требуется изменять ресурсы строк в зависимости от глубины цвета и формата.

Программное обеспечение приложения ссылается на ресурсы, используя идентификатор ресурса, который является индексом для соответствующей таблицы ресурсов. Это позволяет изменять таблицу. Например, таблица цветов может быть изменена, если для продукта переключить режим работы с дневного на ночной. Но значения идентификатора цвета остаются прежними.

Ресурсы приложения записываются в файл ресурсов (или набор файлов ресурсов) с помощью приложения GUIX Studio. Цвета по умолчанию, пиксельные карты и шрифты предоставляются автоматически при создании нового проекта GUIX Studio, но эти значения по умолчанию можно легко заменить при определении внешнего вида и свойств приложения.

Важно отметить, что идентификаторы ресурсов для цветов, шрифтов и пиксельных карт не могут быть разрешены для их фактических значений цвета, шрифта или пиксельной карты, пока не станет известным компонент активного дисплея. Так как архитектура GUIX поддерживает несколько активных дисплеев, идентификаторы ресурсов могут быть разрешены для значений ресурсов, только когда мини-приложение и связанный с ним идентификатор ресурса могут быть разрешены для конкретного дисплея. Это свойство называется динамической привязкой. Идентификатор ресурса для свойства цвета текста, например идентификатор ресурса **GX_COLOR_ID_TEXT**, может разрешаться в 16-битное значение R:G:B для белого цвета, если используется для одного дисплея. Но тот же идентификатор цвета может разрешаться в монохромное значение черного цвета при использовании для другого дисплея.

На практике эта динамическая привязка идентификаторов ресурсов к значениям ресурсов означает, что программное обеспечение приложения и внутренние компоненты GUIX чаще всего разрешают идентификаторы ресурсов только для значений ресурсов в активном контексте рисования. Активный контекст рисования определяет текущий активный дисплей, что позволяет GUIX разрешать каждый идентификатор ресурса для определенного значения ресурса. Если для программного обеспечения приложения необходимо найти определенное значение ресурса за пределами контекста рисования, это также можно сделать для видимых мини-приложений. Видимые мини-приложения связаны с корневым окном, которое также можно использовать для разрешения активного холста и дисплея для этого мини-приложения.

Если мини-приложение создано, но еще не отображается (т. е. не связано ни с одним корневым окном или другим видимым родительским элементом), любые идентификаторы ресурсов, связанные с этим мини-приложением, не могут быть разрешены для определенного значения ресурса. Это возможно только при непосредственном индексировании для таблицы ресурсов, назначенной конкретному дисплею. Этот прямой доступ к определенной таблице ресурсов может безопасно осуществляться программным обеспечением приложения, но он никогда не осуществляется с помощью программного обеспечения внутренней библиотеки GUIX.

### <a name="widget-defaults"></a>Значения по умолчанию мини-приложения 

Компонент дисплея GUIX также предоставляет определения по умолчанию для различных атрибутов мини-приложения. Если в приложении не указано иное, мини-приложения или окна создаются с этими системными атрибутами. Эти системные атрибуты в основном состоят из шрифтов, цветов и растровых изображений, сохраненных в таблицах системных ресурсов. Дополнительные атрибуты для внешнего вида полосы прокрутки по умолчанию также поддерживаются компонентом дисплея GUIX.

Параметры цвета по умолчанию определяются с помощью таблицы цветов, назначенной каждому дисплею, а также предварительно определенных идентификаторов цвета по умолчанию. К этим идентификаторам цвета по умолчанию относятся следующие идентификаторы.

| Идентификатор цвета | Описание |
| ------------------ | -------------------------------------------------------------------------------------------------------------------------------- |
| GX_COLOR_ID_CANVAS | Цвет холста по умолчанию (т. е. фон дисплея) |
| GX_COLOR_ID_WIDGET_FILL | Цвет заливки мини-приложения по умолчанию |
| GX_COLOR_ID_WINDOW_FILL | Цвет заливки окна по умолчанию |
| GX_COLOR_ID_DISABLED_FILL | Цвет заливки отключенного мини-приложения по умолчанию |
| GX_COLOR_ID_DEFAULT_BORDER | Цвет границы мини-приложения по умолчанию |
| GX_COLOR_ID_WINDOW_BORDER | Цвет границы окна по умолчанию |
| GX_COLOR_ID_TEXT | Цвет текста по умолчанию |
| GX_COLOR_ID_SELECTED_TEXT | Цвет выбранного текста по умолчанию |
| GX_COLOR_ID_DISABLED_TEXT | Цвет отключенного текста по умолчанию |
| GX_COLOR_ID_SELECTED_TEXT_FILL | Цвет заливки выбранного текста по умолчанию |
| GX_COLOR_ID_READONLY_TEXT | Цвет текста только для чтения по умолчанию |
| GX_COLOR_ID_READONLY_FILL | Цвет заливки текста только для чтения по умолчанию |
| GX_COLOR_ID_SCROLL_FILL |    Цвет заливки полосы прокрутки |
| GX_COLOR_ID_SCROLL_BUTTON | Цвет заливки кнопки полосы прокрутки |
| GX_COLOR_ID_SHADOW | Цвет тени по умолчанию |
| GX_COLOR_ID_SHINE | Цвет выделения по умолчанию |
| GX_COLOR_ID_BUTTON_BORDER | Цвет границы мини-приложения кнопки |
| GX_COLOR_ID_BUTTON_UPPER | Цвет верхней заливки мини-приложения кнопки |
| GX_COLOR_ID_BUTTON_LOWER | Цвет нижней заливки мини-приложения кнопки |
| GX_COLOR_ID_BUTTON_TEXT | Цвет текста мини-приложения кнопки |
| GX_COLOR_ID_TEXT_INPUT_TEXT | Цвет текста мини-приложения ввода текста |
| GX_COLOR_ID_TEXT_INPUT_FILL | Цвет заливки текстового поля |
| GX_COLOR_ID_SLIDER_TICK | Цвет, используемый для рисования делений ползунка |
| GX_COLOR_ID_SLIDER_GROOVE_BOTTOM | Цвет, используемый для рисования бороздки ползунка |
| GX_COLOR_ID_SLIDER_NEEDLE_OUTLINE | Цвет, используемый для рисования контура стрелки |
| GX_COLOR_ID_SLIDER_NEEDLE_FILL | Цвет, используемый для заполнения стрелки ползунка |
| GX_COLOR_ID_SLIDER_NEEDLE_LINE1 | Цвет, используемый для рисования выделения стрелки |
| GX_COLOR_ID_SLIDER_NEEDLE_LINE2 | Цвет, используемый для рисования тени стрелки |

Эти значения идентификатора цвета сопоставляются со значением цвета, определенным в таблице цветов, назначенной каждому из дисплеев. Эти значения по умолчанию можно изменить как группу для одного дисплея, вызвав функцию API ***gx_display_color_table_set***. Если используется GUIX Studio, таблица цветов дисплея автоматически инициализируется, когда приложение вызывает функцию ***gx_studio_display_configure***.

Компонент дисплея GUIX также поддерживает таблицу шрифтов по умолчанию. Таблица шрифтов по умолчанию определяет шрифт, используемый для каждого типа мини-приложения, если он не указан приложением. К предварительно определенным идентификаторам таблицы шрифтов дисплея относятся указанные ниже значения.

| Идентификатор&nbsp;шрифта | Описание |
| ------------------ | --------------------------------------------------------------------------------------------------------------------------------|
| GX_FONT_ID_DEFAULT | Шрифт по умолчанию, используемый, когда не определен конкретный шрифт |
| GX_FONT_ID_BUTTON | Шрифт по умолчанию, используемый для всего текста на кнопках |
| GX_FONT_ID_TEXT_INPUT | Шрифт по умолчанию, используемый для полей редактирования текста |

Идентификатор шрифта, используемый любым мини-приложением типа текста, можно переназначить с помощью API **gx_<widget_type>_font_set**, который предоставляется для каждого типа мини-приложения, связанного с текстом. Всю таблицу шрифтов можно переназначить, вызвав функцию API **gx_display_font_table_set**.

### <a name="scrollbar-appearance"></a>Внешний вид полосы прокрутки 

Дисплей GUIX также поддерживает параметры внешнего вида полосы прокрутки по умолчанию для соответствующего дисплея. Эти параметры определяются структурой **GX_SCROLLBAR_APPEARANCE**, которая определена ниже. Дисплей GUIX поддерживает одну структуру внешнего вида для вертикальных полос прокрутки и другую структуру — для горизонтальных полос прокрутки. Приложение может изменить внешний вид полосы прокрутки по умолчанию для любого дисплея, инициализируя структуру **GX_SCROLLBAR_APPEARANCE** и вызывая функцию API ***gx_display_scroll_appearance_set***.

```c
typedef struct GX_SCROLLBAR_APPEARANCE_STRUCT
{
    GX_VALUE       gx_scroll_width;
    GX_VALUE       gx_scroll_thumb_width;
    GX_VALUE       gx_scroll_thumb_travel_min;
    GX_VALUE       gx_scroll_thumb_travel_max;
    GX_UBYTE       gx_scroll_thumb_border_style;
    GX_RESOURCE_ID gx_scroll_fill_pixelmap;
    GX_RESOURCE_ID gx_scroll_thumb_pixelmap;
    GX_RESOURCE_ID gx_scroll_up_pixelmap;
    GX_RESOURCE_ID gx_scroll_down_pixelmap;
    GX_RESOURCE_ID gx_scroll_thumb_color;
    GX_RESOURCE_ID gx_scroll_thumb_border_color;
    GX_RESOURCE_ID gx_scroll_button_color;
} GX_SCROLLBAR_APPEARANCE;
```
| Элемент структуры GX_SCROLLBAR_APPEARANCE | Описание |
| --- | --- |
| gx_scroll_width | Ширина вертикальной полосы прокрутки или высота горизонтальной полосы прокрутки (в пикселях). |
| gx_scroll_thumb_width | Ширина вертикального ползунка и конечных кнопок (в пикселях). |
| gx_scroll_thumb_travel_max | Смещение от конца полосы прокрутки до точки максимального хода кнопки ползунка. |
| gx_scroll_fill_pixelmap | Пиксельная карта, используемая для заливки фона полосы прокрутки. |
| gx_scroll_thumb_pixelmap | Пиксельная карта, используемая для рисования кнопки ползунка. |
| gx_scroll_up_pixelmap | Пиксельная карта, используемая для рисования кнопки прокрутки вверх. |
| gx_scroll_down_pixelmap | Пиксельная карта, используемая для рисования кнопки прокрутки вниз. |
| gx_scroll_fill_color | Идентификатор цвета, используемый для заполнения фона полосы прокрутки. |
| gx_scroll_button_color | Идентификатор цвета, используемый для заполнения кнопки бегунка полосы прокрутки. |

Помимо этих параметров по умолчанию для шрифтов, цветов и стилей, приложение может указать любой из параметров в индивидуальном порядке с помощью API, предоставляемого каждым типом мини-приложения.

### <a name="skinning-and-themes"></a>Создание обложек и темы

Создавая обложки, можно легко изменять базовый внешний вид мини-приложений и окон GUIX, так как при изменении обложки в одном месте изменится базовый внешний вид всех связанных мини-приложений и окон.

Для повторного создания обложки приложения GUIX необходимо предоставить новые цвет, шрифт и таблицу пиксельных карт для таблиц ресурсов дисплея GUIX. Так как все мини-приложения GUIX ссылаются на цвет, растровое изображение или шрифт с помощью идентификатора ресурсов, при предоставлении новой таблицы ресурсов все мини-приложения GUIX автоматически используют новые цвета и пиксельные карты, когда выполняется их рисование на соответствующем дисплее.

Новый набор шрифтов, цветов и пиксельных карт, предназначенных для создания привлекательного внешнего вида, называется *темой*. Тема определяет набор таблиц ресурсов и размер каждой таблицы ресурсов. С помощью приложения GUIX Studio для любого дисплея можно определить любое количество тем. Необходимо передать начальный индекс темы в функцию ***gx_studio_display_configure***, которая создается в GUIX Studio и устанавливает исходную тему для созданного дисплея. Активную тему для любого дисплея можно изменить в любое время, вызвав функцию ***gx_display_theme_install***.

### <a name="root-window"></a>Корневое окно

Для каждого созданного приложением видимого холста приложение должно также создать одно корневое окно для соответствующего холста. Это специальное окно по сути выступает в качестве контейнера для всех окон и мини-приложений верхнего уровня приложения. С помощью корневого окна выполняется рисование фона холста. Так как корневое окно является производным элементом от класса **GX_WINDOW**, корневое окно может также иметь фоновый рисунок. Чтобы изменить цвет фона для дисплея или холста, нужно просто изменить цвет заливки корневого окна, подключенного к этому холсту.

Если для настройки дисплеев используется созданная в GUIX Studio функция с именем ***gx_studio_display_configure***, то холст и корневое окно для каждого дисплея создаются как часть этой функции инициализации.

### <a name="anti-aliasing"></a>Сглаживание 

Сглаживание — это дополнительная функция в GUIX, которая используется для сглаживания линий, кривых и шрифтов. Сглаживание поддерживается только при использовании драйвера дисплея с глубиной цвета 16 бит/пкс или выше.

Рисование линий со сглаживанием можно включить путем установки вспышки **GX_BRUSH_ALIAS** для активной кисти. Эту функцию можно применить к обычным нарисованным линиям, а также к линиям, нарисованным в качестве границы многоугольника или круга.

Рисование текста со сглаживанием можно включить с помощью соответствующего инструмента шрифта со сглаживанием, который создается приложением GUIX Studio. При создании шрифта необходимо указать, должен ли шрифт создаваться как сглаженный или двоичный.
В GUIX для шрифтов со сглаживанием используется 16 уровней прозрачности для каждого пикселя.

### <a name="clipping"></a>Усечение 

Возможность обрезки поддерживается на внутреннем уровне компонентом дисплея GUIX, а также на уровнях окон и мини-приложений с помощью архитектуры "родительский элемент — дочерний элемент", которая поддерживается мини-приложениями GUIX. Ни в окне, ни в мини-приложении не разрешено рисовать за пределами соответствующей области мини-приложения. Кроме того, в мини-приложении не разрешено рисовать за пределами области соответствующего родительского элемента мини-приложения.

При этом мини-приложения также не могут выполнять рисование, используя пиксельные координаты, которые расположены за пределами памяти холста, так как может возникнуть повреждение памяти или сбой системы. Мини-приложения не могут выполнять операцию рисования за пределами области мини-приложения, родительской области мини-приложения или за пределами экстента холста.

Кроме того, мини-приложения могут выполнять операцию рисования только в тех областях, которые ранее были помечены как "грязные". Таким образом предотвращается рисование во всем окне, например, когда отображен только угол окна. Только часть окна, которую действительно требуется обновить, помечается как "грязная". Поэтому функция рисования в окне обновляет пиксели только в "грязной" области.

Компонент дисплея GUIX применяет соответствующие алгоритмы обрезки перед вызовом функций рисования на уровне драйвера.

### <a name="views"></a>Представления 

В GUIX всегда хранится набор представлений для каждого корневого окна и каждого дочернего окна корневого окна. Представления — это динамическая, определяемая во время выполнения область обрезки, которая изменяется при изменении расположения окна и Z-порядка.
GUIX использует представления, чтобы предотвратить рисование в фоновых окне или мини-приложении поверх окна или мини-приложения на переднем плане. Представления применяют дисциплину Z-порядка. Кроме того, представления важны для повышения эффективности, так как они предотвращают рисование в фоновом окне в области холста, которая не отображается. Если окно полностью перекрыто другим окном, перекрытому окну не разрешается выполнять рисование на холсте, даже если оно пытается это сделать.

### <a name="display-driver-interface"></a>Интерфейс драйвера дисплея 

Драйверы дисплея GUIX позволяют выполнять все операции взаимодействия с базовым физическим экраном. Драйверы дисплея имеют три основные функции: инициализация, рисование и отображение буфера кадров.
Инициализация используется для подготовки оборудования физического дисплея и передает в GUIX свойства оборудования физического дисплея, а также сообщает в GUIX, какие конкретные функции рисования следует использовать. Инициализация основного драйвера дисплея вызывается из функции GUIX ***gx_display_create***. Кроме того, поток GUIX также вызывает инициализацию дополнительного драйвера дисплея из контекста потока. Этот дополнительный драйвер дисплея необходим только в том случае, если драйверу требуются службы ОСРВ во время инициализации (например, устройство прерывает работу или ***tx_thread_sleep*** запрашивает задержку между шагами в процессе инициализации).

После завершения инициализации драйвер дисплея выполняет рисование, которое допускается в физическом оборудовании дисплея.
Наконец, драйвер дисплея отображает буфер кадров.

## <a name="guix-widget-component"></a>Компонент мини-приложения GUIX

Мини-приложение GUIX — это видимый графический элемент. Используются компоненты GUIX, которые не являются видимыми, такие как таймеры и математические служебные функции.
Но все видимые компоненты являются производными от базового компонента мини-приложения GUIX. Мини-приложение GUIX — это основной стандартный блок дисплея GUIX. Все остальные графические элементы являются производными от базовой функции мини-приложения.

Мини-приложения GUIX реализуются объектно-ориентированным методом с полной поддержкой наследования. Это достигается с помощью ANSI C и позволяет максимально снизить требования к памяти и обработке. Если одно конкретное мини-приложение, например **GX_BUTTON**, является *производным от* другого мини-приложения, такого как базовое **GX_WIDGET**, это означает, что структура управления **GX_BUTTON** содержит все переменные-члены и указатели функций **GX_WIDGET**, а также некоторые дополнительные переменные, характерные для **GX_BUTTON**. GUIX создает слои мини-приложений таким образом, чтобы более сложные мини-приложения всегда основывались на более простом мини-приложении перед ними. Эта иерархическая модель выведения производных элементов упрощает использование API для изменения параметров мини-приложения. Если необходимо изменить цвет кнопки, используйте тот же API, который используется для изменения цвета мини-приложения, а именно ***gx_widget_fill_color_set***.

Организация видимых мини-приложений обеспечивается с помощью структуры "родительский элемент — дочерний элемент" при использовании списков с древовидной структурой, связывающих дочерние мини-приложения с их родительскими элементами. Дочерние элементы наследуют характеристики родительских элементов, таких как представления и холст, с помощью которых выполняется рисование.
Дочерние мини-приложения могут иметь собственные дочерние мини-приложения и наследовать различные характеристики родительского элемента. Характеристики любого мини-приложения можно переопределить с помощью различных вызовов API GUIX.

### <a name="widget-creation"></a>Создание мини-приложения 

Объект мини-приложения можно создать во время инициализации или в любое время при выполнении потоков приложения. Количество объектов мини-приложения, которые можно создать с помощью приложения, не ограничено. Кроме того, нет ограничений на количество дочерних элементов для мини-приложения с учетом ограничений памяти вашего целевого оборудования.

У каждого типа мини-приложения есть собственная функция операции создания, например ***gx_button_create** _ или _*_gx_prompt_create_**. Первые три параметра этих функций всегда одинаковы — указатель на структуру управления мини-приложением, строковый указатель на имя мини-приложения и указатель на его родительский элемент. Каждая функция создания может иметь любое количество дополнительных параметров в зависимости от требований конкретного типа мини-приложения.

### <a name="widget-control-block"></a>Блок управления мини-приложением 

Характеристики каждого объекта мини-приложения расположены в блоке управления ***GX_WIDGET** _ и определены в **_gx_api.h_**. Память, необходимая для объекта мини-приложения, предоставляется приложением и может находиться в любом месте в основной памяти. Однако чаще всего блок управления объектом мини-приложения становится глобальной структурой путем его определения вне области какой-либо функции. Если используется GUIX Studio, блоки управления мини-приложением можно выделить статически в файле спецификаций GUIX Studio. Кроме того, их можно выделить динамически с помощью приложения.

### <a name="dynamic-widget-control-block-allocation-and-de-allocation"></a>Динамическое выделение блока управления мини-приложением и отмена выделения 

Если используется динамическое выделение блока управления, необходимо определить две функции, которые GUIX может использовать для выделения и освобождения памяти, необходимой для блоков управления мини-приложениями. Функции управления памятью передаются в системный компонент GUIX с помощью функции API ***gx_system_memory_allocator_set***. Эта функция позволяет передавать два указателя функций в GUIX: первый — указатель на функцию выделения памяти, а второй — указатель на функцию освобождения памяти. Чаще всего эти функции реализуются с помощью пулов байтов ThreadX, но структура GUIX позволяет реализовать динамическое управление памятью любым предпочтительным способом.

Динамическое выделение мини-приложений чаще всего используется в файле спецификаций приложения Studio при выборе параметра Dynamically allocated (Динамически выделенное) в поле свойств мини-приложения Studio. Однако в приложении можно также использовать динамическое выделение блоков управления. Если в приложении используется динамическое выделение блока управления, следует вызвать функцию API ***gx_widget_allocate** _, чтобы выделить блок управления мини-приложением. Затем при создании мини-приложения убедитесь, что вы передали флаг стиля _ *GX_WIDGET_STYLE_DYNAMICALLY_ALLOCATED** (вместе с любыми другими необходимыми флагами стиля) для функции создания мини-приложения. Этот флаг используется для пометки мини-приложения в поле состояния как динамически выделенного. Если мини-приложение удалено с помощью **_gx_widget_delete_**, GUIX проверяет это поле состояния и автоматически вызывает функцию отмены выделения памяти, чтобы убедиться в отсутствии утечек памяти.

> [!IMPORTANT]
> Мини-приложение, созданное с помощью динамически выделенного блока управления, должно быть создано с использованием флага стиля **GX_WIDGET_STYLE_DYNAMICALLY_ALLOCATED** для предотвращения потери памяти.

### <a name="types"></a>Типы

GUIX предоставляет расширенный полнофункциональный набор встроенных мини-приложений. Как упоминалось ранее, все специализированные мини-приложения являются производными от базового мини-приложения. Ниже приведен список встроенных мини-приложений в GUIX.

**GX_TYPE_WIDGET**

**GX_TYPE_BUTTON**

**GX_TYPE_TEXT_BUTTON**

**GX_TYPE_MULTI_LINE_TEXT_BUTTON**

**GX_TYPE_RADIO_BUTTON**

**GX_TYPE_CHECKBOX**

**GX_TYPE_PIXELMAP_BUTTON**

**GX_TYPE_ICON_BUTTON**

**GX_TYPE_ICON**

**GX_TYPE_SPRITE**

**GX_TYPE_SLIDER**

**GX_TYPE_PIXELMAP_SLIDER**

**GX_TYPE_VERTICAL_SCROLL**

**GX_TYPE_HORIZONTAL_SCROLL**

**GX_TYPE_PROGRESS_BAR**

**GX_TYPE_PROMPT**

**GX_TYPE_NUMERIC_PROMPT**

**GX_TYPE_PIXELMAP_PROMPT**

**GX_TYPE_NUMERIC_PIXELMAP_PROMPT**

**GX_TYPE_SINGLE_LINE_TEXT_INPUT**

**GX_TYPE_MULTI_LINE_TEXT_VIEW**

**GX_TYPE_MULTI_LINE_TEXT_INPUT**

**GX_TYPE_WINDOW**

**GX_TYPE_ROOT_WINDOW**

**GX_TYPE_VERTICAL_LIST**

**GX_TYPE_HORIZONTAL_LIST**

**GX_TYPE_POPUP_LIST**

**GX_TYPE_DROP_LIST**

**GX_TYPE_LINE_CHART**

**GX_TYPE_DIALOG**

**GX_TYPE_KEYBOARD**

**GX_TYPE_SCROLL_WHEEL**

**GX_TYPE_TEXT_SCROLL_WHEEL**

**GX_TYPE_STRING_SCROLL_WHEEL**

**GX_TYPE_NUMERIC_SCROLL_WHEEL**

**GX_TYPE_CIRCULAR_GAUGE**

**GX_TYPE_RADIAL_PROGRESS_BAR**

**GX_TYPE_RADIAL_SLIDER**

**GX_TYPE_MENU_LIST**

**GX_TYPE_MENU**

**GX_TYPE_ACCORDION_MENU**

**GX_TYPE_TREE_VIEW**


### <a name="styles"></a>Стили

Стили мини-приложений состоят из таких элементов, как свойства границ (выпуклые, углубленные, тонкие, толстые или без границ), а также свойств для конкретных типов мини-приложений, как показано выше. Флаги стиля мини-приложения являются простейшим способом изменения внешнего вида любого мини-приложения.
Исходный стиль мини-приложения всегда является параметром, передаваемым в конкретную функцию создания типа мини-приложения.

### <a name="colors"></a>Цвета 

Рисование мини-приложений выполняется с помощью цветов, определенных в таблице цветов системы.
Идентификаторы цвета определяются для фона холста, цвета заливки мини-приложения по умолчанию, цвета заливки кнопок, цвета заливки мини-приложения текста, цвета заливки окон и нескольких других значений цвета по умолчанию. Кроме того, объекты **GX_WINDOW** поддерживают отображение растрового изображения или фонового рисунка при заполнении клиента окна.

Самый простой способ изменить цветовую схему по умолчанию — использовать GUIX Studio для создания или определения цветовой схемы, соответствующей вашим требованиям.
Кроме того, можно определить цветовую схему вручную, создав массив значений GX_COLOR и вызвав функцию API gx_system_color_table_set.

### <a name="event-notification"></a>Уведомление о событии 

События GUIX — это запросы к одному или нескольким мини-приложениям для выполнения определенных действий и создания уведомлений для мини-приложений о вводе данных пользователем и внутренних изменениях состояния системы. Например, когда мини-приложение выполняет фокусирование, **GX_EVENT_FOCUS_GAINED** отправляется в мини-приложение с помощью службы API ***gx_system_event_send***.

События передаются через очередь событий GUIX, где каждое событие является экземпляром структуры данных **GX_EVENT**. Структура данных **GX_EVENT** определена в ***gx_api.h***, однако наиболее важными полями структуры являются **gx_event_type**, **gx_event_sender**, **gx_event_target** и **gx_event_payload**.

Поле **gx_event_type** используется для идентификации конкретного класса событий. Тип события указывает, является ли элемент, например, событием **GX_EVENT_PEN_DOWN** или событием **GX_EVENT_TIMER**. **gx_event_payload** является объединением различных полей данных. Они не являются допустимыми для каждого типа событий.
Сначала используется поле типа события. Затем проверяются другие поля данных событий.

Поле **gx_event_sender** содержит идентификатор мини-приложения, создавшего событие, если событие является уведомлением для дочернего мини-приложения.

Поле **gx_event_target** можно использовать для отправки определяемых пользователем событий в определенное окно или мини-приложение. Если необходимо отправить событие в определенное окно, следует присвоить окну уникальное значение идентификатора (чтобы его можно было однозначно идентифицировать) и при создании события задать значение идентификатора окна в поле **gx_event_target**. Если идентификатор целевого объекта неизвестен или необходимо, чтобы событие было отправлено в мини-приложение, имеющее фокус ввода, обязательно задайте для поля **gx_event_target** значение 0.

Наконец, поле **gx_event_payload** является объединением различных типов данных. Для событий **GX_EVENT_PEN_DOWN** и **GX_EVENT_PEN_UP** поле **gx_event_pointdata** содержит пиксельные координаты x, y для позиции пера. Для событий таймера поле **gx_event_timer_id** содержит идентификатор таймера с истекшим значением. Остальные поля полезных данных используются для других типов событий. Полный список предварительно определенных типов событий и их полей полезных данных см. в [приложении E с описанием событий GUIX](appendix-e.md).

Приложение может также добавлять собственные пользовательские события, начиная с числа после константы **GX_FIRST_APP_EVENT**. Все номера событий после этой константы зарезервированы для использования приложением. Разумеется, обработчик событий мини-приложений приложения должен выполнить соответствующую обработку для этих событий приложения.

### <a name="event-processing"></a>Обработка событий 

Для каждого мини-приложения используется функция обработки событий мини-приложения по умолчанию с именем ***gx_<widget-type>_event_process***. В большинстве случаев приложению не нужно проверять обработку событий мини-приложений. Однако в ситуациях, когда для приложения требуется пользовательская или дополнительная обработка событий, приложение может переопределить функцию обработки данных по умолчанию с помощью API GUIX ***gx_widget_event_process_set***. Эта функция переопределяет функцию обработки событий по умолчанию функцией обработки событий, указанной в API.

> [!IMPORTANT]
> Функции обработки событий приложения могут использовать обработку по умолчанию (т. е. не дублировать обработку), просто вызвав обработку по умолчанию ***gx_widget_event_process*** напрямую.

Обработка событий вызывается исключительно из контекста внутреннего системного потока GUIX. Таким образом, требования стека обрабатывать события применяются только к потоку GUIX.

### <a name="implementing-custom-event-processing-example"></a>Реализация обработки пользовательских событий (пример) 

Вы можете предоставить собственную функцию обработки событий для любого мини-приложения или окна в системе GUIX. При создании собственного пользовательского типа мини-приложения обычно в функции создания мини-приложений устанавливается обработчик настраиваемых событий. Если необходимо просто расширить или изменить работу существующего мини-приложения или окна, можно вызвать функцию API gx_widget_event_process_set после создания мини-приложения или окна. Для окон верхнего уровня (также называемых экранами) вы почти всегда будете выполнять собственную обработку событий, чтобы обработать события, созданные с помощью дочерних элементов управления. Обработка события, созданного с помощью дочерних элементов управления экраном, является основным способом добавления функциональных возможностей в приложение GUIX.

Например, предположим, что вы определили экран верхнего уровня с именем main_menu.
Этот экран может быть определен с помощью GUIX Studio или создан в коде приложения. Если вы определили экран в GUIX Studio, просто введите имя обработчика событий в поле свойств Studio для этого экрана, и код спецификации Studio автоматически установит обработчик событий. В этом случае вызывается обработчик настраиваемых событий ***main_menu_event_handler***. При этом необходимо использовать следующий код:

```C
int main_menu_item; /* example: variable to keep track of selected item */

UINT main_menu_event_handler(GX_WINDOW *main_screen, GX_EVENT *event_ptr)
{
    UINT status = GX_SUCCESS;

    switch(event_ptr->gx_event_type)
    {
    /* this is an example for catching events from a child button */
    case GX_SIGNAL(IDB_CHILD_BUTTON, GX_EVENT_CLICKED):
        /* insert your button handler code here */
        break;

    case GX_EVENT_SHOW:
        /* add functionality to the show event handler */
        /* first, do default processing */
        status = gx_window_event_process(main_screen, event_ptr); /* note 1 */

        /* now add my own processing */
        main_menu_item = 0;
        break;

    default:
        /* pass all other events to base processing function */
        status = gx_window_event_process(main_screen, event_ptr); /* note 1 */
        break;
    }
    return status;
}
```

В рамках приведенного выше примера важно отметить, что для системных событий, таких как **GX_EVENT_SHOW** (события, созданные внутренним образом для уведомления мини-приложения об изменении состояния), приложение должно передать эти события в базовую функцию обработки событий мини-приложения, чтобы обеспечить соответствующую обработку данных. Приложение может при необходимости добавить дополнительную логику. Все события, которые не обрабатываются приложением (вариант по умолчанию выше), также должны передаваться в базовую функцию обработки событий. Так как этот пример предназначен для экрана верхнего уровня на основе **GX_WINDOW**, функция обработки событий по умолчанию — gx_window_event_process.

### <a name="drawing-function"></a>Функция рисования 

Все операции рисования в мини-приложении выполняются отдельно от обработки событий. Это более эффективно, так как операция рисования обычно является ресурсоемкой в отношении циклов ЦП. При реализации алгоритма отложенного рисования все необработанные события и связанные изменения дисплея можно завершить до выполнения рисования. Это позволяет предотвратить рисование впустую. Аналогично обработке событий для большинства мини-приложений используется функция рисования мини-приложения по умолчанию с именем ***gx_<widget-type>_draw***, где xxx — это тип мини-приложения. В большинстве случаев приложению не нужно контролировать выполнение функции рисования для любого мини-приложения. Однако в ситуациях, когда приложение должно выполнить пользовательскую или дополнительную операцию рисования, оно может переопределить функцию рисования по умолчанию с помощью соответствующего API GUIX ***gx_widget_draw_set***. Эта функция позволяет приложению предоставить собственную пользовательскую функцию рисования для любого мини-приложения. Это также позволяет приложению определять полностью новые типы мини-приложений.

> [!IMPORTANT]
> Функции рисования приложений могут выполнять операцию рисования по умолчанию (т. е. не дублировать код), просто вызвав ее непосредственно в переопределенной функции рисования.

Рисование для мини-приложений вызывается исключительно из контекста внутреннего системного потока GUIX. Таким образом, требования параметра времени и стека относительно выполнения рисования применяются только к потоку GUIX.

### <a name="implementing-custom-drawing-example"></a>Реализация пользовательского рисования (пример) 

Ссылка на функцию рисования для любого мини-приложения выполняется с помощью косвенного указателя на функцию, который является элементом блока управления GX_WIDGET. Если для определения мини-приложения используется GUIX Studio, можно установить собственный указатель на функцию, введя имя функции в параметре Drawing Function (Функция рисования) для свойств мини-приложения. При создании мини-приложения в Studio будет установлен указатель на функцию. Если вы создаете мини-приложение в коде приложения, необходимо использовать функцию API ***gx_widget_draw_set***, чтобы установить пользовательскую функцию рисования после создания мини-приложения.

В рамках этого примера предполагается, что необходимо настроить внешний вид кнопки. Кнопка похожа на кнопку **GX_TEXT_BUTTON**, но при ее нажатии в средней правой части кнопки добавляется маленькое зеленое растровое изображение LED_ON, а если кнопка не нажата — маленькое растровое изображение LED_OFF. Необходимо создать кнопку, которая выглядит как на иллюстрациях ниже.

![Снимок экрана с зеленой кнопкой в режиме "Вкл."](./media/guix/image4.jpg) Пользовательская кнопка "Вкл."

![Снимок экрана с красной кнопкой в режиме "Выкл."](./media/guix/image5.jpg) Пользовательская кнопка "Выкл."

В этом случае создается функция рисования кнопки, которая выглядит, как показано ниже.

```C
UINT my_button_draw(GX_TEXT_BUTTON *button)
{
    GX_PIXELMAP *map;
    ULONG button_style;
    INT xpos;
    INT ypos;

    /* first, do the normal text button drawing */
    gx_text_button_draw(button);

    /* now add our extra pixelmap */

    gx_widget_style_get(button, &button_style);

    if (button_style & GX_STYLE_BUTTON_PUSHED)
    {
        /* use the ON pixelmap */
        gx_context_pixelmap_get(GX_PIXELMAP_ID_LED_ON, &map);
    }
    else
    {
        /* use the OFF pixelmap */
        gx_context_pixelmap_get(GX_PIXELMAP_ID_LED_OFF, &map);
    }
    if (map)
    {
        /* draw it 20 pixels in from right edge */
        xpos = button->gx_widget_size.gx_rectangle_right;
        xpos -= map->gx_pixelmap_width + 20;

        /* and draw 10 pixels from the top edge */
        ypos = button->gx_widget_size.gx_rectangle_top + 10;

        /* draw the extra pixelmap on top of the button */
        gx_canvas_pixelmap_draw(xpos, ypos, map);
    }
}
```

## <a name="guix-drawing-context-component"></a>Компонент контекста рисования GUIX 

Контекст рисования создается динамически в среде выполнения, так как GUIX выполняет каждую операцию обновления холста. Контекст рисования связывает холст, драйвер экрана и кисть для выполнения текущих операций рисования.

Контекст рисования определяется структурой **GX_DRAW_CONTEXT**.
Эта структура содержит переменные, определяющие обрезку и представление текущей операции рисования, а также текущие используемые холст и драйвер экрана. Структура **GX_DRAW_CONTEXT** также содержит кисть, используемую для рисования. Кисть контекста рисования — это элемент, который используется непосредственно в пользовательских функциях рисования. Структура кисти определяется, как показано в приведенном ниже коде.

```C
typedef struct GX_BRUSH_STRUCT
{
    GX_PIXELMAP *gx_brush_pixelmap;
    GX_FONT     *gx_brush_font;
    ULONG        gx_brush_line_pattern;
    ULONG        gx_brush_pattern_mask;
    GX_COLOR     gx_brush_fill_color;  
    GX_COLOR     gx_brush_line_color;  
    UINT         gx_brush_style;
    GX_VALUE     gx_brush_width;
    UCHAR        gx_brush_alpha;  
} GX_BRUSH;
```

Поле **gx_brush_pixelmap** определяет пиксельную карту, используемую для заливки прямоугольника и многоугольника. Этот элемент используется, только если **gx_brush_style** содержит стиль **GX_BRUSH_PIXELMAP**.

Элемент **gx_brush_font** определяет шрифт для рисования текста.
Элемент **gx_brush_line_pattern** определяет шаблон для пунктирных линий.
Элемент **gx_brush_style** — это набор флагов стиля, которые можно совместно использовать для полного определения атрибутов кисти. Доступные флаги стиля кисти включают в себя указанные ниже элементы.

**GX_BRUSH_OUTLINE**  
**GX_BRUSH_SOLID_FILL**  
**GX_BRUSH_PIXELMAP_FILL**  
**GX_BRUSH_ALIAS**  
**GX_BRUSH_UNDERLINE**  
**GX_BRUSH_ROUND**

Элемент **gx_brush_width** определяет линию для операции рисования линий, а также ширину контура для операции рисования контура фигуры.

Элемент **gx_brush_line_color** определяет цвет переднего плана для рисования линий и для рисования текста.

Элемент **gx_brush_fill_color** определяет цвет сплошной заливки фигур. Компонент контекста GUIX предоставляет набор API для удобного изменения текущей кисти в активном контексте. К этим API относятся **gx_context_brush_define**, **gx_context_line_color_set**, **gx_context_fill_color_set**, **gx_context_font_set** и многие другие.

Контекст рисования родительского объекта наследуется дочерними объектами. Фактически при вызове функций рисования дочерние объекты наследуют клон родительского контекста рисования. Дочерний элемент может изменять контекст, не влияя на рисование для родительского элемента, но при необходимости он может также наследовать сведения от родительского элемента, например цвет и стиль кисти.

## <a name="guix-window-component"></a>Компонент окна GUIX 

Компонент окна позволяет выполнять всю обработку окон в GUIX. Окно GUIX представляет собой отдельную область дисплея, которая может содержать одно или несколько дочерних мини-приложений. В GUIX окно представляет собой лишь особую форму основного объекта мини-приложения.

Окна GUIX реализуются объектно-ориентированным методом с полной поддержкой наследования. Это достигается с помощью ANSI C и позволяет максимально снизить требования к памяти и обработке.

Окна GUIX позволяют расширить функциональные возможности мини-приложения GUIX преимущественно благодаря добавлению поддержки горизонтальной и вертикальной прокрутки. Объекты окна GUIX могут автоматически создавать и отображать полосы прокрутки и реагировать на входные данные полосы прокрутки. В перемещаемых окнах также встроена обработка событий, позволяющая перемещать или перетаскивать окно на основе событий ввода с помощью пера.
Наконец, окно GUIX реагирует на получение фокуса ввода, перемещая окно в переднюю часть Z-порядка окна.

Окно GUIX поддерживает концепцию *клиентской области*, которая является внутренней частью окна после удаления границ окна и неклиентских объектов, таких как полосы прокрутки, из доступной области. Дочерние мини-приложения клиентской области обрезаются по размеру клиентской области окна, а неклиентские дочерние элементы, такие как полосы прокрутки, могут рисовать за пределами клиентской области, но обрезаются по размеру внешнего окна.

Окна поддерживаются в виде структуры "родительский элемент — дочерний элемент", где дочерние элементы наследуют характеристики родительского элемента. У дочерних окон могут быть собственные дочерние окна, которые наследуют различные характеристики родительского элемента. Характеристики любого окна можно переопределить с помощью различных вызовов API GUIX.

### <a name="window-creation"></a>Создание окна 

Объект окна можно создать во время инициализации или в любое время при выполнении потоков приложения. Количество объектов окна, которые можно создать с помощью приложения, не ограничено. Кроме того, нет ограничений на количество дочерних элементов для какого-либо окна.

### <a name="window-control-block"></a>Блок управления окном 

Характеристики каждого объекта окна расположены в блоке управления **GX_WINDOW** и определены в **_gx_api.h_**. Память, необходимая для объекта окна, предоставляется приложением и может находиться в любом месте в основной памяти. Однако чаще всего блок управления объектом окна становится глобальной структурой путем его определения вне области какой-либо функции.

### <a name="root-window"></a>Корневое окно 

В GUIX для каждого холста необходимо корневое окно. Корневое окно не имеет границ и имеет те же размеры, что и холст, к которому оно подключено. Оно используется преимущественно в качестве контейнера для всех мини-приложений и окон первого уровня. Корневое окно обычно создается приложением с помощью функции API ***gx_window_root_create*** сразу после создания экрана и холста. Если используется функция gx_studio_display_configure, созданная с помощью Studio, адрес корневого окна может быть возвращен в соответствующее расположение в качестве последнего параметра этой функции.

По умолчанию корневое окно не может быть перемещено, и в самом простом случае корневое окно имеет размер холста. Корневое окно создает фон дисплея, поэтому для изменения цвета фона дисплея или для отображения фонового рисунка необходимо назначить корневому окну цвет или фоновый рисунок.

Если корневое окно является перемещаемым, оно перемещается не путем изменения его положения на холсте подобно дочернему окну, а путем перемещения самого холста.
Эта возможность позволяет корневому окну GUIX использовать оборудование, которое поддерживает несколько буферов кадров с аппаратными регистрами смещения.

### <a name="background"></a>Фон 

Для фона окна используются либо сплошные цвета, либо растровые изображения. На системном уровне используется фон окна по умолчанию, который предоставляет значение по умолчанию для начального набора окон. Разумеется, любое фоновое окно можно изменить с помощью API GUIX.

Чтобы изменить сплошной цвет фона окна, используйте API ***gx_widget_fill_color_set***. Чтобы назначить фоновый рисунок для окна, используйте API ***gx_window_wallpaper_set***.

### <a name="scrolling"></a>Прокрутка 

GUIX поддерживает стандартную прокрутку окна, когда область для отображения дочерних окон превышает текущий размер окна (горизонтально и (или) вертикально). Чтобы включить прокрутку, приложение должно создать нужные полосы прокрутки и подключить их к окну.

Компонент окна GUIX обеспечивает реализацию прокрутки по умолчанию на основе размера клиентской области окна и экстента всех дочерних мини-приложений. Приложения также могут предоставлять собственную реализацию и интерпретацию прокрутки путем переопределения функции ***gx_window_scroll_info_get*** для конкретного окна.

### <a name="event-notification"></a>Уведомление о событии 

Функция обработки событий окна по умолчанию отличается от обработки событий GX_WIDGET преимущественно способом обработки событий прокрутки и изменения размера. GX_WINDOW предоставляет обработчики по умолчанию для событий прокрутки и изменения размера.

Приложение может также добавлять собственные пользовательские события, начиная с числа после константы **GX_FIRST_APP_EVENT**. Все номера событий после этой константы зарезервированы для использования приложением. Разумеется, обработчик событий окна приложения должен выполнить соответствующую обработку для этих событий приложения.

### <a name="event-processing"></a>Обработка событий 

Подобно всем остальным типам мини-приложений для каждого окна используется функция обработки событий окна по умолчанию с именем ***gx_window_event_process***. Как правило, эта функция обработки событий переопределяется собственным обработчиком событий в создаваемых окнах. Таким способом вы реагируете на события и предпринимаете действия на основе событий, созданных дочерними элементами управления окном.

Важно вызывать базовую функцию ***gx_window_event_process*** для системных событий GUIX при переопределении соответствующего обработчика событий, чтобы разрешить обработку событий по умолчанию в дополнение к любому действию, которое добавляется в обработчик событий. Например, если используется пользовательский обработчик для события **GX_EVENT_SHOW** и это событие не передается в ***gx_window_event_process***, окно никогда не станет видимым.
Чтобы предоставить пользовательский обработчик событий для окна, используйте функцию ***gx_widget_event_process_set*** для определения адреса обработчика событий. Эта функция переопределяет функцию обработки событий по умолчанию функцией обработки событий, указанной в API.

> [!IMPORTANT]
> Функции обработки событий приложения могут использовать обработку по умолчанию (т. е. не дублировать обработку), просто вызвав обработку по умолчанию ***gx_window_event_process*** напрямую.

Обработка событий вызывается исключительно из контекста внутреннего системного потока GUIX. Таким образом, требования стека обрабатывать события применяются только к потоку GUIX.

## <a name="guix-image-reader-component"></a>Компонент читателя изображений GUIX 

Компонент читателя изображений предоставляет служебные программы и функции API для распаковки необработанных сжатых изображений в формате пиксельных карт GUIX. Необработанные данные изображений в формате JPEG и PNG поддерживаются. Дополнительные форматы зарезервированы для будущих выпусков.

Обратите внимание, что для большинства приложений GUIX не требуется компонент читателя изображений GUIX. Большинство приложений используют приложение GUIX Studio для преобразования графических ресурсов в формате JPEG и PNG в GUIX-совместимые ресурсы **GX_PIXELMAP**. Компонент читателя изображений GUIX используется, когда необработанные графические ресурсы известны только в среде выполнения или если ограничения хранилища системы не позволяют хранить ресурсы в формате **GX_PIXELMAP**. Данные изображений в формате JPEG и PNG обычно более компактны, чем в формате **GX_PIXELMAP**, однако при этом возникают значительные нагрузки в среде выполнения, связанные с динамическим выполнением распаковки и преобразования цветового пространства этих типов изображений.

Если изображения в необработанном формате JPEG или PNG передаются в функцию API gx_canvas_pixelmap_draw, GUIX динамически распаковывает данные JPEG или PNG и выполняет соответствующую операцию рисования. Обратите внимание, что это окажет значительное негативное влияние на скорость рисования в среде выполнения. Передача данных изображения в формате RAW в функцию gx_canvas_pixelmap_draw не рекомендуется, если вы не используете аппаратный целевой объект, который поддерживает аппаратную распаковку данных JPEG или PNG.

> [!IMPORTANT]
> Передача необработанных изображений в формате JPEG или PNG в API gx_canvas_pixelmap_draw приводит к значительной нагрузке в среде выполнения для большей части целевого оборудования.

В качестве альтернативы необработанные данные JPEG и PNG можно преобразовать в формат GX_PIXELMAP в среде выполнения с помощью компонента читателя изображений.
Созданные таким образом пиксельные карты можно использовать и рисовать так же, как пиксельные карты, созданные в Studio и содержащиеся в вашем файле ресурсов. Это позволяет вашему приложению выполнять распаковку изображения, сглаживание и преобразование цветового пространства один раз (обычно во время запуска программы) вместо того, чтобы выполнять эти операции каждый раз при создании изображения.

Функции компонента читателя изображений указаны ниже.

***gx_image_reader_create***  
***gx_image_reader_palette_set***  
***gx_image_reader_start***

## <a name="guix-animation-component"></a>Компонент анимации GUIX 

Компонент анимации GUIX — это набор функций и служб, используемых для автоматизации операций экрана и переходов мини-приложений. Компонент анимации GUIX поддерживает эффекты появления, исчезания, перемещения или анимации перемещения для любого типа мини-приложения.

Анимация появления и исчезания изображения может поддерживаться путем изменения внутреннего альфа-фактора соответствующего эффекта мини-приложения (если элемент **GX_BRUSH_ALPHA_SUPPORT** включен) или путем рисования любой коллекции мини-приложений на отдельном холсте памяти и соответствующего смешения с фоном. Для аппаратных целевых объектов, которые поддерживают несколько аппаратных графических слоев, поддержка эффектов плавного появления и исчезания изображения лучше всего достигается с помощью данного подхода смешения холста (часто с использованием невысокой требуемой пропускной способности ЦП). Для аппаратных целевых объектов, которые не поддерживают несколько графических слоев, смешение с использованием альфа-фактора кисти GUIX поддерживается при использовании глубин цвета 16 бит/пкс и выше.

Если для анимации должно использоваться отдельное полотно, компонент анимации GUIX предоставляет службу API gx_animation_canvas_define для этой цели. Для других типов анимации не требуется отдельный холст, но они используют его, если он доступен. Это позволяет максимально эффективно использовать любую базовую поддержку оборудования для нескольких аппаратных поверхностей.

Переменные, управляющие анимацией, определяются с помощью двух блоков управления. Сначала — блоком управления **GX_ANIMATION**, который определяет контроллер анимации. Контроллер анимации — это обработчик, который выполняет определенную последовательность анимации. Один контроллер анимации можно использовать многократно для выполнения различных последовательностей анимации. Если требуется одновременное выполнение нескольких последовательностей анимации, можно создать несколько контроллеров анимации **GX_ANIMATION**.

Системный компонент GUIX может предоставить многократно используемый блок структур управления **GX_ANIMATION**, которые могут запрашиваться приложением, когда требуется анимация, и автоматически возвращаться в системный пул при завершении последовательности анимации. Это освобождает приложение от необходимости статического определения структуры **GX_ANIMATION** для каждой анимации при ее реализации. Размер этого пула структур **GX_ANIMATION** определяется константой **GX_ANIMATION_POOL_SIZE**, у которой значение по умолчанию — 6. Это означает, что по умолчанию из системного пула можно выделить 6 одновременных анимаций. Эта константа может быть переопределена в файле заголовка gx_user.h, если требуется больше одновременных анимаций. Если **GX_ANIMATION_POOL_SIZE** имеет значение 0, то системный компонент GUIX не предоставляет пул анимаций или связанные службы.

Вторым блоком управления или второй структурой, которые используются для определения анимации, является структура **GX_ANIMATION_INFO**. Эта структура используется для определения одной конкретной последовательности анимации. Эта информационная структура передается в контроллер анимации для инициации последовательности анимации с помощью службы API gx_animation_start. Структура **GX_ANIMATION_INFO** содержит следующие поля:

```C
typedef struct GX_ANIMATION_INFO_STRUCT
{
    GX_WIDGET *gx_animation_target;
    GX_WIDGET *gx_animation_parent;
    GX_WIDGET *gx_animation_screen_list;
    USHORT gx_animation_style;
    USHORT gx_animation_id;
    USHORT gx_animation_start_delay;
    USHORT gx_animation_frame_interval;
    GX_POINT gx_animation_start_position;
    GX_POINT gx_animation_end_position;
    GX_UBYTE gx_animation_start_alpha;
    GX_UBYTE gx_animation_end_alpha;
    GX_UBYTE gx_animation_steps;
} GX_ANIMATION_INFO;
```

Элемент **gx_animation_target** определяет целевое мини-приложение, на основе которого будет работать контроллер анимации.

Элемент **gx_animation_parent** определяет родительское мини-приложение, если таковое имеется, к которому будет подключено целевое мини-приложение после завершения последовательности анимации. Элемент gx_animation_parent является также получателем события GX_ANIMATION_COMPLETE, которое создается при завершении анимации.

Элемент **gx_animation_screen_list** определяет список мини-приложений для анимаций перетаскивания экрана при вводе с помощью пера. Список мини-приложений должен заканчиваться указателем GX_NULL, а каждое мини-приложение в списке должно иметь те же измерения x, y, что и элемент gx_animation_parent.

**gx_animation_style** — это битовая маска, определяющая тип выполняемой анимации и связанные с ней параметры. К флагам стиля анимации относятся указанные ниже элементы.

| Флаг &nbsp;стиля&nbsp; анимации | Описание |
| --- | --- |
| GX_ANIMATION_TRANSLATE | Запрос анимации перетаскивания или типа эффекта исчезания или появления изображения. |
| GX_ANIMATION_SCREEN_DRAG | Запрос анимации перетаскивания экрана при вводе с помощью пера. |

Указанные ниже флаги можно использовать в сочетании с анимацией типа **SCREEN_DRAG**.

| Флаги&nbsp;перетаскивания&nbsp;экрана | Описание |
| --- | --- |
| GX_ANIMATION_WRAP | Перенос списка экранов должен выполняться от конечного элемента обратно к начальному элементу. |
| GX_ANIMATION_HORIZONTAL | Перетаскивание экрана разрешено в горизонтальном направлении.  |
| GX_ANIMATION_VERTICAL | Перетаскивание экрана разрешено в вертикальном направлении. |

Указанный ниже флаг можно использовать в сочетании с анимациями преобразования.

| Флаги&nbsp;анимаций&nbsp;преобразования | Описание |
| --- | --- |
| GX_ANIMATION_DETACH | Удалите целевой объект анимации из родительского элемента анимации по завершении анимации. Если целевой объект динамически выделен и создан с помощью автоматизированной обработки событий на основе GUIX Studio, он удаляется после его отключения. |
| GX_ANIMATION_TRANSLATE | Типы анимации — это анимации, управляемые таймером. Приложение определяет начальное и конечное положение, а также начальный и конечный альфа-фактор для целевого мини-приложения, а диспетчер анимации создает таймер для выполнения анимации.
| GX_ANIMATION_SCREEN_DRAG | Отличается от анимаций **TRANSLATE** тем, что этот тип анимации инициируется событиями ввода с помощью пера. Этот тип анимации отслеживает при вводе с помощью сенсорного экрана прокрутку целевого мини-приложения, когда пользователь перетаскивает перо на сенсорном экране ввода. Чтобы использовать этот тип анимации, приложение должно вызвать API **_gx_animation_drag_enable_** и включить эту анимацию. |

Значение **gx_animation_id** передается обратно родительскому элементу анимации в поле event.gx_event_sender события **GX_ANIMATION_COMPLETE**. Это значение используется родительским элементом анимации для определения того, какая из возможных нескольких дочерних анимаций сообщает о завершении операции. Это значение может быть равно 0, а анимация со значением идентификатора 0 не может создать событие **ANIMATION_COMPLETE**.

Значение **gx_animation_start_delay** — это счетчик тактов GUIX, указывающий количество тактов таймера для задержки после вызова **_gx_animation_start_ *_ перед фактическим выполнением анимации. Значение может быть равно 0 для запуска анимации сразу после вызова _* _gx_animation_start_**.

Поле **gx_animation_frame_interval** определяет количество тактов таймера GUIX (кратное частоте тактов ОС) для задержки между кадрами последовательности анимации. Минимальное значение: 1.

Элемент **gx_animation_start_position** определяет начальную верхнюю левую точку для целевого мини-приложения для анимаций преобразования.

Элемент **gx_animation_end_position** определяет конечную верхнюю левую точку для целевого мини-приложения для анимаций типа преобразования.

Поле **gx_animation_start_alpha** определяет начальное значение альфа-фактора холста для анимаций типа преобразования.

Поле **gx_animation_end_alpha** определяет конечное значение альфа-фактора холста для анимаций типа преобразования.

Поле **gx_animation_steps** определяет количество шагов или кадров, которые контроллер должен выполнить для анимаций преобразования. Чем больше шагов, тем более гладко выполняется перетаскивание и (или) появление (исчезание) изображения, но для этого также требуется большая пропускная способность системы.

Чтобы реализовать эффекты анимации в приложении, необходимо сначала вызвать ***gx_animation_create*** для инициализации контроллера анимации. Если для анимации используется вторичный холст, инициализируйте данный холст, вызвав gx_animation_canvas_define. Далее следует инициализировать структуру **GX_ANIMATION_INFO**, чтобы определить конкретный тип выполняемой анимации и другие параметры анимации. Наконец, вызовите gx_animation_start, чтобы запустить последовательность анимации.

Когда контроллер анимации завершает последовательность анимации, он отправляет событие **GX_ANIMATION_COMPLETE** родительскому мини-приложению для выполнения всех необходимых операций очистки холста анимации.

## <a name="guix-utility-component"></a>Компонент служебной программы GUIX 

Компонент служебной программы выполняет все общие служебные функции в GUIX. Это распространенные функции, которые являются полезными служебными программами. Их можно вызвать из любого расположения в приложении или во внутреннем коде GUIX. Служебные функции компонентов указаны ниже.

***gx_utility_canvas_to_bmp***

***gx_utility_circle_point_get***

***gx_utility_alphamap_create***

***gx_utility_gradient_create***

***gx_utility_gradient_delete***

***gx_utlity_ltoa***

***gx_utility_math_acos***

***gx_utility_math_asin***

***gx_utility_math_cos***

***gx_utility_math_sin***

***gx_utility_math_sqrt***

***gx_utility_pixelmap_resize***

***gx_utility_pixelmap_rotate***

***gx_utility_pixelmap_simple_rotate***

***gx_utility_rectangle_center***

***gx_utility_rectangle_center_find***

***gx_utility_rectangle_combine***

***gx_utility_rectangle_compare***

***gx_utility_rectangle_define***

***gx_utility_rectangle_overlap_detect***

***gx_utility_rectangle_point_detect***

***gx_utility_rectangle_resize***

***gx_utility_rectangle_shift***

***gx_utility_string_to_alphamap***
