---
title: Приложение Е. Службы привязки GUIX для ОСРВ
description: Сведения о службах привязки GUIX для ОСРВ.
author: philmea
ms.author: philmea
ms.date: 05/19/2020
ms.topic: article
ms.service: rtos
ms.openlocfilehash: 1d94dbb9d7d53ec3e1900188142974cc981dfea9
ms.sourcegitcommit: e3d42e1f2920ec9cb002634b542bc20754f9544e
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/22/2021
ms.locfileid: "104815567"
---
# <a name="appendix-f---guix-rtos-binding-services"></a><span data-ttu-id="85d33-103">Приложение Е. Службы привязки GUIX для ОСРВ</span><span class="sxs-lookup"><span data-stu-id="85d33-103">Appendix F - GUIX RTOS Binding Services</span></span>

<span data-ttu-id="85d33-104">Для функционирования GUIX требуются службы потоков или задач, мьютекс, очередь событий и службы времени, предоставляемые базовой системой ОСРВ.</span><span class="sxs-lookup"><span data-stu-id="85d33-104">GUIX requires thread or tasking services, mutex, event queue, and timing services providing by the underlying RTOS.</span></span> <span data-ttu-id="85d33-105">Для предоставления этих служб GUIX по умолчанию настроен для использования операционной системы реального времени ThreadX.</span><span class="sxs-lookup"><span data-stu-id="85d33-105">By default GUIX is configured to utilize the ThreadX real time operating system to provide these services.</span></span> <span data-ttu-id="85d33-106">Чтобы перенести GUIX в другую операционную систему, разработчик должен определить директиву препроцессора GX_DISABLE_THREADX_BINDING и перестроить библиотеку GUIX, чтобы удалить зависимости ThreadX.</span><span class="sxs-lookup"><span data-stu-id="85d33-106">To port GUIX to another operating system, the developer should # define the pre-processor directive GX_DISABLE_THREADX_BINDING and rebuild the GUIX library to remove the ThreadX dependencies.</span></span> <span data-ttu-id="85d33-107">Кроме того, разработчик должен предоставить следующие определения макросов и вспомогательные функции.</span><span class="sxs-lookup"><span data-stu-id="85d33-107">In addition, the developer will need to provide the following macro definitions and supporting functions.</span></span> <span data-ttu-id="85d33-108">Примеры этих определений макросов и вспомогательных функций можно найти в файлах gx_system_rtos_bind.h и gx_system_rtos_bind.c, в которых приведен пример универсальной интеграции ОСРВ.</span><span class="sxs-lookup"><span data-stu-id="85d33-108">Examples of these macro definitions and supporting functions can be found in the files gx_system_rtos_bind.h and gx_system_rtos_bind.c, which provide an example generic rtos integration.</span></span>

<span data-ttu-id="85d33-109">Макросы системной интеграции:</span><span class="sxs-lookup"><span data-stu-id="85d33-109">System Integration macros:</span></span>

<span data-ttu-id="85d33-110">**GX_RTOS_BINDING_INITIALIZE**</span><span class="sxs-lookup"><span data-stu-id="85d33-110">**GX_RTOS_BINDING_INITIALIZE**</span></span>

<span data-ttu-id="85d33-111">Этот макрос вызывается во время инициализации системы.</span><span class="sxs-lookup"><span data-stu-id="85d33-111">This macro is invoked during system initialization.</span></span> <span data-ttu-id="85d33-112">Макрос должен быть определен для вызова любой функции, необходимой для подготовки системных служб ОСРВ или ресурсов ОСРВ перед использованием.</span><span class="sxs-lookup"><span data-stu-id="85d33-112">The macro should be defined to call any function needed to prepare your rtos system services or rtos resources prior to use.</span></span> <span data-ttu-id="85d33-113">Это возможность привязки для подготовки ресурсов ОСРВ, которые будут использоваться GUIX.</span><span class="sxs-lookup"><span data-stu-id="85d33-113">This is the binding’s opportunity to prepare the rtos resources that GUIX will use.</span></span>

<span data-ttu-id="85d33-114">**GX_SYSTEM_THREAD_START**</span><span class="sxs-lookup"><span data-stu-id="85d33-114">**GX_SYSTEM_THREAD_START**</span></span>

<span data-ttu-id="85d33-115">Этот макрос вызывается, когда задача или поток GUIX должны начать выполняться.</span><span class="sxs-lookup"><span data-stu-id="85d33-115">This macro is invoked when the GUIX task or thread should start executing.</span></span> <span data-ttu-id="85d33-116">Этот макрос должен быть определен для вызова функции, запускающей поток GUIX.</span><span class="sxs-lookup"><span data-stu-id="85d33-116">This macro should be defined to call a function which will start the GUIX thread running.</span></span> <span data-ttu-id="85d33-117">Точка входа в поток GUIX передается вызываемой функции.</span><span class="sxs-lookup"><span data-stu-id="85d33-117">The entry point to the GUIX thread is passed to the called function.</span></span> <span data-ttu-id="85d33-118">Сигнатура вызываемой функции должна иметь следующий вид:</span><span class="sxs-lookup"><span data-stu-id="85d33-118">The signature of the called function must be</span></span>

<span data-ttu-id="85d33-119">**UINT *function_name*(VOID (thread_entry_point)(VOID));**</span><span class="sxs-lookup"><span data-stu-id="85d33-119">**UINT *function_name*(VOID (thread_entry_point)(VOID));**</span></span>

<span data-ttu-id="85d33-120">Эта функция должна возвращать GX_SUCCESS, если поток успешно запущен; в противном случае должно возвращаться GX_FAILURE.</span><span class="sxs-lookup"><span data-stu-id="85d33-120">This function should return GX_SUCCESS if the thread is successfully started, or GX_FAILURE.</span></span>

<span data-ttu-id="85d33-121">**GX_EVENT_PUSH**</span><span class="sxs-lookup"><span data-stu-id="85d33-121">**GX_EVENT_PUSH**</span></span>

<span data-ttu-id="85d33-122">Этот макрос вызывается для отправки события в очередь событий FIFO, используемую GUIX.</span><span class="sxs-lookup"><span data-stu-id="85d33-122">This macro is invoked to push an event into the FIFO event queue used by GUIX.</span></span> <span data-ttu-id="85d33-123">При переносе в новую систему ОСРВ именно вы несете ответственность за реализацию этой очереди событий потокобезопасным способом.</span><span class="sxs-lookup"><span data-stu-id="85d33-123">When porting to a new rtos, it is your responsibility to implement this event queue in a thread-safe manner.</span></span> <span data-ttu-id="85d33-124">Структуры GX_EVENT должны быть скопированы в эту очередь и скопированы из нее, то есть очередь указателей GX_EVENT не будет работать, так как события GUIX могут быть автоматическими переменными из представления производителя событий.</span><span class="sxs-lookup"><span data-stu-id="85d33-124">GX_EVENT structures must be copied into this queue and copied out of this queue, i.e. a queue of GX_EVENT pointers will not work, since GUIX events can be automatic variables from the view of the event producer.</span></span> <span data-ttu-id="85d33-125">Сигнатура функции, вызываемой этим макросом, должна иметь следующий вид:</span><span class="sxs-lookup"><span data-stu-id="85d33-125">The signature of the function called by this macro must be:</span></span>

<span data-ttu-id="85d33-126">\**UINT *function_name* (GX_EVENT *event_ptr);**</span><span class="sxs-lookup"><span data-stu-id="85d33-126">\**UINT *function_name* (GX_EVENT *event_ptr);**</span></span>

<span data-ttu-id="85d33-127">Эта функция должна возвращать GX_SUCCESS, если событие передается в очередь событий; в противном случае должно возвращаться GX_FAILURE.</span><span class="sxs-lookup"><span data-stu-id="85d33-127">This function should return GX_SUCCESS if the event is pushed into the event queue, otherwise it should return GX_FAILURE.</span></span>

<span data-ttu-id="85d33-128">**GX_EVENT_POP**</span><span class="sxs-lookup"><span data-stu-id="85d33-128">**GX_EVENT_POP**</span></span>

<span data-ttu-id="85d33-129">Этот макрос вызывается для удаления самого старого события из очереди событий GUIX и его копирования в запрошенное расположение.</span><span class="sxs-lookup"><span data-stu-id="85d33-129">This macro is invoked to remove the head (oldest) event from the GUIX event queue and copy it into the requested location.</span></span> <span data-ttu-id="85d33-130">Эта функция должна при необходимости блокировать или ожидать события, если на данный момент в очереди событий нет событий.</span><span class="sxs-lookup"><span data-stu-id="85d33-130">This function must be able to optionally block or wait for an event if no events are currently in the event queue.</span></span> <span data-ttu-id="85d33-131">Сигнатура функции, вызываемой этим макросом, должна иметь следующий вид:</span><span class="sxs-lookup"><span data-stu-id="85d33-131">The signature of the function invoked by this macro must be</span></span>

<span data-ttu-id="85d33-132">UINT function_name(GX_EVENT \*put_event, GX_BOOL wait)</span><span class="sxs-lookup"><span data-stu-id="85d33-132">UINT function_name(GX_EVENT \*put_event, GX_BOOL wait)</span></span>

<span data-ttu-id="85d33-133">Если параметр wait = = GX_TRUE, функция не должна возвращать значение, пока не будет предоставлено событие.</span><span class="sxs-lookup"><span data-stu-id="85d33-133">If the wait parameter == GX_TRUE, the function should not return until an event is provided.</span></span> <span data-ttu-id="85d33-134">Если параметр wait имеет значение GX_FALSE, функция должна возвращаться немедленно с событием или без него.</span><span class="sxs-lookup"><span data-stu-id="85d33-134">If the wait parameter is GX_FALSE, the function should return immediately with or without an event.</span></span>

<span data-ttu-id="85d33-135">Если событие извлекается из очереди, оно должно быть скопировано в расположение put_event, а возвращаемое состояние имеет значение GX_SUCCESS.</span><span class="sxs-lookup"><span data-stu-id="85d33-135">If an event is retrieved from the queue, it should copied into the put_event location and the return status is GX_SUCCESS.</span></span> <span data-ttu-id="85d33-136">В противном случае возвращаемое состояние должно иметь значение GX_FAILURE.</span><span class="sxs-lookup"><span data-stu-id="85d33-136">Otherwise the return status should be GX_FAILURE.</span></span>

<span data-ttu-id="85d33-137">**GX_EVENT_FOLD**</span><span class="sxs-lookup"><span data-stu-id="85d33-137">**GX_EVENT_FOLD**</span></span>

<span data-ttu-id="85d33-138">GUIX вызывает этот макрос для свертывания события в очередь событий FIFO, используемую GUIX.</span><span class="sxs-lookup"><span data-stu-id="85d33-138">This macro is invoked by GUIX to fold an event into the FIFO event queue.</span></span> <span data-ttu-id="85d33-139">Свертывание события означает, что если в очереди уже существует событие того же типа, эта запись обновляется для включения полезных данных нового события.</span><span class="sxs-lookup"><span data-stu-id="85d33-139">Folding an event means that if an event of the same type already exists in the queue, that entry is update to contain the payload of the new event.</span></span> <span data-ttu-id="85d33-140">Если в очереди отсутствует событие того же типа, в нее помещается новое событие.</span><span class="sxs-lookup"><span data-stu-id="85d33-140">If an existing event of the same type is not found in the queue, a new event is pushed into the queue.</span></span> 

<span data-ttu-id="85d33-141">Для привязок, которые не могут реализовать функцию свертывания событий, можно просто вызвать GX_EVENT_PUSH.</span><span class="sxs-lookup"><span data-stu-id="85d33-141">For bindings that cannot implement the event fold feature, it is acceptable to simply invoke the GX_EVENT_PUSH.</span></span>

<span data-ttu-id="85d33-142">**GX_TIMER_START**</span><span class="sxs-lookup"><span data-stu-id="85d33-142">**GX_TIMER_START**</span></span>

<span data-ttu-id="85d33-143">Этот макрос вызывается, когда GUIX требуется получить входные данные периодического таймера.</span><span class="sxs-lookup"><span data-stu-id="85d33-143">This macro is invoked when GUIX needs to receive periodic timer input.</span></span> <span data-ttu-id="85d33-144">Этот макрос должен вызывать службу, запускающую службу периодического таймера ОСРВ низкого уровня.</span><span class="sxs-lookup"><span data-stu-id="85d33-144">This macro should invoke a service that starts the low-level RTOS periodic timer service.</span></span> <span data-ttu-id="85d33-145">Если службу таймера ОСРВ трудно остановить или запустить, можно, но нецелесообразно, оставить ее в запущенном состоянии.</span><span class="sxs-lookup"><span data-stu-id="85d33-145">If the RTOS timer service cannot be easily stopped and started, it is acceptable but less efficient to leave this service running at all times.</span></span>

<span data-ttu-id="85d33-146">Когда служба таймера ОСРВ нижнего уровня время от времени завершает работу, привязка должна вызывать системную функцию GUIX _gx_system_timer_expiration(0). Ее периодический вызов обеспечивает функционирование служб мини-приложения таймера GUIX высокого уровня.</span><span class="sxs-lookup"><span data-stu-id="85d33-146">When the low-level RTOS timer service periodically expires, the binding must call the GUIX system function _gx_system_timer_expiration(0); Calling this function periodically is what drives the high-level GUIX timer widget timer services.</span></span>

<span data-ttu-id="85d33-147">**GX_TIMER_STOP**</span><span class="sxs-lookup"><span data-stu-id="85d33-147">**GX_TIMER_STOP**</span></span>

<span data-ttu-id="85d33-148">Этот макрос вызывается, когда GUIX больше не требуется периодический таймера (т. е. нет активных запущенных таймеров GUIX).</span><span class="sxs-lookup"><span data-stu-id="85d33-148">This macro is invoked when GUIX no longer needs a periodic timer (i.e. there are no active GUIX timers running).</span></span> <span data-ttu-id="85d33-149">Если службу таймера ОСРВ трудно остановить или запустить, можно, но нецелесообразно, оставить ее в запущенном состоянии и не задавать для макроса никаких действий.</span><span class="sxs-lookup"><span data-stu-id="85d33-149">If the RTOS timer service cannot be easily stopped and started, it is acceptable but less efficient to leave this service running at all times and define this macro to do nothing.</span></span>

<span data-ttu-id="85d33-150">**GX_SYSTEM_MUTEX_LOCK**</span><span class="sxs-lookup"><span data-stu-id="85d33-150">**GX_SYSTEM_MUTEX_LOCK**</span></span>

<span data-ttu-id="85d33-151">Этот макрос вызывается GUIX в критических разделах кода, чтобы запретить другой задаче вытеснять и изменять общие структуры данных, что в противном случае может привести к повреждению.</span><span class="sxs-lookup"><span data-stu-id="85d33-151">This macro is invoked by GUIX during critical code sections to prevent another task from  pre-empting and modifying common data structures, potentially causing corruption.</span></span> <span data-ttu-id="85d33-152">Этот макрос должен вызывать функцию, которая реализует подходящую службу блокировки ресурсов ОСРВ.</span><span class="sxs-lookup"><span data-stu-id="85d33-152">This macro should call a function that implements the suitable RTOS resource locking service.</span></span>

<span data-ttu-id="85d33-153">Если вы никогда не использовали никакие службы API GUIX вне потока GUIX, можно не задавать для макроса никаких действий.</span><span class="sxs-lookup"><span data-stu-id="85d33-153">If you never utilize any GUIX API services outside of the GUIX thread, you can define this macro to do nothing.</span></span>

<span data-ttu-id="85d33-154">**GX_SYSTEM_MUTEX_UNLOCK**</span><span class="sxs-lookup"><span data-stu-id="85d33-154">**GX_SYSTEM_MUTEX_UNLOCK**</span></span>

<span data-ttu-id="85d33-155">Этот макрос вызывается в конце критических разделов кода и должен разблокировать ресурс GUIX с помощью подходящей базовой службы ОСРВ.</span><span class="sxs-lookup"><span data-stu-id="85d33-155">This macro is invoked at the end of critical code sections, and should unlock the GUIX resource using the suitable underlying RTOS service.</span></span> <span data-ttu-id="85d33-156">Если вы никогда не использовали никакие службы API GUIX вне потока GUIX, можно не задавать для макроса никаких действий.</span><span class="sxs-lookup"><span data-stu-id="85d33-156">If you never utilize any GUIX API services outside of the GUIX thread, you can define this macro to do nothing.</span></span>

<span data-ttu-id="85d33-157">**GX_SYSTEM_TIME_GET**</span><span class="sxs-lookup"><span data-stu-id="85d33-157">**GX_SYSTEM_TIME_GET**</span></span>

<span data-ttu-id="85d33-158">Этот макрос должен вызывать функцию, возвращающую текущее системное время (системные такты), которое обычно представляет собой число прерываний таймера низкого уровня, произошедших с момента запуска системы.</span><span class="sxs-lookup"><span data-stu-id="85d33-158">This macro should call a function that returns the current system time is “system ticks”, which is usually the number of low-level timer interrupts that have occurred since system startup.</span></span> <span data-ttu-id="85d33-159">Эта служба используется для вычисления скорости сенсорного пера для жестов сенсорного ввода.</span><span class="sxs-lookup"><span data-stu-id="85d33-159">This service is used to calculate touch event pen speed for touch input gestures.</span></span> <span data-ttu-id="85d33-160">Сигнатура функции, вызываемой этим макросом, должна иметь следующий вид:</span><span class="sxs-lookup"><span data-stu-id="85d33-160">The signature of the function invoked by this macro must be:</span></span>

<span data-ttu-id="85d33-161">**ULONG *function_name*(VOID);**</span><span class="sxs-lookup"><span data-stu-id="85d33-161">**ULONG *function_name*(VOID);**</span></span>

<span data-ttu-id="85d33-162">**GX_CURRENT_THREAD**</span><span class="sxs-lookup"><span data-stu-id="85d33-162">**GX_CURRENT_THREAD**</span></span>

<span data-ttu-id="85d33-163">Этот макрос вызывается для определения выполняющегося в данный момент потока.</span><span class="sxs-lookup"><span data-stu-id="85d33-163">This macro is invoked to identify the currently executing thread.</span></span> <span data-ttu-id="85d33-164">Служба, вызываемая этим макросом, должна возвращать void \*. Это значит, что для возврата в GUX тип данных, используемый операционной системой для определения текущего потока выполнения, должен быть приведен к типу void \*.</span><span class="sxs-lookup"><span data-stu-id="85d33-164">The service called by this macro must return a void \*, meaning that the data type used by your operating system to identify the current execution thread must be cast to a void \* to be returned to GUX.</span></span>

<span data-ttu-id="85d33-165">Полный пример универсальной привязки ОСРВ реализован в файлах gx_system_rtos_bind.h и gx_system_rtos_bind.c.</span><span class="sxs-lookup"><span data-stu-id="85d33-165">A complete example of a generic RTOS binding is implemented in the filed gx_system_rtos_bind.h and gx_system_rtos_bind.c</span></span>