---
title: Глава 1. Введение в протокол PPP NetX Duo для ОСРВ Azure
description: В этой главе представлено введение в модуль по протоколу PPP NetX Duo для ОСРВ Azure.
author: philmea
ms.author: philmea
ms.date: 06/04/2020
ms.topic: article
ms.service: rtos
ms.openlocfilehash: f439cf66e6619652ae8ab9097b2de5e584d78c59
ms.sourcegitcommit: e3d42e1f2920ec9cb002634b542bc20754f9544e
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/22/2021
ms.locfileid: "104814612"
---
# <a name="chapter-1---introduction-to-the-azure-rtos-netx-duo-point-to-point-protocol-ppp"></a>Глава 1. Введение в протокол PPP NetX Duo для ОСРВ Azure

Как правило, приложения NetX подключаются к реальной физической сети через Ethernet. Это обеспечивает быстрый и эффективный доступ к сети. Но бывают ситуации, когда у приложения нет доступа к сети Ethernet. В таких случаях приложение может подключиться к сети через последовательный интерфейс, напрямую соединенный с другим участником сети. Самый распространенный программный протокол для управления таким подключением — протокол PPP.

Хотя обмен данными через последовательные интерфейсы относительно прост, протокол PPP может быть в некоторой мере сложен. Протокол PPP фактически состоит из нескольких протоколов, таких как LCP, IPCP, PAP и CHAP. LCP — это основной протокол PPP. Именно он обеспечивает динамическое пиринговое согласование базовых компонентов связи. После успешного согласования базовых характеристик связи задействуются протоколы PAP и (или) CHAP, чтобы обеспечить допустимость однорангового узла. Если допустимы оба одноранговых узла, используется IPCP для согласования IP-адресов, используемых ими. После завершения работы IPCP протокол PPP сможет отправлять и получать IP-пакеты.

NetX рассматривает PPP в основном как драйвер устройств. Функция *nx_ppp_driver* предоставляется функции создания IP-адреса NetX (*nx_ip_create*). В противном случае NetX не располагает достоверными данными об использовании PPP.

## <a name="ppp-serial-communication"></a>Последовательная связь с помощью PPP

Пакет PPP для NetX требует, чтобы приложение предоставило драйвер последовательной связи. Драйвер должен поддерживать 8-разрядные символы и также может использовать программное управление потоком. Приложение отвечает за инициализацию драйвера, причем эту операцию необходимо выполнить до создания экземпляра PPP.

Чтобы отправлять пакеты PPP, необходимо предоставить протоколу PPP подпрограмму байтового вывода драйвера последовательной связи (задается функцией *nx_ppp_create*). Эта подпрограмма байтового вывода драйвера последовательной связи будет вызываться несколько раз для передачи всего пакета PPP. Буферизацию вывода должен обеспечить драйвер последовательной связи. На стороне получения драйвер последовательной связи приложения должен вызывать функцию PPP *nx_ppp_byte_receive* при каждом получении нового байта. Обычно эта операция выполняется в контексте обработчика прерываний (ISR). Функция *nx_ppp_byte_receive* помещает входящий байт в циклический буфер и оповещает поток получения PPP о его наличии.

## <a name="ppp-over-ethernet-communication"></a>Связь по протоколу PPP через Ethernet

NetX PPP также может передавать сообщение PPP через Ethernet. В такой ситуации пакет NetX PPP требует, чтобы приложение предоставило драйвер связи по Ethernet.

Чтобы отправлять пакеты PPP через Ethernet, необходимо предоставить протоколу PPP подпрограмму вывода (задается функцией *nx_ppp_packet_send_set*). Эта подпрограмма вывода будет вызываться несколько раз для передачи всего пакета PPP. На стороне получения получатель приложения должен вызывать функцию PPP *nx_ppp_packet_receive* при каждом получении нового пакета.

## <a name="ppp-packet"></a>Пакет PPP

Протокол PPP использует кадрирование AHDLC (подвид HDLC) для инкапсуляции всех данных управления и пользователей протокола PPP. Кадр AHDLC выглядит следующим образом:

|**Пометить**|**Addr**|**Ctrl**|**Информация**|**CRC**|**Пометить**|
|--------|--------|--------|---------------|-------|--------|
|7E |FF|03|[0–1502 байт]|2-байтовая| 7E|

Каждый кадр PPP имеет приблизительно такой вид. Первые два байта информационного поля содержат сведения о типе протокола PPP. Допустимые значения определяются следующим образом:

- C021: LCP
- 8021: IPCP
- C023: PAP
- C223: CHAP
- 0021: пакет данных протокола IP

Если указан тип протокола 0x0021, за ним сразу же следует пакет протокола IP. В противном случае при наличии одного из других протоколов, следующие байты будут соответствовать такому конкретному протоколу.

Чтобы обеспечить уникальность маркеров начала и конца кадра 0x7E и поддержку программного управления потоком, AHDLC использует escape-последовательности для представления различных байтовых значений. Значение 0x7D указывает, что следующий символ закодирован (по сути является исходным символом, к которому применена операция исключающего ИЛИ с 0x20). Например, значение 0x03 для поля Ctrl в заголовке представлено двухбайтовой последовательностью: 7D 23. По умолчанию значения меньше 0x20 преобразуются в escape-последовательность, как и значения 0x7E и 0x7D в информационном поле. Обратите внимание, что escape-последовательности также применяются к полю CRC.

## <a name="link-control-protocol-lcp"></a>Протокол LCP

LCP является основным протоколом PPP и запускается первым. LCP отвечает за согласование различных параметров PPP, включая максимальную длину получаемых пакетов (MRU) и используемый протокол проверки подлинности (PAP, CHAP или без протокола). После согласования параметров PPP обеими сторонами LCP запускаются протоколы проверки подлинности (если они заданы).

## <a name="password-authentication-protocol-pap"></a>Протокол PAP

PAP — это относительно простой протокол, который использует имя и пароль, предоставляемые одной стороной подключения (в соответствии с согласованными параметрами при запуске LCP). Другая сторона затем проверяет эту информацию. При корректности данных отправителю возвращается сообщение о принятии, а протокол PPP может перейти к конечному автомату IPCP. Если же имя или пароль неверны, подключение отклоняется.

>[!NOTE]
> Протокол PAP может быть запрошен обеими сторонами интерфейса, но обычно PAP используется только в одном направлении.

## <a name="challenge-handshake-authentication-protocol-chap"></a>Протокол CHAP

CHAP — это более сложный протокол проверки подлинности, чем PAP. Структура проверки подлинности CHAP предоставляет своему одноранговому узлу имя и значение. Одноранговый узел затем использует предоставленное имя для поиска общего секрета между двумя сущностями. После этого выполняется расчет на основе идентификатора, значения и секрета. Результат этого расчета возвращается в ответе. При корректности результата PPP может перейти к конечному автомату IPCP. Если же результат неправильный, подключение отклоняется.

Еще одной интересной особенностью CHAP является то, что такой расчет может выполняться в случайные интервалы после того, как подключение было установлено. Это делается для того, чтобы не допустить перехват подключения после его проверки подлинности. Если запрос завершается сбоем в один из таких случайных интервалов, подключение немедленно завершается.

>[!NOTE]
> Протокол CHAP может быть запрошен обеими сторонами интерфейса, но обычно CHAP используется только в одном направлении.

## <a name="internet-protocol-control-protocol-ipcp"></a>Протокол IPCP

IPCP — это последний протокол, который выполняется перед тем, как связь PPP станет доступна для передачи данных по протоколу IP в NetX. Основное назначение этого протокола — информирование одноранговым узлом других одноранговых узлов о своем IP-адресе. После настройки IP-адреса можно выполнять передачу данных по протоколу IP в NetX.

## <a name="data-transfer"></a>Передача данных

Как упоминалось ранее, пакеты данных протокола IP в NetX располагаются в кадрах PPP с идентификатором протокола 0x0021. Все полученные пакеты данных помещаются в одну или несколько структур NX_PACKET и перемещаются в конвейер обработки получения NetX. При передаче содержимое пакетов NetX помещается в кадр AHDLC и отправляется.

## <a name="ppp-rfcs"></a>Стандарты RFC и протокол PPP

NetX PPP удовлетворяет требованиям RFC 1332, RFC 1334, RFC 1661, RFC 1994 и связанным RFC.