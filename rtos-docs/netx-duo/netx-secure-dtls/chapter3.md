---
title: Глава 3. Функциональное описание ОСРВ Azure NetX Secure DTLS
description: Эта глава содержит функциональное описание ОСРВ Azure NetX Secure DTLS.
author: philmea
ms.author: philmea
ms.date: 06/04/2020
ms.topic: article
ms.service: rtos
ms.openlocfilehash: 347bd83fa8c72ced2e8678a92ec5c5f8393c136d
ms.sourcegitcommit: 60ad844b58639d88830f2660ab0c4ff86b92c10f
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/07/2021
ms.locfileid: "106550207"
---
# <a name="chapter-3-functional-description-of-azure-rtos-netx-secure-dtls"></a><span data-ttu-id="929ee-103">Глава 3. Функциональное описание ОСРВ Azure NetX Secure DTLS</span><span class="sxs-lookup"><span data-stu-id="929ee-103">Chapter 3: Functional description of Azure RTOS NetX Secure DTLS</span></span>

## <a name="execution-overview"></a><span data-ttu-id="929ee-104">Общие сведения о выполнении</span><span class="sxs-lookup"><span data-stu-id="929ee-104">Execution Overview</span></span>

<span data-ttu-id="929ee-105">Эта глава содержит функциональное описание ОСРВ Azure NetX Secure DTLS.</span><span class="sxs-lookup"><span data-stu-id="929ee-105">This chapter contains a functional description of Azure RTOS NetX Secure DTLS.</span></span> <span data-ttu-id="929ee-106">В приложении NetX Secure DTLS используются два основных типа выполнения программы: инициализация и вызовы интерфейса приложения.</span><span class="sxs-lookup"><span data-stu-id="929ee-106">There are two primary types of program execution in a NetX Secure DTLS application: initialization and application interface calls.</span></span> 

<span data-ttu-id="929ee-107">NetX Secure предполагает наличие компонентов ThreadX и NetX или NetX Duo.</span><span class="sxs-lookup"><span data-stu-id="929ee-107">NetX Secure assumes the existence of ThreadX and NetX/NetXDuo.</span></span> <span data-ttu-id="929ee-108">В ThreadX требуется выполнение потоков, приостановка, периодические таймеры и средства взаимного исключения.</span><span class="sxs-lookup"><span data-stu-id="929ee-108">From ThreadX, it requires thread execution, suspension, periodic timers, and mutual exclusion facilities.</span></span> <span data-ttu-id="929ee-109">В NetX или NetX Duo требуются сетевые средства и драйверы UDP и IP.</span><span class="sxs-lookup"><span data-stu-id="929ee-109">From NetX/NetXDuo it requires the UDP and IP networking facilities and drivers.</span></span>

## <a name="datagram-transport-layer-security-dtls-and-transport-layer-security-tls"></a><span data-ttu-id="929ee-110">Протоколы DTLS и TLS</span><span class="sxs-lookup"><span data-stu-id="929ee-110">Datagram Transport Layer Security (DTLS) and Transport Layer Security (TLS)</span></span>

<span data-ttu-id="929ee-111">NetX Secure DTLS реализует протокол датаграмм безопасности транспортного уровня версии 1.2, определенный в документе RFC 6347.</span><span class="sxs-lookup"><span data-stu-id="929ee-111">NetX Secure DTLS implements the Datagram Transport Layer Security protocol version 1.2 defined in RFC 6347.</span></span> <span data-ttu-id="929ee-112">Протокол DTLS версии 1.0 был определен в документе RFC 4347 и соответствует протоколу TLS версии 1.1.</span><span class="sxs-lookup"><span data-stu-id="929ee-112">DTLS version 1.0 was defined in RFC 4347 and corresponded to TLS version 1.1.</span></span> <span data-ttu-id="929ee-113">Так как DTLS является расширением протокола TLS, было решено, что его следующая версия получит тот же номер, что и соответствующая версия протокола TLS.</span><span class="sxs-lookup"><span data-stu-id="929ee-113">Due to DTLS being essentially an extension to TLS, it was decided that the next version would use the same version number as the corresponding TLS version.</span></span> <span data-ttu-id="929ee-114">Поэтому не существует протокол DTLS версии 1.1, так как протоколу TLS версии 1.2 соответствует DTLS версии 1.2.</span><span class="sxs-lookup"><span data-stu-id="929ee-114">Thus, there is no DTLS version 1.1 as DTLS version 1.2 corresponds to TLS version 1.2.</span></span>

> [!NOTE]
> <span data-ttu-id="929ee-115">NetX Secure поддерживает DTLS версии 1.2.</span><span class="sxs-lookup"><span data-stu-id="929ee-115">NetX Secure supports DTLS version 1.2.</span></span> <span data-ttu-id="929ee-116">Протокол DTLS 1.0 (RFC 4347) в настоящее время **не** поддерживается.</span><span class="sxs-lookup"><span data-stu-id="929ee-116">DTLS 1.0 (RFC 4347) is **not** currently supported.</span></span>

<span data-ttu-id="929ee-117">*SSL* — это первоначальное название протокола TLS, использовавшееся до того, как он стал стандартом в RFC 2246, и название "SSL" часто используется в качестве универсального названия протоколов TLS.</span><span class="sxs-lookup"><span data-stu-id="929ee-117">*Secure Sockets Layer* (SSL) was the original name of TLS before it became a standard in RFC 2246 and “SSL” is often used as a generic name for the TLS protocols.</span></span> <span data-ttu-id="929ee-118">Последней версией SSL была версия 3.0, а протокол TLS 1.0 иногда называют протоколом SSL версии 3.1.</span><span class="sxs-lookup"><span data-stu-id="929ee-118">The last version of SSL was 3.0, and TLS 1.0 is sometimes referred to as SSL version 3.1.</span></span> <span data-ttu-id="929ee-119">Все версии официального протокола SSL считаются устаревшими и небезопасными, и в настоящее время NetX Secure не предоставляет реализацию SSL.</span><span class="sxs-lookup"><span data-stu-id="929ee-119">All versions of the official “SSL” protocol are considered obsolete and insecure and currently NetX Secure does not provide an SSL implementation.</span></span>

<span data-ttu-id="929ee-120">TLS задает протокол для создания *ключей сеанса*, которые создаются во время *подтверждения* TLS между клиентом и сервером TLS. Эти ключи используются для шифрования данных, отправляемых приложением во время *сеанса* TLS.</span><span class="sxs-lookup"><span data-stu-id="929ee-120">TLS specifies a protocol to generate *session keys* which are created during the TLS *handshake* between a TLS client and server and those keys are used to encrypt data sent by the application during the TLS *session.*</span></span>

<span data-ttu-id="929ee-121">Протокол DTLS тесно связан с протоколом TLS, так как в них используются одинаковые механизмы безопасности.</span><span class="sxs-lookup"><span data-stu-id="929ee-121">DTLS is closely coupled with TLS, as the underlying security mechansims are shared between the protocols.</span></span> <span data-ttu-id="929ee-122">Тем не менее, протокол TLS предназначен для работы на транспортном уровне, обеспечивающем гарантированную доставку пакетов и их порядок. На практике почти всегда это протокол TCP, так как протокол TLS не будет функционировать посредством ненадежного протокола, например UDP.</span><span class="sxs-lookup"><span data-stu-id="929ee-122">However, TLS is designed to work over a transport layer protocol that provides guarantees about packet delivery and order (almost always TCP in practice) and will not function over an unreliable protocol like UDP.</span></span> <span data-ttu-id="929ee-123">Именно из-за протокола UDP был создан протокол DTLS. Протокол DTLS был разработан специально с учетом ненадежности протокола UDP и аналогичных протоколов.</span><span class="sxs-lookup"><span data-stu-id="929ee-123">It is precisely because of UDP that DTLS was introduced: DTLS was designed handle the unreliable nature of UDP and similar protocols.</span></span> <span data-ttu-id="929ee-124">В нем реализована логика упорядочения и обеспечения надежности (например, повторная передача удаленных данных), как в надежных протоколах, например TCP.</span><span class="sxs-lookup"><span data-stu-id="929ee-124">It does this by including ordering and reliability logic (e.g. retransmission of dropped data) similar to reliable protocols like TCP.</span></span>

<span data-ttu-id="929ee-125">Подробное описание протокола TLS приведено в главе 3 руководства пользователя NetX Secure TLS, поэтому в этом документе основное внимание уделяется различиям между протоколами TLS и DTLS.</span><span class="sxs-lookup"><span data-stu-id="929ee-125">A complete discussion of TLS is included in Chapter 3 of the NetX Secure TLS User’s Guide, so this document will focus on the differences between TLS and DTLS.</span></span>

### <a name="dtls-record-header"></a><span data-ttu-id="929ee-126">Заголовок записи DTLS</span><span class="sxs-lookup"><span data-stu-id="929ee-126">DTLS Record header</span></span>

<span data-ttu-id="929ee-127">Любая допустимая запись DTLS должна иметь заголовок DTLS, как показано на рисунке 1.</span><span class="sxs-lookup"><span data-stu-id="929ee-127">Any valid DTLS record must have a DTLS header, as shown in Figure 1.</span></span> <span data-ttu-id="929ee-128">Заголовок такой же, как и в протоколе TLS, только в него добавлены два поля: 16-разрядное значение *эпохи* и 48-разрядный *порядковый номер*, описанные ниже.</span><span class="sxs-lookup"><span data-stu-id="929ee-128">The header is the same as TLS with the addition of two new fields: the 16-bit *epoch* and the 48-bit *sequence number*, described below.</span></span>

![Схема заголовка записи DTLS.](media/image2.png)

<span data-ttu-id="929ee-130">**Рисунок 1. Заголовок записи DTLS**</span><span class="sxs-lookup"><span data-stu-id="929ee-130">**Figure 1 - DTLS record header**</span></span>

<span data-ttu-id="929ee-131">Ниже приведены определения полей заголовка записи TLS.</span><span class="sxs-lookup"><span data-stu-id="929ee-131">The fields of the TLS record header are defined as follows:</span></span>

| <span data-ttu-id="929ee-132">Поле заголовка TLS</span><span class="sxs-lookup"><span data-stu-id="929ee-132">TLS Header Field</span></span> | <span data-ttu-id="929ee-133">Назначение</span><span class="sxs-lookup"><span data-stu-id="929ee-133">Purpose</span></span>  |
| ---------------- | --------- |
| <span data-ttu-id="929ee-134">**8 разрядов: тип сообщения**</span><span class="sxs-lookup"><span data-stu-id="929ee-134">**8-bit Message Type**</span></span> | <span data-ttu-id="929ee-135">Это поле содержит тип отправляемой записи DTLS.</span><span class="sxs-lookup"><span data-stu-id="929ee-135">This field contains the type of DTLS record being sent.</span></span> <span data-ttu-id="929ee-136">Допустимые типы:</span><span class="sxs-lookup"><span data-stu-id="929ee-136">Valid types are as follows:</span></span><br /><span data-ttu-id="929ee-137">- ChangeCipherSpec: 0x14;</span><span class="sxs-lookup"><span data-stu-id="929ee-137">- ChangeCipherSpec: 0x14</span></span><br /><span data-ttu-id="929ee-138">- Alert: 0x15;</span><span class="sxs-lookup"><span data-stu-id="929ee-138">- Alert: 0x15</span></span><br /><span data-ttu-id="929ee-139">- Handshake: 0x16;</span><span class="sxs-lookup"><span data-stu-id="929ee-139">- Handshake: 0x16</span></span><br /><span data-ttu-id="929ee-140">- данные приложения: 0x17.</span><span class="sxs-lookup"><span data-stu-id="929ee-140">- Application Data: 0x17</span></span><br /> |
| <span data-ttu-id="929ee-141">**16 разрядов: версия протокола**</span><span class="sxs-lookup"><span data-stu-id="929ee-141">**16-bit Protocol Version**</span></span> | <span data-ttu-id="929ee-142">Это поле содержит версию протокола DTLS.</span><span class="sxs-lookup"><span data-stu-id="929ee-142">This field contains the DTLS protocol version.</span></span> <span data-ttu-id="929ee-143">Допустимы следующие значения:</span><span class="sxs-lookup"><span data-stu-id="929ee-143">Valid values are as follows:</span></span><br /><span data-ttu-id="929ee-144">- DTLS 1.1: 0xFEFD</span><span class="sxs-lookup"><span data-stu-id="929ee-144">- DTLS 1.1: 0xFEFD</span></span> |
|  <span data-ttu-id="929ee-145">**16 разрядов: эпоха**</span><span class="sxs-lookup"><span data-stu-id="929ee-145">**16-bit Epoch**</span></span> |  <span data-ttu-id="929ee-146">Это поле содержит "эпоху" DTLS. Это счетчик, который увеличивается при каждом изменении состояния шифрования (например, при создании новых ключей сеанса).</span><span class="sxs-lookup"><span data-stu-id="929ee-146">This field contains the DTLS “epoch” which is a counter that is incremented each time the encryption state is changed (e.g. when generating new session keys).</span></span>  |
|  <span data-ttu-id="929ee-147">**48 разрядов: порядковый номер**</span><span class="sxs-lookup"><span data-stu-id="929ee-147">**48-bit Sequence Number**</span></span> |  <span data-ttu-id="929ee-148">Это поле содержит порядковый номер, который определяет данную запись.</span><span class="sxs-lookup"><span data-stu-id="929ee-148">This field contains a sequence number which identifies this particular record.</span></span> <span data-ttu-id="929ee-149">Он используется протоколом DTLS для упорядочения записей и проверки необходимости повторной передачи.</span><span class="sxs-lookup"><span data-stu-id="929ee-149">It is used by DTLS to maintain record ordering and check for retransmission need.</span></span> |
|  <span data-ttu-id="929ee-150">**16 разрядов: длина в битах**</span><span class="sxs-lookup"><span data-stu-id="929ee-150">**16-bit Length**</span></span> |  <span data-ttu-id="929ee-151">Это поле содержит длину данных, инкапсулированных в запись DTLS.</span><span class="sxs-lookup"><span data-stu-id="929ee-151">This field contains the length of the data encapsulated in the DTLS record.</span></span>  |

### <a name="dtls-handshake-record-header"></a><span data-ttu-id="929ee-152">Заголовок записи подтверждения DTLS</span><span class="sxs-lookup"><span data-stu-id="929ee-152">DTLS Handshake Record header</span></span>

<span data-ttu-id="929ee-153">Любая допустимая запись подтверждения DTLS должна содержать заголовок подтверждения DTLS, как показано на рисунке 2.</span><span class="sxs-lookup"><span data-stu-id="929ee-153">Any valid DTLS handshake record must have a DTLS Handshake header, as shown in Figure 2.</span></span>

![Схема заголовка записи подтверждения DTLS.](media/image3.png)

<span data-ttu-id="929ee-155">**Рисунок 2. Заголовок записи подтверждения DTLS**</span><span class="sxs-lookup"><span data-stu-id="929ee-155">**Figure 2 - DTLS Handshake record header**</span></span>

<span data-ttu-id="929ee-156">Ниже приведены определения полей заголовка записи подтверждения DTLS.</span><span class="sxs-lookup"><span data-stu-id="929ee-156">The fields of the DTLS Handshake record header are defined as follows:</span></span>

| <span data-ttu-id="929ee-157">Поле заголовка TLS</span><span class="sxs-lookup"><span data-stu-id="929ee-157">TLS Header Field</span></span> | <span data-ttu-id="929ee-158">Назначение</span><span class="sxs-lookup"><span data-stu-id="929ee-158">Purpose</span></span>  |
| ---------------- | ------------------------------------------------ |
| <span data-ttu-id="929ee-159">**8 разрядов: тип сообщения**</span><span class="sxs-lookup"><span data-stu-id="929ee-159">**8-bit Message Type**</span></span> | <span data-ttu-id="929ee-160">Это поле содержит тип отправляемой записи DTLS.</span><span class="sxs-lookup"><span data-stu-id="929ee-160">This field contains the type of DTLS record being sent.</span></span> <span data-ttu-id="929ee-161">Допустимые типы:</span><span class="sxs-lookup"><span data-stu-id="929ee-161">Valid types are as follows:</span></span><br /><span data-ttu-id="929ee-162">- ChangeCipherSpec: 0x14;</span><span class="sxs-lookup"><span data-stu-id="929ee-162">- ChangeCipherSpec: 0x14</span></span><br /><span data-ttu-id="929ee-163">- Alert: 0x15;</span><span class="sxs-lookup"><span data-stu-id="929ee-163">- Alert: 0x15</span></span><br /><span data-ttu-id="929ee-164">- Handshake: 0x16;</span><span class="sxs-lookup"><span data-stu-id="929ee-164">- Handshake: 0x16</span></span><br /><span data-ttu-id="929ee-165">- данные приложения: 0x17.</span><span class="sxs-lookup"><span data-stu-id="929ee-165">- Application Data: 0x17</span></span> |
|  <span data-ttu-id="929ee-166">**16 разрядов: эпоха**</span><span class="sxs-lookup"><span data-stu-id="929ee-166">**16-bit Epoch**</span></span> | <span data-ttu-id="929ee-167">Это поле содержит "эпоху" DTLS. Это счетчик, который увеличивается при каждом изменении состояния шифрования (например, при создании новых ключей сеанса).</span><span class="sxs-lookup"><span data-stu-id="929ee-167">This field contains the DTLS “epoch” which is a counter that is incremented each time the encryption state is changed (e.g. when generating new session keys).</span></span> |
|  <span data-ttu-id="929ee-168">**48 разрядов: порядковый номер**</span><span class="sxs-lookup"><span data-stu-id="929ee-168">**48-bit Sequence Number**</span></span> | <span data-ttu-id="929ee-169">Это поле содержит порядковый номер, который определяет данную запись.</span><span class="sxs-lookup"><span data-stu-id="929ee-169">This field contains a sequence number which identifies this particular record.</span></span> <span data-ttu-id="929ee-170">Он используется протоколом DTLS для упорядочения записей и проверки необходимости повторной передачи.</span><span class="sxs-lookup"><span data-stu-id="929ee-170">It is used by DTLS to maintain record ordering and check for retransmission need.</span></span> |
|  <span data-ttu-id="929ee-171">**16 разрядов: версия протокола**</span><span class="sxs-lookup"><span data-stu-id="929ee-171">**16-bit Protocol Version**</span></span> | <span data-ttu-id="929ee-172">Это поле содержит версию протокола DTLS.</span><span class="sxs-lookup"><span data-stu-id="929ee-172">This field contains the DTLS protocol version.</span></span> <span data-ttu-id="929ee-173">Допустимы следующие значения:</span><span class="sxs-lookup"><span data-stu-id="929ee-173">Valid values are as follows:</span></span><br /><span data-ttu-id="929ee-174">- DTLS 1.1: 0xFEFD</span><span class="sxs-lookup"><span data-stu-id="929ee-174">- DTLS 1.1: 0xFEFD</span></span> |
| <span data-ttu-id="929ee-175">**16 разрядов: длина в битах**</span><span class="sxs-lookup"><span data-stu-id="929ee-175">**16-bit Length**</span></span> | <span data-ttu-id="929ee-176">Это поле содержит длину данных, инкапсулированных в запись DTLS.</span><span class="sxs-lookup"><span data-stu-id="929ee-176">This field contains the length of the data encapsulated in the DTLS record.</span></span> |
| <span data-ttu-id="929ee-177">**8 разрядов: тип подтверждения**</span><span class="sxs-lookup"><span data-stu-id="929ee-177">**8-bit Handshake Type**</span></span> | <span data-ttu-id="929ee-178">Это поле содержит тип сообщения подтверждения.</span><span class="sxs-lookup"><span data-stu-id="929ee-178">This field contains the handshake message type.</span></span> <span data-ttu-id="929ee-179">Допустимы следующие значения:</span><span class="sxs-lookup"><span data-stu-id="929ee-179">Valid values are as follows:</span></span><br /><span data-ttu-id="929ee-180">- HelloRequest: 0x00;</span><span class="sxs-lookup"><span data-stu-id="929ee-180">- HelloRequest: 0x00</span></span><br /><span data-ttu-id="929ee-181">- ClientHello: 0x01;</span><span class="sxs-lookup"><span data-stu-id="929ee-181">- ClientHello: 0x01</span></span><br /><span data-ttu-id="929ee-182">- ServerHello: 0x02;</span><span class="sxs-lookup"><span data-stu-id="929ee-182">- ServerHello: 0x02</span></span><br /><span data-ttu-id="929ee-183">- Certificate: 0x0B;</span><span class="sxs-lookup"><span data-stu-id="929ee-183">- Certificate: 0x0B</span></span><br /><span data-ttu-id="929ee-184">- ServerKeyExchange: 0x0C;</span><span class="sxs-lookup"><span data-stu-id="929ee-184">- ServerKeyExchange: 0x0C</span></span><br /><span data-ttu-id="929ee-185">- CertificateRequest: 0x0D;</span><span class="sxs-lookup"><span data-stu-id="929ee-185">- CertificateRequest: 0x0D</span></span><br /><span data-ttu-id="929ee-186">- ServerHelloDone: 0x0E;</span><span class="sxs-lookup"><span data-stu-id="929ee-186">- ServerHelloDone: 0x0E</span></span><br /><span data-ttu-id="929ee-187">- CertificateVerify: 0x0F;</span><span class="sxs-lookup"><span data-stu-id="929ee-187">- CertificateVerify: 0x0F</span></span><br /><span data-ttu-id="929ee-188">- ClientKeyExchange: 0x10;</span><span class="sxs-lookup"><span data-stu-id="929ee-188">- ClientKeyExchange: 0x10</span></span><br /><span data-ttu-id="929ee-189">- Finished: 0x14;</span><span class="sxs-lookup"><span data-stu-id="929ee-189">- Finished: 0x14</span></span> |
| <span data-ttu-id="929ee-190">**24 разряда: длина**</span><span class="sxs-lookup"><span data-stu-id="929ee-190">**24-bit Length**</span></span> | <span data-ttu-id="929ee-191">Это поле содержит длину данных сообщения подтверждения.</span><span class="sxs-lookup"><span data-stu-id="929ee-191">This field contains the length of the handshake message data.</span></span> |
| <span data-ttu-id="929ee-192">**16 разрядов: порядковый номер**</span><span class="sxs-lookup"><span data-stu-id="929ee-192">**16-bit Sequence Number**</span></span> | <span data-ttu-id="929ee-193">Это поле содержит порядковый номер.</span><span class="sxs-lookup"><span data-stu-id="929ee-193">This field contains a sequence number.</span></span> |

### <a name="the-dtls-handshake-and-dtls-session"></a><span data-ttu-id="929ee-194">Подтверждение DTLS и сеанс DTLS</span><span class="sxs-lookup"><span data-stu-id="929ee-194">The DTLS Handshake and DTLS Session</span></span>

<span data-ttu-id="929ee-195">Типичное подтверждение DTLS показано на рисунке 3.</span><span class="sxs-lookup"><span data-stu-id="929ee-195">A typical DTLS handshake is shown in Figure 3.</span></span> <span data-ttu-id="929ee-196">Оно почти очень похоже на типичное подтверждение TLS с одним важным отличием — при первой отправке сообщения ClientHello сервер отвечает новым сообщением DTLS, *HelloVerifyRequest*, которое содержит файл cookie.</span><span class="sxs-lookup"><span data-stu-id="929ee-196">It is nearly identical to the typical TLS handshake with an important difference – when the ClientHello message is first sent, the server responds with a new DTLS-specific message, *HelloVerifyRequest* which contains a “cookie”.</span></span> <span data-ttu-id="929ee-197">Клиент DTLS должен ответить вторым сообщением ClientHello, содержащим этот файл cookie, прежде чем можно будет продолжить подтверждение.</span><span class="sxs-lookup"><span data-stu-id="929ee-197">The DTLS Client must respond with a second ClientHello message containing that cookie before the handshake can proceed.</span></span> <span data-ttu-id="929ee-198">Этот механизм был добавлен в протокол DTLS для предотвращения атак типа "отказ в обслуживании", так как протокол UDP не зависит от подключения (для протокола TCP требуется выделенное подключение или порт, поэтому протокол TLS не подвержен данной проблеме).</span><span class="sxs-lookup"><span data-stu-id="929ee-198">This mechanism was added to DTLS to prevent certain Denial of Service (DoS) attacks since UDP is a connectionless protocol (TCP requires a dedicated connection/port so TLS does not suffer from the same issue).</span></span>

<span data-ttu-id="929ee-199">Подтверждение DTLS начинается, когда клиент отправляет сообщение *ClientHello* на сервер DTLS, указывая необходимость начать сеанс DTLS.</span><span class="sxs-lookup"><span data-stu-id="929ee-199">A DTLS handshake begins when the Client sends a *ClientHello* message to a DTLS server, indicating its desire to start a DTLS session.</span></span> <span data-ttu-id="929ee-200">Это сообщение содержит сведения о шифровании, которое клиент предпочитает использовать для сеанса, а также данные, используемые для создания ключей сеанса позже при подтверждении.</span><span class="sxs-lookup"><span data-stu-id="929ee-200">The message contains information about the encryption the client would like to use for the session, along with information used to generate the session keys later in the handshake.</span></span> <span data-ttu-id="929ee-201">Пока не созданы ключи сеанса, все сообщения в подтверждении DTLS не шифруются.</span><span class="sxs-lookup"><span data-stu-id="929ee-201">Until the session keys are generated, all messages in the DTLS handshake are not encrypted.</span></span> <span data-ttu-id="929ee-202">Как упоминалось выше, сервер DTLS может отправить сообщение HelloVerifyRequest в ответ на ClientHello, вынуждая клиент ответить вторым, обновленным сообщением ClientHello.</span><span class="sxs-lookup"><span data-stu-id="929ee-202">As mentioned above, the DTLS Server may send a HelloVerifyRequest in response to the ClientHello, forcing the client to respond with a second updated ClientHello.</span></span>

<span data-ttu-id="929ee-203">После получения второго сообщения ClientHello сервер DTLS проверит файл cookie и, если он правильный, ответит сообщением ServerHello, указывающим выбранные параметры шифрования, предоставленные клиентом.</span><span class="sxs-lookup"><span data-stu-id="929ee-203">Upon receiving the second ClientHello message, the DTLS Server will verify the cookie and if correct will respond with a ServerHello message indicating a selection from the encryption options provided by the client.</span></span> <span data-ttu-id="929ee-204">За сообщением ServerHello следует сообщение Certificate, в котором сервер предоставляет цифровой сертификат для проверки подлинности клиента (если используется проверка X.509).</span><span class="sxs-lookup"><span data-stu-id="929ee-204">The ServerHello is followed by a Certificate message, in which the server provides a digital certificate to authenticate its identity to the client (if X.509 verification is used).</span></span> <span data-ttu-id="929ee-205">Наконец, сервер отправляет сообщение ServerHelloDone, указывающее, что отправлены все сообщения.</span><span class="sxs-lookup"><span data-stu-id="929ee-205">Finally, the server sends a ServerHelloDone message to indicate it has no more messages to send.</span></span> <span data-ttu-id="929ee-206">Сервер может дополнительно отправлять и другие сообщения после сообщения ServerHello, а в некоторых случаях он может не отправлять сообщение Certificate (например, если используются общие ключи), поэтому потребуется сообщение ServerHelloDone.</span><span class="sxs-lookup"><span data-stu-id="929ee-206">The server may optionally send other messages following the ServerHello and in some cases it may not send a Certificate message (such as when Pre-Shared Keys are used), hence the need for the ServerHelloDone message.</span></span>

<span data-ttu-id="929ee-207">После того как клиент получит все сообщения сервера, у него будет достаточно сведений для создания ключей сеанса.</span><span class="sxs-lookup"><span data-stu-id="929ee-207">Once the client has received all the server’s messages, it has enough information to generate the session keys.</span></span> <span data-ttu-id="929ee-208">Для этого протокол TLS или DTLS создает общий фрагмент случайных данных, называемый *предварительной главной копией секрета*, который имеет фиксированный размер и используется в качестве начального значения для создания всех необходимых ключей после включения шифрования.</span><span class="sxs-lookup"><span data-stu-id="929ee-208">TLS/DTLS does this by creating a shared bit of random data called the *Pre-Master Secret*, which is a fixed-size and is used as a seed to generate all the keys needed once encryption is enabled.</span></span> <span data-ttu-id="929ee-209">Предварительная главная копия секрета шифруется с помощью алгоритма с открытым ключом (например, RSA), указанного в сообщениях Hello (дополнительные сведения об алгоритмах с открытым ключом см. ниже), и открытого ключа, предоставленного сервером в его сертификате.</span><span class="sxs-lookup"><span data-stu-id="929ee-209">The Pre-Master Secret is encrypted using the public key algorithm (e.g. RSA) specified in the Hello messages (see below for information on public key algorithms) and the public key provided by the server in its certificate.</span></span> <span data-ttu-id="929ee-210">Необязательная функция TLS или DTLS, называемая общими ключами (PSK), включает в себя комплекты шифров, которые не используют сертификат, а вместо этого используют значение секрета, которое передается между узлами (как правило, путем физического перемещения или другого безопасного метода).</span><span class="sxs-lookup"><span data-stu-id="929ee-210">An optional TLS/DTLS feature called Pre-Shared Keys (PSK) enables ciphersuites that do not use a certificate but instead use a secret value shared between the hosts (usually through physical transfer or other secured method).</span></span> <span data-ttu-id="929ee-211">Если использование PSK включено, то для создания предварительной главной копии секрета используется общий секретный ключ.</span><span class="sxs-lookup"><span data-stu-id="929ee-211">When PSK is enabled, the pre-shared secret key is used to generate the Pre-Master Secret.</span></span> <span data-ttu-id="929ee-212">Ознакомьтесь с информацией об общих ключах в разделе "Способы проверки подлинности" ниже.</span><span class="sxs-lookup"><span data-stu-id="929ee-212">See the section on Pre-Shared Keys in “Authentication Methods” below.</span></span>

<span data-ttu-id="929ee-213">При обычном подтверждении TLS или DTLS зашифрованная предварительная главная копия секрета передается на сервер в сообщении ClientKeyExchange.</span><span class="sxs-lookup"><span data-stu-id="929ee-213">In a usual TLS/DTLS handshake, the encrypted Pre-Master Secret is sent to the server in the ClientKeyExchange message.</span></span> <span data-ttu-id="929ee-214">При получении сообщения ClientKeyExchange сервер расшифровывает предварительную главную копию секрета с помощью своего закрытого ключа и продолжает создавать ключи сеанса одновременно с клиентом DTLS.</span><span class="sxs-lookup"><span data-stu-id="929ee-214">The server, upon receiving the ClientKeyExchange message, decrypts the Pre-Master Secret using its private key and proceeds to generate the session keys in parallel with the TLS/DTLS client.</span></span>

<span data-ttu-id="929ee-215">После создания ключей сеанса все последующие сообщения могут быть зашифрованы с помощью алгоритма с закрытым ключом (например, AES), выбранного в сообщениях Hello.</span><span class="sxs-lookup"><span data-stu-id="929ee-215">Once the session keys are generated, all further messages can be encrypted using the private-key algorithm (e.g. AES) selected in the Hello messages.</span></span> <span data-ttu-id="929ee-216">Одно завершающее незашифрованное сообщение, именуемое ChangeCipherSpec, отправляет как клиент, так и сервер, чтобы указать, что все последующие сообщения будут зашифрованы.</span><span class="sxs-lookup"><span data-stu-id="929ee-216">One final un-encrypted message called ChangeCipherSpec is sent by both the client and server to indicate that all further messages will be encrypted.</span></span>

<span data-ttu-id="929ee-217">Первое зашифрованное сообщение, отправленное и клиентом, и сервером, также является завершающим сообщением подтверждения TLS, именуемым Finished.</span><span class="sxs-lookup"><span data-stu-id="929ee-217">The first encrypted message sent by both the client and server is also the final TLS handshake message, called Finished.</span></span> <span data-ttu-id="929ee-218">Это сообщение содержит хэш всех полученных и отправленных сообщений подтверждения.</span><span class="sxs-lookup"><span data-stu-id="929ee-218">This message contains a hash of all the handshake messages received and sent.</span></span> <span data-ttu-id="929ee-219">Этот хэш используется, чтобы проверить, что ни одно из сообщений в подтверждении не было изменено или повреждено (что может указывать на нарушение безопасности).</span><span class="sxs-lookup"><span data-stu-id="929ee-219">This hash is used to verify that none of the messages in the handshake have been tampered with or corrupted (indicating a possible breach of security).</span></span>

<span data-ttu-id="929ee-220">После получения сообщений Finished и проверки хэшей подтверждения начинается сеанс TLS или DTLS. Приложение начинает отправку и получение данных.</span><span class="sxs-lookup"><span data-stu-id="929ee-220">Once the Finished messages are received and the handshake hashes are verified, the TLS/DTLS session begins, and the application begins sending and receiving data.</span></span> <span data-ttu-id="929ee-221">Все данные, отправляемые любой из сторон во время сеанса TLS или DTLS, сначала хэшируются с помощью хэш-алгоритма, выбранного в сообщениях Hello (для обеспечения целостности сообщений), и шифруются с помощью выбранного алгоритма с закрытым ключом и созданных ключей сеанса.</span><span class="sxs-lookup"><span data-stu-id="929ee-221">All data sent by either side during the TLS/DTLS session is first hashed using the hash algorithm chosen in the Hello messages (to provide message integrity) and encrypted using the chosen private-key algorithm with the generated session keys.</span></span>

<span data-ttu-id="929ee-222">Наконец, сеанс TLS иил DTLS может быть успешно завершен только в том случае, если это действие выбрал клиент или сервер.</span><span class="sxs-lookup"><span data-stu-id="929ee-222">Finally, a TLS/DTLS session can only be successfully ended if either the Client or Server chooses to do so.</span></span> <span data-ttu-id="929ee-223">Усеченный сеанс считается нарушением безопасности, так как злоумышленник может попытаться предотвратить получение всех данных. Поэтому, когда одна из сторон желает завершить сеанс, передается специальное уведомление, которое называется оповещением CloseNotify.</span><span class="sxs-lookup"><span data-stu-id="929ee-223">A truncated session is considered a security breach (since an attacker may be attempting to prevent all the data being sent from being received) so a special notification is sent when either side wants to end the session, called a CloseNotify alert.</span></span> <span data-ttu-id="929ee-224">Как клиент, так и сервер должны отправить и обработать оповещение CloseNotify, чтобы успешно завершить сеанс.</span><span class="sxs-lookup"><span data-stu-id="929ee-224">Both the client and server must send and process a CloseNotify alert for a successful session shutdown.</span></span>

![Схема типичного сеанса подтверждения DTLS.](media/image4.png)

<span data-ttu-id="929ee-226">**Рисунок 3. Типичное подтверждение DTLS**</span><span class="sxs-lookup"><span data-stu-id="929ee-226">**Figure 3- Typical DTLS handshake**</span></span>

### <a name="initialization"></a><span data-ttu-id="929ee-227">Инициализация</span><span class="sxs-lookup"><span data-stu-id="929ee-227">Initialization</span></span>

<span data-ttu-id="929ee-228">Прежде чем использовать NetX Secure DTLS, необходимо инициализировать стек NetX или NetX Duo.</span><span class="sxs-lookup"><span data-stu-id="929ee-228">The NetX or NetXDuo stack must be initialized prior to using NetX Secure DTLS.</span></span> <span data-ttu-id="929ee-229">Сведения о том, как правильно инициализировать стек TCP/IP для операций UDP, см. в руководстве пользователя NetX или NetX Duo.</span><span class="sxs-lookup"><span data-stu-id="929ee-229">Refer to the NetX or NetXDuo User Guide for information on how to properly initialize the TCP/IP stack for UDP operation.</span></span>

<span data-ttu-id="929ee-230">После инициализации NetX UDP можно включить протокол DTLS.</span><span class="sxs-lookup"><span data-stu-id="929ee-230">Once NetX UDP has been initialized, DTLS can be enabled.</span></span> <span data-ttu-id="929ee-231">На внутреннем уровне передача всего сетевого трафика и обработка DTLS выполняется стеком NetX или NetX Duo без необходимости вмешательства пользователя.</span><span class="sxs-lookup"><span data-stu-id="929ee-231">Internally, all DTLS network traffic and processing is handled by the NetX/NetXDuo stack without requiring user intervention.</span></span> <span data-ttu-id="929ee-232">Однако протокол DTLS накладывает определенные требования, которые должны выполняться отдельно от базового сетевого стека.</span><span class="sxs-lookup"><span data-stu-id="929ee-232">However, DTLS has some specific requirements that must be handled separately from the underlying network stack.</span></span> <span data-ttu-id="929ee-233">Для операций клиента DTLS эти параметры присваиваются блоку управления DTLS с именем \***NX_SECURE_DTLS_SESSION** _.</span><span class="sxs-lookup"><span data-stu-id="929ee-233">DTLS Client operation these parameters are assigned to the DTLS control block called \***NX_SECURE_DTLS_SESSION** _.</span></span> <span data-ttu-id="929ee-234">Для операций сервера DTLS блок управления называется _ *_NX_SECURE_DTLS_SERVER_*\* и содержит инфраструктуру, необходимую для работы с несколькими сеансами DTLS через один UDP-порт. Обратите внимание, что это отличается от протокола TLS, в котором каждый сеанс TLS привязывается к отдельному TCP-порту.</span><span class="sxs-lookup"><span data-stu-id="929ee-234">For DTLS Server operation, control block is called _ *_NX_SECURE_DTLS_SERVER_*\* and it contains the infrastructure needed to handle multiple DTLS sessions on a single UDP port – note that this is different from TLS where a each TLS session is bound to a single TCP port.</span></span>

<span data-ttu-id="929ee-235">В приложении можно включить два режима DTLS, сервер или клиент (но только один режим на сокет NetX). Каждый из режимов имеет собственные требования. Они описаны ниже.</span><span class="sxs-lookup"><span data-stu-id="929ee-235">The two DTLS modes, Server and Client, may be enabled in an application (but only one mode per NetX socket), and each have their own specific requirements, detailed below.</span></span>

### <a name="initialization--dtls-server"></a><span data-ttu-id="929ee-236">Инициализация: сервер DTLS</span><span class="sxs-lookup"><span data-stu-id="929ee-236">Initialization – DTLS Server</span></span>

<span data-ttu-id="929ee-237">Режим NetX Secure DTLS Server отличается от режима сервера TLS, так как в качестве базового сетевого транспортного протокола используется UDP.</span><span class="sxs-lookup"><span data-stu-id="929ee-237">NetX Secure DTLS Server mode differs from TLS Server mode due to the use of UDP for the underlying network transport protocol.</span></span> <span data-ttu-id="929ee-238">При использовании протокола TCP порт привязывается к одному удаленному узлу на время сеанса TLS.</span><span class="sxs-lookup"><span data-stu-id="929ee-238">With TCP, the port is bound to a single remote host for the duration of the TLS session.</span></span> <span data-ttu-id="929ee-239">В протоколе UDP не сохраняются сведения о состоянии удаленного узла, поэтому все запросы DTLS от разных узлов будут приниматься на один и тот же интерфейс UDP.</span><span class="sxs-lookup"><span data-stu-id="929ee-239">UDP has no notion of state with regard to the remote host so DTLS requests from different hosts will all be received on the same UDP interface.</span></span> <span data-ttu-id="929ee-240">Поэтому протокол DTLS должен обрабатывать состояние сеанса, а не полагаться на сокет, как в случае с протоколами TLS и TCP.</span><span class="sxs-lookup"><span data-stu-id="929ee-240">Therefore, DTLS must maintain session state rather than relying on the socket as with TLS and TCP.</span></span> <span data-ttu-id="929ee-241">По этой причине блок управления сервером DTLS (NX_SECURE_DTLS_SERVER) поддерживает сопоставление сведений об удаленном узле (IP-адрес и порт) с сеансами DTLS.</span><span class="sxs-lookup"><span data-stu-id="929ee-241">For this reason, the DTLS Server control block (NX_SECURE_DTLS_SERVER) maintains a mapping of remote host information (IP address and port) to DTLS sessions.</span></span> <span data-ttu-id="929ee-242">Все входящие данные на сокете UDP, назначенном серверу DTLS, будут сопоставляться с существующим или новым сеансом DTLS, в зависимости от удаленного узла.</span><span class="sxs-lookup"><span data-stu-id="929ee-242">All incoming data on the UDP socket assigned to a DTLS Server will be mapped to an existing or new DTLS session based on the remote host.</span></span> <span data-ttu-id="929ee-243">По этой причине, помимо параметров клиента TLS и DTLS, при создании сервера DTLS требуется указать ряд дополнительных параметров.</span><span class="sxs-lookup"><span data-stu-id="929ee-243">For this reason, the DTLS server creation requires several additional parameters beyond what TLS and DTLS Client need.</span></span>

<span data-ttu-id="929ee-244">В дополнение к блоку управления сервером DTLS, комплектам шифров TLS и области временных данных шифров или буферу метаданных, серверам DTLS требуется буфер для обслуживания сеансов DTLS и буфер для повторной сборки пакетов, используемый для расшифровки входящих записей DTLS.</span><span class="sxs-lookup"><span data-stu-id="929ee-244">In addition to the DTLS Server control block, TLS ciphersuites, and cipher scratchspace/metadata buffer, DTLS Servers require a buffer to maintain DTLS sessions and a packet reassembly buffer used to decrypt incoming DTLS records.</span></span>

<span data-ttu-id="929ee-245">Помимо буферов сеансов, серверам DTLS требуется *цифровой сертификат*— документ, используемый для идентификации сервера TLS для подключающегося клиента TLS, а также сертификаты, соответствующие *закрытому ключу* (обычно для алгоритма шифрования RSA).</span><span class="sxs-lookup"><span data-stu-id="929ee-245">In addition to the session buffers, DTLS Servers require a *Digital Certificate*, which is a document used to identify the TLS server to the connecting TLS client, and the certificates corresponding *Private Key*, usually for the RSA encryption algorithm.</span></span> <span data-ttu-id="929ee-246">Стандарт X.509 Международного союза электросвязи определяет формат сертификата, используемого протоколом TLS или DTLS, и существует множество служебных программ для создания цифровых сертификатов X.509.</span><span class="sxs-lookup"><span data-stu-id="929ee-246">The International Telecommunications Union X.509 standard specifies the certificate format used by TLS/DTLS and there are numerous utilities for creating X.509 digital certificates.</span></span>

<span data-ttu-id="929ee-247">Для NetX Secure DTLS сертификат X.509 должен быть зашифрован в двоичном формате Distinguished Encoding Rules (DER) ASN.1.</span><span class="sxs-lookup"><span data-stu-id="929ee-247">For NetX Secure DTLS, the X.509 certificate must be binary-encoded using the Distinguished Encoding Rules (DER) format of ASN.1.</span></span> <span data-ttu-id="929ee-248">DER — это стандартный сетевой двоичный формат TLS для сертификатов.</span><span class="sxs-lookup"><span data-stu-id="929ee-248">DER is the standard TLS over-the-wire binary format for certificates.</span></span>

<span data-ttu-id="929ee-249">Закрытый ключ, связанный с предоставленным сертификатом, должен быть зашифрован в формате DER с открытым ключом (PKCS) № 1.</span><span class="sxs-lookup"><span data-stu-id="929ee-249">The private key associated with the provided certificate must be in DER-Encoded PKCS#1 format.</span></span> <span data-ttu-id="929ee-250">Закрытый ключ используется только на устройстве и никогда не передается по сети.</span><span class="sxs-lookup"><span data-stu-id="929ee-250">The private key is only used on the device and will never be transmitted over the wire.</span></span> <span data-ttu-id="929ee-251">Обеспечьте безопасность закрытых ключей, так как они обеспечивают защиту при обмене данными по протоколу TLS или DTLS.</span><span class="sxs-lookup"><span data-stu-id="929ee-251">Keep private keys safe as they provide the security for TLS/DTLS communications!</span></span>

<span data-ttu-id="929ee-252">Чтобы инициализировать сертификат сервера DTLS, приложение должно предоставить указатель на буфер, содержащий сертификат X.509, зашифрованный в формате DER, и (необязательно) данные закрытого ключа RSA, зашифрованные в формате DER с открытым ключом (PKCS) № 1, с помощью службы ***nx_secure_x509_certificate_intialize***, которая заполняет структуру **NX_SECURE_X509_CERT** соответствующими данными сертификата для протокола TLS.</span><span class="sxs-lookup"><span data-stu-id="929ee-252">To initialize the DTLS Server certificate, the application must provide a pointer to a buffer containing the DER-encoded X.509 certificate and optional DER-encoded PKCS#1 RSA private key data using the ***nx_secure_x509_certificate_intialize*** service, which populates the **NX_SECURE_X509_CERT** structure with the appropriate certificate data for use by TLS.</span></span>

<span data-ttu-id="929ee-253">После инициализации сертификата сервера его необходимо добавить в блок управления TLS с помощью службы ***nx_secure_dtls_server_local_certificate_add***.</span><span class="sxs-lookup"><span data-stu-id="929ee-253">Once the server certificate has been initialized, it must be added to the TLS control block using the ***nx_secure_dtls_server_local_certificate_add*** service.</span></span>

<span data-ttu-id="929ee-254">После добавления сертификата сервера в блок управления сервером DTLS этот сервер можно использовать для безопасного обмена данными по протоколу DTLS (см. пример выше).</span><span class="sxs-lookup"><span data-stu-id="929ee-254">Once the server’s certificate has been added to the DTLS Server control block, the server can be used for secure DTLS communications (see example above).</span></span>

### <a name="initialization--dtls-client"></a><span data-ttu-id="929ee-255">Инициализация: клиент DTLS</span><span class="sxs-lookup"><span data-stu-id="929ee-255">Initialization – DTLS Client</span></span>

<span data-ttu-id="929ee-256">Режим NetX Secure DTLS Client прост в работе по сравнению с сервером DTLS, так как в нем используется только одно исходящее подключение к удаленному узлу через сокет UDP.</span><span class="sxs-lookup"><span data-stu-id="929ee-256">NetX Secure DTLS Client mode is simple in operation compared to the DTLS server since there is only a single outgoing connection to the remote host over the UDP socket.</span></span>

<span data-ttu-id="929ee-257">Для настройки клиента DTLS требуется *хранилище доверенных сертификатов*, которое представляет собой коллекцию цифровых сертификатов в кодировке X.509 из доверенных центров сертификации (ЦС).</span><span class="sxs-lookup"><span data-stu-id="929ee-257">To setup a DTLS Client, it requires a *Trusted Certificate Store*, which is a collection of X.509-encoded digital certificates from trusted Certificate Authorities (CA’s).</span></span> <span data-ttu-id="929ee-258">Предполагается, что эти сертификаты являются доверенными для протокола DTLS. Они служат базой для проверки подлинности сертификатов, предоставляемых сущностями сервера DTLS клиентскому приложению NetX Secure DTLS.</span><span class="sxs-lookup"><span data-stu-id="929ee-258">These certificates are assumed by the DTLS protocol to be “trusted” and serve as the basis for authenticating certificates provided by DTLS server entities to the NetX Secure DTLS Client application.</span></span>

<span data-ttu-id="929ee-259">Сертификат доверенного ЦС может быть либо *самозаверяющим*, либо подписанным другим центром сертификации. В последнем случае сертификат называется сертификатом *промежуточного ЦС* (ICA).</span><span class="sxs-lookup"><span data-stu-id="929ee-259">A trusted CA certificate may either be *self-signed* or signed by another CA, in which case that certificate is called an *Intermediate CA* (ICA).</span></span> <span data-ttu-id="929ee-260">В типичном приложении TLS или DTLS сервер предоставляет сертификаты ICA вместе с сертификатом сервера, но единственным требованием для успешной проверки подлинности является то, что цепочка издателей (сертификатов, используемых для подписи других сертификатов) должна отслеживаться от сертификата сервера до сертификата доверенного ЦС в хранилище доверенных сертификатов.</span><span class="sxs-lookup"><span data-stu-id="929ee-260">In a typical TLS/DTLS application, the server provides the ICA certificates along with its server certificate, but the only requirement for successful authentication is that a chain of issuers (certificates used to sign other certificates) can be traced from the server certificate back to a trusted CA certificate in the Trusted Certificate Store.</span></span> <span data-ttu-id="929ee-261">Эта цепочка называется *цепочкой доверия* или *цепочкой сертификатов*.</span><span class="sxs-lookup"><span data-stu-id="929ee-261">This chain is known as a *chain of trust* or *certificate chain*.</span></span>

<span data-ttu-id="929ee-262">Чтобы инициализировать сертификат доверенного ЦС или сертификат ICA, приложение должно предоставить указатель на буфер, содержащий сертификат X.509, зашифрованный в формате DER, с помощью службы ***nx_secure_x509_certificate_intialize** _, которая заполняет структуру _ *NX_SECURE_X509_CERT** соответствующими данными сертификата для протокола TLS.</span><span class="sxs-lookup"><span data-stu-id="929ee-262">To initialize a trusted CA or ICA certificate, the application must provide a pointer to a buffer containing the DER-encoded X.509 certificate using the ***nx_secure_x509_certificate_intialize** _ service, which populates the _ *NX_SECURE_X509_CERT** structure with the appropriate certificate data for use by TLS.</span></span>

<span data-ttu-id="929ee-263">Клиенту DTLS также нужно пространство, выделяемое для входящего сертификата сервера (при условии, что не используется режим общего ключа), и буфер для сборки пакетов в записи DTLS, предназначенные для расшифровки.</span><span class="sxs-lookup"><span data-stu-id="929ee-263">The DTLS Client also needs space for the incoming server certificate to be allocated (assuming a Pre-Shared Key mode is not being used) and a buffer for assembling packets into DTLS records to be decrypted.</span></span> <span data-ttu-id="929ee-264">Эти буферы передаются в качестве параметров в службу ***nx_secure_dtls_session_create*** (дополнительные сведения см. в справочнике по API).</span><span class="sxs-lookup"><span data-stu-id="929ee-264">These buffers are passed in as parameters to the ***nx_secure_dtls_session_create*** service (see API reference for more information).</span></span>

<span data-ttu-id="929ee-265">После этого доверенные сертификаты, которые были инициализированы, добавляются в блок управления сеансом DTLS с помощью службы ***nx_secure_dtls_session_trusted_certificate_add***.</span><span class="sxs-lookup"><span data-stu-id="929ee-265">Trusted certificates that have been initialized are then added to the created DTLS session control block using the ***nx_secure_dtls_session_trusted_certificate_add*** service.</span></span> <span data-ttu-id="929ee-266">Сбой при добавлении сертификата приведет к сбою сеанса клиента DTLS, так как протокол DTLS не сможет проверить подлинность удаленных узлов сервера.</span><span class="sxs-lookup"><span data-stu-id="929ee-266">Failure to add a certificate will cause the DTLS Client session to fail as there will be no way for the DTLS protocol to authenticate remote server hosts.</span></span>

<span data-ttu-id="929ee-267">После создания хранилища доверенных сертификатов можно будет использовать сеанс для безопасного подключения клиента TLS.</span><span class="sxs-lookup"><span data-stu-id="929ee-267">Once the Trusted Certificate Store has been created the session may be used to establish a secure TLS Client connection.</span></span>

### <a name="application-interface-calls"></a><span data-ttu-id="929ee-268">Вызовы интерфейса приложения</span><span class="sxs-lookup"><span data-stu-id="929ee-268">Application Interface Calls</span></span>

<span data-ttu-id="929ee-269">Приложения NetX Secure DTLS обычно будут выполнять вызовы функций из потоков приложения, работающих в ОСРВ ThreadX.</span><span class="sxs-lookup"><span data-stu-id="929ee-269">NetX Secure DTLS applications will typically make function calls from within application threads running under the ThreadX RTOS.</span></span> <span data-ttu-id="929ee-270">В некоторых случаях инициализация, особенно для базовых протоколов сетевого взаимодействия (например, UDP и IP), может быть вызвана из ***tx_application_define*** .</span><span class="sxs-lookup"><span data-stu-id="929ee-270">Some initialization, particularly for the underlying network communications protocols (e.g. UDP and IP) may be called from \***tx_application_define\*.**</span></span> <span data-ttu-id="929ee-271">Дополнительные сведения об инициализации сетевого взаимодействия см. в руководстве пользователя NetX или NetX Duo.</span><span class="sxs-lookup"><span data-stu-id="929ee-271">See the NetX/NetXDuo User Guide for more information on initializing network communications.</span></span>

<span data-ttu-id="929ee-272">Протокол DTLS активно использует процедуры шифрования, которые являются ресурсоемкими операциями.</span><span class="sxs-lookup"><span data-stu-id="929ee-272">DTLS makes heavy use of encryption routines which are processor-intensive operations.</span></span> <span data-ttu-id="929ee-273">Как правило, эти операции будут выполняться в контексте вызывающего потока.</span><span class="sxs-lookup"><span data-stu-id="929ee-273">Generally, these operations will be performed within the context of calling thread.</span></span>

### <a name="dtls-session-start"></a><span data-ttu-id="929ee-274">Начало сеанса DTLS</span><span class="sxs-lookup"><span data-stu-id="929ee-274">DTLS Session Start</span></span>

<span data-ttu-id="929ee-275">Для работы протокола DTLS требуется базовый сетевой протокол транспортного уровня.</span><span class="sxs-lookup"><span data-stu-id="929ee-275">DTLS requires an underlying transport-layer network protocol in order to function.</span></span> <span data-ttu-id="929ee-276">Обычно используется протокол TCP.</span><span class="sxs-lookup"><span data-stu-id="929ee-276">The protocol typically used is TCP.</span></span> <span data-ttu-id="929ee-277">Чтобы установить сеанс NetX Secure TLS, необходимо создать **NX_UDP_SOCKET** и передать его в службу **_NX_SECURE_DTLS_CLIENT_SESSION_START_** для клиентов DTLS.</span><span class="sxs-lookup"><span data-stu-id="929ee-277">In order to establish a NetX Secure TLS session an **NX_UDP_SOCKET** must be created and passed into the **_nx_secure_dtls_client_session_start_** service for DTLS Clients.</span></span>

<span data-ttu-id="929ee-278">Серверы DTLS работают иначе.</span><span class="sxs-lookup"><span data-stu-id="929ee-278">DTLS Servers operate differently.</span></span> <span data-ttu-id="929ee-279">Сокет UDP, используемый для входящих запросов клиентов DTLS, содержится в блоке управления NX_SECURE_DTLS_SERVER и инициализируется в вызове службы \***nx_secure_dtls_server_create** _, которая принимает локальный UDP-порт в качестве параметра.</span><span class="sxs-lookup"><span data-stu-id="929ee-279">The UDP socket used for incoming DTLS Client requests is contained within the NX_SECURE_DTLS_SERVER control block and is initialized in the call to \***nx_secure_dtls_server_create** _, which takes the local UDP port as a parameter.</span></span> <span data-ttu-id="929ee-280">Затем служба _*_nx_secure_dtls_server_start_*_ используется для запуска сервера DTLS для обработки входящих запросов.</span><span class="sxs-lookup"><span data-stu-id="929ee-280">The service _*_nx_secure_dtls_server_start_*_ is then used to start the DTLS Server to handle incoming requests.</span></span> <span data-ttu-id="929ee-281">Все входящие запросы обрабатываются в подпрограммах обратного вызова (одна для подключений и одна для получения уведомлений), предоставленных для _nx_secure_dtls_server_create\*. Приложение обрабатывает запуск сеанса DTLS при получении уведомления о подключении (обратный вызов уведомления о подключении выполняет DTLS) путем вызова \***nx_secure_dtls_server_session_start**_.</span><span class="sxs-lookup"><span data-stu-id="929ee-281">All incoming requests are handled in callback routines provided to _nx_secure_dtls_server_create\*: one for connections and one for receive notifications. It is up to the application to handle starting the DTLS session when a connection notification is received (the connect notify callback is invoked by DTLS) by calling \***nx_secure_dtls_server_session_start**_.</span></span> <span data-ttu-id="929ee-282">Приложение также должно обрабатывать входящие данные при выполнении обратного вызова для уведомления о получении (который следует после завершения подтверждения DTLS), вызывая службу _\*_nx_secure_dtls_session_receive_\*\*.</span><span class="sxs-lookup"><span data-stu-id="929ee-282">The application also must handle incoming data when the receive notify callback is invoked (which follows a completed DTLS handshake) by calling _\*_nx_secure_dtls_session_receive_\*\*.</span></span> <span data-ttu-id="929ee-283">Подробные сведения об этом приведены в примере выше, а также в справочнике по API для каждой из перечисленных ранее служб.</span><span class="sxs-lookup"><span data-stu-id="929ee-283">The details of this are provided in the example above and in the API reference for each of the above mentioned services.</span></span>

### <a name="dtls-packet-allocation"></a><span data-ttu-id="929ee-284">Выделение пакетов DTLS</span><span class="sxs-lookup"><span data-stu-id="929ee-284">DTLS Packet Allocation</span></span>

<span data-ttu-id="929ee-285">NetX Secure DTLS использует ту же структуру пакетов, что и NetX TCP или NetX Duo TCP (***NX_PACKET** _), за исключением того, что вместо службы _*_nx_packet_allocate_\*_ необходимо вызвать службу _ \*_nx_secure_dtls_packet_allocate_\*\*, чтобы правильно выделить пространство для заголовка DTLS.</span><span class="sxs-lookup"><span data-stu-id="929ee-285">NetX Secure DTLS uses the same packet structure as NetX/NetXDuo TCP (***NX_PACKET** _) except that instead of calling the _*_nx_packet_allocate_*_ service, the _ *_nx_secure_dtls_packet_allocate_** service must be called so that space for the DTLS header may be allocated properly.</span></span>

### <a name="dtls-session-send"></a><span data-ttu-id="929ee-286">Отправка данных в сеансе DTLS</span><span class="sxs-lookup"><span data-stu-id="929ee-286">DTLS Session Send</span></span>

<span data-ttu-id="929ee-287">После начала сеанса TLS приложение может отправить данные с помощью службы ***nx_secure_dtls_session_send***.</span><span class="sxs-lookup"><span data-stu-id="929ee-287">Once the TLS session has started, the application may send data using the ***nx_secure_dtls_session_send*** service.</span></span> <span data-ttu-id="929ee-288">Служба send работает как служба \***nx_udp_socket_send** _. Она принимает структуру данных _ \*_NX_PACKET_\*\*, содержащую отправляемые данные, целевой IP-адрес и целевой UDP-порт.</span><span class="sxs-lookup"><span data-stu-id="929ee-288">The send service is identical in use to the ***nx_udp_socket_send** _ service, taking an _ *_NX_PACKET_** data structure containing the data being sent, a target IP address, and a target UDP port.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="929ee-289">При отправке данных с помощью службы nx_secure_dtls_session_send важно использовать те же IP-адрес и порт, которые использовались для установления сеанса DTLS, если не существует механизма для динамического перемещения сеанса на новый адрес и UDP-порт (что не распространено).</span><span class="sxs-lookup"><span data-stu-id="929ee-289">When sending data using nx_secure_dtls_session_send, it is important to use the same IP address and port that were used to establish the DTLS session, unless there is a mechanism in place to move the session to a new address and UDP port on-the-fly (this is not common).</span></span>

<span data-ttu-id="929ee-290">Все данные, передаваемые по протоколу DTLS, перед отправкой шифруются с помощью стека NX Secure DTLS и настроенных процедур шифрования.</span><span class="sxs-lookup"><span data-stu-id="929ee-290">Any data sent over DTLS will be encrypted by the NX Secure DTLS stack and the configured encryption routines before being sent.</span></span>

### <a name="dtls-session-receive"></a><span data-ttu-id="929ee-291">Получение данных в сеансе DTLS</span><span class="sxs-lookup"><span data-stu-id="929ee-291">DTLS Session Receive</span></span>

<span data-ttu-id="929ee-292">После начала сеанса DTLS приложение может начать получение данных с помощью службы \***nx_secure_dtls_session_send** _.</span><span class="sxs-lookup"><span data-stu-id="929ee-292">Once the DTLS session has started, the application may begin receiving data using the \***nx_secure_Dtls_session_receive** _ service.</span></span> <span data-ttu-id="929ee-293">Как и в случае отправки данных в сеансе DTLS, эта служба работает аналогично службе _\*_nx_tcp_socket_receive_\*\*, за исключением того, что входящие данные расшифровываются и проверяются стеком DTLS перед возвращением в структуру пакета.</span><span class="sxs-lookup"><span data-stu-id="929ee-293">Like the DTLS Session send, this service is identical in use to _\*_nx_udp_socket_receive_\*\*, except that the incoming data is decrypted and verified by the DTLS stack before being returned in the packet structure.</span></span>

### <a name="tls-session-close"></a><span data-ttu-id="929ee-294">Закрытие сеанса TLS</span><span class="sxs-lookup"><span data-stu-id="929ee-294">TLS Session Close</span></span>

<span data-ttu-id="929ee-295">По завершении сеанса DTLS и клиент DTLS, и сервер DTLS должны отправить оповещение CloseNotify другой стороне, чтобы окончательно завершить сеанс.</span><span class="sxs-lookup"><span data-stu-id="929ee-295">Once a DTLS session is complete, both the DTLS client and server must send a CloseNotify alert to the other side to shut down the session.</span></span> <span data-ttu-id="929ee-296">Обе стороны должны получить и обработать это оповещение, чтобы успешно завершить сеанс.</span><span class="sxs-lookup"><span data-stu-id="929ee-296">Both sides must receive and process the alert to ensure a successful session shutdown.</span></span>

<span data-ttu-id="929ee-297">Если удаленный узел отправляет оповещение CloseNotify, все вызовы службы ***nx_secure_dtls_session_receive** _ обрабатывают его, отправляют соответствующее оповещение обратно на удаленный узел и возвращают значение _*_NX_SECURE_TLS_SESSION_CLOSED_\*\*.</span><span class="sxs-lookup"><span data-stu-id="929ee-297">If the remote host sends a CloseNotify alert, any calls to the ***nx_secure_dtls_session_receive** _ service will process the alert, send the corresponding alert back to the remote host, and return a value of _*_NX_SECURE_TLS_SESSION_CLOSED_\*\*.</span></span> <span data-ttu-id="929ee-298">После закрытия сеанса дальнейшие попытки отправить или получить данные в этом сеансе DTLS завершатся ошибкой.</span><span class="sxs-lookup"><span data-stu-id="929ee-298">Once the session is closed, any further attempts to send or receive data with that DTLS session will fail.</span></span>

<span data-ttu-id="929ee-299">Если приложению нужно закрыть сеанс TLS, необходимо вызвать службу \***nx_secure_dtls_session_end** _.</span><span class="sxs-lookup"><span data-stu-id="929ee-299">If the application wishes to close the TLS session, the \***nx_secure_dtls_session_end** _ service must be called.</span></span> <span data-ttu-id="929ee-300">Эта служба отправит оповещение CloseNotify и обработает ответное оповещение CloseNotify.</span><span class="sxs-lookup"><span data-stu-id="929ee-300">The service will send the CloseNotify alert and process the response CloseNotify.</span></span> <span data-ttu-id="929ee-301">Если ответ не получен, будет возвращено значение ошибки _ \*_NX_SECURE_TLS_SESSION_CLOSE_FAIL_\*\*, указывающее на то, что сеанс DTLS не был корректно завершен, возможно из-за нарушения безопасности.</span><span class="sxs-lookup"><span data-stu-id="929ee-301">If the response is not received, an error value of _ *_NX_SECURE_TLS_SESSION_CLOSE_FAIL_*\* will be returned, indicating that the DTLS session was not cleanly shutdown, a possible security breach.</span></span>

### <a name="tlsdtls-alerts"></a><span data-ttu-id="929ee-302">Оповещения TLS и DTLS</span><span class="sxs-lookup"><span data-stu-id="929ee-302">TLS/DTLS Alerts</span></span>

<span data-ttu-id="929ee-303">Протоколы TLS и DTLS предназначены для обеспечения максимальной безопасности, поэтому любое аномальное поведение в протоколе считается потенциальным нарушением безопасности.</span><span class="sxs-lookup"><span data-stu-id="929ee-303">TLS/DTLS is designed to provide maximum security, so any errant behavior in the protocol is considered a potential security breach.</span></span> <span data-ttu-id="929ee-304">По этой причине все ошибки, возникающие при обработке, шифровании или расшифровке сообщений, считаются неустранимыми ошибками, которые немедленно завершают подтверждение или сеанс.</span><span class="sxs-lookup"><span data-stu-id="929ee-304">For this reason, any errors in message processing or encryption/decryption are considered fatal errors that terminate the handshake or session immediately.</span></span>

<span data-ttu-id="929ee-305">Хотя обработка ошибок в локальном приложении относительно проста, удаленный узел должен быть уведомлен о том, что произошла ошибка, чтобы правильно обработать ситуацию и предотвратить возможные дальнейшие нарушения безопасности.</span><span class="sxs-lookup"><span data-stu-id="929ee-305">While handling errors in a local application is relatively straightforward, the remote host needs to know that an error has occurred in order to properly handle the situation and prevent any further possible security breaches.</span></span> <span data-ttu-id="929ee-306">По этой причине при любой ошибке протокол TLS или DTLS отправляет сообщение *Alert* на удаленный узел.</span><span class="sxs-lookup"><span data-stu-id="929ee-306">For this reason, TLS/DTLS will send an *Alert* message to the remote host upon any error.</span></span>

<span data-ttu-id="929ee-307">Сообщения Alert обрабатываются так же, как и любые другие сообщения TLS и DTLS, и шифруются во время сеанса, чтобы предотвратить сбор информации злоумышленником из указанного типа оповещения.</span><span class="sxs-lookup"><span data-stu-id="929ee-307">Alerts are treated in the same manner as any other TLS/DTLS messages and are encrypted during the session to prevent an attacker from gathering information from the type of alert provided.</span></span> <span data-ttu-id="929ee-308">Во время подтверждения отправляются ограниченные оповещения, чтобы уменьшить объем сведений, которые могут быть получены потенциальным злоумышленником.</span><span class="sxs-lookup"><span data-stu-id="929ee-308">During the handshake, the alerts sent are limited in scope to limit the amount of information that could be obtained by a potential attacker.</span></span>

<span data-ttu-id="929ee-309">Оповещение CloseNotify, используемое для закрытия сеанса TLS или DTLS, является единственным оповещением не об неустранимом сбое.</span><span class="sxs-lookup"><span data-stu-id="929ee-309">The CloseNotify alert, used to close the TLS/DTLS session, is the only non-fatal alert.</span></span> <span data-ttu-id="929ee-310">Хотя оно считается оповещением и отправляется в виде сообщения Alert, отличие CloseNotify от других оповещений состоит в том, что оно не указывает на ошибку.</span><span class="sxs-lookup"><span data-stu-id="929ee-310">While it is considered an alert and sent as an alert message, a CloseNotify is unlike other alerts in that it does not indicate an error has occurred.</span></span>

### <a name="tlsdtls-session-renegotiation-and-resumption"></a><span data-ttu-id="929ee-311">Повторное согласование и возобновление сеанса TLS или DTLS</span><span class="sxs-lookup"><span data-stu-id="929ee-311">TLS/DTLS Session Renegotiation and Resumption</span></span>

<span data-ttu-id="929ee-312">Протокол TLS поддерживает понятие "повторное согласование", которое представляет собой просто согласование параметров сеанса TLS в контексте существующего сеанса TLS.</span><span class="sxs-lookup"><span data-stu-id="929ee-312">TLS supports the notion of “renegotiation” which is simply a renegotiation of the TLS session parameters within the context of an existing TLS session.</span></span>

<span data-ttu-id="929ee-313">*Возобновление* сеанса TLS не следует путать с *повторным согласованием* сеанса, несмотря на некоторое сходство.</span><span class="sxs-lookup"><span data-stu-id="929ee-313">TLS session *resumption* should not be confused with session *renegotiation*, despite some similarities.</span></span> <span data-ttu-id="929ee-314">*Повторное согласование* сеанса включает в себя запуск нового подтверждения в существующем сеансе TLS, тогда как *возобновление* сеанса является необязательной функцией, включающей в себя перезапуск сеанса TLS без полного подтверждения TLS.</span><span class="sxs-lookup"><span data-stu-id="929ee-314">Where session *renegotiation* involves starting a new handshake within an existing TLS session, session *resumption* is a purely optional feature that involves restarting a closed TLS session without performing a complete TLS handshake.</span></span>

<span data-ttu-id="929ee-315">NX Secure DTLS обрабатывает входящие запросы на повторное согласование от удаленных узлов.</span><span class="sxs-lookup"><span data-stu-id="929ee-315">NX Secure DTLS handles incoming renegotiation requests from remote hosts.</span></span> <span data-ttu-id="929ee-316">NX Secure DTLS **не** поддерживает возобновление сеансов.</span><span class="sxs-lookup"><span data-stu-id="929ee-316">It does **not** support session resumption.</span></span> <span data-ttu-id="929ee-317">Более подробное описание этих функций можно найти в главе 3 руководства пользователя NetX Secure TLS.</span><span class="sxs-lookup"><span data-stu-id="929ee-317">A more complete discussion of these features can be found in Chapter 3 of the NetX Secure TLS User Guide.</span></span>

### <a name="protocol-layering"></a><span data-ttu-id="929ee-318">Уровень протокола</span><span class="sxs-lookup"><span data-stu-id="929ee-318">Protocol Layering</span></span>

<span data-ttu-id="929ee-319">Протокол TLS (и, следовательно, DTLS) располагается между транспортным уровнем (например, протоколы TCP или UDP) и прикладным уровнем.</span><span class="sxs-lookup"><span data-stu-id="929ee-319">The TLS protocol (and therefore DTLS as well) fits into the networking stack between the transport layer (e.g. TCP or UDP) and the application layer.</span></span> <span data-ttu-id="929ee-320">Протокол TLS иногда считают протоколом транспортного уровня (отсюда и его название — TLS, *Transport Layer* Security (безопасность транспортного уровня)), но так как он действует как приложение по отношению к базовым сетевым протоколам, иногда его относят к прикладному уровню.</span><span class="sxs-lookup"><span data-stu-id="929ee-320">TLS is sometimes considered a transport-layer protocol (hence *Transport Layer* Security) but because it acts as an application with regard to the underlying network protocols it is sometimes grouped into the application layer.</span></span>

<span data-ttu-id="929ee-321">Для протокола TLS требуется протокол транспортного уровня, поддерживающий доставку по порядку и без потерь, например протокол TCP.</span><span class="sxs-lookup"><span data-stu-id="929ee-321">TLS requires a transport layer protocol that supports in-order and lossless delivery, such as TCP.</span></span> <span data-ttu-id="929ee-322">В соответствии с этим требованием протокол TLS не может выполняться на основе протокола UDP, так как UDP не гарантирует доставку датаграмм.</span><span class="sxs-lookup"><span data-stu-id="929ee-322">Due to this requirement, TLS cannot run on top of UDP since UDP does not guarantee delivery of datagrams.</span></span> <span data-ttu-id="929ee-323">Для приложений, которым требуется безопасность TLS по протоколу передачи датаграмм, например UDP, используется протокол *DTLS*, который является модифицированной версией протокола TLS.</span><span class="sxs-lookup"><span data-stu-id="929ee-323">*DTLS* is a modified version of TLS, is used for applications that need the security of TLS over a datagram protocol like UDP.</span></span>

![Схема уровней протокола TLS.](media/image6.png)

<span data-ttu-id="929ee-325">**Рисунок 4. Уровни протоколов TCP/IP, UDP, TLS и DTLS**</span><span class="sxs-lookup"><span data-stu-id="929ee-325">**Figure 4- TCP/IP, UDP and TLS/DTLS protocol layers**</span></span>

## <a name="network-communications-security-and-encryption"></a><span data-ttu-id="929ee-326">Безопасность и шифрование сетевых подключений</span><span class="sxs-lookup"><span data-stu-id="929ee-326">Network Communications Security and Encryption</span></span>

<span data-ttu-id="929ee-327">Обеспечение безопасности взаимодействия через общедоступные сети и Интернет является важнейшей темой, которой посвящено огромное количество книг, статей и решений.</span><span class="sxs-lookup"><span data-stu-id="929ee-327">Securing communications over public networks and the Internet is a critically important topic and the subject of vast numbers of books, articles, and solutions.</span></span> <span data-ttu-id="929ee-328">Эта тема является немыслимо сложной, но ее можно упростить до следующей идеи: нужно отправлять информацию по сети так, чтобы только указанный адресат мог получить доступ к этой информации или изменить ее.</span><span class="sxs-lookup"><span data-stu-id="929ee-328">The topic is mind-bogglingly complex, but can be reduced to a simple idea: sending information over a network so that only the intended target can access or change that information.</span></span> <span data-ttu-id="929ee-329">Эта идея порождает три важных понятия: секретность, целостность и проверка подлинности.</span><span class="sxs-lookup"><span data-stu-id="929ee-329">This breaks down into three important concepts: secrecy, integrity, and authentication.</span></span> <span data-ttu-id="929ee-330">Протокол TLS или DTLS предоставляет решения для всех этих трех понятий.</span><span class="sxs-lookup"><span data-stu-id="929ee-330">The TLS/DTLS protocol provides solutions for all three.</span></span>

<span data-ttu-id="929ee-331">Шифрование используется в протоколах TLS и DTLS различными способами для обеспечения секретности, целостности и проверки подлинности.</span><span class="sxs-lookup"><span data-stu-id="929ee-331">Encryption is used in different ways to provide secrecy, integrity, and authentication within the TLS and DTLS protocols.</span></span> <span data-ttu-id="929ee-332">Шифрование должно применяться к протоколу TLS или DTLS при создании экземпляра сеанса или сервера, так как протокол TLS предоставляет гибкую платформу для использования шифрования, а не само шифрование.</span><span class="sxs-lookup"><span data-stu-id="929ee-332">The encryption must be supplied to TLS or DTLS upon creation of a session or server instance as TLS provides a flexible framework for using encryption and not the encryption itself.</span></span> <span data-ttu-id="929ee-333">NetX Secure DTLS предоставляет необходимые для большинства приложений процедуры шифрования, поэтому вам не нужно беспокоиться о поиске соответствующих средств шифрования.</span><span class="sxs-lookup"><span data-stu-id="929ee-333">NetX Secure DTLS provides the necessary encryption routines for most applications so you do not have to be concerned about finding appropriate encryption.</span></span>

<span data-ttu-id="929ee-334">Более подробное описание этих тем можно найти в главе 3 руководства пользователя NetX Secure TLS.</span><span class="sxs-lookup"><span data-stu-id="929ee-334">A more detailed description of these topics can be found in Chapter 3 of the NetX Secure TLS User Guide.</span></span>

## <a name="tls-and-dtls-extensions"></a><span data-ttu-id="929ee-335">Расширения TLS и DTLS</span><span class="sxs-lookup"><span data-stu-id="929ee-335">TLS and DTLS Extensions</span></span>

<span data-ttu-id="929ee-336">Протокол TLS (а, следовательно, и протокол DTLS) предоставляет ряд расширений, которые обеспечивают дополнительные функциональные возможности для определенных приложений.</span><span class="sxs-lookup"><span data-stu-id="929ee-336">TLS (and therefore DTLS) provides a number of extensions that provide additional functionality for certain applications.</span></span> <span data-ttu-id="929ee-337">Эти расширения обычно передаются как часть сообщений ClientHello или ServerHello, указывая удаленному узлу намерение использовать расширение или предоставляя дополнительные сведения для установления безопасного сеанса TLS.</span><span class="sxs-lookup"><span data-stu-id="929ee-337">These extensions are typically sent as part of the ClientHello or ServerHello messages, indicating to a remote host the desire to use an extension or providing additional details for use in establishing the secure TLS session.</span></span>

<span data-ttu-id="929ee-338">NetX Secure DTLS поддерживает все расширения, используемые в NetX Secure TLS, а полное описание этих расширений можно найти в главе 3 руководства пользователя NetX Secure TLS.</span><span class="sxs-lookup"><span data-stu-id="929ee-338">NetX Secure DTLS supports all of the extensions found in NetX Secure TLS, and a complete description of those can be found in the NetX Secure TLS User Guide, Chapter 3.</span></span>

## <a name="authentication-methods"></a><span data-ttu-id="929ee-339">Способы проверки подлинности</span><span class="sxs-lookup"><span data-stu-id="929ee-339">Authentication Methods</span></span>

<span data-ttu-id="929ee-340">Протоколы TLS и DTLS предоставляют платформу для установления безопасного подключения между двумя устройствами по незащищенной сети, но часть проблемы заключается в том, чтобы определить подлинность устройства на другом конце этого подключения.</span><span class="sxs-lookup"><span data-stu-id="929ee-340">TLS and DTLS provide the framework for establishing a secure connection between two devices over an insecure network, but part of the problem is knowing the identity of the device on the other end of that connection.</span></span> <span data-ttu-id="929ee-341">Без механизма проверки подлинности удостоверений удаленных узлов злоумышленник легко сможет предоставить фальшивое доверенное устройство.</span><span class="sxs-lookup"><span data-stu-id="929ee-341">Without a mechanism for authenticating the identity of remote hosts, it becomes a trivial operation for an attacker to pose as a trusted device.</span></span>

<span data-ttu-id="929ee-342">Изначально может показаться, что использование IP-адресов, аппаратных MAC-адресов или DNS обеспечивает относительно высокий уровень надежности для идентификации узлов в сети, но, учитывая характер технологии TCP/IP и простоту подмены адресов и повреждения записей DNS (например, с помощью подделки записей кэша DNS), для протокола TLS требуется дополнительный уровень защиты от поддельных удостоверений.</span><span class="sxs-lookup"><span data-stu-id="929ee-342">Initially, it may seem that using IP addresses, hardware MAC addresses, or DNS would provide a relatively high level of confidence for identifying hosts on a network, but given the nature of TCP/IP technology and the ease with which addresses can be spoofed and DNS entries corrupted (e.g. through DNS cache poisoning), it becomes clear that TLS needs an additional layer of protection against fraudulent identities.</span></span>

<span data-ttu-id="929ee-343">Существует ряд механизмов, которые могут обеспечить этот дополнительный уровень проверки подлинности для TLS, но наиболее распространенным является *цифровой сертификат*.</span><span class="sxs-lookup"><span data-stu-id="929ee-343">There are various mechanisms that can provide this extra layer of authentication for TLS, but the most common is the *digital certificate.*</span></span> <span data-ttu-id="929ee-344">К другим механизмам относятся схемы на основе общих ключей (PSK) и паролей.</span><span class="sxs-lookup"><span data-stu-id="929ee-344">Other mechanisms include Pre-Shared Keys (PSK) and password schemes.</span></span>

### <a name="digital-cerificates"></a><span data-ttu-id="929ee-345">Цифровые сертификаты</span><span class="sxs-lookup"><span data-stu-id="929ee-345">Digital Cerificates</span></span>

<span data-ttu-id="929ee-346">Цифровые сертификаты — наиболее распространенный способ проверки подлинности удаленного узла в протоколе TLS.</span><span class="sxs-lookup"><span data-stu-id="929ee-346">Digital certificates are the most common method for authenticating a remote host in TLS.</span></span> <span data-ttu-id="929ee-347">По сути, цифровой сертификат — это документ с особым форматированием, который предоставляет идентификационные данные устройства в компьютерной сети.</span><span class="sxs-lookup"><span data-stu-id="929ee-347">Essentially, a digital certificate is a document with specific formatting that provides identity information for a device on a computer network.</span></span>

<span data-ttu-id="929ee-348">В протоколе TLS обычно используется формат X.509 — стандарт, разработанный Международным союзом электросвязи, хотя могут использоваться и другие форматы сертификатов, если узлы TLS могут согласовать используемый формат.</span><span class="sxs-lookup"><span data-stu-id="929ee-348">TLS normally uses a format called X.509, a standard developed by the International Telecommunication Union, though other formats of certificates may be used if the TLS hosts can agree on the format being used.</span></span> <span data-ttu-id="929ee-349">Стандарт X.509 определяет точный формат сертификатов и различные кодировки, которые можно использовать для создания цифрового документа.</span><span class="sxs-lookup"><span data-stu-id="929ee-349">X.509 defines a specific format for certificates and various encodings that can be used to produce a digital document.</span></span> <span data-ttu-id="929ee-350">Большинство сертификатов X.509, используемых с протоколом TLS, кодируется с использованием разновидности ASN.1 — еще одного стандарта связи.</span><span class="sxs-lookup"><span data-stu-id="929ee-350">Most X.509 certificates used with TLS are encoded using a variant of ASN.1, another telecommunications standard.</span></span> <span data-ttu-id="929ee-351">В ASN.1 доступны различные цифровые кодировки, но чаще всего для кодирования сертификатов TLS применяется стандарт DER (Distinguished Encoding Rules).</span><span class="sxs-lookup"><span data-stu-id="929ee-351">Within ASN.1 there are various digital encodings, but the most common encoding for TLS certificates is the Distinguished Encoding Rules (DER) standard.</span></span> <span data-ttu-id="929ee-352">DER — это упрощенное подмножество стандарта BER (Basic Encoding Rules) ASN.1, которое предназначено обеспечить однозначность и упростить анализ.</span><span class="sxs-lookup"><span data-stu-id="929ee-352">DER is a simplified subset of the ASN.1 Basic Encoding Rules (BER) that is designed to be unambiguous, making parsing easier.</span></span> <span data-ttu-id="929ee-353">В сети сертификаты TLS обычно кодируются в двоичном формате DER, и именно в этом формате NetX Secure ожидает сертификаты X.509.</span><span class="sxs-lookup"><span data-stu-id="929ee-353">Over the wire, TLS certificates are usually encoded in binary DER, and this is the format that NetX Secure expects for X.509 certificates.</span></span>

<span data-ttu-id="929ee-354">Хотя двоичные сертификаты в формате DER используются в фактическом протоколе TLS, они могут создаваться и храниться в разных кодировках с такими расширениями файла, как PEM, CRT и P12.</span><span class="sxs-lookup"><span data-stu-id="929ee-354">Though DER-formatted binary certificates are used in the actual TLS protocol, they may be generated and stored in a number of different encodings, with file extensions such as .pem, .crt, and .p12.</span></span> <span data-ttu-id="929ee-355">Различные варианты используются приложениями разных производителей, но в целом их можно преобразовать в формат DER с помощью широко доступных средств.</span><span class="sxs-lookup"><span data-stu-id="929ee-355">The different variants are used by different applications from different manufacturers, but generally all can be converted into DER using widely available tools.</span></span>

<span data-ttu-id="929ee-356">Наиболее распространенной альтернативной кодировкой сертификатов является PEM.</span><span class="sxs-lookup"><span data-stu-id="929ee-356">The most common of the alternative certificate encodings is PEM.</span></span> <span data-ttu-id="929ee-357">Формат PEM (Privacy-Enhanced Mail) представляет собой версию кодировки DER в формате Base64, которая часто используется, так как это кодирование позволяет получить печатный текст, который можно легко отправить с помощью электронной почты или веб-протоколов.</span><span class="sxs-lookup"><span data-stu-id="929ee-357">The PEM format (from Privacy-Enhanced Mail) is a base-64 encoded version of the DER encoding that is often used because the encoding results in printable text that can be easily sent using email or web-based protocols.</span></span>

<span data-ttu-id="929ee-358">Создание сертификата для вашего приложения NetX Secure обычно выходит за рамки данного руководства, но программа командной строки OpenSSL ([www.openssl.org](http://www.openssl.org)) широко доступна и может выполнять взаимное преобразование большинства форматов.</span><span class="sxs-lookup"><span data-stu-id="929ee-358">Generating a certificate for your NetX Secure application is generally outside the scope of this manual, but the OpenSSL command-line tool ([www.openssl.org](http://www.openssl.org)) is widely available and can convert between most formats.</span></span>

<span data-ttu-id="929ee-359">В зависимости от приложения вы можете создавать собственные сертификаты, получать сертификаты от изготовителя или правительственной организации или приобретать сертификаты у коммерческого центра сертификации.</span><span class="sxs-lookup"><span data-stu-id="929ee-359">Depending on your application, you may generate your own certificates, be provided certificates by a manufacturer or government organization, or purchase certificates from a commercial certificate authority.</span></span>

<span data-ttu-id="929ee-360">Чтобы использовать цифровой сертификат в приложении NetX Secure, необходимо сначала преобразовать этот сертификат в двоичный формат DER и, при необходимости, преобразовать в двоичный формат соответствующий закрытый ключ (например, "закрытый показатель" для RSA), обычно это ключ RSA в кодировке DER и формате PKCS № 1.</span><span class="sxs-lookup"><span data-stu-id="929ee-360">To use a digital certificate in your NetX Secure application, you must first convert your certificate into a binary DER format and, optionally, convert the associated private key (the “private exponent” for RSA, for example) into a binary format, typically a PKCS#1-formatted, DER-encoded RSA key.</span></span> <span data-ttu-id="929ee-361">После завершения преобразования необходимо загрузить сертификат и закрытый ключ на устройство.</span><span class="sxs-lookup"><span data-stu-id="929ee-361">Once the conversion is complete, it is up to you to load the certificate and private key onto the device.</span></span> <span data-ttu-id="929ee-362">Возможные варианты включают в себя использование файловой системы флэш-памяти или создание массива C на основе данных (с помощью такого инструмента, как xxd в Linux), а также компиляцию сертификата и ключа в приложении в качестве постоянных данных.</span><span class="sxs-lookup"><span data-stu-id="929ee-362">Possible options include using a flash-based file system or generating a C array from the data (using a tool such as “xxd” from Linux) and compiling the certificate and key into your application as constant data.</span></span>

<span data-ttu-id="929ee-363">После загрузки сертификата на устройство можно использовать API DTLS, чтобы связать этот сертификат с сеансом или сервером DTLS.</span><span class="sxs-lookup"><span data-stu-id="929ee-363">Once your certificate is loaded onto the device, the DTLS API can be used to associate your certificate with a DTLS session or server.</span></span>

<span data-ttu-id="929ee-364">Дополнительные сведения и примеры использования сертификатов X.509 с NetX Secure DTLS приведены в разделе "Импорт сертификатов X.509 в NetX Secure" руководства пользователя NetX Secure TLS.</span><span class="sxs-lookup"><span data-stu-id="929ee-364">For details and examples on how to use X.509 certificates with NetX Secure DTLS, see the section “Importing X.509 certificates into NetX Secure” in the NetX Secure TLS User Guide.</span></span>

<span data-ttu-id="929ee-365">Ознакомьтесь с дополнительными сведениями о приведенных ниже службах DTLS в справочнике по API:</span><span class="sxs-lookup"><span data-stu-id="929ee-365">Refer to the following DTLS services in the API reference for more information:</span></span>

- <span data-ttu-id="929ee-366">nx_secure_x509_certificate_initialize</span><span class="sxs-lookup"><span data-stu-id="929ee-366">nx_secure_x509_certificate_initialize,</span></span>
- <span data-ttu-id="929ee-367">nx_secure_dtls_session_local_certificate_add</span><span class="sxs-lookup"><span data-stu-id="929ee-367">nx_secure_dtls_session_local_certificate_add,</span></span>
- <span data-ttu-id="929ee-368">nx_secure_dtls_server_local_certificate_add</span><span class="sxs-lookup"><span data-stu-id="929ee-368">nx_secure_dtls_server_local_certificate_add,</span></span>
- <span data-ttu-id="929ee-369">nx_secure_dtls_session_local_certificate_remove</span><span class="sxs-lookup"><span data-stu-id="929ee-369">nx_secure_dtls_session_local_certificate_remove,</span></span>
- <span data-ttu-id="929ee-370">nx_secure_dtls_server_local_certificate_remove</span><span class="sxs-lookup"><span data-stu-id="929ee-370">nx_secure_dtls_server_local_certificate_remove,</span></span>
- <span data-ttu-id="929ee-371">nx_secure_dtls_session_trusted_certificate_add</span><span class="sxs-lookup"><span data-stu-id="929ee-371">nx_secure_dtls_session_trusted_certificate_add,</span></span>
- <span data-ttu-id="929ee-372">nx_secure_dtls_server_trusted_certificate_add</span><span class="sxs-lookup"><span data-stu-id="929ee-372">nx_secure_dtls_server_trusted_certificate_add,</span></span>
- <span data-ttu-id="929ee-373">nx_secure_dtls_session_trusted_certificate_remove</span><span class="sxs-lookup"><span data-stu-id="929ee-373">nx_secure_dtls_session_trusted_certificate_remove</span></span>
- <span data-ttu-id="929ee-374">nx_secure_dtls_server_trusted_certificate_remove</span><span class="sxs-lookup"><span data-stu-id="929ee-374">nx_secure_dtls_server_trusted_certificate_remove</span></span>

### <a name="tls-client-certificate-specifics"></a><span data-ttu-id="929ee-375">Особенности сертификата клиента TLS</span><span class="sxs-lookup"><span data-stu-id="929ee-375">TLS Client Certificate Specifics</span></span>

<span data-ttu-id="929ee-376">Для реализаций клиента DTLS обычно не требуется загрузка локального сертификата на устройство.</span><span class="sxs-lookup"><span data-stu-id="929ee-376">DTLS Client implementations generally do not require a local certificate to be loaded onto the device.</span></span> <span data-ttu-id="929ee-377">Локальный сертификат — это сертификат, идентифицирующий локальное устройство.</span><span class="sxs-lookup"><span data-stu-id="929ee-377">A local certificate is a certificate that identifies the local device.</span></span> <span data-ttu-id="929ee-378">В частности, локальный сертификат предоставляет идентификационные данные устройства, на которое загружено приложение TLS или DTLS.</span><span class="sxs-lookup"><span data-stu-id="929ee-378">Specifically, a local certificate provides identity information for the device upon which the TLS/DTLS application is loaded.</span></span> <span data-ttu-id="929ee-379">Исключением является применение проверки подлинности на основе сертификата клиента, но она гораздо менее распространена.</span><span class="sxs-lookup"><span data-stu-id="929ee-379">The exception to this is when Client Certificate Authentication is enabled, but this is less common.</span></span>

<span data-ttu-id="929ee-380">Клиенту DTLS требуется загрузка по крайней мере одного доверенного сертификата (при необходимости может быть загружено больше) и выделение пространства для удаленного сертификата.</span><span class="sxs-lookup"><span data-stu-id="929ee-380">A DTLS Client requires at least one trusted certificate to be loaded (more may be loaded if required), and space for a remote certificate to be allocated.</span></span> <span data-ttu-id="929ee-381">Доверенный сертификат — это сертификат, который предоставляет основу для доверия и проверки подлинности удаленного устройства напрямую либо посредством инфраструктуры открытых ключей (PKI).</span><span class="sxs-lookup"><span data-stu-id="929ee-381">A trusted certificate is a certificate that provides a basis for trust and authentication of the remote device, either directly or through a Public Key Infrastructure (PKI).</span></span> <span data-ttu-id="929ee-382">Корень цепочки доверия обычно называется центром сертификации или сертификатом ЦС.</span><span class="sxs-lookup"><span data-stu-id="929ee-382">The root of the chain of trust is usually called a Certification Authority or CA certificate.</span></span> <span data-ttu-id="929ee-383">Удаленный сертификат означает сертификат, отправленный удаленным узлом во время подтверждения TLS.</span><span class="sxs-lookup"><span data-stu-id="929ee-383">A remote certificate refers to the certificate sent by the remote host during the TLS handshake.</span></span> <span data-ttu-id="929ee-384">Он предоставляет удостоверение этого удаленного узла и проходит проверку подлинности, при которой это удостоверение сравнивается с доверенным сертификатом на локальном устройстве.</span><span class="sxs-lookup"><span data-stu-id="929ee-384">It provides identity for that remote host and is authenticated by comparing it to a trusted certificate on the local device.</span></span>

<span data-ttu-id="929ee-385">Дополнительные сведения о добавлении доверенных сертификатов и выделении пространства для удаленных сертификатов см. в справочнике по API TLS для служб nx_secure_dtls_session_create и nx_secure_dtls_session_trusted_certificate_add.</span><span class="sxs-lookup"><span data-stu-id="929ee-385">For more information on adding trusted certificates and allocating space for remote certificates, see the TLS API reference for the following services: nx_secure_dtls_session_create, nx_secure_dtls_session_trusted_certificate_add.</span></span>

### <a name="tlsdtls-server-certificate-specifics"></a><span data-ttu-id="929ee-386">Особенности сертификата сервера TLS или DTLS</span><span class="sxs-lookup"><span data-stu-id="929ee-386">TLS/DTLS Server Certificate Specifics</span></span>

<span data-ttu-id="929ee-387">Для реализации сервера DTLS обычно не требуется загрузка доверенных сертификатов на устройство или выделение удаленных сертификатов.</span><span class="sxs-lookup"><span data-stu-id="929ee-387">DTLS Server implementations generally do not require “trusted” certificates to be loaded onto the device or remote certificates to be allocated.</span></span> <span data-ttu-id="929ee-388">Исключением является применение проверки подлинности на основе сертификата клиента.</span><span class="sxs-lookup"><span data-stu-id="929ee-388">The exception to this being when Client Certificate Authentication is enabled.</span></span>

<span data-ttu-id="929ee-389">Сервер TLS требует загрузки локального сертификата (или удостоверения), чтобы сервер мог предоставить его удаленному клиенту во время подтверждения TLS, чтобы клиент мог проверить подлинность сервера.</span><span class="sxs-lookup"><span data-stu-id="929ee-389">A TLS Server requires a “local” (or “identity”) certificate to be loaded so the server can provide it to the remote client during the TLS handshake to authenticate the server to the client.</span></span>

<span data-ttu-id="929ee-390">Дополнительные сведения о загрузке локальных сертификатов для использования серверными приложениями NetX TLS см. в справочнике по API для служб nx_secure_dtls_server_local_certificate_add и nx_secure_dtls_server_local_certificate_remove.</span><span class="sxs-lookup"><span data-stu-id="929ee-390">For more information about loading local certificates for use with NetX TLS server applications, see the API reference for the following services: nx_secure_dtls_server_local_certificate_add, nx_secure_dtls_server_local_certificate_remove.</span></span>


### <a name="pre-shared-keys-psk"></a><span data-ttu-id="929ee-391">Общие ключи (PSK)</span><span class="sxs-lookup"><span data-stu-id="929ee-391">Pre-Shared Keys (PSK)</span></span>

<span data-ttu-id="929ee-392">Альтернативным механизмом идентификации для проверки подлинности в протоколе TLS является понятие общих ключей (PSK).</span><span class="sxs-lookup"><span data-stu-id="929ee-392">An alternative mechanism for providing identification authentication in TLS is the notion of Pre-Shared Keys (PSK).</span></span> <span data-ttu-id="929ee-393">Использование комплекта шифров PSK устраняет необходимость выполнять операции шифрования с открытым ключом, требующие интенсивного использования процессора, что является явным преимуществом для встроенных устройств с ограниченными ресурсами.</span><span class="sxs-lookup"><span data-stu-id="929ee-393">Using a PSK ciphersuite removes the need to do the processor-intensive public-key encryption operations, a boon for resource-constrained embedded devices.</span></span> <span data-ttu-id="929ee-394">PSK заменяет сертификат в подтверждении TLS и DTLS и используется вместо зашифрованной предварительной главной копии секрета для создания ключа сеанса TLS или DTLS.</span><span class="sxs-lookup"><span data-stu-id="929ee-394">The PSK replaces the certificate in the TLS/DTLS handshake and is used in place of the encrypted Pre-Master Secret for TLS/DTLS session key generation.</span></span>

<span data-ttu-id="929ee-395">Комплекты шифров PSK ограничены в том смысле, что общий секрет должен находиться на обоих устройствах, прежде чем можно будет установить сеанс TLS или DTLS.</span><span class="sxs-lookup"><span data-stu-id="929ee-395">The PSK ciphersuites are limited in the sense that that a shared secret must be present on both devices before a TLS/DTLS session can be established.</span></span> <span data-ttu-id="929ee-396">Это означает, что этот секрет должен быть загружен на устройства каким-либо альтернативным безопасным способом, а не через подключение по протоколу TLS для PSK. PSK можно обновить через подключение TLS для PSK, но устройство должно быть запущено с PSK, загруженным с помощью какого-либо другого механизма.</span><span class="sxs-lookup"><span data-stu-id="929ee-396">This means that the devices must have been loaded with that secret using some secure means other than a TLS PSK connection - PSKs may be updated over a TLS PSK connection, but the device must necessarily start with a PSK that is loaded through some other mechanism.</span></span> <span data-ttu-id="929ee-397">Например, ключи PSK можно загрузить на устройства датчика и его шлюза на фабрике перед отправкой или использовать стандартное подключение TLS (с сертификатом) для загрузки PSK.</span><span class="sxs-lookup"><span data-stu-id="929ee-397">For example, a sensor device and its gateway device could be loaded with PSKs in the factory before shipping, or a standard TLS connection (with a certificate) could be used to load the PSK.</span></span>

<span data-ttu-id="929ee-398">Существуют два варианта комплектов шифров PSK, они описаны в документе RFC 4279.</span><span class="sxs-lookup"><span data-stu-id="929ee-398">PSK ciphersuites come in a couple of forms, described in RFC 4279.</span></span> <span data-ttu-id="929ee-399">В первом применяются ключи RSA или Диффи-Хелмана, которые используются точно так же, как и открытые ключи, передаваемые в сертификате при стандартном подтверждении TLS.</span><span class="sxs-lookup"><span data-stu-id="929ee-399">The first uses RSA or Diffie-Hellman keys which are used in the same manner as the public keys transmitted in the certificate in standard TLS handshakes.</span></span> <span data-ttu-id="929ee-400">Во втором варианте, который чаще используется в среде с ограниченными ресурсами, применяется PSK, который используется для непосредственного создания ключей сеанса (например, для использования AES), что позволяет избежать выполнения ресурсоемких операций RSA или Диффи-Хелмана.</span><span class="sxs-lookup"><span data-stu-id="929ee-400">The second form, which is of more use in a resource-constrained environment, uses a PSK that is used to directly generate the session keys (for use by AES, for example), avoiding the use of the expensive RSA or Diffie-Hellman operations.</span></span>

<span data-ttu-id="929ee-401">NetX Secure поддерживает второй вариант комплектов шифров PSK, что позволяет избавить приложения от всего кода шифрования с открытым ключом и проблем с использованием памяти.</span><span class="sxs-lookup"><span data-stu-id="929ee-401">NetX Secure supports the second form of PSK ciphersuites, enabling applications to remove all public-key cryptography code and memory usage.</span></span> <span data-ttu-id="929ee-402">Сам по себе PSK не является ключом AES, а, скорее, является паролем, с помощью которого создаются фактические ключи.</span><span class="sxs-lookup"><span data-stu-id="929ee-402">The PSK itself is not an AES key, but can be considered as being more like a password from which the actual keys are generated.</span></span> <span data-ttu-id="929ee-403">Существует несколько ограничений для значения PSK, хотя более длинные значения обеспечивают большую безопасность (то же относится и к паролям).</span><span class="sxs-lookup"><span data-stu-id="929ee-403">There are few restrictions on what the PSK value can be, though longer values will provide more security (same as with passwords).</span></span>

<span data-ttu-id="929ee-404">Чтобы использовать PSK в приложении NetX Secure, необходимо сначала определить глобальный макрос **NX_SECURE_ENABLE_PSK_CIPHERSUITES**.</span><span class="sxs-lookup"><span data-stu-id="929ee-404">To use PSK with your NetX Secure application, you must first define the global macro **NX_SECURE_ENABLE_PSK_CIPHERSUITES**.</span></span> <span data-ttu-id="929ee-405">Обычно это делается с помощью параметров компилятора, но определение можно также поместить в файл заголовка nx_secure_tls.h.</span><span class="sxs-lookup"><span data-stu-id="929ee-405">This is usually done through your compiler settings, but the definition can also be placed in the nx_secure_tls.h header file.</span></span> <span data-ttu-id="929ee-406">После определения макроса поддержка комплекта шифров PSK будет скомпилирована в приложение NetX Secure DTLS.</span><span class="sxs-lookup"><span data-stu-id="929ee-406">With the macro defined, PSK ciphersuite support will be compiled into your NetX Secure DTLS application.</span></span>

<span data-ttu-id="929ee-407">После включения поддержки PSK можно будет использовать API DTLS, чтобы настроить ключи PSK для приложения.</span><span class="sxs-lookup"><span data-stu-id="929ee-407">With PSK support enabled, you can then use the DTLS API to set up PSKs for your application.</span></span> <span data-ttu-id="929ee-408">Для каждого PSK потребуется значение PSK (фактический секретный "ключ", который должен храниться в безопасном месте), значение "удостоверения", используемое для идентификации конкретного PSK, и "указание удостоверения", которое используется сервером TLS для выбора определенного значения PSK.</span><span class="sxs-lookup"><span data-stu-id="929ee-408">Each PSK will require a PSK value (the actual secret “key” – keep this value safe), an “identity” value used to identify the specific PSK, and an “identity hint” that is used by a TLS server to choose a particular PSK value.</span></span>

<span data-ttu-id="929ee-409">PSK может быть любым двоичным значением, так как он никогда не передается через сетевое подключение.</span><span class="sxs-lookup"><span data-stu-id="929ee-409">The PSK itself can be any binary value as it is never sent over a network connection.</span></span> <span data-ttu-id="929ee-410">Значение PSK может содержать до 64 байт.</span><span class="sxs-lookup"><span data-stu-id="929ee-410">The PSK can be any value up to 64 bytes in length.</span></span>

<span data-ttu-id="929ee-411">Удостоверение и указание должны представлять собой печатные строки символов в формате UTF-8.</span><span class="sxs-lookup"><span data-stu-id="929ee-411">The identity and hint must be printable character strings formatted using UTF-8.</span></span> <span data-ttu-id="929ee-412">Значения удостоверения и указания могут содержать до 128 байт.</span><span class="sxs-lookup"><span data-stu-id="929ee-412">The identity and hint values may be any length up to 128 bytes.</span></span>

<span data-ttu-id="929ee-413">Удостоверение и PSK образуют уникальную пару, которая загружается на все устройства в сети, которые должны взаимодействовать друг с другом.</span><span class="sxs-lookup"><span data-stu-id="929ee-413">The identity and PSK form a unique pair that is loaded onto every device in the network that need to communicate with one another.</span></span>

<span data-ttu-id="929ee-414">"Указание" в основном используется, чтобы определить конкретные профили приложений для группирования ключей PSK по функциям или службам.</span><span class="sxs-lookup"><span data-stu-id="929ee-414">The “hint” is primarily used for defining specific application profiles to group PSKs by function or service.</span></span> <span data-ttu-id="929ee-415">Эти значения должны быть согласованы заранее, и они зависят от приложения.</span><span class="sxs-lookup"><span data-stu-id="929ee-415">These values must be agreed upon in advance and are application dependent.</span></span> <span data-ttu-id="929ee-416">Например, серверное приложение командной строки OpenSSL (использующее PSK) применяет строку по умолчанию "Client_identity", которая должна быть предоставлена клиентом TLS для продолжения подтверждения TLS.</span><span class="sxs-lookup"><span data-stu-id="929ee-416">As an example, the OpenSSL command-line server application (with PSK enabled) uses the default string “Client_identity”, which must be provided by a TLS client in order to continue with the TLS handshake.</span></span>

<span data-ttu-id="929ee-417">Дополнительные сведения о ключах PSK см. в справочнике по API NetX Secure для служб nx_secure_dtls_psk_add и nx_secure_dtls_server_psk_add.</span><span class="sxs-lookup"><span data-stu-id="929ee-417">For more information on PSKs, see the NetX Secure API reference for the following services: nx_secure_dtls_psk_add, nx_secure_dtls_server_psk_add.</span></span>

## <a name="importing-x509-certificates-into-netx-secure"></a><span data-ttu-id="929ee-418">Импорт сертификатов X.509 в NetX Secure</span><span class="sxs-lookup"><span data-stu-id="929ee-418">Importing X.509 certificates into NetX Secure</span></span>

<span data-ttu-id="929ee-419">Цифровые сертификаты необходимы для большинства подключений TLS в Интернете.</span><span class="sxs-lookup"><span data-stu-id="929ee-419">Digital certificates are required for most TLS connections on the Internet.</span></span> <span data-ttu-id="929ee-420">Сертификаты обеспечивают метод проверки подлинности неизвестных ранее узлов через Интернет за счет использования доверенных посредников, которые обычно называются *центрами сертификации* (ЦА).</span><span class="sxs-lookup"><span data-stu-id="929ee-420">Certificates provide a method for authenticating previously unknown hosts over the Internet through the use of trusted intermediaries, usually called *Certificate Authorities* or CAs.</span></span> <span data-ttu-id="929ee-421">Чтобы подключить устройство NetX Secure к коммерческой облачной службе (например, Amazon Web Services), необходимо будет импортировать сертификаты в свое приложение, загрузив их на устройство.</span><span class="sxs-lookup"><span data-stu-id="929ee-421">To connect your NetX Secure device with a commercial cloud service (such as Amazon Web Services), you will need to import certificates into your application by loading them onto your device.</span></span>

<span data-ttu-id="929ee-422">Наряду с сертификатами иногда может понадобиться *закрытый ключ*, связанный с вашим сертификатом.</span><span class="sxs-lookup"><span data-stu-id="929ee-422">Along with certificates, you will also sometimes need a *private key* that is associated with your certificate.</span></span> <span data-ttu-id="929ee-423">В некоторых приложениях (например, в клиенте TLS, если не используется проверка подлинности на основе сертификата клиента) будет достаточно только сертификата, но если сертификат используется для идентификации устройства, вам потребуется закрытый ключ.</span><span class="sxs-lookup"><span data-stu-id="929ee-423">In some applications (such as TLS Client when Client Certificate Authentication is not being used) the certificate alone will be sufficient, but if your certificate is being used to identify your device you will need a private key.</span></span> <span data-ttu-id="929ee-424">Закрытые ключи обычно создаются при создании сертификата и хранятся в отдельном файле, который часто шифруется и защищается паролем.</span><span class="sxs-lookup"><span data-stu-id="929ee-424">Private keys are typically generated when you create your certificate and are stored in a separate file, often encrypted with a password.</span></span>

<span data-ttu-id="929ee-425">Подробное описание импорта сертификатов в приложения NetX Secure см. в главе 3 руководства пользователя NetX Secure TLS.</span><span class="sxs-lookup"><span data-stu-id="929ee-425">For a detailed description of importing certificates into NetX Secure applications, please refer to Chapter 3 in the NetX Secure TLS User Guide.</span></span>

## <a name="client-certificate-authentication-in-netx-secure-tls"></a><span data-ttu-id="929ee-426">Проверка подлинности на основе сертификата клиента в NetX Secure TLS</span><span class="sxs-lookup"><span data-stu-id="929ee-426">Client Certificate Authentication in NetX Secure TLS</span></span>

<span data-ttu-id="929ee-427">При использовании проверки подлинности на основе сертификата X.509 протокол TLS или DTLS требует, чтобы экземпляр сервера DTLS предоставил сертификат для идентификации, но по умолчанию экземпляру клиента DTLS не требуется предоставлять сертификат для проверки подлинности. Вместо этого используется другая разновидность проверки подлинности (например, сочетание имени пользователя и пароля).</span><span class="sxs-lookup"><span data-stu-id="929ee-427">When using X.509 certificate authentication, the TLS/DTLS protocol requires that the DTLS Server instance provide a certificate for identification, but by default the DTLS Client instance does not need to provide a certificate for authentication, using another form of authentication instead (e.g. a username/password combination).</span></span> <span data-ttu-id="929ee-428">Это соответствует наиболее распространенному использованию протокола TLS в Интернете для веб-сайтов.</span><span class="sxs-lookup"><span data-stu-id="929ee-428">This matches the most common use of TLS on the Internet for Web sites.</span></span> <span data-ttu-id="929ee-429">Например, веб-сайт розничной торговли должен доказать потенциальному клиенту, использующему веб-браузер, что сервером является действительным, но пользователь будет использовать имя для входа и пароль для доступа к определенной учетной записи.</span><span class="sxs-lookup"><span data-stu-id="929ee-429">For example, an online retail site must prove to a potential customer using a web browser that the server is legitimate, but the user will use a login/password to access a specific account.</span></span>

<span data-ttu-id="929ee-430">Однако вариант использования по умолчанию не всегда желателен, поэтому протоколы TLS и DTLS дополнительно позволяют экземпляру сервера DTLS запрашивать сертификат у удаленного клиента.</span><span class="sxs-lookup"><span data-stu-id="929ee-430">However, the default case is not always desirable, so TLS/DTLS optionally allows for the DTLS Server instance to request a certificate from the remote Client.</span></span> <span data-ttu-id="929ee-431">Если эта функция включена, то во время подтверждения сервер DTLS отправляет сообщение CertificateRequest клиенту DTLS.</span><span class="sxs-lookup"><span data-stu-id="929ee-431">When this feature is enabled, the DTLS Server will send a CertificateRequest message to the DTLS Client during the handshake.</span></span> <span data-ttu-id="929ee-432">Клиент должен отправить в ответ свой сертификат и сообщение CertificateVerify, которое содержит криптографический маркер, подтверждающий, что клиент владеет соответствующим закрытым ключом, связанным с этим сертификатом.</span><span class="sxs-lookup"><span data-stu-id="929ee-432">The Client must respond with a certificate of its own and a CertificateVerify message which contains a cryptographic token proving that the Client owns the matching private key associated with that certificate.</span></span> <span data-ttu-id="929ee-433">Если проверка завершается сбоем или сертификат не связан с доверенным сертификатом на сервере, происходит сбой подтверждения TLS.</span><span class="sxs-lookup"><span data-stu-id="929ee-433">If the verification fails or the certificate is not connected to a trusted certificate on the Server, the TLS handshake fails.</span></span>

<span data-ttu-id="929ee-434">Существуют два отдельных варианта проверки подлинности на основе сертификата клиента в протоколе TLS, они рассматриваются в следующих разделах.</span><span class="sxs-lookup"><span data-stu-id="929ee-434">There are two separate cases for Client Certificate Authentication in TLS – the following sections cover both cases.</span></span>

### <a name="client-certificate-authentication-for-dtls-clients"></a><span data-ttu-id="929ee-435">Проверка подлинности на основе сертификата клиента для клиентов DTLS</span><span class="sxs-lookup"><span data-stu-id="929ee-435">Client Certificate Authentication for DTLS Clients</span></span>

<span data-ttu-id="929ee-436">Клиент DTLS может попытаться подключиться к серверу, который запрашивает сертификат для проверки подлинности клиента.</span><span class="sxs-lookup"><span data-stu-id="929ee-436">A DTLS Client may attempt a connection to a server that requests a certificate for client authentication.</span></span> <span data-ttu-id="929ee-437">В этом случае клиент должен предоставить сертификат серверу и подтвердить, что он владеет соответствующим закрытым ключом, иначе сервер завершит подтверждение DTLS.</span><span class="sxs-lookup"><span data-stu-id="929ee-437">In this case the Client must provide a certificate to the server and verify that it owns the matching private key or the Server will terminate the DTLS handshake.</span></span>

<span data-ttu-id="929ee-438">В NetX Secure DTLS нет специальной конфигурации для поддержки этой функции, но приложению потребуется указать локальный сертификат для экземпляра клиента DTLS с помощью службы *nx_secure_tls_session_local_certificate_add*.</span><span class="sxs-lookup"><span data-stu-id="929ee-438">In NetX Secure DTLS, there is no special configuration to support this feature but the application will have to provide a local identification certificate for the TLS Client instance using the *nx_secure_tls_session_local_certificate_add* service.</span></span> <span data-ttu-id="929ee-439">Если приложение не предоставило сертификат, а удаленный сервер использует проверку подлинности на основе сертификата клиента и запрашивает сертификат, то подтверждение DTLS завершится сбоем.</span><span class="sxs-lookup"><span data-stu-id="929ee-439">If no certificate is provided by the application but the remote server is using Client Certificate Authentication and requests a certificate, the DTLS handshake will fail.</span></span> <span data-ttu-id="929ee-440">Для выполнения подтверждения DTLS сертификат, предоставленный сеансу DTLS службой *nx_secure_dtls_session_local_certificate_add*, должен быть распознан удаленным сервером.</span><span class="sxs-lookup"><span data-stu-id="929ee-440">The certificate provided to the DTLS Session with *nx_secure_dtls_session_local_certificate_add* must be recognized by the remote server in order to complete the DTLS handshake.</span></span>

### <a name="client-certificate-authentication-for-tls-servers"></a><span data-ttu-id="929ee-441">Проверка подлинности на основе сертификата клиента для серверов TLS</span><span class="sxs-lookup"><span data-stu-id="929ee-441">Client Certificate Authentication for TLS Servers</span></span>

<span data-ttu-id="929ee-442">В случае сервера DTLS проверка подлинности на основе сертификата клиента выполняется немного сложнее, чем в случае клиента DTLS, ввиду необязательного использования функции.</span><span class="sxs-lookup"><span data-stu-id="929ee-442">The DTLS Server case for Client Certificate Authentication is slightly more complex than the DTLS Client case due to the feature being optional.</span></span> <span data-ttu-id="929ee-443">В этом случае сервер TLS должен запросить сертификат у удаленного клиента TLS, обработать сообщение CertificateVerify, чтобы убедиться, что удаленный клиент владеет соответствующим закрытым ключом, а затем сервер должен убедиться, что сертификат, предоставленный клиентом, можно отследить до сертификата в хранилище локальных доверенных сертификатов.</span><span class="sxs-lookup"><span data-stu-id="929ee-443">In this case, the TLS Server needs to specifically request a certificate from the remote TLS Client, then process the CertificateVerify message to verify that the remote Client owns the matching private key, and then the Server must check that the certificate provided by the Client can be traced to a certificate in the local trusted certificate store.</span></span>

<span data-ttu-id="929ee-444">В экземплярах сервера NetX Secure TLS проверкой подлинности на основе сертификата клиента управляют службы *nx_secure_dtls_server_x509_client_verify_configure* и *nx_secure_dtls_server_x509_client_verify_disable*.</span><span class="sxs-lookup"><span data-stu-id="929ee-444">In NetX Secure TLS Server instances, Client Certificate Authentication is controlled by the *nx_secure_dtls_server_x509_client_verify_configure* and *nx_secure_dtls_server_x509_client_verify_disable* services.</span></span>

<span data-ttu-id="929ee-445">Чтобы включить проверку подлинности на основе сертификата клиента, приложение должно вызвать службу *nx_secure_dtls_server_x509_client_verify_configure* для экземпляра сеанса сервера DTLS, прежде чем вызывать службу *nx_secure_dtls_server_start*.</span><span class="sxs-lookup"><span data-stu-id="929ee-445">To enable Client Certificate Authentication, an application must call *nx_secure_dtls_server_x509_client_verify_configure* with the DTLS Server session instance before calling *nx_secure_dtls_server_start*.</span></span> <span data-ttu-id="929ee-446">Для проверки необходимо выделить пространство для входящих сертификатов клиента, которые передаются в качестве параметра в службу *nx_secure_dtls_server_x509_client_verify_configure*.</span><span class="sxs-lookup"><span data-stu-id="929ee-446">The verification requires space to be allocated for incoming client certificates which is provided as a parameter to *nx_secure_dtls_server_x509_client_verify_configure.*</span></span> <span data-ttu-id="929ee-447">Обратите внимание на то, что буфер должен быть достаточно большим. Он должен вместить столько цепочек сертификатов максимального размера, предоставляемых клиентом, сколько может существовать *сеансов сервера DTLS*.</span><span class="sxs-lookup"><span data-stu-id="929ee-447">Note that the buffer must be large enough to hold the maximum-size certificate chain provided by a client *times the number of DTLS server sessions*.</span></span> <span data-ttu-id="929ee-448">Каждому сеансу сервера требуется пространство, выделяемое из одного предоставленного буфера.</span><span class="sxs-lookup"><span data-stu-id="929ee-448">Each server session requires space which will be allocated from the single provided buffer.</span></span> <span data-ttu-id="929ee-449">Убедитесь, что буфер достаточно большой. Если предоставленная цепочка сертификатов клиента окажется слишком велика, возникнет ошибка.</span><span class="sxs-lookup"><span data-stu-id="929ee-449">Make sure the buffer is large enough or an error will occur if the provided Client certificate chain is too large.</span></span>

<span data-ttu-id="929ee-450">Если включена проверка подлинности на основе сертификата клиента, сервер DTLS запрашивает сертификат у удаленного клиента DTLS во время подтверждения DTLS.</span><span class="sxs-lookup"><span data-stu-id="929ee-450">When Client Certificate Authentication is enabled, the DTLS Server will request a certificate from the remote DTLS Client during the DTLS handshake.</span></span> <span data-ttu-id="929ee-451">На сервере NetX Secure DTLS сертификат клиента проверяется с помощью хранилища доверенных сертификатов, созданных с помощью *nx_secure_dtls_server_trusted_certificate_add*, в соответствии с цепочкой издателей X.509.</span><span class="sxs-lookup"><span data-stu-id="929ee-451">In NetX Secure DTLS Server, the Client certificate is checked against the store of trusted certificates created with *nx_secure_dtls_server_trusted_certificate_add* by following the X.509 issuer chain.</span></span> <span data-ttu-id="929ee-452">Удаленный клиент должен предоставить цепочку, которая связывает удостоверяющий сертификат с сертификатом в доверенном хранилище, иначе произойдет сбой подтверждения DTLS.</span><span class="sxs-lookup"><span data-stu-id="929ee-452">The remote Client must provide a chain that connects its identity certificate to a certificate in the trusted store or the DTLS handshake will fail.</span></span> <span data-ttu-id="929ee-453">Кроме того, если происходит сбой обработки сообщения CertificateVerify, то подтверждение DTLS также завершается ошибкой.</span><span class="sxs-lookup"><span data-stu-id="929ee-453">Additionally, if the CertificateVerify message processing fails, the DTLS handshake will also fail.</span></span>

<span data-ttu-id="929ee-454">Методы сигнатур, используемые для метода CertificateVerify, являются фиксированными для протоколов TLS 1.0 и TLS 1.1 и задаются сервером TLS в протоколе TLS 1.2. Именно на основе этих методов реализован протокол NetX Secure DTLS.</span><span class="sxs-lookup"><span data-stu-id="929ee-454">The signature methods used for the CertificateVerify method are fixed for TLS version 1.0 and TLS version 1.1, and are specified by the TLS Server in TLS version 1.2, upon which NetX Secure DTLS is based.</span></span> <span data-ttu-id="929ee-455">Для протокола DTLS 1.2 поддерживаются методы сигнатур, которые, как правило, соответствуют методам, передаваемым в таблице криптографических методов, но обычно это RSA с SHA-256 (ознакомьтесь с разделом "Шифрование в NetX Secure TLS", чтобы получить дополнительные сведения об инициализации TLS с помощью криптографических методов).</span><span class="sxs-lookup"><span data-stu-id="929ee-455">For DTLS 1.2, the signature methods supported generally follow the relevant methods supplied in the cryptographic method table, but typically RSA with SHA-256 (see the section “Cryptography in NetX Secure TLS” for more information on initializing TLS with cryptographic methods).</span></span>

## <a name="cryptography-in-netx-secure-tls"></a><span data-ttu-id="929ee-456">Шифрование в NetX Secure TLS</span><span class="sxs-lookup"><span data-stu-id="929ee-456">Cryptography in NetX Secure TLS</span></span>

<span data-ttu-id="929ee-457">TLS определяет протокол, в котором может использоваться шифрование для защиты сетевого взаимодействия.</span><span class="sxs-lookup"><span data-stu-id="929ee-457">TLS defines a protocol in which cryptography can be used to secure network communications.</span></span> <span data-ttu-id="929ee-458">Поэтому выбор фактического алгоритма шифрования, который может быть применен, не слишком ограничен для пользователей протокола TLS.</span><span class="sxs-lookup"><span data-stu-id="929ee-458">As such, it leaves the actual cryptography to be used fairly wide open for TLS users.</span></span> <span data-ttu-id="929ee-459">Спецификация только требует реализовать один комплект шифров. В случае протокола TLS 1.2 это комплект шифров TLS_RSA_WITH_AES_128_CBC_SHA, предписывающий использование RSA для операций с открытым ключом, AES — в режиме CBC с 128-разрядными ключами для шифрования сеансов и SHA-1 — для хэшей для проверки подлинности сообщений.</span><span class="sxs-lookup"><span data-stu-id="929ee-459">The specification only requires a single ciphersuite to be implemented – in the case of TLS 1.2, that ciphersuite is TLS_RSA_WITH_AES_128_CBC_SHA, indicating the use of RSA for public-key operations, AES in CBC mode with 128-bit keys for session encryption, and SHA-1 for message authentication hashes.</span></span>

<span data-ttu-id="929ee-460">Так как протокол NetX Secure совместим с протоколом TLS 1.2, он обеспечивает обязательный комплект шифров TLS_RSA_WITH_AES_128_CBC_SHA по умолчанию, но, учитывая количество возможных реализаций для каждого из криптографических методов ввиду возможностей оборудования и других соображений, NetX Secure предоставляет универсальный криптографический API, позволяющий пользователю указать, какие криптографические методы использовать в протоколе TLS.</span><span class="sxs-lookup"><span data-stu-id="929ee-460">Being TLS 1.2-compliant, NetX Secure enables the mandatory TLS_RSA_WITH_AES_128_CBC_SHA ciphersuite by default, but given the number of possible implementations for each of the cryptographic methods due to hardware capabilities and other considerations, NetX Secure provides a generic cryptographic API that allows a user to specify which cryptographic methods to use with TLS.</span></span>

> [!NOTE]
> <span data-ttu-id="929ee-461">Механизм универсального криптографического API также позволяет пользователям реализовать собственные комплекты шифров, но это рекомендуется для опытных пользователей, уже работавших с комплектами шифров и расширениями TLS.</span><span class="sxs-lookup"><span data-stu-id="929ee-461">The generic cryptographic API mechanism also allows users to implement their own ciphersuites, but this is recommended for advanced users who are familiar with the TLS ciphersuites and extensions.</span></span> <span data-ttu-id="929ee-462">Если вы заинтересованы в поддержке собственных комплектов шифров, обратитесь к своему представителю Express Logic.</span><span class="sxs-lookup"><span data-stu-id="929ee-462">Please contact your Express Logic representative if you are interested in supporting your own ciphersuites.</span></span>

<span data-ttu-id="929ee-463">Подробное описание настройки криптографических методов для DTLS см. в главе 3 руководства пользователя NetX Secure TLS.</span><span class="sxs-lookup"><span data-stu-id="929ee-463">Please see the NetX Secure TLS User Guide, Chapter 3 for a detailed discussion about how to configure cryptographic methods for DTLS.</span></span> <span data-ttu-id="929ee-464">Для протоколов TLS и DTLS используются одинаковые процедуры.</span><span class="sxs-lookup"><span data-stu-id="929ee-464">The same process applies to both TLS and DTLS.</span></span>
