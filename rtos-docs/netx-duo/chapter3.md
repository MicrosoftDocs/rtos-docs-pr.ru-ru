---
title: Глава 3. Функциональные компоненты ОСРВ Azure NetX Duo
description: В этой главе с точки зрения функциональности описывается высокопроизводительный стек TCP/IP ОСРВ Azure NetX Duo.
author: philmea
ms.author: philmea
ms.date: 05/19/2020
ms.topic: article
ms.service: rtos
ms.openlocfilehash: 32af483db1f97b45bfe3d334b8c79d984dedc8470a37ce1d4164331549b6954c
ms.sourcegitcommit: 93d716cf7e3d735b18246d659ec9ec7f82c336de
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/07/2021
ms.locfileid: "116789054"
---
# <a name="chapter-3---functional-components-of-azure-rtos-netx-duo"></a>Глава 3. Функциональные компоненты ОСРВ Azure NetX Duo

В этой главе с точки зрения функциональности описывается высокопроизводительный стек TCP/IP ОСРВ Azure NetX Duo. 

## <a name="execution-overview"></a>Общие сведения о выполнении

В приложении NetX Duo существует пять типов выполнения программы: инициализация, вызовы интерфейса приложения, внутренний IP-поток, периодические IP-таймеры и драйвер сети.

> [!NOTE]
> *NetX Duo предполагает наличие системы ThreadX и использует ее выполнение потока, приостановку, периодические таймеры и средства взаимного исключения.*

### <a name="initialization"></a>Инициализация

Службу ***nx_system_initialize** _ необходимо вызывать до вызова любой другой службы NetX Duo. Инициализацию системы можно вызвать из функции ThreadX _ *_tx_application_define_** или из потоков приложения.

После возврата ***nx_system_initialize** _ система готова к созданию пулов пакетов и IP-экземпляров. Поскольку для создания IP-экземпляра требуется пул пакетов по умолчанию, на момент его создания должен существовать по крайней мере один пул пакетов NetX Duo. Создавать пулы пакетов и IP-экземпляры разрешено из функции инициализации ThreadX _ *_tx_application_define_** и из потоков приложения.

На внутреннем уровне создание экземпляра IP-адреса выполняется в два этапа: первая часть выполняется в контексте вызывающего объекта, из ***tx_application_define***, либо из контекста потока приложения. Она предусматривает настройку структуры данных IP и создание различных ресурсов IP, в том числе внутреннего IP-потока. Вторая часть осуществляется во время начального выполнения из внутреннего IP-потока. Именно на этом этапе первый раз вызывается драйвер сети, предоставляемый при выполнении первой части процесса создания IP-экземпляра. Вызов сетевого драйвера из внутреннего IP-потока позволяет драйверу выполнять операции ввода-вывода и приостанавливать выполнение при обработке инициализации.

Когда сетевой драйвер возвращает результат обработки инициализации, создание IP-экземпляра завершается.

Инициализация IPv6 в NetX Duo требует наличия нескольких дополнительных служб NetX Duo. Они описаны более подробно в разделе [IPv6 в NetX Duo](#ipv6-in-netx-duo) далее в этой главе.

> [!NOTE]
> *Служба NetX Duo **nx_ip_status_check** доступна для получения сведений об экземпляре IP и состоянии его основного интерфейса. Такие сведения о состоянии включают информацию о том, была ли ссылка инициализирована, включена и был ли разрешен IP-адрес. Эти сведения используются для синхронизации потоков приложений, которым нужно использовать только что созданный экземпляр IP. Для получения информации о системах с множественной адресацией см. раздел [Поддержка множественной адресации](#multihome-support). **nx_ip_interface_status_check** доступен для получения информации по указанному интерфейсу.*

### <a name="application-interface-calls"></a>Вызовы интерфейса приложения

Вызовы из приложения в основном выполняются из потоков приложений, работающих под управлением ОСРВ ThreadX. Однако некоторые службы инициализации, создания и включения можно вызывать из ***tx_application_define***. В разделах "Разрешено с" в [главе 4. Описание служб ОСРВ Azure NetX Duo](chapter4.md) указано, откуда можно вызывать каждую из служб NetX Duo.

В большинстве случаев обработка ресурсоемких операций, таких как вычисление контрольных сумм, выполняется в контексте вызывающего потока и не приводит к блокированию доступ других потоков к IP-экземпляру. Например, при передаче перед вызовом базовой функции отправки IP-пакетов в службе ***nx_udp_socket_send** _ выполняется расчет контрольной суммы UDP. Для полученного пакета контрольная сумма UDP вычисляется в службе _ *_nx_udp_socket_receive_**, которая выполняется в контексте потока приложения. Это помогает предотвратить приостановку обработки сетевых запросов с более высоким приоритетом в связи с ресурсоемким вычислением контрольной суммы в потоках с более низким приоритетом.

Такие значения, как IP-адреса и номера портов, передаются API в соответствии с порядком байтов узла. Для внутренних целей эти значения также хранятся в соответствии с этим порядком. Это позволяет разработчикам легко просматривать значения с помощью отладчика. Если эти значения запрограммированы в кадре для передачи, они преобразуются в сетевой порядок байтов.

### <a name="internal-ip-thread"></a>Внутренний IP-поток

Как уже упоминалось, у каждого IP-экземпляра в NetX Duo имеется собственный поток. Приоритет и размер стека внутреннего IP-потока определяются в службе ***nx_ip_create***. Внутренний IP-поток создается в режиме готовности к выполнению. Если IP-поток имеет более высокий приоритет, чем вызывающий поток, при вызове операции создания IP-адреса может произойти вытеснение.

Точка входа во внутренний IP-поток находится во внутренней функции ***_nx_ip_thread_entry***. При запуске внутренний IP-поток сначала выполняет инициализацию драйвера сети, которая заключается в выполнении трех вызовов драйвера сети конкретного приложения. Первый вызов обеспечивает присоединение сетевого драйвера к IP-экземпляру. Далее следует вызов инициализации, который позволяет сетевому драйверу пройти процесс инициализации. После того как сетевой драйвер возвращается из состояния инициализации (он может быть приостановлен, ожидая правильной настройки оборудования), внутренний IP-поток снова вызывает его, чтобы включить канал. После возврата сетевого драйвера из вызова включения канала внутренний IP-поток переходит в бесконечный цикл проверки для различных событий, требующих обработки для данного IP-экземпляра. События, обрабатываемые в этом цикле, включают отложенное получение IP-пакетов, сборку фрагментов IP-пакетов, обработку проверки связи ICMP, обработку IGMP, обработку очереди пакетов TCP, периодическую обработку TCP, истечение времени ожидания сборки фрагментов IP-адресов и периодическую обработку IGMP. События также включают действия по разрешению адресов; обработку пакетов ARP и периодическую обработку ARP в IPv4, обнаружение повторяющихся адресов, запрос маршрутизатора и обнаружение соседей в IPv6.

> [!CAUTION]
> *Функции обратного вызова NetX Duo, включая обратные вызовы операций ожидания передачи данных и отключения, вызываются не из исходного вызывающего потока, а из внутреннего IP-потока. В приложении должны быть приняты меры для предотвращения приостановки внутри любой функции обратного вызова NetX Duo.*

### <a name="ip-periodic-timers"></a>Периодические таймеры IP-экземпляра

Для каждого IP-экземпляра используется два периодических таймера ThreadX. Первый — это секундный таймер для времени ожидания ARP, IGMP и TCP, а также для инициализации обработки повторной сборки фрагмента IP-пакета. Второй таймер — это таймер на 100 мс, позволяющий управлять временем ожидания повторной отправки TCP-пакетов и операциями, связанными с IPv6.

### <a name="network-driver"></a>Сетевой драйвер

Каждый IP-экземпляр в NetX Duo имеет основной интерфейс, который определяется драйвером устройства, указанным в службе ***nx_ip_create***. Сетевой драйвер отвечает за обработку различных запросов NetX Duo, в том числе запросов на передачу и получение пакетов, а также запросов состояния и управления. 

В системах с множественной адресацией IP-экземпляр имеет несколько интерфейсов, у каждого из которых имеется соответствующий сетевой драйвер, выполняющий эти задачи для соответствующего интерфейса.

Сетевой драйвер также должен обрабатывать асинхронные события, происходящие на носителе. Асинхронные события с носителя включают в себя получение пакетов, завершение передачи пакетов и изменение состояния. NetX Duo предоставляет сетевой драйвер с несколькими функциями доступа для управления различными событиями. Эти функции предназначены для вызова из части сетевого драйвера, связанной с подпрограммой обработки прерываний. Для сетей IPv4 сетевой драйвер должен пересылать все полученные ARP-пакеты внутренней функции ***_nx_arp_packet_deferred_receive***. Все пакеты RARP должны перенаправляться внутренней функции * **_nx_rarp_packet_deferred_receive** _. Для IP-пакетов существует два варианта. Если требуется быстрая отправка IP-пакетов, входящие IP-пакеты должны перенаправляться в _ *_ _nx_ip_packet_receive_* _ для немедленной обработки. Это значительно повышает производительность NetX Duo при обработке IP-пакетов. В противном случае следует пересылать IP-пакеты в _ *_ _nx_ip_packet_deferred_receive_**. Эта служба помещает IP-пакет в очередь отложенной обработки, где он обрабатывается внутренним IP-потоком, что обеспечивает минимальное время обработки ISR.

Сетевой драйвер также может отложить обработку прерываний для выполнения вне контекста IP-потока. В этом режиме ISR сохраняет необходимые сведения, вызывает внутреннюю функцию ***_nx_ip_driver_deferred_processing*** и подтверждает использование контроллера прерываний. Эта служба уведомляет IP-поток о том, что необходимо запланировать обратный вызов драйвера устройства для завершения обработки события, вызывающего прерывание.

Некоторые сетевые контроллеры способны выполнять вычисление и проверку контрольной суммы заголовков TCP/IP аппаратными средствами, не расходуя ценные ресурсы ЦП. Для использования функции возможностей оборудования NetX Duo предоставляет возможность включать или отключать различные вычисления контрольных сумм программного обеспечения во время компиляции, а также включать или отключать вычисления контрольных сумм во время выполнения, если драйвер устройства может сообщить IP-уровню возможности его оборудования. Более подробные сведения о создании сетевых драйверов NetX Duo см. в главе 5 [Сетевые драйверы NetX Duo ОСРВ Azure](chapter5.md).

### <a name="multihome-support"></a>Поддержка множественной адресации

NetX Duo поддерживает системы, подключенные к нескольким физическим устройствам с помощью одного экземпляра IP. Каждый физический интерфейс назначается блоку управления взаимодействием в IP-экземпляре. Приложения, желающие использовать систему с несколькими домашними устройствами, должны устанавливать значение ***NX_MAX_PHSYCIAL_INTERFACES** _, равное количеству физических устройств, подключенных к системе, и перестраивать библиотеку NetX Duo. По умолчанию значение _ *_NX_MAX_PHYSICAL_INTERFACES_** равно единице, что обеспечивает создание одного блока управления взаимодействием в IP-экземпляре.

Приложение NetX Duo создает один экземпляр IP-адреса для основного устройства с помощью службы ***nx_ip_create** _. Для каждого дополнительного сетевого устройства приложение подключает устройство к IP-экземпляру с помощью службы _ *_nx_ip_interface_attach_**.

Каждая структура сетевого интерфейса содержит подмножество сетевых сведений о сетевом интерфейсе, который содержится в блоке управления IP-экземпляра, в том числе адрес IPv4 интерфейса, маску подсети, размер MTU IP-экземпляра и сведения об адресе MAC-уровня.

> [!NOTE]
> *NetX Duo с поддержкой множественной адресации обеспечивает обратную совместимость с более ранними версиями NetX Duo. Службы, которые не принимают явные сведения об интерфейсе, используют в качестве устройства по умолчанию основное сетевое устройство.*

Первичный интерфейс имеет нулевой индекс в списке IP-экземпляров. Каждому последующему устройству, подключенному к IP-экземпляру, присваивается следующий индекс.

Все службы протокола верхнего уровня, для которых включен экземпляр IP-адресов, включая TCP, UDP, ICMP и IGMP, доступны для всех подключенных устройств.

В большинстве случаев NetX Duo может определить оптимальный исходный адрес, который будет использоваться при передаче пакета. Адрес источника выбирается на основе адреса назначения. Службы NetX Duo добавляются, чтобы разрешить приложениям указывать конкретный адрес источника для использования в тех случаях, когда наиболее подходящий адрес источника не может быть определен адресом назначения. Например, в системе с множественной адресацией приложение должно отправлять пакет на широковещательный адрес IPv4 или адрес назначения многоадресной рассылки.

Ниже перечислены службы, предназначенные специально для разработки приложений с множественной адресацией.

- *nx_igmp_multicast_interface_join*
- *nx_igmp_multicast_interface_leave*
- *nx_ip_driver_interface_direct_command*
- *nx_ip_interface_address_get*
- *nx_ip_interface_address_mapping_configure*
- *nx_ip_interface_address_set*  
- *nx_ip_interface_attach*
- *nx_ip_interface_capability_get* 
- *nx_ip_interface_capability_set*
- *nx_ip_interface_detach*
- *nx_ip_interface_info_get*
- *nx_ip_interface_mtu_set*
- *nx_ip_interface_physical_address_get*
- *nx_ip_interface_physical_address_set*
- *nx_ip_interface_status_check*
- *nx_ip_raw_packet_source_send*
- *nx_ipv4_multicast_interface_join*
- *nx_ipv4_multicast_interface_leave*
- *nx_udp_socket_source_send*
- *nxd_ipv6_multicast_interface_join*
- *nxd_ipv6_multicast_interface_leave* 
- *nxd_udp_socket_source_send*
- *nxd_icmp_source_ping*
- *nxd_ip_raw_packet_source_send*
- *nxd_udp_socket_source_send*

Эти службы более подробно описаны в [Описании служб NetX Duo](chapter4.md).

### <a name="loopback-interface"></a>Интерфейс замыкания на себя

Интерфейс замыкания на себя — это специальный сетевой интерфейс без подключения физического канала. Интерфейс замыкания на себя позволяет приложениям обмениваться данными с помощью петлевого адреса IPv4 127.0.0.1. Для использования логического интерфейса замыкания на себя убедитесь, что настраиваемый параметр ***NX_DISABLE_LOOPBACK_INTERFACE*** не задан.

### <a name="interface-control-blocks"></a>Блоки управления взаимодействием

Количество блоков управления взаимодействием в IP-экземпляре — это число физических интерфейсов (определяемое ***NX_MAX_PHYSICAL_INTERFACES** _), плюс интерфейс замыкания на себя, если он включен. Общее число интерфейсов определяется в _*_NX_MAX_IP_INTERFACES_**.

## <a name="protocol-layering"></a>Разделение протокола на уровни

Протокол TCP/IP, реализованный в NetX Duo, является многоуровневым протоколом. Это означает, что более сложные протоколы основаны на более простых базовых протоколах. В протоколе TCP/IP протокол самого низкого уровня находится на *канальном уровне* и обрабатывается сетевым драйвером. Этот уровень обычно предназначен для Ethernet, но он также может быть реализован на базе оптоволоконного или последовательного канала или практически любого физического носителя.

Над канальным уровнем находится *сетевой*. В TCP/IP это IP-интерфейс, который, по сути, отвечает за отправку и получение простых пакетов по сети по принципу наименьших затрат. Протоколы типов управления, такие как ICMP и IGMP, обычно также делятся на сетевые уровни, хотя и используют IP-протокол для отправки и получения.

*Транспортный уровень* располагается поверх сетевого. Этот уровень отвечает за управление потоком данных между узлами в сети. Существует два типа транспортных служб, поддерживаемых NetX Duo: UDP и TCP. Службы UDP обеспечивают отправку и получение данных между двумя узлами по принципу наименьших затрат без установки подключения, в то время как TCP обеспечивает надежное обслуживание с ориентацией на подключение для передачи данных между двумя сущностями узла.

Это разделение на уровни отражается на фактических пакетах сетевых данных. Каждый слой в TCP/IP содержит блок данных, называемый заголовком. Такой метод заключения данных (и, возможно, сведений о протоколе) в заголовок обычно называется инкапсуляцией данных. На рис. 1 показан пример многоуровневого NetX Duo, а на рис. 2 показана полученная инкапсуляция данных для отправляемых данных UDP.

![Разделение протокола на уровни](./media/user-guide/image12.jpg)

**РИС. 1. Разделение протокола на уровни**

## <a name="packet-pools"></a>Пулы пакетов

Быстрое и детерминированное выделение пакетов — вечная проблема в сетевых приложениях реального времени. Ввиду этого NetX Duo предоставляет возможность создать и администрировать несколько пулов сетевых пакетов фиксированного размера.

Так как пулы пакетов NetX Duo состоят из блоков памяти фиксированного размера, никаких внутренних проблем фрагментации не возникает. Конечно, фрагментация приводит к поведению, которое, по сути, является недетерминированным. Кроме того, время, необходимое для выделения и освобождения пакета NetX Duo, соответствует времени простой операции со связанным списком. Более того, выделение и освобождение пакета выполняется на уровне заголовка списка доступных ресурсов. Это обеспечивает максимально быструю обработку связанного списка.

![Инкапсуляция данных UDP](./media/user-guide/image13.png)

**РИС. 2. Инкапсуляция данных UDP**

Отсутствие гибкости обычно является основным недостатком пулов пакетов фиксированного размера. Определение оптимального размера полезных данных пакета, который также позволит обрабатывать входящие пакеты в худшем случае, — сложная задача. Пакеты NetX Duo устраняют эту проблему с помощью необязательного компонента, называемого цепочкой пакетов. Фактический сетевой пакет может состоять из одного или нескольких пакетов NetX Duo, связанных друг с другом. Кроме того, в заголовке пакета хранится указатель на верхнюю часть пакета. По мере добавления дополнительных протоколов этот указатель просто смещается назад, а непосредственно перед данными записывается новый заголовок. Без технологии гибких пакетов стеку пришлось бы выделить другой буфер и скопировать данные в новый буфер с новым заголовком, а это весьма ресурсоемкая задача.

Так как размер полезных данных каждого пакета фиксирован для заданного пула пакетов, данные приложения, превышающие размер полезных данных, потребуют объединения нескольких пакетов в цепочку. При заполнении пакета данными пользователя приложение должно использовать службу ***nx_packet_data_append***. Эта служба перемещает данные приложения в пакет. В ситуациях, когда пакета недостаточно для хранения пользовательских данных, для них выделяются дополнительные пакеты. Чтобы использовать цепочку пакетов, у драйвера должна быть возможность получения и передачи данных в объединенных в цепочку пакетах.

Для встроенных систем, которым не нужно использовать функцию создания цепочек пакетов, библиотеку NetX Duo можно построить с помощью ***NX_DISABLE_PACKET_CHAIN** _, чтобы удалить логику цепочки пакетов. Обратите внимание, что для возможности фрагментации и пересборки IP-адресов может быть необходимо использовать функцию сцепленных пакетов. Поэтому для определения _*_NX_DISABLE_PACKET_CHAIN_*_ необходимо также определить _ *_NX_DISABLE_FRAGMENTATION_**. 

Каждый пул памяти пакетов NetX Duo является общедоступным ресурсом. NetX Duo не накладывает ограничений на то, как используются пулы пакетов. 

### <a name="packet-pool-memory-area"></a>Область памяти пула пакетов

Область памяти для пула пакетов задается во время его создания. Как и в случае с другими областями памяти для объектов ThreadX и NetX Duo, она может находиться в любом месте целевого адресного пространства. 

Это важная возможность, так как она обеспечивает значительную гибкость для приложения. Например, предположим, что у продукта взаимодействия имеется высокоскоростная область памяти для операций сетевых буферов. Эту область памяти можно легко использовать, превратив ее в пул памяти пакетов NetX Duo.

### <a name="creating-packet-pools"></a>Создание пулов пакетов

Пулы пакетов создаются во время инициализации или выполнения потоками приложения. Количество пулов памяти пакетов в приложении NetX Duo не ограничено.

### <a name="dual-packet-pool"></a>Двойной пул пакетов

Обычно размер полезных данных пула IP-пакетов по умолчанию достаточно велик, чтобы допускать размер кадра вплоть до MTU сетевого интерфейса. Во время нормальной работы потоку IP необходимо отправлять такие сообщения, как ARP, управляющие сообщения TCP, IGMP-сообщения, ICMPv6-сообщения. Эти сообщения используют пакеты, выделенные из пула пакетов по умолчанию в экземпляре IP. В системе с ограниченным объемом памяти, в которой объем доступной памяти для пула пакетов также ограничен, использование одного пула пакетов (с большим объемом полезных данных для соответствия размеру MTU) может оказаться неоптимальным решением. NetX Duo позволяет приложению установить вспомогательный пул пакетов, где размер полезных данных меньше. После установки вспомогательного пула пакетов вспомогательный поток IP будет выделять пакеты из пула пакетов по умолчанию или из вспомогательного пула в зависимости от размера передаваемого сообщения. Для вспомогательного пула пакетов размер полезных данных в 200 байт будет работать для большинства сообщений, передаваемых вспомогательным потоком IP.

По умолчанию библиотека NetX Duo создается без включения двойного пула пакетов. Чтобы включить эту функцию, создайте библиотеку с определенным ***NX_DUAL_PACKET_POOL_ENABLE** _. Затем можно задать вспомогательный пул пакетов, вызвав _*_nx_ip_auxiliary_packet_pool_set_**.

Существует также возможность создания более одного пула пакетов. Например, пул пакетов передачи создается с оптимальным размером полезных данных для ожидаемых размеров сообщений. Пул пакетов получения создается в драйвере с размером полезных данных, установленным на MTU драйвера, так как предсказать размер получаемых пакетов невозможно.

### <a name="packet-header-nx_packet"></a>Заголовок пакета NX_PACKET   
По умолчанию NetX Duo размещает заголовок пакета непосредственно перед областью полезных данных пакета. Пул памяти пакетов — это, по сути, ряд, состоящий из пакетов: заголовков, непосредственно за которыми следуют полезные данные пакета. Заголовок пакета (***NX_PACKET***) и макет пула пакетов изображены на рис. 3.

Обычно для драйвера сетевых устройств, который может выполнять операции без копирования, начальный адрес области полезных данных пакета запрограммирован в логике DMA. Некоторые модули DMA имеют требование к выравниванию для области полезных данных. Чтобы обеспечить правильное выведение начального адреса области полезных данных для модуля DMA или операции кэширования, пользователь может определить символ ***NX_PACKET_ALIGNMENT***.

> [!WARNING]
> *При завершении передачи пакета важно, чтобы сетевой драйвер использовал функцию **nx_packet_transmit_release**. Эта функция проверяет, что пакет не входит в очередь вывода TCP, прежде чем он фактически помещается обратно в пул доступных.*

![Заголовок пакета и макет пула пакетов](./media/user-guide/image14.jpg)

**РИС. 3. Заголовок пакета и макет пула пакетов**

Ниже приведены определения полей заголовка пакета. Обратите внимание, что эта таблица не является исчерпывающим списком всех элементов структуры *NX_PACKET*.

|Заголовок пакета | Назначение |
|---|---|
|***nx_packet_pool_owner***|Это поле указывает на пул пакетов, которому принадлежит этот конкретный пакет. После освобождения пакета он становится доступным в этом конкретном пуле. Когда владение пулом находится внутри каждого пакета, датаграмма может охватывать несколько пакетов из нескольких пулов пакетов.|
|***nx_packet_next** _|Это поле указывает на следующий пакет в том же кадре. Если значение равно NULL, дополнительные пакеты, которые являются частью кадра, отсутствуют. Это поле используется для хранения фрагментированных пакетов до тех пор, пока не выполнена повторная сборка всего пакета. оно удаляется, если определен _*_NX_DISABLE_PACKET_CHAIN_**.|
|***nx_packet_last** _|Это поле указывает на последний пакет в том же сетевом пакете. Если значение равно NULL, этот пакет представляет весь сетевой пакет. Это поле удаляется, если определено значение _*_NX_DISABLE_PACKET_CHAIN_**.|
|***nx_packet_length** _| Это поле содержит общее число байтов во всем сетевом пакете, включая общее количество байтов во всех пакетах, связанных в цепочку с помощью элемента _nx_packet_next*.|
|***nx_packet_ip_interface***| Это поле является блоком управления интерфейсом, который назначается пакету при его получении драйвером интерфейса и его получении NetX Duo для исходящих пакетов. Блок управления взаимодействием описывает интерфейс, например сетевой адрес, MAC-адрес, IP-адрес и состояние интерфейса, скажем, указывает, включена ли связь и требуется ли физическое сопоставление.|
|***nx_packet_data_start** _| Это поле указывает на начало физической области полезных данных этого пакета. Заголовок NX_PACKET не обязательно должен следовать непосредственно за ним, но для службы _ *_nx_packet_pool_create_** такая схема используется по умолчанию.|
|***nx_packet_data_end** _|Это поле указывает на конец физической области полезных данных этого пакета. Разница между этим полем и полем _nx_packet_data_start* соответствует размеру полезных данных.|
|***nx_packet_prepend_ptr** _|Это поле указывает на расположение данных пакетов (заголовка протокола либо фактических данных), добавленных перед имеющимися данными пакета (если таковые имеются) в области полезных данных пакета. Его значение должно быть большим или равным значению положения указателя _nx_packet_data_start* и меньшим или равным значению указателя *nx_packet_append_ptr*.|
> [!CAUTION]
> *В целях повышения производительности NetX Duo предполагает, что когда пакет передается в службы NetX Duo для передачи, то указатель в начале указывает на длинный адрес, выровненный по словам.*

| Заголовок пакета | Назначение |
|---|---|
|***nx_packet_append_ptr** _|Это поле указывает на конец данных, находящихся в данный момент в области полезных данных пакета. Он должен находиться между расположением в памяти, на которое указывает _nx_packet_prepend_ptr* и *nx_packet_data_end.* Разница между этим полем и полем *nx_packet_prepend_ptr* соответствует количеству данных в этом пакете.|
|***nx_packet_packet_pad** _|Эти поля определяют длину заполнения (в 4-байтовых словах) для обеспечения требуемого выравнивания. Это поле удаляется, если значение _*_NX_PACKET_HEADER_PAD_*_ не определено. Вместо определения _nx_packet_header_pad можно использовать _*_NX_PACKET_ALIGNMENT_*_.*|

### <a name="packet-header-offsets"></a>Отступ для заголовка пакета

Чтобы обеспечить достаточно места для размещения заголовка определенного размера, необходимо определить этот размер. Служба ***nx_packet_allocate*** используется для выделения пакета и корректирует положение указателя, находящегося в начале в пакете, в соответствии с заданным типом пакета. Тип пакета указывает NetX Duo отступ, необходимый для вставки заголовка протокола (например, UDP, TCP или ICMP) перед данными протокола.

Следующие типы определяются в NetX Duo, чтобы учитывать заголовок IP и заголовок физического уровня (Ethernet) в пакете. В последнем случае предполагается, что отступ равен 16 байтам при условии 4-байтового выравнивания. Пакеты IPv4 по-прежнему определяются в NetX Duo, чтобы приложения выделяли пакеты для сетей IPv4. Обратите внимание, что если библиотека NetX Duo создана с включенным протоколом IPv6, универсальные типы пакетов (такие как NX_IP_PACKET) сопоставляются с версией IPv6. Если библиотека NetX Duo создана без включенного протокола IPv6, универсальные типы пакетов сопоставляются с версией IPv4.

В следующей таблице показаны символы, определенные при включенном протоколе IPv6.

|**Тип пакета** |**Значение** |
|---|---|
|NX_IPv6_PACKET (NX_IP_PACKET) | 0x38 |
|NX_UDPv6_PACKET (NX_UDP_PACKET) |0x40 |
|NX_TCPv6_PACKET (NX_TCP_PACKET) |0x4c |
|NX_IPv4_PACKET |0x24 |
|NX_IPv4_UDP_PACKET |0x2c |
|NX_IPv4_TCP_PACKET |0x38 |

В следующей таблице показаны символы, определенные при отключенном протоколе IPv6.

|**Тип пакета** |**Значение** |
|---|---|
|NX_IPv4_PACKET (NX_IP_PACKET) |0x24 |
|NX_IPv4_UDP_PACKET (NX_UDP_PACKET) |0x2c |
|NX_IPv4_TCP_PACKET (NX_TCP_PACKET) |0x38 |

Обратите внимание, что эти значения изменятся при определенном *NX_IPSEC_ENABLE*. Дополнительные сведения о приложениях, использующих IPsec, см. в Руководстве пользователя IPsec NetX Duo.

### <a name="pool-capacity"></a>Емкость пула

Количество пакетов в пуле пакетов — это функция размера полезных данных, а также общего числа байтов в области памяти, предоставляемой службе создания пула пакетов. Емкость пула вычисляется путем деления размера пакета (с учетом размера заголовка NX_PACKET, размера полезных данных и правильного выравнивания) на общее число байтов в указанной области памяти.

### <a name="payload-area-alignment"></a>Выравнивание области полезных данных

Структура пула пакетов в NetX Duo поддерживает нулевое копирование. На уровне драйвера устройства драйвер может назначить область полезных данных непосредственно в дескрипторах буфера для приема данных. Иногда обработчику DMA или механизму синхронизации кэша требуется, чтобы начальный адрес области полезных данных имел определенное требование выравнивания. Этого можно достигнуть, определив требуемое требование выравнивания (в байтах) в ***NX_PACKET_ALIGNMENT***. При создании пула пакетов начальный адрес области полезных данных будет согласовываться с этим значением. По умолчанию начальный адрес имеет значение в байтах, являющееся производным 4.

### <a name="thread-suspension"></a>Приостановка потока

Потоки приложения могут быть приостановлены при ожидании пакета из пустого пула. Когда пакет возвращается в пул, приостановленный поток получает этот пакет и его выполнение возобновляется.

Если на одного пула пакетов приостанавливается несколько потоков, они возобновляются в том же порядке, в котором были приостановлены (FIFO).

### <a name="pool-statistics-and-errors"></a>Статистические показатели и ошибки пула

Если этот параметр включен, программное обеспечение для управления пакетами NetX Duo отслеживает несколько статистических показателей и ошибок, которые могут быть полезны для приложения. Для пулов пакетов поддерживаются следующие статистические показатели и отчеты об ошибках:

- общее количество пакетов в пуле;
- количество свободных пакетов в пуле;
- всего выделений пакетов;
- запросов на выделение из пустого пула;
- приостановок выделения из пустого пула;
- освобождений недопустимых пакетов.

Все эти статистические показатели и отчеты об ошибках, за исключением общего числа и количества свободных пакетов в пуле, встроены в библиотеку NetX Duo, если не определено значение ***NX_DISABLE_PACKET_INFO** _. Эти данные предоставляет приложению служба _ *_nx_packet_pool_info_get_**.

### <a name="packet-pool-control-block-nx_packet_pool"></a>Блок управления пула пакетов NX_PACKET_POOL

Характеристики каждого пула памяти пакетов находятся в его блоке управления. Он содержит полезную информацию, в том числе связанный список свободных пакетов, число свободных пакетов и размер полезных данных в пакетах этого пула. Эта структура определена в файле ***nx_api.h***.

Блоки управления пула пакетов могут размещаться в любом месте в памяти, но чаще всего они определяются вне области какой-либо функции, благодаря чему функционируют как глобальная структура.

## <a name="ipv4-protocol"></a>Протокол IPv4

Компонент протокола Интернета (IP) NetX Duo отвечает за отправку и получение пакетов IPv4 в Интернете. В NetX Duo этот компонент, в конечном итоге, отвечает за отправку и получение сообщений TCP, UDP, ICMP и IGMP с помощью базового драйвера сети.

NetX Duo поддерживает как протокол IPv4 (RFC 791), так и протокол IPv6 (RFC 2460). В этом разделе рассматривается IPv4. IPv6 рассматривается в следующем разделе.

### <a name="ipv4-addresses"></a>IPv4-адреса

Каждый узел в Интернете имеет уникальный 32-разрядный идентификатор, называемый IP-адресом. Существует пять классов адресов IPv4, которые продемонстрированы на рис. 4. Ниже перечислены диапазоны этих пяти классов адресов IPv4.

|Класс|Диапазон|
|---|---|
|Объект |От 0.0.0.0 до 127.255.255.255|
|B |От 128.0.0.0 до 191.255.255.255|
|C |От 192.0.0.0 до 223.255.255.255|
|D |От 224.0.0.0 до 239.255.255.255|
|E |От 240.0.0.0 до 247.255.255.255|

![Схема структуры адресов IPv4.](./media/user-guide/ipv4-address-structure.png)

### <a name="figure-4-ipv4-address-structure"></a>РИС. 4. Структура адресов IPv4

Существует также три типа спецификаций адресов: *одноадресная*, *широковещательная* и *многоадресная рассылка*. Адреса одноадресной рассылки — это адреса IPv4, которые определяют конкретный узел в Интернете. Они могут быть адресами IPv4 источника или места назначения. Широковещательный адрес позволяет идентифицировать все узлы в определенной сети или подсети и может использоваться только в качестве адреса назначения. Чтобы задать широковещательные адреса, необходимо заполнить ту их часть, которая представляет идентификатор узла, единицами. Адреса многоадресной рассылки (класс D) задают динамическую группу узлов в Интернете. Члены группы многоадресной рассылки могут присоединяться к группе и выходить из нее по мере необходимости.

> [!IMPORTANT]
> *Только протоколы без подключения, такие как UDP через IPv4, могут использовать широковещательную рассылку и ограниченные возможности широковещательной рассылки группы многоадресной рассылки.*

> [!IMPORTANT]
> * Макрос *IP_ADDRESS* определен в ***nx_api.h** _. Это позволяет легко определить адреса IPv4, используя запятые вместо точек. Например, IP_ADDRESS (128,0,0,0)* задает первый адрес класса B, показанный на рис. 4*.

### <a name="ipv4-gateway-address"></a>Адрес шлюза IPv4

Сетевые шлюзы помогают узлам в своих сетях передавать пакеты, предназначенные для мест назначений, находящихся за пределами локального домена. У каждого узла имеются определенные сведения о следующем прыжке для отправки (к месту назначения либо на один из соседних узлов) либо возможность воспользоваться предварительно запрограммированной статической таблицей маршрутизации. Но если эти подходы не работают, узел должен переадресовать пакет шлюзу по умолчанию, который содержит больше сведений о маршрутизации пакета к месту назначения. Обратите внимание, что шлюз по умолчанию должен быть напрямую доступен через один из физических интерфейсов, подключенных к IP-экземпляру. Приложение вызывает ***nx_ip_gateway_address_set** _, чтобы настроить адрес IPv4 шлюза по умолчанию. Используйте службу _*_nx_ip_gateway_address_get_*_ для получения текущих параметров шлюза IPv4. Для очистки параметра шлюза приложению следует использовать службу _ *_nx_ip_gateway_address_clear_**.

### <a name="ipv4-header"></a>Заголовок IPv4

Для отправки любого пакета IPv4 через Интернет у него должен быть заголовок IPv4. Когда протоколы более высокого уровня (UDP, TCP, ICMP или IGMP) вызывают компонент IP для отправки пакета, модуль передачи пакетов IPv4 помещает заголовок IPv4 перед данными. И наоборот, при получении IP-пакетов из сети компонент IP удаляет заголовок IPv4 из пакета перед его доставкой протоколам более высокого уровня. На рис. 5 показан формат IP-заголовка.

![Формат заголовка IPv4](./media/user-guide/ipv4-header-format.png)

### <a name="figure-5-ipv4-header-format"></a>РИС. 5. Формат заголовка IPv4

> [!IMPORTANT]
> *Все заголовки в реализации TCP/IP должны быть представлены в формате **с обратным порядком байтов**. В этом формате наиболее значимый байт слова размещается по наименьшему байтовому адресу. Например, в IP-адресе поля "4-разрядное поле версии" и "4-разрядное поле длины заголовка" должны располагаться в первом байте заголовка.*

Ниже приведены определения полей заголовка IPv4.

|Поле &nbsp;заголовка&nbsp; IPv4 |Назначение |
|---|---|
|***4-разрядная версия*** |Это поле содержит версию IP-адреса, которую представляет этот заголовок. Для IP версии 4, которую поддерживает NetX Duo, значение этого поля равно 4. |
|***4-разрядная длина заголовка*** |В этом поле указывается число 32-разрядных слов в IP-заголовке. Если необязательные слова отсутствуют, значение этого поля равно 5. |
|***8-разрядный тип службы (TOS)*** |В этом поле указывается тип службы, запрошенной для этого IP-пакета. Допустимые запросы приведены ниже:<br />— Обычная: 0x00 <br />— Минимальная задержка: 0x00<br />— Максимальный размер данных: 0x08<br />— Максимальная надежность: 0x04<br />— Минимальная стоимость: 0x02 |
|***16-разрядная общая длина*** |Это поле содержит общую длину IP-датаграммы в байтах, включая IP-заголовок. IP-датаграмма — это основная единица информации, передаваемая в Интернете по протоколу TCP/IP. Помимо данных, она содержит адреса источника и назначения. Поскольку это 16-разрядное поле, максимальный размер IP-датаграммы составляет 65 535 байт.|
|***16-разрядная идентификация*** |Значение этого поля равно числу, используемому для уникальной идентификации каждой IP-датаграммы, отправленной с узла. Это число обычно увеличивается после отправки IP-датаграммы. Оно играет важную роль при сборке полученных фрагментов IP-пакетов.|
|***3-разрядные флаги*** |Это поле содержит сведения о фрагментации IP-пакетов. 14-й бит — это бит, требующий отсутствия фрагментации. Если этот бит задан, исходящая IP-датаграмма не фрагментируется. 13-й бит — это бит, требующий дополнительных фрагментов. Если этот бит задан, то существуют дополнительные фрагменты. Если этот бит очищен, это последний фрагмент IP-пакета.|
|***13-разрядное смещение фрагмента*** |Это поле содержит верхние 13 бит смещения фрагмента. По этой причине смещения фрагментов разрешены только для 8-байтовых границ. В первом фрагменте фрагментированной IP-датаграммы будет установлен бит наличия дополнительных фрагментов, а смещение будет равно 0.|
|***8-разрядный срок жизни (TTL)*** |Это поле содержит число маршрутизаторов, через которые может быть передана эта датаграмма, которое, по сути, ограничивает время ее существования.|
|***8-разрядный протокол***|В этом поле указывается, какой протокол использует IP-датаграмму. Ниже приведен список допустимых протоколов и их значения:<br />— ICMP: 0x01 <br />— IGMP: 0x02<br />— TCP: 0X06<br />— UDP: 0X11 |
|***16-разрядная контрольная сумма*** |Это поле содержит 16-разрядное значение контрольной суммы, охватывающее только IP-заголовок. В протоколах более высокого уровня имеются дополнительные контрольные суммы, охватывающие полезные данные IP. |
|***32-разрядный IP-адрес источника*** |Это поле содержит IP-адрес отправителя и всегда является адресом узла. |
|***32-разрядный IP-адрес назначения*** |Это поле содержит IP-адрес одного или нескольких (если это широковещательный адрес или адрес многоадресной рассылки) получателей. |

### <a name="creating-ip-instances"></a>Создание IP-экземпляров

IP-экземпляры создаются во время инициализации или выполнения потоками приложения. Начальный адрес IPv4, маска сети, пул пакетов по умолчанию, драйвер носителя, а также память и приоритет внутреннего потока IP определяются службой ***nx_ip_create***, даже если в приложении планируется использовать только сети IPv6. Если приложение инициализирует IP-экземпляр с адресом IPv4, значение которого недопустимо (0.0.0.0), предполагается, что адрес интерфейса будет позже разрешен вручную, с помощью RARP, либо через DHCP или аналогичный протокол.

Для систем с несколькими сетевыми интерфейсами основной интерфейс назначается при вызове ***nx_ip_create** _. Все дополнительные интерфейсы можно подключить к одному и тому же IP-экземпляру, вызвав _*_nx_ip_interface_attach_**. Эта служба хранит сведения о сетевом интерфейсе (например, IP-адрес, маску сети) в блоке управления взаимодействием и связывает экземпляр драйвера с блоком управления взаимодействием в IP-экземпляре. Когда драйвер получает пакет данных, ему необходимо сохранить сведения об интерфейсе в структуре NX_PACKET перед отправкой в логику приема IP-пакетов. Обратите внимание, что перед присоединением интерфейсов необходимо сначала создать IP-экземпляр.

Службы IPv6 не запускаются после вызова ***nx_ip_create** _. Приложения, желающие использовать службы IPv6, должны вызывать службу _ *_nx_ipv6_enable_** для запуска протокола IPv6.

В сети IPv6 каждый интерфейс в экземпляре IP может иметь несколько глобальных адресов IPv6. Кроме использования протокола DHCPv6 для назначения адресов IPv6, устройство может также использовать автонастройку адресов без отслеживания состояния. Дополнительные сведения см. в разделах "Блок управления IP" и "Разрешение адресов IPv6" далее в этой главе.

### <a name="ip-send"></a>Отправка IP-пакетов

Обработка IP-отправки в NetX Duo очень проста. Указатель в начале пакета перемещается назад для размещения IP-заголовка. Заголовок IP-адреса готов (содержит все параметры, заданные на уровне вызывающего протокола), контрольная сумма IP вычисляется в строке (только для пакетов IPv4), а пакет отправляется в соответствующий драйвер сети. Кроме того, исходящая фрагментация также координируется в рамках обработки отправки IP-пакетов.

Для IPv4 NetX Duo инициирует запросы ARP, если для целевого IP-адреса требуется физическое сопоставление. IPv6 использует обнаружение соседей для сопоставления адресов IPv6 с физическими адресами.

> [!NOTE]
> *Для подключений по протоколу IPv4 пакеты, требующие разрешения IP-адресов (т. е. физического сопоставления), помещаются в очередь ARP до тех пор, пока число пакетов в очереди не превысит глубину очереди ARP (определяется символом **NX_ARP_MAX_QUEUE_DEPTH**). Если глубина очереди достигнута, NetX Duo удалит самый старый пакет в очереди и продолжит ожидание разрешения адреса для оставшихся пакетов, поставленных в очередь. С другой стороны, если разрешение записи ARP не выполнено, ожидающие пакеты в записи ARP освобождаются после истечения времени ожидания записи ARP.*

Для систем с несколькими сетевыми интерфейсами NetX Duo выбирает интерфейс на основе IP-адреса назначения. В процессе выбора применяется следующая процедура.

1. Если отправитель указывает исходящий интерфейс и интерфейс является допустимым, используйте этот интерфейс.
2. Если адрес назначения является широковещательной или многоадресной рассылкой по протоколу IPv4, используется первый включенный физический интерфейс.
3. Если адрес назначения присутствует в таблице статической маршрутизации, используется интерфейс, связанный со шлюзом.
4. Если назначением является адрес с прямым подключением, используется интерфейс прямого подключения.
5. Если адрес назначения является адресом локальной связи (169.254.0.0/16), то используется первый допустимый интерфейс.
6. Если шлюз по умолчанию настроен, для передачи пакета используется интерфейс, связанный со шлюзом по умолчанию.
7. Наконец, если один из допустимых IP-адресов интерфейса является адресом локальной связи (169.254.0.0/16), этот интерфейс используется в качестве исходного адреса для передачи.
8. Выходной пакет удаляется, если все вышеуказанные сбои завершились ошибкой.

### <a name="ip-receive"></a>Получение IP-пакетов

Обработка получения IP-пакетов вызывается либо из сетевого драйвера, либо из внутреннего IP-потока (для обработки пакетов в очереди пакетов с отложенным получением). При обработке получения IP-пакетов проверяется поле протокола и предпринимается попытка отправить пакет в соответствующий компонент протокола. Перед тем как пакет будет фактически отправлен, IP-заголовок удаляется путем перемещения расположенного в начале пакета указателя за IP-заголовок.

При обработке получения IP-пакетов также обнаруживаются фрагментированные IP-пакеты и, если включена фрагментация, выполняются необходимые действия для их сборки. Если требуется фрагментация, но она не включена, пакет удаляется.

NetX Duo определяет соответствующий сетевой интерфейс на основе интерфейса, указанного в пакете. Если интерфейс пакета имеет значение NULL, по умолчанию NetX Duo будет использовать основной интерфейс. Это делается для обеспечения совместимости с устаревшими драйверами Ethernet NetX Duo.

### <a name="raw-ip-send"></a>Отправка необработанных IP-пакетов

Необработанный IP-пакет — это IP-кадр, который содержит полезные данные протокола верхнего уровня, которые не поддерживаются напрямую (и не обрабатываются) NetX Duo. Необработанный пакет позволяет разработчикам определять собственные приложения на основе протокола IP. Приложение может отправлять необработанные IP-пакеты напрямую с помощью службы ***nxd_ip_raw_packet_send** _, если в службе _*_nx_ip_raw_packet_enabled_*_ включена их обработка. При передаче одноадресного пакета в сети IPv6 NetX Duo автоматически определяет оптимальный исходный IPv6-адрес, который будет использоваться для отправки пакетов, на основе адреса назначения. Однако если адрес назначения является адресом многоадресной рассылки (или широковещательной рассылки для IPv4), NetX Duo по умолчанию будет использовать первый (основной) интерфейс. Таким образом, чтобы отправить такие пакеты во вторичные интерфейсы, приложение должно воспользоваться службой _ *_nx_ip_raw_packet_source_send_**, чтобы задать исходный адрес, используемый для исходящего пакета.

### <a name="raw-ip-receive"></a>Получение необработанных IP-пакетов

Если включена обработка необработанных IP-пакетов, приложение может получать необработанные IP-пакеты с помощью службы ***nx_ip_raw_packet_receive** _. Все входящие пакеты обрабатываются в соответствии с протоколом, указанным в IP-заголовке. Если протокол указывает UDP, TCP, IGMP или ICMP, NetX Duo обработает пакет, используя соответствующий обработчик для типа протокола пакетов. Если протокол не является одним из этих протоколов и включен режим получения необработанных IP-пакетов, входящий пакет будет помещен в очередь необработанных пакетов, ожидая, когда приложение получит его через _службу *_nx_ip_raw_packet_receive_**. Кроме того, потоки приложений могут быть приостановлены с необязательным временем ожидания при ожидании необработанного IP-пакета. Количество пакетов, которые могут быть поставлены в очередь необработанных пакетов, ограничено. Максимальное значение определяется в ***NX_IP_RAW_MAX_QUEUE_DEPTH**_, значение по умолчанию — 20. Приложение может изменить максимальное значение, вызвав службу _ *_nx_ip_raw_receive_queue_max_set_**.

Кроме того, библиотеку NetX Duo можно создать с помощью ***NX_ENABLE_IP_RAW_PACKET_FILTER *.** В этом режиме работы приложение предоставляет функцию обратного вызова, которая вызывается каждый раз при получении пакета с необработанным типом протокола. Логика приема IP-адресов пересылает пакет в определенную пользователем подпрограмму фильтра получения необработанных пакетов. Подпрограмма фильтра определяет, необходимо ли сохранить необработанный пакет для будущего процесса. Возвращаемое значение из подпрограммы обратного вызова указывает, был ли пакет обработан фильтром получения необработанных пакетов. Если пакет обрабатывается функцией обратного вызова, пакет должен быть освобожден после завершения работы приложения с пакетом. В ином случае NetX Duo отвечает за освобождение пакета. Дополнительные сведения об использовании функции фильтрации необработанных пакетов см. в **_nx_ip_raw_packet_filter_set_**.

> [!NOTE]
> * Функция-оболочка BSD для NetX Duo использует функцию фильтрации необработанных пакетов для обработки необработанных сокетов BSD. Таким образом, для поддержки необработанного сокета в оболочке BSD библиотека NetX Duo должна быть построена с помощью ***NX_ENABLE_IP_RAW_PACKET_FILTER** _, а приложение не должно использовать _*_nx_ip_raw_packet_filter_set_*_ для установки собственного фильтра необработанных пакетов functions._

### <a name="default-packet-pool"></a>Пул пакетов по умолчанию

Каждый IP-экземпляр получает во время создания пул пакетов по умолчанию. Этот пул пакетов используется, чтобы выделять пакеты для ARP, RARP, ICMP, IGMP, различных пакетов управления TCP (SYN, ACK и т. д.), обнаружения соседей, маршрутизатора и повторяющихся адресов. Если пул пакетов по умолчанию пуст, когда NetX Duo должно выделить пакет, NetX Duo может прервать эту конкретную операцию и по возможности возвратит сообщение об ошибке.

### <a name="ip-helper-thread"></a>Вспомогательный IP-поток

Каждый IP-экземпляр имеет вспомогательный поток. Этот поток отвечает за выполнение обработки всех отложенных пакетов и периодическую обработку. Вспомогательный поток IP-адресов создается в ***nx_ip_create.*** Именно там потоку даются его стек и приоритет. Обратите внимание, что первая обработка во вспомогательном IP-потоке заключается в завершении инициализации сетевого драйвера, связанного со службой создания IP-экземпляра. После завершения инициализации сетевого драйвера вспомогательный поток запускает бесконечный цикл обработки пакетов и периодических запросов.

> [!IMPORTANT]
> *Если во вспомогательном IP-потоке наблюдается необъяснимое поведение, первым этапом отладки будет увеличение размера стека во время работы службы создания IP-экземпляра. Если стек слишком мал, вспомогательный IP-поток может перезаписывать память, что может вызвать необычные проблемы.*

### <a name="thread-suspension"></a>Приостановка потока

При попытке получения необработанных IP-пакетов потоки приложения могут быть приостановлены. После получения необработанного пакета первому приостановленному потоку присваивается новый пакет, и этот поток возобновляется. У всех служб получения пакетов NetX Duo имеется дополнительная функция времени ожидания приостановки. При получении пакета или истечении времени ожидания выполнение потока приложения возобновляется с соответствующим состоянием завершения.

### <a name="ip-statistics-and-errors"></a>Статистические показатели и ошибки IP-экземпляра

Если этот параметр включен, NetX Duo отслеживает несколько статистических показателей и ошибок, которые могут быть полезны для приложения. Для каждого IP-экземпляра поддерживаются следующие статистические показатели и отчеты об ошибках:

- общее число отправленных IP-пакетов;
- общее число байтов, отправленных по протоколу IP;
- общее число полученных IP-пакетов;
- общее число байтов, полученных по протоколу IP;
- общее число недопустимых IP-пакетов;
- общее число отброшенных пакетов, получаемых по протоколу IP;
- общее число ошибок контрольной суммы при получении по протоколу IP;
- общее число отброшенных пакетов, отправляемых по протоколу IP;
- общее число отправленных фрагментов IP-пакетов;
- общее число полученных фрагментов IP-пакетов.

Все эти статистические показатели и отчеты об ошибках предоставляются приложению службой ***nx_ip_info_get***.

### <a name="ip-control-block-nx_ip"></a>Блок управления IP NX_IP

Характеристики каждого IP-экземпляра находятся в его блоке управления. Он содержит такие полезные сведения, как IP-адреса и маски сети каждого сетевого устройства, а также таблицу соседних IP-адресов и сопоставления адресов физического оборудования. Эта структура определена в файле ***nx_api.h** _. Если протокол IPv6 включен, он также содержит массив IPv6-адресов, число которых указывается пользователем с помощью параметра _*_NX_MAX_IPV6_ADDRESSES_**. Значение по умолчанию позволяет каждому физическому сетевому интерфейсу иметь три адреса IPv6.

Блоки управления экземпляра IP могут размещаться в любом месте в памяти, но чаще всего они определяются вне области какой-либо функции, благодаря чему функционируют как глобальная структура.

### <a name="static-ipv4-routing"></a>Статическая маршрутизация IPv4

Функция статической маршрутизации позволяет приложению указать сеть IPv4 и адрес следующего прыжка для конкретных IP-адресов назначения вне сети. Если включена статическая маршрутизация, NetX Duo выполняет поиск записи, соответствующей адресу назначения отправляемого пакета, в статической таблице маршрутизации. Если совпадений не найдено, NetX Duo выполняет поиск по списку физических интерфейсов и выбирает исходный IP-адрес и адрес следующего прыжка на основе IP-адреса назначения и маски сети. Если назначение не соответствует ни одному из IP-адресов сетевых драйверов, подключенных к экземпляру IP-адреса, NetX Duo выбирает интерфейс, напрямую подключенный к шлюзу по умолчанию, и использует IP-адрес интерфейса в качестве исходного адреса, а шлюз по умолчанию — в качестве следующего прыжка.

Записи можно добавлять и удалять из таблицы статической маршрутизации с помощью служб ***nx_ip_static_route_add** _ и _ *_nx_ip_static_route_delete_**, соответственно. Чтобы использовать статическую маршрутизацию, ведущее приложение должно включить эту функцию, определив значение ***NX_ENABLE_IP_STATIC_ROUTING.***

> [!NOTE]
> *При добавлении записи в таблицу статической маршрутизации NetX Duo проверяет наличие соответствующей записи для указанного адреса назначения, уже находящегося в таблице. Если таковая существует, NetX Duo дает предпочтение записи с меньшей сетью (более длинным префиксом) в маске сети.*

### <a name="ipv4-forwarding"></a>Пересылка IPv4

Если входящий пакет IPv4 не предназначен для этого узла и включена функция переадресации IPv4, NetX Duo пытается перенаправить пакет через другие интерфейсы.  

### <a name="ip-fragmentation"></a>Фрагментация IP-пакетов

У сетевого устройства могут быть ограничения на размер исходящих пакетов. Это ограничение называется максимальной единицей передачи данных (MTU). Значение MTU для протокола IP равно размеру наибольшего IP-кадра, который драйвер канального уровня может передавать без фрагментации IP-пакета. На этапе инициализации драйвера устройства модуль драйвера должен настроить его размер MTU для протокола IP с помощью службы ***nx_ip_interface_mtu_set.***

Хотя это и не рекомендуется, приложение может формировать датаграммы, размер которых превышает базовый размер MTU для протокола IP, поддерживаемый устройством. Перед передачей такой IP-датаграммы эти пакеты должны быть фрагментированы на уровне IP. При получении фрагментированных IP-кадров принимающая конечная точка должна хранить все фрагментированные кадры IP-адресов с одинаковым идентификатором фрагментации и повторно собирать их по порядку. Если логике получения IP-пакетов не удается вовремя собрать все фрагменты для восстановления исходного IP-кадра, все фрагменты освобождаются. За обнаружение потери пакетов и их восстановление отвечает протокол верхнего уровня.

Фрагментация IP-адресов применима к пакетам и IPv4, и IPv6.

Для поддержки фрагментации IP-адресов и операции пересборки конструктор систем должен включить функцию фрагментации IP-адресов в NetX Duo с помощью службы ***nx_ip_fragment_enable***. Если эта функция не включена, входящие фрагментированные IP-пакеты отклоняются, как и пакеты, превышающие MTU сетевого драйвера.

> [!NOTE]
> * Логика фрагментации IP-адресов может быть полностью удалена путем определения ***NX_DISABLE_FRAGMENTATION** _ при создании библиотеки NetX Duo. Это помогает сократить размер кода NetX Duo. Обратите внимание, что в этом случае функции фрагментации и пересборки IPv4 и IPv6 отключены._

> [!NOTE]
> *Если определен **NX_DISABLE_CHAINED_PACKET**, фрагментация IP-адресов должна быть отключена.*

> [!NOTE]
> *В сети IPv6 маршрутизаторы не выполняют фрагментацию датаграмм, если размер датаграммы превышает ее минимальный размер MTU. Таким образом, отправляющее устройство должно определить минимальный MTU между источником и назначением и убедиться, что размер датаграммы IP не превышает MTU пути. В NetX Duo обнаружение MTU пути IPv6 можно включить, создав библиотеку NetX Duo с определенным символом **NX_ENABLE_IPV6_PATH_MTU_DISCOVERY**.*

## <a name="address-resolution-protocol-arp-in-ipv4"></a>Протокол разрешения адресов в экземпляре IPv4

Протокол разрешения адресов (ARP) отвечает за динамическое сопоставление 32-разрядных адресов IPv4 с базовыми физическими носителями (RFC 826). Ethernet — это наиболее распространенный физический носитель, который поддерживает 48-разрядные адреса. Необходимость в ARP определяется драйвером сети, предоставленным службе ***nx_ip_create** _. Если требуется физическое сопоставление, сетевой драйвер должен использовать службу _ *_nx_interface_address_mapping_needed_** для правильной настройки интерфейса драйвера.

### <a name="arp-enable"></a>Включение ARP

Чтобы протокол ARP правильно функционировал, он должен быть включен приложением с помощью службы ***nx_arp_enable***. Эта служба настраивает различные структуры данных для обработки ARP, включая создание области кэша ARP из памяти, предоставляемой службе включения ARP.

### <a name="arp-cache"></a>Кэш ARP

Кэш ARP можно рассматривать как массив внутренних структур данных сопоставления ARP. Каждая внутренняя структура может поддерживать связь между IP-адресом и адресом физического оборудования. Кроме того, каждая структура данных имеет указатели на каналы, поэтому она может быть включена в несколько связанных списков.

Если сопоставление присутствует в таблице ARP, приложение может найти IP-адрес в кэше ARP, указав MAC-адрес оборудования с помощью службы ***nx_arp_ip_address_find** _. Аналогичным образом служба _ *_nx_arp_hardware_address_find_** возвращает MAC-адрес для заданного IP-адреса.

### <a name="arp-dynamic-entries"></a>Динамические записи ARP

По умолчанию служба включения ARP размещает все записи в кэше ARP в списке доступных динамических записей ARP. При обнаружении запроса на отправку в несопоставленный IP-адрес NetX Duo выделяет из этого списка динамические записи ARP. После выделения настраивается запись ARP, а на физический носитель отправляется запрос ARP.

Динамическая запись также может быть создана службой ***nx_arp_dynamic_entry_setом***.

> [!IMPORTANT]
> *Если используются все динамические записи ARP, то по крайней мере недавно использованная запись ARP заменяется новым сопоставлением.*

### <a name="arp-static-entries"></a>Статические записи ARP

Приложение также может настроить статическое сопоставление ARP с помощью службы ***nx_arp_static_entry_create** _. Эта служба выделяет запись ARP из динамического списка записей ARP и помещает ее в статический список с информацией о сопоставлении, предоставленной приложением. Статические записи ARP не предусматривают повторное использование или устаревание. Приложение может удалить статическую запись с помощью службы _*_nx_arp_static_entry_delete_*_. Чтобы удалить все статические записи в таблице ARP, приложение может использовать службу _*_nx_arp_static_entries_delete_**.

### <a name="automatic-arp-entry"></a>Автоматическая запись ARP

NetX Duo записывает сопоставление IP/MAC-адресов однорангового узла после одноранговых ответов на запрос ARP. NetX Duo также реализует функцию автоматического входа в систему ARP, где она записывает сопоставление одноранговых IP/MAC-адресов на основе непрошенных запросов ARP из сети. Эта функция позволяет заполнить таблицу ARP данными однорангового узла, уменьшая задержку, возникающую при прохождении цикла запросов и ответов ARP. Однако у автоматической записи ARP есть и свой недостаток. Он заключается в том, что при включении этой функции в загруженной сети с большим количеством узлов на локальном канале таблица ARP быстро заполняется, что в конечном итоге приводит к замене записи ARP.

Эта функция включена по умолчанию. Чтобы отключить ее, необходимо скомпилировать библиотеку NetX Duo, где определен символ ***NX_DISABLE_ARP_AUTO_ENTRY***.</p>

### <a name="arp-messages"></a>Сообщения ARP

Как упоминалось ранее, если при выполнении задачи IP-экземпляра обнаруживается, что для IP-адреса требуется сопоставление, отправляется сообщение запроса ARP. Запросы ARP отправляются периодически (каждые ***NX_ARP_UPDATE_RATE** _ секунд), пока не будет получен соответствующий ответ ARP. Попытки ARP прекращаются после того, как общее количество запросов ARP достигает _ *_NX_ARP_MAXIMUM_RETRIES_**. При получении ответа ARP сведения о связанном физическом адресе сохраняются в записи ARP, которая находится в кэше.

Для систем с множественной адресацией NetX Duo определяет, какой интерфейс будет отправлять запросы и ответы ARP, на основе указанного адреса назначения.

> [!NOTE]
> *Исходящие пакеты IP помещаются в очередь, пока NetX Duo ожидает ответа ARP. Число исходящих IP-пакетов в очереди определяется константой **NX_ARP_MAX_QUEUE_DEPTH**.*

NetX Duo также отвечает на запросы ARP от других узлов локальной сети IPv4. Когда выполняется внешний запрос ARP, совпадающий с текущим IP-адресом интерфейса, получающего запрос ARP, NetX Duo создает ответное сообщение ARP, содержащее текущий физический адрес.

Форматы запросов и ответов ARP в Ethernet показаны на рис. 6 и описаны ниже.

| **Поле&nbsp;запроса/ответа**         | **Назначение**            |
| ---------------------------------- | ---------------------- |
| ***Адрес назначения в Ethernet*** | Это поле размером 6 байт содержит адрес назначения для ответа ARP и является широковещательным для запросов ARP (применяется для всех). Это поле настраивается сетевым драйвером. 
| ***Адрес источника в Ethernet***      | Это поле размером 6 байт содержит адрес отправителя запроса или ответа ARP и настраивается сетевым драйвером. |
| ***Тип кадра*** | Это поле размером 2 байта содержит тип представления кадра Ethernet. Для запросов и ответов ARP его значение равно 0x0806. Это последнее поле, за настройку которого отвечает сетевой драйвер. |
| ***Тип оборудования*** | Это поле размером 2 байта содержит тип оборудования и имеет значение 0x0001 для Ethernet. |
| ***Тип протокола*** | Это поле размером 2 байта содержит тип протокола, для IP-адресов оно имеет значение 0x0800. |
| ***Размер оборудования*** | Это поле размером 1 байт содержит размер аппаратного адреса (6 для адресов Ethernet). |

![Схема формата пакета ARP.](./media/user-guide/arp-packet-format.png)

**РИС. 6. Формат пакетов ARP**

| Поле&nbsp;запроса/ответа | Назначение |
|---|---|
| ***Размер протокола*** | Это поле размером 1 байт содержит размер IP-адреса, который равен 4 для IP-адресов. |
| ***Код операции*** | Это поле размером 2 байта содержит операцию для этого пакета ARP. Запрос ARP задается значением 0x0001, а ответ ARP представляется значением 0x0002. |
| ***Адрес Ethernet отправителя*** | Это поле размером 6 байт содержит адрес Ethernet отправителя. |
| ***IP-адрес отправителя*** | Это поле размером 4 байта содержит IP-адрес отправителя. |
| ***Целевой адрес Ethernet*** | Это поле размером 6 байт содержит целевой адрес Ethernet. |
| ***Целевой IP-адрес*** | Это поле размером 4 байта содержит целевой IP-адрес. |

> [!NOTE]
> *Запросы и ответы ARP — это пакеты уровня Ethernet. Все остальные пакеты TCP/IP инкапсулируются в заголовке IP-пакета.*

> [!NOTE]
> *Все сообщения ARP в реализации TCP/IP должны быть представлены в формате с **обратным порядком байтов**. В этом формате наиболее значимый байт слова размещается по наименьшему байтовому адресу.*

### <a name="arp-aging"></a>Устаревание ARP

NetX поддерживает автоматическое аннулирование динамической записи ARP. ***NX_ARP_EXPIRATION_RATE** _ задает время (в секундах), в течение которого установленное сопоставление IP-адреса с физическим адресом остается действительным. После истечения срока действия запись ARP удаляется из кэша ARP. Следующая попытка отправить на соответствующий IP-адрес приведет к появлению нового запроса ARP. Установка нулевого значения для _ *_NX_ARP_EXPIRATION_RATE_** отключает устаревание ARP (конфигурация по умолчанию).

### <a name="arp-defend"></a>Защита ARP

Когда получен запрос ARP или пакет ответа ARP, а отправитель имеет тот же IP-адрес, который конфликтует с IP-адресом этого узла, NetX Duo отправляет запрос ARP для этого адреса в качестве защиты. Если конфликтный пакет ARP получен более одного раза в течение 10 секунд, NetX Duo не отправляет больше пакетов защиты. Заданный по умолчанию интервал в 10 секунд можно переопределить с помощью ***NX_ARP_DEFEND_INTERVAL** _. Это поведение соответствует политике, заданной в разделе 2.4(c) RFC5227. Так как Windows XP игнорирует объявление ARP как ответ на пробу ARP, пользователь может определить _ *_NX_ARP_DEFEND_BY_REPLY_** для отправки ответа ARP в качестве дополнительной защиты.

### <a name="arp-statistics-and-errors"></a>Статистические показатели и ошибки ARP

Если этот параметр включен, программное обеспечение ARP NetX Duo отслеживает несколько статистических показателей и ошибок, которые могут быть полезны для приложения. Для каждой обработки ARP в IP-экземпляре поддерживаются следующие статистические показатели и отчеты об ошибках:

- общее число отправленных запросов ARP;
- общее число полученных запросов ARP;
- общее число отправленных ответов ARP; 
- общее число полученных ответов ARP; 
- общее число динамических записей ARP; 
- общее число статических записей ARP; 
- общее число устаревших записей ARP; 
- общее число недопустимых сообщений ARP. 

Все эти статистические показатели и отчеты об ошибках предоставляются приложению службой ***nx_ip_info_get***.

## <a name="reverse-address-resolution-protocol-rarp-in-ipv4"></a>Протокол обратного разрешения адресов (RARP) в экземпляре IPv4

Протокол обратного разрешения адресов (RARP) — это протокол для запроса сетевого назначения 32-разрядных IP-адресов узла (RFC 903). Для этого используется запрос RARP, который периодически повторяется, пока элемент сети не присвоит IP-адрес сетевому интерфейсу узла в ответе RARP. Приложение создает IP-экземпляр с нулевым IP-адресом с помощью службы ***nx_ip_create***. Если в приложении включен протокол RARP, оно может использовать протокол RARP для запроса IP-адреса у сетевого сервера, доступного через интерфейс с нулевым IP-адресом.

### <a name="rarp-enable"></a>Включение RARP

Чтобы использовать RARP, приложение должно создать IP-экземпляр с нулевым IP-адресом, а затем включить RARP с помощью службы ***nx_rarp_enable***. Для систем с множественной адресацией по крайней мере одно сетевое устройство, связанное с IP-экземпляром, должно иметь IP-адрес, равный нулю. Обработка RARP периодически отправляет сообщения запроса RARP для системы NetX Duo, требуя IP-адрес, пока не будет получен допустимый RARP ответ с назначенным сетевым IP-адресом. На этом обработка RARP завершается.

После включения протокола RARP он автоматически отключается после разрешения всех адресов интерфейсов. Приложение может принудительно завершить использование RARP с помощью службы ***nx_rarp_disable***.

### <a name="rarp-request"></a>Запрос RARP

Формат пакета запроса службы практически идентичен формату пакета ARP, показанному на [рис. 6](#arp-messages). Единственное отличие заключается в том, что значение поля типа кадра равно 0x8035, а значение поля *Код операции* равно 3, что соответствует запросу RARP. Как упоминалось ранее, запросы RARP будут отправляться периодически (каждые ***NX_RARP_UPDATE_RATE*** секунд) до получения ответа RARP с назначенным сетью IP-адресом.

> [!NOTE]
> *Все сообщения RARP в реализации TCP/IP должны быть представлены в формате с **обратным порядком байтов**. В этом формате наиболее значимый байт слова размещается по наименьшему байтовому адресу.*

### <a name="rarp-reply"></a>Ответ RARP

Сообщения с ответами RARP принимаются из сети и содержат IP-адрес, назначенный сетью этому узлу. Формат пакета ответа RARP практически идентичен формату пакета ARP, показанному на рис. 6. Единственное отличие заключается в том, что значение поля типа кадра равно 0x8035, а значение поля *Код операции* равно 4, что соответствует ответу RARP. После получения ответа в IP-экземпляре настраивается IP-адрес, отключается периодическая отправка запроса RARP, а IP-экземпляр переходит в состояние готовности к нормальной работе в сети.

Для узлов с множественной адресацией IP-адрес применяется к запрашивающему сетевому интерфейсу. Если есть другие сетевые интерфейсы, которые по-прежнему запрашивают назначение IP-адресов, периодическое обслуживание RARP продолжается до тех пор, пока не будут разрешены все запросы IP-адресов интерфейса.

> [!NOTE]
> *Приложение не должно использовать IP-экземпляр до завершения обработки RARP. Приложения могут использовать **nx_ip_status_check** для ожидания завершения RARP. Для систем с множественной адресацией приложение не должно использовать запрашивающий интерфейс до завершения обработки RARP на этом интерфейсе. Состояние IP-адреса на вторичном устройстве можно проверить с помощью службы **nx_ip_interface_status_check**.*

### <a name="rarp-statistics-and-errors"></a>Статистические показатели и ошибки RARP

Если этот параметр включен, программное обеспечение RARP NetX Duo отслеживает несколько статистических показателей и ошибок, которые могут быть полезны для приложения. Для каждой обработки RARP в IP-экземпляре поддерживаются следующие статистические показатели и отчеты об ошибках:

- общее число отправленных запросов RARP;
- общее число полученных ответов RARP;
- общее число недопустимых сообщений RARP.

Все эти статистические показатели и отчеты об ошибках предоставляются приложению службой ***nx_rarp_info_get***.

## <a name="internet-control-message-protocol-icmp"></a>Протокол межсетевых управляющих сообщений (ICMP)

Применение протокола межсетевых управляющих сообщений для IPv4 (ICMP) ограничивается передачей сведений об ошибках и управлении между элементами IP-сети. Протокол обмена сообщениями в Интернете для протокола IPv6 (ICMPv6) также обрабатывает сведения об ошибках и управлении и требуется для протоколов разрешения адресов, таких как обнаружение повторяющихся адресов (DAD) и автонастройка адресов без отслеживания состояния.

Как и на большинстве других уровней приложений (например, TCP/IP), сообщения ICMP и ICMPv6 инкапсулируются в заголовке IP с помощью обозначения протокола ICMP (или ICMPv6).

### <a name="icmp-statistics-and-errors"></a>Статистические показатели и ошибки ICMP

Если этот параметр включен, NetX Duo отслеживает несколько статистических показателей ICMP и ошибок, которые могут быть полезны для приложения. Для каждой обработки ICMP в IP-экземпляре поддерживаются следующие статистические показатели и отчеты об ошибках: 

- общее число отправленных запросов проверки связи ICMP;  
- общее число случаев истечения времени ожидания проверки связи ICMP; 
- общее число приостановленных потоков проверки связи ICMP; 
- общее число полученных ответов проверки связи ICMP; 
- общее число ошибок контрольной суммы ICMP; 
- общее число необработанных сообщений ICMP. 

Все эти статистические показатели и отчеты об ошибках предоставляются приложению службой ***nx_icmp_info_get***.

## <a name="icmpv4-services-in-netx-duo"></a>Службы ICMPv4 в NetX Duo

### <a name="icmpv4-enable"></a>Включение ICMPv4

Прежде чем сообщения ICMPv4 могут быть обработаны NetX Duo, приложение должно вызвать службу ***nx_icmp_enable***, чтобы включить обработку ICMPv4. После этого приложение может отправить запросы проверки связи и принять входящие пакеты проверки связи.  

### <a name="icmpv4-echo-request"></a>Эхо-запрос ICMPv4

Запрос проверки связи — это один из типов сообщений ICMPv4, который обычно используется для проверки существования определенного узла в сети, идентифицируемого по IP-адресу узла. Популярная команда проверки связи реализуется с помощью сообщений с запросами проверки связи и ответами на них. При наличии конкретного узла его сетевой стек обрабатывает запрос проверки связи и ответы на него с помощью ответа на команду проверки связи. На рис. 7 подробно описывается формат сообщения проверки связи ICMPv4.

![Сообщение проверки связи ICMPv4](./media/user-guide/icmpv4-ping-message.png)  

**РИС. 7. Сообщение проверки связи ICMPv4**

> [!NOTE]
> *Все сообщения ICMPv4 в реализации TCP/IP должны быть представлены в формате с **обратным порядком байтов**. В этом формате наиболее значимый байт слова размещается по наименьшему байтовому адресу.*

В следующей таблице описывается формат заголовка ICMPv4.

|Поле заголовка |Назначение |
|---|---|
|**Тип** |В этом поле указывается сообщение ICMPv4 (биты 31–24). Чаще всего эти следующие сообщения:<br />0: ответ на запрос проверки связи;<br />3: назначение недоступно;<br />8: запрос проверки связи;<br />11: превышение времени;<br />12: проблема с параметром. |
|**Код** |Это поле зависит от контекста в поле типа (биты 23–16). Для запроса проверки связи или ответа на него код имеет значение 0.|
|**Контрольная сумма** |Это поле содержит 16-разрядную контрольную сумму для суммы, дополняющей единицу, в сообщении ICMPv4, включая весь заголовок ICMPv4, начинающийся с поля типа. Перед созданием контрольной суммы поле контрольной суммы очищается.|
|**Идентификация** | Это поле содержит значение идентификатора, по которому можно определить узел. Для узла должен использоваться идентификатор, извлеченный из запроса проверки связи и ответа на него (биты 31–16).|
|**Порядковый номер** |Это поле содержит значение идентификатора. Для узла должен использоваться идентификатор, извлеченный из запроса проверки связи и ответа на него (биты 31–16). В отличие от поля идентификатора, это значение изменится в последующем запросе проверки связи, отправленном с того же узла (биты 15–0).|

### <a name="icmpv4-echo-response"></a>Эхо-ответ ICMPv4    
Ответ на запрос проверки связи — это еще один тип сообщения ICMP, который создается внутренними средствами с помощью компонента ICMP в ответ на внешний запрос проверки связи. Кроме подтверждения, ответ на запрос проверки связи также содержит копию данных пользователя, содержащихся в запросе проверки связи.

### <a name="icmpv4-error-messages"></a>Сообщения об ошибках ICMPv4   
В NetX Duo поддерживаются следующие сообщения об ошибках ICMPv4: 
- Объект назначения недоступен 
- Время превышено 
- Проблема с параметром

## <a name="internet-group-management-protocol-igmp"></a>протокол управления группами Интернета (IGMP)

Протокол управления группами Интернета (IGMP) предоставляет устройству возможность взаимодействовать с его соседями и маршрутизаторами, связь с которыми он намеревается установить. Иными словами, он позволяет присоединиться к группе многоадресной рассылки по протоколу IPv4 (RFC 1112 и RFC 2236). Группа многоадресной рассылки, по сути, является динамической коллекцией сетевых элементов и представляется IP-адресом класса D. Группа многоадресной рассылки поддерживает исключение из нее текущих элементов и присоединение новых в любое время. За координацию, связанную с присоединением к группе и выходом из нее, отвечает IGMP.

> [!NOTE]
> *Протокол IGMP предназначен только для групп многоадресной рассылки IPv4. Его нельзя использовать в сети IPv6.*

### <a name="igmp-enable"></a>Включение IGMP     
Прежде чем выполнить какую-либо многоадресную операцию в NetX Duo, приложение должно вызвать службу ***nx_igmp_enable***. Эта служба выполняет базовую инициализацию IGMP при подготовке запросов многоадресной рассылки.

### <a name="multicast-ipv4-addressing"></a>Многоадресная адресация IPv4  
Как упоминалось ранее, адреса многоадресной рассылки фактически представляют собой IP-адреса класса D, как показано на [рис. 4](#ipv4-addresses). Младшие 28 разрядов адреса класса D соответствуют идентификатору группы многоадресной рассылки. Существует ряд предварительно определенных адресов многоадресной рассылки. Однако *адрес всех узлов* (244.0.0.1) особенно важен для обработки IGMP. *Адрес всех узлов* используется маршрутизаторами для запроса у участников многоадресной рассылки отчетов о том, к каким группам многоадресной рассылки они принадлежат.  

### <a name="physical-address-mapping-in-ipv4"></a>Сопоставление физических адресов в IPv4
Адреса многоадресной рассылки класса D сопоставляются непосредственно с физическими адресами Ethernet в диапазоне от 01.00.5e.00.00.00 до 01.00.5e.7f.ff.ff. Младшие 23 бита IP-адреса многоадресной рассылки сопоставляются непосредственно с младшими 23 битами адреса Ethernet.

### <a name="multicast-group-join"></a>Присоединение к группе многоадресной рассылки
Приложения, которым необходимо присоединиться к определенной группе многоадресной рассылки, могут сделать это, вызвав службу ***nx_igmp_multicast_join***. Эта служба отслеживает количество запросов на присоединение к данной группе многоадресной рассылки. Если это первый запрос приложения на присоединение к группе многоадресной рассылки, то в основной сети отправляется отчет IGMP, указывающий на то, что этот узел намерен присоединиться к группе. Затем, чтобы настроить ожидание передачи данных пакетов с адресом Ethernet для этой группы многоадресной рассылки, вызывается драйвер сети.

Если в системе с множественной адресацией группа многоадресной рассылки доступна через конкретный интерфейс, приложение должно использовать службу ***nx_igmp_multicast_interface_join** _ вместо службы _*_nx_igmp_multicast_join_**, действие которой ограничено группами многоадресной рассылки в основной сети.

### <a name="multicast-group-leave"></a>Выход из группы многоадресной рассылки   
Приложения, которым необходимо выйти из группы многоадресной рассылки, к которой они присоединились ранее, могут сделать это, вызвав службу ***nx_igmp_multicast_leave***. Эта служба уменьшает значение внутреннего счетчика, связанного с числом операций присоединения к группе. При отсутствии необработанных запросов на присоединение к группе вызывается драйвер сети для отключения ожидания передачи данных пакетов с адресом Ethernet этой группы многоадресной рассылки.

### <a name="multicast-loopback"></a>Многоадресное замыкание на себя    
Приложению может потребоваться получать трафик многоадресной рассылки из одного из источников, находящихся на том же узле. Для этого требуется включить для компонента многоадресной рассылки в IP-экземпляре замыкание на себя с помощью службы ***nx_igmp_loopback_enable***.

### <a name="igmp-report-message"></a>Сообщение с отчетом IGMP      
Когда приложение присоединяется к группе многоадресной рассылки, в сети отправляется сообщение с отчетом IGMP, указывающее на намерение узла присоединиться к определенной группе многоадресной рассылки. Формат сообщения с отчетом IGMP показан на рис. 8. Для сообщения группы в сообщении с отчетом IGMP и IP-адреса назначения используется адрес группы многоадресной рассылки.

На рисунке выше (рис. 8) заголовок IGMP содержит поле версии/типа, максимальный ответ

![Схема сообщения отчета IGMP.](./media/user-guide/image17.jpg)

**РИС. 8. Сообщение с отчетом IGMP**

время, поле контрольной суммы и поле адреса группы многоадресной рассылки. Для сообщений IGMPv1 значение поля максимального времени ответа всегда равно 0, так как оно не предусмотрено в протоколе IGMPv1. Поле максимального времени ответа задается, когда узел получает сообщение IGMP с типом запроса, и удаляется, когда узел получает сообщение с типом отчета другого узла, что предусмотрено определением протокола IGMPv2.

В следующей таблице описывается формат заголовка IGMP.

|Поле заголовка|Назначение|
|---|---|
|**Версия** |В этом поле указывается версия протокола IGMP (биты 31–28).|
|**Тип** |В этом поле указывается тип сообщения IGMP (биты 27–24).|
|**Максимальное время ответа** |Не используется в IGMP версии 1. В IGMP версии 2 это поле служит для определения максимального времени ответа.|
|**Контрольная сумма** |Это поле содержит 16-разрядную контрольную сумму для суммы, дополняющей единицу, для сообщения IGMP, начинающегося с версии IGMP (биты 0–15).|
|**Адрес группы** |32-разрядный IP-адрес группы класса D.|

Сообщения с отчетами IGMP отправляются в ответ на сообщения с запросами IGMP, отправляемые маршрутизатором многоадресной рассылки. Маршрутизаторы многоадресной рассылки периодически отправляют сообщения с запросами, чтобы установить, какие узлы все еще остаются в группе. Как показано на рис. 8, сообщения с запросами имеют тот же формат, что и сообщение с отчетами IGMP. Единственное отличие состоит в том, что тип IGMP равен 1, а поле адреса группы имеет значение 0. Сообщения с запросами IGMP отправляются маршрутизатором многоадресной рассылки на IP-адрес *всех узлов*. Узел, который по-прежнему хочет сохранить членство в группе, отправляет в ответ еще одно сообщение с отчетом IGMP.

> [!NOTE]
> *Все сообщения в реализации TCP/IP должны быть представлены в формате с **обратным порядком байтов**. В этом формате наиболее значимый байт слова размещается по наименьшему байтовому адресу.*

### <a name="igmp-statistics-and-errors"></a>Статистические показатели и ошибки IGMP    
<th><p>Если этот параметр включен, программное обеспечение IGMP NetX Duo отслеживает несколько статистических показателей и ошибок, которые могут быть полезны для приложения. Для каждой обработки IGMP в IP-экземпляре поддерживаются следующие статистические показатели и отчеты об ошибках: 

- общее число отправленных отчетов IGMP; 
- общее число полученных запросов IGMP; 
- общее число ошибок контрольной суммы IGMP; 
- общее число элементов, присоединившихся к текущей группе IGMP. 

Все эти статистические показатели и отчеты об ошибках предоставляются приложению службой ***nx_igmp_info_get***. 

### <a name="multicast-without-igmp"></a>Многоадресная рассылка без IGMP  
Приложение, ожидающее многоадресный трафик IPv4, может присоединиться к адресу группы многоадресной рассылки без вызова IGMP-сообщений с помощью службы ***nx_ipv4_multicast_interface_join***. Эта служба указывает уровню IPv4 и драйверу базового интерфейса принимать пакеты от указанного адреса многоадресной рассылки IPv4. Но для этой группы не отправляются и не обрабатываются сообщения управления группами IGMP.

Приложение, которому больше не следует принимать трафик из группы, может использовать службу ***nx_ipv4_multicast_interface_leave.***

## <a name="ipv6-in-netx-duo"></a>IPv6 в NetX Duo

### <a name="ipv6-addresses"></a>IPv6-адреса   
Адреса IPv6 — 128-разрядные. Архитектура адреса IPv6 описана в документе RFC 4291. Адрес делится на префикс, содержащий наиболее значимые биты и адрес узла, содержащий младшие биты. Префикс указывает тип адреса и примерно аналогичен сетевому адресу в сети IPv4.

IPv6 имеет три типа спецификаций адресов: одноадресная рассылка, произвольная рассылка (не поддерживается в NetX Duo) и многоадресная рассылка. Адреса одноадресной рассылки — это IP-адреса, которые определяют конкретный узел в Интернете. Они могут быть IP-адресами источника или назначения. Адреса многоадресной рассылки задают динамическую группу узлов в Интернете. Члены группы многоадресной рассылки могут присоединяться к группе и выходить из нее по мере необходимости.

У протокола IPv6 нет эквивалента механизма широковещательной рассылки IPv4. Возможность отправки пакета всем узлам может быть достигнута путем отправки пакета по адресу локальной связи группы многоадресной рассылки для всех узлов.

IPv6 использует адреса многоадресной рассылки для процедур обнаружения соседей, обнаружения маршрутизатора и автоматической настройки адресов без отслеживания состояния.

Существует два типа адресов одноадресной рассылки IPv6: адреса локальной связи, обычно создаваемые путем объединения хорошо известного префикса локальной связи с MAC-адресом интерфейса, и глобальные IP-адреса, которые также состоят из префиксной части и части идентификатора узла. Глобальный адрес можно настроить вручную или с помощью автонастройки адресов без отслеживания состояния либо DHCPv6. NetX Duo поддерживает как локальные, так и глобальные адреса связи.

Чтобы поддержать форматы IPv4 и IPv6, NetX Duo предоставляет новый тип данных NXD_ADDRESS для хранения адресов IPv4 и IPv6. Определение этой структуры показано ниже. Поле адреса представляет собой объединение адресов IPv4 и IPv6.

```c
typedef struct NXD_ADDRESS_STRUCT
{
    ULONG nxd_ip_version;
    union
    {
        ULONG v4;
        ULONG v6[4];
    } nxd_ip_address;
} NXD_ADDRESS;
```

В структуре NXD_ADDRESS первый элемент, *nxd_ip_version*, указывает версию IPv4 или IPv6. Поддерживаемые значения: NX_IP_VERSION_V4 или NX_IP_VERSION_V6. *nxd_ip_version* указывает, какое поле в объединении *nxd_ip_address* следует использовать в качестве IP-адреса. Службы API NetX Duo обычно принимают указатель на структуру NXD_ADDRESS в качестве входного аргумента вместо IP-адреса ULONG (32-битного).

### <a name="link-local-addresses"></a>Адреса локальной связи     
Адрес локальной связи действителен только в локальной сети. Устройство может отправлять и получать пакеты на другое устройство в той же сети после назначения ему действительного адреса локальной связи. Приложение назначает адрес локальной связи путем вызова службы NetX Duo ***nxd_ipv6_address_set***, с параметром длины префикса, равным 10. Приложение может предоставить службе адрес локальной связи или просто использовать NX_NULL в качестве адреса локальной связи и разрешить NetX Duo создавать адрес локальной связи на основе MAC-адреса устройства.

В следующем примере NetX Duo настраивает адрес локальной связи с длиной префикса 10 на основном устройстве (индекс 0), используя его MAC-адрес:

```c
nxd_ipv6_address_set(ip_ptr, 0, NX_NULL, 10, NX_NULL);
```
В приведенном выше примере, если MAC-адрес интерфейса — 54:32:10:1A:BC:67, соответствующий адрес локальной связи будет следующим:

```c
FE80::5632:10FF:FE1A:BC67
```
Обратите внимание, что часть идентификатора узла IPv6-адреса (**5632:10ff: FE1A: BC67**) состоит из 6-байтного МАС-адреса со следующими изменениями:

- **0xFFFE** вставлен между байтами 3 и 4 MAC-адреса.
- Второй самый младший бит первого байта MAC-адреса (бит U/L) имеет значение 1.

Дополнительные сведения о том, как создать часть адреса IPv6, касающуюся узла, с помощью MAC-адреса интерфейса, см. в RFC 2464 (Передача пакетов IPv6 по сети Ethernet).

Существует несколько специальных адресов многоадресной рассылки для отправки многоадресных сообщений на один или несколько узлов в IPv6:

| Группа  | Адрес   | Описание  |
|---|---|---|
|Группа всех узлов |**FF02::1** |Все узлы в локальной сети|
|Группа всех маршрутизаторов |**FF02::2** |Все маршрутизаторы в локальной сети|
|Запрашиваемый узел |**FF02::1:FF00:0/104** |Пояснения приведены ниже|

Адрес многоадресной рассылки запрашиваемого узла предназначен для конкретных узлов по локальной ссылке, а не для всех узлов IPv6. Он состоит из префикса **FF02::1:FF00:0/104**, который составляет 104 бита и последних 24 битов целевого IPv6-адреса. Например, адрес IPv6 **205B:209D:D028::F058:D1C8:1024** имеет адрес многоадресной рассылки запрашиваемого узла **FF02::1:FFC8:1024**.

> [!IMPORTANT]
> *Нотация с двойным двоеточием указывает, что все промежуточные биты являются нулями. **FF02::1:FF00:0/104** в полностью развернутом виде выглядит как* **FF02:0000:0000:0000:0000:0001:FF00:0000**.

### <a name="global-addresses"></a>Глобальные адреса    
Пример глобального адреса IPv6 — **2001:0123:4567:89AB:CDEF::1**, NetX Duo хранит адреса IPv6 в структуре NXD_ADDRESS. В приведенном ниже примере переменная NXD_ADDRESS **global_ipv6_address** содержит адрес IPv6 для одноадресной рассылки. В следующем примере показано устройство NetX Duo, создающее конкретный глобальный адрес IPv6 для своего основного устройства:

```c
NXD_ADDRESS global_ipv6_address;
UINT        primary_interface_index = 0;

global_ipv6_address.nxd_ip_version = NX_IP_VERSION_V6;
global_ipv6_address.nxd_ip_address.v6[0] = 0x20010123;
global_ipv6_address.nxd_ip_address.v6[1] = 0x456789AB;
global_ipv6_address.nxd_ip_address.v6[2] = 0xCDEF0000;
global_ipv6_address.nxd_ip_address.v6[3] = 0x00000001;

status = nxd_ipv6_address_set(
            &ip_0,
            primary_interface_index,
            &global_ipv6_address,
            64,
            NX_NULL);
```
Обратите внимание, что префикс IPv6-адреса — **2001:0123:4567:89AB**. Он имеет длину 64 бит и является общей длиной префикса для глобальных адресов одноадресной рассылки IPv6 в Ethernet.

Структура NXD_ADDRESS также содержит адреса IPv4. IP-адрес **192.1.168.10** (**0xC001A80A**), хранящийся в global_ipv4_address, будет иметь следующую организацию памяти:

|Поле |Значение |
|---|---|
|global_ipv4_address.nxd_ip_version |NX_IP_VERSION_V4|
|global_ipv4_address.nxd_ip_address.v4 |0xC001A80A|

Когда приложение передает адрес в службы NetX Duo, в поле *nxd_ip_version* необходимо указать правильную версию IP-адреса для правильной обработки пакетов.

Чтобы обеспечить обратную совместимость с существующими приложениями NetX, NetX Duo поддерживает все службы NetX. На внутреннем уровне NetX Duo преобразует тип адресов IPv4 ULONG в тип данных NXD_ADDRESS, прежде чем пересылать его в фактическую службу NetX Duo.

В следующем примере показаны сходства и различия между службами в NetX и NetX Duo.

```c
/* Make a connection to the destination IPv4 address
   192.1.168.12 through an already created TCP socket bound
   to the well known HTTP port number 80. */

global_ipv4_address.nxd_ip_version = NX_IP_VERSION_V4;
global_ipv4_address.nxd_ip_address.v4 = 0xC001A80C;

nxd_tcp_client_socket_connect(&tcp_socket,
                              &global_ipv4_address,
                              port_number,
                              NX_WAIT_FOREVER);
```

Ниже приведен эквивалентный API NetX:

```c
ULONG         server_ip = 0xC001A80C;
NX_TCP_SOCKET tcp_socket;
UINT          port_number = 80;

nx_tcp_client_socket_connect(&tcp_socket,
                             server_ip,
                             port_number,
                             NX_WAIT_FOREVER); 
```

> [!IMPORTANT]
> *Разработчикам приложений рекомендуется использовать nxd-версии этих API*.

### <a name="ipv6-default-routers"></a>Маршрутизаторы по умолчанию IPv6    
IPv6 использует маршрутизатор по умолчанию для пересылки пакетов назначениям, являющимся транспортными каналами. Служба NetX Duo ***Nxd_ipv6_default_router_add*** позволяет приложению добавить маршрутизатор IPv6 в таблицу маршрутизатора по умолчанию. Дополнительные службы маршрутизатора по умолчанию, предлагаемые NetX Duo, см. в главе 4 "Описание служб".  

При пересылке пакетов IPv6 NetX Duo сначала проверяет, находится ли назначение пакета по ссылке. Если нет, NetX Duo проверяет таблицу маршрутизации по умолчанию на предмет допустимого маршрутизатора, которому можно перенаправить пакет транспортного канала.  

Чтобы удалить маршрутизатор из таблицы маршрутизаторов IPv6 по умолчанию, приложение должно использовать службу ***nxd_ipv6_default_router_delete** _. Чтобы получить записи о таблице маршрутизаторов IPv6 по умолчанию, используйте службу _*_nxd_ipv6_default_router_entry_get_**.

### <a name="ipv6-header"></a>Заголовок IPv6    
Заголовок IPv6 — это измененный заголовок IPv4. При выделении пакета, вызывающий объект указывает протокол приложения (например, UDP, TCP), размер буфера в байтах и ограничение числа прыжков.   

На рис. 9 показан формат заголовка IPv6, а в таблице перечислены компоненты заголовка.

![Схема формата заголовка IPv6.](./media/user-guide/image18.png)

**РИС. 9. Формат заголовка IPv6**

|Заголовок IP | Назначение |
|---|---|
|Версия |4-разрядное поле для версии IP. Для сетей IPv6 значение в этом поле должно быть 6; для сетей IPv4 оно должно быть равно 4.|
|Класс трафика |8-разрядное поле, в котором хранятся сведения о классе трафика. Это поле не используется NetX Duo.|
|Метка потока |20-разрядное поле для уникальной идентификации потока (при наличии), с которым связан пакет. Нулевое значение указывает, что пакет не принадлежит определенному потоку. Это поле заменяет поле *TOS* в IPv4.|
|Длина полезных данных |16-разрядное поле, указывающее объем данных в байтах пакета IPv6, который следует за базовым заголовком IPv6. Сюда входят все заголовки и данные инкапсулированного протокола.|
|Следующий заголовок | 8-разрядное поле, указывающее тип заголовка расширения, который следует за базовым заголовком IPv6. Это поле заменяет поле *Protocol* в IPv4.|
|Предел числа прыжков |8-разрядное поле, ограничивающее количество маршрутизаторов, через которые может проходить пакет. Это поле заменяет поле *TTL* в IPv4.|
|Исходный адрес |128-разрядное поле, в котором хранится IPv6-адрес отправителя.|
|Адрес назначения |128-разрядное поле, в котором хранится IPv6-адрес назначения.|

### <a name="enabling-ipv6-in-netx-duo"></a>Включение IPv6 в NetX Duo    
По умолчанию IPv6 включен в NetX Duo. Службы IPv6 включены в NetX Duo, если настраиваемый параметр ***NX_DISABLE_IPV6** _ в _nx_user.h* не определен. Если определено ***NX_DISABLE_IPV6***, NetX Duo будет предоставлять только службы IPv4, а все связанные с IPv6 модули и службы не встроены в библиотеку NetX Duo.

Для настройки адреса IPv6 устройства в приложениях предусмотрена следующая служба: ***nxd_ipv6_address_set***

Помимо задания адреса IPv6в устройства вручную, система также может использовать автонастройку адресов без отслеживания состояния. Чтобы использовать этот параметр, приложение должно вызвать ***nxd_ipv6_enable** _ для запуска служб IPv6 на устройстве. Кроме того, службы ICMPv6 необходимо запускать путем вызова _*_nxd_icmp_enable_*_, что позволяет NetX Duo оказывать такие услуги, как запрос маршрутизатора, обнаружение соседей и обнаружение повторяющихся адресов. Обратите внимание, что _*_nx_icmp_enable_*_ запускает протокол ICMP только для служб IPv4. _*_nxd_icmp_enable_*_ запускает службы ICMP как для IPv4, так и для IPv6. Если системе не требуются службы ICMPv6, то можно использовать _ *_nx_icmp_enable_**, чтобы модуль ICMPv6 не был связан с системой.

В следующем примере показана типичная процедура инициализации IPv6 NetX Duo.

```c
/* Assume ip_0 has been created and IPv4 services (such as ARP,
   ICMP, have been enabled. */
#define SECONDARY_INTERFACE 1

/* Enable IPv6 */
status = nxd_ipv6_enable(&ip_0);

if(status != NX_SUCCESS)
{
    /* nxd_ipv6_enable failed. */
}

/* Enable ICMPv6 */
status = nxd_icmp_enable(&ip_0);
if(status != NX_SUCCESS)
{
    /* nxd_icmp_enable failed. */
}

/* Configure the link local address on the primary interface. */
status = nxd_ipv6_address_set(&ip_0, 0, NX_NULL, 10, NX_NULL);

/* Configure ip_0 primary interface global address. */
ip_address.nxd_ip_version = NX_IP_VERSION_V6
ip_address.nxd_ip_address.v6[0] = 0x20010db8;
ip_address.nxd_ip_address.v6[1] = 0x0000f101;
ip_address.nxd_ip_address.v6[2] = 0;
ip_address.nxd_ip_address.v6[3] = 0x202;

/* Configure global address of the primary interface. */
status = nxd_ipv6_address_set(&ip_0, SECONDARY_INTERFACE,
                              &ip_address, 64, NX_NULL);
```                              

Протоколы верхнего уровня (например, TCP и UDP) можно включить либо до, либо после запуска IPv6.

> [!IMPORTANT]  
> *Службы IPv6 доступны только после инициализации IP-потока и включения устройства.*

Когда интерфейс будет включен (т. е. драйвер устройства интерфейса готов к отправке и получению данных и получен допустимый адрес локальной связи), устройство может получить глобальные IPv6-адреса одним из следующих способов:

- автоматическая настройка адресов без отслеживания состояния;  
- настройка адресов IPv6 вручную;  
- настройка адресов по протоколу DHCPv6 (с помощью дополнительного пакета DHCPv6).

Первые два метода описаны ниже. Третий метод (DHCPv6) описан в пакете DHCP.

### <a name="stateless-address-autoconfiguration-using-router-solicitation"></a>Автоматическая настройка адресов без отслеживания состояния с помощью запроса маршрутизатора      
Устройства NetX Duo могут автоматически настраивать свои интерфейсы при подключении к сети IPv6 с помощью маршрутизатора, предоставляющего сведения о префиксе. Устройства, которым требуется автоматическая настройка адресов без отслеживания состояния, отправляют сообщения о запросе маршрутизатора (RS). Маршрутизаторы в сети отвечают отправкой запрошенных сообщений объявления маршрутизатора (RA). Сообщения RA объявляют префиксы, указывающие сетевые адреса, связанные с ссылкой. Затем устройства создают уникальный идентификатор сети, к которой подключено устройство. Адрес формируется путем объединения префикса и его уникального идентификатора. Таким образом, при получении сообщений RA узлы создают их IP-адреса. Маршрутизаторы также могут периодически отправлять незапрошенные сообщения RA. 

> [!WARNING]
> *NetX Duo позволяет приложению включать и отключать автоматическую настройку адресов без отслеживания состояния во время выполнения. Чтобы включить эту функцию, необходимо скомпилировать библиотеку NetX Duo с определенным **NX_IPV6_STATELESS_AUTOCONFIG_CONTROL**. После включения этой функции приложения могут использовать **nxd_ipv6_stateless_address_autoconfigure_enable** и **nxd_ipv6_stateless_address_autocofigure_disable** для включения и отключения автоматической настройки адресов IPv6 без отслеживания состояния*.

### <a name="manual-ipv6-address-configuration"></a>Настройка адресов IPv6 вручную     
Если необходим конкретный адрес IPv6, приложение может использовать ***nxd_ipv6_address_set***, чтобы вручную настроить адрес IPv6. Сетевой интерфейс может иметь несколько адресов IPv6. Однако следует помнить, что общее число адресов IPv6 в системе, полученных с помощью автоматической настройки адресов без отслеживания состояния, либо с помощью ручной настройки, не может превышать число в ***NX_MAX_IPV6_ADDRESSES***.

В следующем примере показано, как вручную настроить глобальный адрес на основном интерфейсе (устройство 0) в ip_0.

```c
NXD_ADDRESS global_address;
global_address.nxd_ip_version = NX_IP_VERSION_V6;
global_address.nxd_ip_address.v6[0] = 0x20010000;
global_address.nxd_ip_address.v6[1] = 0x00000000;
global_address.nxd_ip_address.v6[2] = 0x00000000;
global_address.nxd_ip_address.v6[3] = 0x0000ABCD;
```

Затем узел вызывает следующую службу NetX Duo, чтобы сделать этот адрес своим глобальным IP-адресом:

```c
status = nxd_ipv6_address_set(&ip_0, 0,  
                              &global_address, 64
                              NX_NULL);
```

### <a name="duplicate-address-detection-dad"></a>Обнаружение повторяющихся адресов (DAD)    
После того как система настроила IPv6-адрес, адрес помечается как *TENTATIVE* (предварительный). Если функция обнаружения повторяющихся адресов (DAD), описанная в RFC 4862, включена, NetX Duo автоматически отправляет сообщения запроса соседей (NS) с этим пробным адресом в качестве места назначения. Если ни один из узлов в сети не отвечает на эти сообщения NS в течение заданного периода времени, то предполагается, что этот адрес уникален в рамках локальной связи и его состояние переходит к состоянию VALID (допустимое). На этом этапе приложение может начать использовать этот IP-адрес для обмена данными.  

Функция DAD является частью модуля ICMPv6. Поэтому приложение должно включить службы ICMPv6, прежде чем новый настроенный адрес сможет пройти через процесс DAD. Кроме того, процесс DAD может быть отключен путем определения параметра ***NX_DISABLE_IPV6_DAD** _ в среде сборки библиотеки NetX Duo (определяется как _*_nx_user.h_*_). В процессе DAD параметр _*_NX_IPV6_DAD_TRANSMITS_*_ определяет количество сообщений NS, отправленных NetX Duo, без получения ответа для определения уникальности адреса. По умолчанию и согласно рекомендациям RFC 4862, значение _ *_NX_IPV6_DAD_TRANSMITS_** установлено на 3. Установка этого символа равным нулю позволяет по сути отключить DAD.

Если ICMPv6 или DAD не включены в момент, когда приложение назначает IPv6-адрес, DAD не выполняется, а NetX Duo немедленно устанавливает для IPv6-адреса состояние VALID.

NetX Duo не может связаться с сетью IPv6, пока его локальный или глобальный адрес не станет допустимым. После получения допустимого адреса NetX Duo пытается сопоставить адрес назначения входящего пакета с одним из настроенных адресов IPv6 или включенным адресом многоадресной рассылки. Если совпадений не найдено, пакет удаляется. 

> [!WARNING]  
> * В ходе процесса DAD число передаваемых пакетов DAD NS определяется ***NX_IPV6_DAD_TRANSMITS** _, значение которого по умолчанию — 3. По умолчанию задержка между сообщениями DAD NS составляет одну секунду. Таким образом, в системе с использованием DAD после назначения IPv6-адреса (при условии, что он не является дублированным адресом) будет наблюдаться задержка примерно в 3 секунды, прежде чем этот адрес окажется в состоянии VALID и будет готов к обмену данными._

Приложениям может потребоваться получать уведомления при изменении адресов IPv6 в системе. Чтобы включить функцию уведомлений об изменении адресов IPv6, библиотеку NetX Duo следует создавать с определенным символом **NX_ENABLE_IPV6_ADDRESS_CHANGE_NOTIFY**. После включения функции приложения могут установить функцию обратного вызова с помощью службы **_nxd_ipv6_address_change_notify_**.

Когда адрес IPv6 меняется или становится недействительным, вызывается предоставляемая пользователем функция обратного вызова со следующими сведениями:

| Функция  | Описание  |
|---|---|
|ip_ptr |Указатель на экземпляр IP.|
|interface_index |Индекс сетевого интерфейса, с которым связан этот адрес IPv6.
|ipv6_addr_index |Индекс таблицы адресов IPv6.|
|ipv6_address |Указатель на IPv6-адрес в виде массива из четырех целых чисел ULONG. Адреса Pv6 представлены в порядке байтов узла.|

### <a name="ipv6-multicast-support-in-netx-duo"></a>Поддержка многоадресной рассылки IPv6 в NetX Duo      
Адреса многоадресной рассылки задают динамическую группу узлов в Интернете. Члены группы многоадресной рассылки могут присоединяться к группе и выходить из нее по мере необходимости. NetX Duo реализует несколько протоколов ICMPv6, включая обнаружение повторяющихся адресов, обнаружение соседей и обнаружение маршрутизатора, для чего требуется возможность многоадресной рассылки IP. Поэтому NetX Duo ожидает от драйвера базового устройства поддержки операций с многоадресной рассылкой.

Когда NetX Duo необходимо присоединиться к группе многоадресной рассылки (например, адресу многоадресной рассылки для всех узлов и адресу многоадресной рассылки для *запрошенного узла*) или выйти из нее, он отправляет драйверу устройства команду на присоединение к МАС-адресу многоадресной рассылки или выход из него. Команда драйвера для соединения с адресом многоадресной рассылки — ***NX_LINK_MULTICAST_JOIN** _. Чтобы оставить адрес многоадресной рассылки, NetX Duo выдает команду драйвера _*_NX_LINK_MULTICAST_LEAVE_**. Чтобы протоколы ICMPv6 работали правильно, драйвер устройства должен реализовать эти две команды.

Приложения могут присоединяться к группе многоадресной рассылки IPv6 с помощью службы ***nxd_ipv6_multicast_interface_join*.** Эта служба регистрирует адрес многоадресной рассылки с помощью стека IP-адресов, а затем уведомляет указанный драйвер устройства об адресе многоадресной рассылки IPv6. Чтобы выйти из группы многоадресной рассылки, приложения используют службу ***nxd_ipv6_multicast_interface_leave***.

### <a name="neighbor-discovery-nd"></a>Обнаружение соседей (ND)    
Обнаружение соседей — это протокол в сетях IPv6 для сопоставления физических адресов с IPv6-адресами (глобальный адрес или адрес локальной связи). Это сопоставление сохраняется в кэше обнаружения соседей (кэш ND). Процесс ND эквивалентен процессу ARP в IPv4, а кэш ND аналогичен таблице ARP. Узел IPv6 может получить MAC-адрес его соседа по протоколу обнаружения соседей (ND). Он отправляет сообщение запроса соседей (NS) по адресу многоадресной рассылки запрошенного узла, а затем ожидает соответствующее сообщение объявления соседа (NA). MAC-адрес, полученный с помощью этого процесса, хранится в кэше ND.

У каждого экземпляра IP есть один кэш ND. Кэш ND хранится в виде массива записей. Размер массива определяется во время компиляции с помощью параметра ***NX_IPV6_NEIGHBOR_CACHE_SIZE** _, который находится в _*_nx_user.h_**. Обратите внимание, что все интерфейсы, подключенные к экземпляру IP, имеют общий кэш ND.

При запуске NetX Duo весь кэш ND пуст. По ходу работы системы NetX Duo автоматически обновляет кэш ND, добавляя и удаляя записи в соответствии с протоколом ND. Однако приложение также может обновлять кэш ND, добавляя и удаляя записи кэша вручную, используя следующие службы NetX Duo:

- ***nxd_nd_cache_entry_delete***  
- ***nxd_nd_cache_entry_set***   
- ***nxd_nd_cache_invalidate***

При отправке и получении пакетов IPv6 NetX Duo автоматически обновляет таблицу кэша ND.

## <a name="internet-control-message-protocol-in-ipv6-icmpv6"></a>Протокол межсетевых управляющих сообщений в IPv6 (ICMPv6)  

Роль ICMPv6 в IPv6 была значительно расширена для поддержки сопоставления IPv6-адресов и обнаружения маршрутизатора. Кроме того, ICMPv6 NetX Duo поддерживает эхо-запросы и ответы, отчеты об ошибках ICMPv6 и сообщения перенаправления ICMPv6.

### <a name="icmpv6-enable"></a>Включение ICMPv6    
Прежде чем сообщения ICMPv6 смогут быть обработаны NetX Duo, приложение должно вызвать службу ***nxd_icmp_enable***, чтобы включить обработку ICMPv6, как описано выше. 

### <a name="icmpv6-messages"></a>Сообщения ICMPv6     
Структура заголовка ICMPv6 аналогична структуре заголовка ICMPv4. Как показано ниже, базовый заголовок ICMPv6 содержит три поля, тип, код и контрольную сумму, а также переменную длину данных параметра ICMPv6. 

![Схема базового заголовка ICMPv6.](./media/user-guide/image19.png)

**РИС. 10. Базовый заголовок ICMPv6**

|Поле |Размер (байт) |Описание |
|-----|-----|-----|
|     | 1   |Определяет тип сообщения ICMPv6: |
|     |     |1 Назначение недоступно |
|     |     |2 Пакет слишком велик |
|     |     |3 Превышение времени |
|     |     |4 Проблема с параметром |
|     |     |128 Запрос проверки связи |
|     |     |129 Ответ на запрос проверки связи |
|     |     |133 Запрос маршрутизатора |
|     |     |134 Объявление маршрутизатора |
|     |     |135 Запрос соседей |
|     |     |136 Объявление соседа |
|     |     |137 Сообщение о перенаправлении |
|Код | 1   |Дополнительно определяет тип сообщения ICMPv6. Обычно используется с сообщениями об ошибках. Если не используется, значение устанавливается на ноль. Запросы проверки связи, ответы на них и сообщения NS не используют его.|
|Контрольная сумма | 2 |16-разрядное поле контрольной суммы для заголовка ICMP. Это 16-разрядное дополнение для всего сообщения ICMPv6, включая заголовок ICMPv6. Оно также включает в себя псевдозаголовок исходного адреса IPv6, адрес назначения и длину полезных данных пакета. |

Ниже приведен пример заголовка запроса соседей.

![Схема примера заголовка запроса соседей.](./media/user-guide/image20.jpg)

**РИС. 11. Заголовок ICMPv6 для сообщения запроса соседей**

|Поле |Размер (байт) |Описание |
|-----|-----|-----|
|Тип | 1   |Определяет тип сообщения ICMPv6 для сообщений запроса соседей. Значение равно 135. |
|Код | 1   |Не используется. Задайте значение 0. |
|Контрольная сумма | 2  |16-разрядное поле контрольной суммы для заголовка ICMPv6. |
|Зарезервировано | 4  |4 зарезервированных байта имеют значение 0. |
|Целевой адрес | 16  |Адрес IPv6 цели запроса. Для разрешения адресов IPv6 это фактический IP-адрес устройства, для которого необходимо разрешить адрес канального уровня. |
|Параметры | Переменная |Дополнительные сведения, заданные протоколом обнаружения соседей. |

### <a name="icmpv6-ping-request"></a>Запрос проверки связи ICMPv6
В приложениях NetX Duo используйте ***nxd_icmp_ping***, чтобы выдавать запросы проверки связи IPv6 или IPv4 на основе IP-адреса назначения, указанного в параметрах.  

### <a name="icmpv6-ping-response"></a>Запрос проверки связи ICMPv6
Ответ на запрос проверки связи ICMPv6 — это еще один тип сообщения ICMPv6, который создается внутри компонента ICMPv6 в ответ на внешний запрос проверки связи ICMPv6. Кроме подтверждения, ответ на запрос проверки связи ICMPv6 также содержит копию данных пользователя, содержащихся в запросе проверки связи ICMPv6.  

### <a name="thread-suspension"></a>Приостановка потока
Потоки приложения могут быть приостановлены во время попыток проверить связь с другим членом сети. После получения ответа на запрос проверки связи сообщение об этом ответе выдается первому приостановленному потоку, и этот поток возобновляется. Как и все службы NetX Duo, приостановка в запросе проверки связи имеет необязательное время ожидания.  

### <a name="other-icmpv6-messages"></a>Другие сообщения ICMPv6
Сообщения ICMPv6 необходимы для следующих функций:  

- Обнаружение окружения  
- Автоматическая настройка адресов без отслеживания состояния 
- Обнаружение маршрутизатора 
- Обнаружение недостижимости соседа  

### <a name="neighbor-unreachability-router-and-prefix-discovery"></a>Недостижимость соседа, обнаружение маршрутизатора и префикса    
Обнаружение недостижимости соседа, обнаружение маршрутизатора и обнаружение префикса основаны на протоколе обнаружения соседей и описаны ниже. 

***Обнаружение недостижимости соседа:*** устройство IPv6 выполняет поиск целевого адреса канального уровня в кэше обнаружения соседей (ND), когда необходимо отправить пакет. Немедленное место назначения, которое иногда называют "следующим прыжком", может быть фактическим местом назначения по той же ссылке или маршрутизатором, если назначением является транспортный канал. Запись кэша ND содержит состояние доступности соседа.

Состояние REACHABLE (достижим) указывает, что сосед считается достижимым. Сосед доступен, если он недавно получил подтверждение о получении пакетов, отправленных соседу. Подтверждение в NetX Duo принимает сообщение Н/Д от соседа в ответ на сообщение NS, отправленное устройством NetX Duo. NetX Duo также изменит состояние соседа на REACHABLE, если приложение вызывает службу NetX Duo ***nxd_nd_cache_entry_set***, чтобы вручную ввести запись кэша.

***Обнаружение маршрутизатора:*** устройство IPv6 использует маршрутизатор для пересылки всех пакетов, отправляемых транспортным каналам. Кроме того, для настройки глобальных IPv6-адресов может использоваться информация, передаваемая маршрутизатором, например сообщения объявлений маршрутизатора (RA).

Устройство в сети может инициировать процесс обнаружения маршрутизатора, отправляя сообщение о запросе маршрутизатора (RS) по адресу многоадресной рассылки для всех маршрутизаторов (FF01::2). Или оно может ожидать периодические объявления маршрутизатора на адресе многоадресной рассылки для всех узлов (FF::1).

Сообщение RA содержит сведения о префиксах, чтобы настроить адрес IPv6 для этой сети. В NetX Duo запрос маршрутизатора включен по умолчанию и может быть отключен путем установки параметра конфигурации ***NX_DISABLE_ICMPV6_ROUTER_SOLICITATION** _ в _*_nx_user.h_**. Дополнительные сведения о настройке параметров запроса маршрутизатора см. в разделе "Параметры конфигурации" главы "Установка и использование NetX Duo". 

***Обнаружение префиксов***: устройство IPv6 использует обнаружение префиксов, чтобы узнавать, какие целевые узлы доступны напрямую без использования маршрутизатора. Эта информация предоставляется устройству IPv6 через сообщения RA от маршрутизатора. На устройстве IPv6 сведения о префиксах хранятся в таблице префиксов. Обнаружение префикса — это сопоставление префикса из таблицы префиксов устройств IPv6 с целевым адресом. Префикс соответствует целевому адресу, если все биты в префиксе совпадают с наиболее значащими битами целевого адреса. Если более одного префикса соответствует адресу, то выбирается самый длинный.

### <a name="icmpv6-error-messages"></a>Сообщения об ошибках ICMPv6    
В NetX Duo поддерживаются следующие сообщения об ошибках ICMPv6:  

- Объект назначения недоступен  
- Пакет слишком велик  
- Время превышено  
- Проблема с параметром  

## <a name="user-datagram-protocol-udp"></a>Протокол пользовательских датаграмм (UDP)

Протокол пользовательских датаграмм (UDP) обеспечивает простейшую форму передачи данных между участниками сети (RFC 768). Пакеты данных UDP отправляются от одного участника сети к другому по принципу наименьших затрат, т. е. встроенный механизм подтверждения получателем пакета отсутствует. Кроме того, в данном случае перед отправкой пакета UDP не требуется устанавливать подключение заранее. По этой причине передача пакетов UDP очень эффективна.

Для разработчиков, которые переходят свои приложения NetX на NetX Duo, в NetX Duo есть лишь несколько основных изменений функций UDP, по сравнению с NetX. Это связано с тем, что IPv6 в первую очередь касается базового уровня IP. Все службы UDP NetX Duo можно использовать для подключений IPv4 или IPv6.

### <a name="udp-header"></a>Заголовок UDP       
При передаче UDP помещает простой заголовок пакета перед данными приложения и удаляет аналогичный заголовок UDP из пакета при его получении, прежде чем передавать полученный UDP-пакет приложению. UDP использует протокол IP для отправки и получения пакетов, поэтому, когда пакет находится в сети, перед его заголовком UDP размещается заголовок IP. На рис. 12 показан формат заголовка UDP.

![Схема формата заголовка UDP.](./media/user-guide/image21.png)

### <a name="figure-12-udp-header"></a>РИС. 12. Заголовок UDP

> [!NOTE]
> *Все заголовки в реализации UDP/IP должны быть представлены в формате с **обратным порядком байтов**. В этом формате наиболее значимый байт слова размещается по наименьшему байтовому адресу.*

В следующей таблице описывается формат заголовка UDP.

|Поле заголовка |Назначение |
|---|---|
|**16-разрядное поле номера исходного порта** |Это поле содержит порт, из которого отправляется UDP-пакет. Допустимый диапазон UDP-портов — от 1 до 0xFFFF. |
|**16-разрядное поле номера порта назначения** |Это поле содержит порт UDP, на который отправляется UDP-пакет. Допустимый диапазон UDP-портов — от 1 до 0xFFFF. |
|**16-разрядное поле длины UDP-пакета** |Это поле содержит число байтов в UDP-пакете, включая размер заголовка UDP. |
|**16-разрядное поле контрольной суммы UDP** |Это поле содержит 16-разрядную контрольную сумму пакета, включая заголовок UDP, область данных пакета и псевдозаголовок IP. |

### <a name="udp-enable"></a>Включение UDP   
Перед передачей UDP-пакетов приложение должно сначала включить протокол UDP, вызвав службу ***nx_udp_enable***. После включения приложение может отправлять и получать UDP-пакеты.  

### <a name="udp-socket-create"></a>Создание сокета UDP    
Сокеты UDP создаются во время инициализации или выполнения потоками приложения. Начальный тип службы, срок жизни и длина очереди получения определяются службой ***nx_udp_socket_create***. Число сокетов UDP в приложении не ограничено.

### <a name="udp-checksum"></a>Контрольная сумма UDP   
Для протокола IPv6 требуется вычисление контрольной суммы заголовка UDP для данных пакета, тогда как в протоколе IPv4 это необязательно.  

Протокол UDP указывает свою дополняющую 16-разрядную контрольную сумму, охватывающую псевдозаголовок IP (состоящий из исходного IP-адреса, IP-адреса назначения и IP-слова, указывающего протокол и длину), заголовок UDP и данные пакета UDP. Единственным различием между контрольными суммами заголовков UDP-пакетов IPv4 и IPv6 является то, что исходный и конечный IP-адреса являются 32-разрядными в IPv4, а в IPv6 они 128-разрядные. Если вычисленная контрольная сумма UDP равна 0, она сохраняется как значение, состоящее только из единиц (0xFFFF). Если для отправляющего сокета отключена логика контрольной суммы UDP, в поле контрольной суммы UDP помещается нулевое значение, указывающее, что контрольная сумма не вычислена.

Если контрольная сумма UDP не совпадает с вычисленной контрольной суммой получателя, пакет UDP просто отбрасывается.

В сети IPv4 контрольная сумма UDP необязательна. NetX Duo позволяет приложению включать или отключать расчет контрольной суммы UDP для каждого сокета. По умолчанию логика контрольной суммы UDP-сокета включена. Приложение может отключить логику контрольной суммы для определенного сокета UDP, вызвав службу ***nx_udp_socket_checksum_disable** _. Однако в сети IPv6 контрольная сумма UDP является обязательной. Таким образом, служба _ *_nx_udp_socket_checksum_disable_** не отключает логику контрольной суммы UDP при отправке пакета через сеть IPv6.

Некоторые контроллеры Ethernet могут создавать контрольную сумму UDP на лету. Если система может использовать функцию вычисления контрольной суммы оборудования, библиотеку NetX Duo можно построить без логики контрольной суммы. Чтобы отключить контрольную сумму программного обеспечения UDP, Библиотека NetX Duo должна быть создана со следующими определенными символами: ***NX_DISABLE_UDP_TX_CHECKSUM** _ и _*_NX_DISABLE_UDP_RX_CHECKSUM_*_ (описывается в главе 2). Параметры конфигурации полностью удаляют логику контрольной суммы UDP с NetX Duo, при этом вызов службы _ *_nx_udp_socket_checksum_disable_** позволяет приложению отключить обработку контрольной суммы UDP по протоколу IPv4 для каждого сокета.

### <a name="udp-ports-and-binding"></a>Порты и привязка UDP      
UDP-порт — это логическая конечная точка в протоколе UDP. В компоненте UDP NetX Duo имеется 65 535 допустимых портов в диапазоне от 1 до 0xFFFF. Для отправки или получения данных UDP приложение должно сначала создать сокет UDP, а затем привязать его к нужному порту. После привязки сокета UDP к порту приложение может отправлять и получать данные на этом сокете.

### <a name="udp-fast-pathtrade"></a>UDP Fast Path&trade;   
UDP Fast Path&trade; — это название пути с низкими издержками пакетов за счет реализации UDP NetX Duo. Для отправки UDP-пакета требуется вызов всего нескольких функций (***nx_udp_socket_send** _ и _*_nx_ip_packet_send_*_) с дальнейшим вызовом сетевого драйвера. _*_nx_udp_socket_send_*_ доступен в NetX Duo для существующих приложений NetX и применим только для пакетов IPv4. Однако предпочтительным методом является использование службы _ *_nxd_udp_socket_send_**, описанной ниже. При получении UDP-пакета он помещается в соответствующую очередь получения в сокете UDP либо доставляется в приостановленный поток приложения в ходе одного вызова функции из обработки прерывания получения сетевого драйвера. Эта логика с высокой степенью оптимизации для отправки и получения пакетов UDP является основой технологии UDP Fast Path.  

### <a name="udp-packet-send"></a>Отправка UDP-пакета    
Отправку данных UDP через сети IPv6 или IPv4 легко осуществить путем вызова функции ***nx_udp_socket_send** _. Вызывающий объект должен задать версию IP-адреса в поле _nx_ip_version* параметра указателя NXD_ADDRESS. NetX Duo определит оптимальный исходный адрес для передаваемых пакетов UDP на основе адреса назначения IPv4 или IPv6. Эта служба помещает заголовок UDP перед данными пакета и отправляет его в сеть с помощью внутренней подпрограммы отправки IP-пакетов. При отправке UDP-пакетов приостановка потока не применяется, так как все операции передачи UDP-пакетов обрабатываются незамедлительно. 

Для мест назначения многоадресной или широковещательной рассылки приложение должно указать исходный IP-адрес, который будет использоваться, если у устройства NetX Duo есть несколько IP-адресов на выбор. Это можно сделать с помощью служб ***nxd_udp_socket_source_send.***

> [!IMPORTANT]    
> *Если для передачи многоадресных или широковещательных пакетов используется **nx_udp_socket_send**, в качестве исходного адреса используется IP-адрес первого включенного интерфейса*.

> [!NOTE] 
> *Если для этого сокета включена логика контрольной суммы UDP, операция вычисления контрольной суммы выполняется в контексте вызывающего потока, не блокируя доступ к структурам данных UDP или IP*. 

> [!WARNING]    
> *Полезные данные UDP, находящиеся в структуре NX_PACKET, должны располагаться на границе длинных слов. Приложению необходимо оставить достаточно места между открывающим указателем и указателем начала данных, чтобы NetX Duo могло разместить заголовки UDP, IP и физических носителей*.

### <a name="udp-packet-receive"></a>Получение UDP-пакетов    
Потоки приложения могут получать UDP-пакеты от определенного сокета, вызвав ***nx_udp_socket_receive***. Функция получения сокета доставляет самый старый пакет в его очереди получения. Если в очереди получения нет пакетов, вызывающий поток может быть приостановлен (с необязательным временем ожидания) до поступления пакета.

Функция обработки получаемых UDP-пакетов (обычно вызывается из обработчика прерываний получения сетевого драйвера) отвечает за помещение пакета в очередь получения UDP-сокета или доставку его первому приостановленному потоку, ожидающему пакет. Если пакет находится в очереди, то при обработке получения проверяется также связанная с сокетом максимальная длина очереди получения. Если размер нового пакета, поступившего в очередь, превышает длину очереди, самый старый пакет в очереди отбрасывается.

### <a name="udp-receive-notify"></a>Уведомление о получении UDP-пакета   
Если поток приложения должен обрабатывать полученные данные из нескольких сокетов, следует использовать функцию ***nx_udp_socket_receive_notify***. Эта функция регистрирует функцию обратного вызова получения пакетов для сокета. При каждом получении пакета сокетом выполняется функция обратного вызова.

Содержимое функции обратного вызова зависит от конкретного приложения. Эта функция, скорее всего, будет содержать логику для информирования потока обработки о том, что пакет сейчас доступен в соответствующем сокете.

### <a name="peer-address-and-port"></a>Адрес и порт однорангового узла   
При получении UDP-пакета приложение может найти IP-адрес и номер порта отправителя с помощью службы ***nx_udp_packet_info_extract***. При успешном возвращении результата эта служба предоставляет сведения об IP-адресе и номере порта отправителя, а также локальном интерфейсе, через который был получен пакет.  

### <a name="thread-suspension"></a>Приостановка потока   
Как упоминалось ранее, потоки приложений могут быть приостановлены при попытке получить UDP-пакет на определенном UDP-порте. После получения пакета на этом порте он передается первому приостановленному потоку, и этот поток возобновляется. Необязательное время ожидания при приостановке пакета приема UDP — это функция, доступная для большинства служб NetX Duo.  

### <a name="udp-socket-statistics-and-errors"></a>Статистические показатели и ошибки UDP-сокета     
Если этот параметр включен, программное обеспечение сокета UDP NetX Duo отслеживает несколько статистических показателей и ошибок, которые могут быть полезны для приложения. Для каждого IP/UDP-экземпляра поддерживаются следующие статистические показатели и отчеты об ошибках:

- общее число отправленных UDP-пакетов;  
- общее число отправленных байтов UDP;  
- общее число полученных UDP-пакетов;   
- общее число полученных байтов UDP;  
- общее число недопустимых UDP-пакетов;  
- общее число отброшенных пакетов, получаемых по протоколу UDP;  
- общее число ошибок контрольной суммы при получении по протоколу UDP;  
- число отправленных пакетов UDP-сокета;  
- число отправленных байтов UDP-сокета;  
- число полученных пакетов UDP-сокета;   
- число полученных байтов UDP-сокета;  
- число поставленных в очередь пакетов UDP-сокета;  
- число отброшенных пакетов, получаемых от UDP-сокета;  
- число ошибок контрольной суммы UDP-сокета.  

Все эти статистические показатели и отчеты об ошибках предоставляются приложению службой ***nx_udp_info_get** _ (для статистики UDP, собранной по всем UDP-сокетам) и службой _ *_nx_udp_socket_info_get_** (для статистики UDP, собранной для заданного UDP-сокета).

### <a name="udp-socket-control-block-nx_udp_socket"></a>NX_UDP_SOCKET: блок управления сокетом UDP
Характеристики каждого UDP-сокета находятся в связанном блоке управления NX_UDP_SOCKET. Он содержит такие полезные сведения, как ссылка на структуру данных IP, сетевой интерфейс для путей отправки и получения, привязанный порт и очередь получения пакетов. Эта структура определена в файле ***nx_api.h***.

## <a name="transmission-control-protocol-tcp"></a>Протокол TCP

Управляющий протокол передачи (TCP) обеспечивает надежную потоковую передачу данных между двумя элементами сети (RFC 793). Все данные, отправленные одним элементом сети, проверяются и подтверждаются получающим элементом. Кроме того, перед любой передачей данных эти два элемента должны установить соединение. Все это обеспечивает надежную передачу данных, однако требует значительно больших временных затрат, чем описанная ранее передача данных UDP.

За исключением случаев, когда указано иное, в службах API протокола TCP NetX и NetX Duo нет никаких различий, так как IPv6 в первую очередь касается базового уровня IP. Все службы TCP NetX Duo можно использовать для подключений IPv4 или IPv6.

### <a name="tcp-header"></a>Заголовок TCP   
При передаче заголовок TCP помещается перед данными, полученными от пользователя. При получении заголовок TCP удаляется из входящего пакета, а для приложения остаются только пользовательские данные. TCP использует протокол IP для отправки и получения пакетов, поэтому, когда пакет находится в сети, перед его заголовком TCP размещается заголовок IP. На рис. 13 показан формат заголовка TCP.

![Схема формата заголовка TCP.](./media/user-guide/image22.png)

### <a name="figure-13-tcp-header"></a>РИС. 13. Заголовок TCP

В следующей таблице описывается формат заголовка TCP.

|Поле&nbsp;заголовка |Назначение |
|------|------|
| **16-разрядное поле номера исходного порта** | Это поле содержит порт, на который отправляется TCP-пакет. Допустимый диапазон TCP-портов — от 1 до 0xFFFF. |
| **16-разрядный порт назначения** | Это поле содержит TCP-порт, на который отправляется пакет. Допустимый диапазон TCP-портов — от 1 до 0xFFFF. |
| **32-разрядное поле порядкового номера** | Это поле содержит порядковый номер для данных, отправляемых с данного конца соединения. Во время начальной последовательности соединения между двумя узлами TCP устанавливается исходная последовательность. С этого момента каждая передача данных приводит к увеличению порядкового номера на количество отправленных байтов. |
| **32-разрядное поле номера подтверждения** | Это поле содержит порядковый номер, соответствующий последнему байту, полученному данной стороной соединения. Используется для определения того, были ли отправленные ранее данные успешно получены на другом конце соединения. |
| **4-разрядная длина заголовка** | Это поле содержит число 32-разрядных слов в заголовке TCP. Если в заголовке TCP отсутствуют параметры, значение этого поля равно 5. |
| **6-разрядное поле битов кода** |Это поле содержит шесть разных битов кода, используемых для обозначения различных управляющих сведений, связанных с соединением. Биты элемента управления определяются следующим образом: <br \> - URG (21): присутствуют срочные данные<br \> - ACK (20): Номер подтверждения действителен<br \> - PSH (19): Немедленно обработать эти данные<br \> - RST (18): Сброс подключения<br \> - SYN (17): Синхронизация порядковых номеров (используется для установления соединения)<br \> - FIN (16): отправитель завершил передачу (используется для закрытия соединения). |
|**16-разрядное поле окна** |Это поле используется для управления потоком. Оно содержит количество байтов, которое сокет может получить в данный момент. По сути, оно используется для управления потоком. Ответственность за то, чтобы отправляемые данные помещались в объявленное окно получателя, несет отправитель. |
|**16-разрядное поле контрольной суммы TCP** |Это поле содержит 16-разрядную контрольную сумму пакета, включая заголовок TCP, область данных пакета и псевдозаголовок IP. |
|**16-разрядное поле указателя срочности** |Это поле содержит положительное смещение последнего байта срочных данных. Оно допустимо только в случае, если в заголовке задан бит кода URG. |

> [!NOTE]  
> *Все заголовки в реализации TCP/IP должны быть представлены в формате с **обратным порядком байтов**. В этом формате наиболее значимый байт слова размещается по наименьшему байтовому адресу*.

### <a name="tcp-enable"></a>Включение TCP       
Перед установкой TCP-соединения и передачей TCP-пакетов приложение должно сначала включить протокол TCP, вызвав службу ***nx_tcp_enable***. После включения приложение может получить доступ ко всем службам TCP.  

### <a name="tcp-socket-create"></a>Создание сокета TCP    
Сокеты TCP создаются во время инициализации или выполнения потоками приложения. Начальный тип службы, срок жизни и размер окна определяются службой ***nx_tcp_socket_create***. Число сокетов TCP в приложении не ограничено.  

### <a name="tcp-checksum"></a>Контрольная сумма TCP     
Протокол TCP указывает свою дополняющую 16-разрядную контрольную сумму, охватывающую псевдозаголовок IP (состоящий из исходного IP-адреса, IP-адреса назначения и IP-слова, указывающего протокол и длину), заголовок TCP и данные пакета TCP. Единственным различием между контрольными суммами заголовков TCP-пакетов IPv4 и IPv6 является то, что исходный и конечный IP-адреса являются 32-разрядными в IPv4, а в IPv6 они 128-разрядные. 

Некоторые сетевые контроллеры могут выполнять вычисление и проверку контрольной суммы TCP в оборудовании. В таких системах приложения могут в максимальной мере использовать аппаратную логику вычисления контрольной суммы, чтобы сократить количество служебных данных во время выполнения. Приложения могут полностью отключить логику вычисления контрольной суммы TCP из библиотеки NetX Duo во время сборки, определив ***NX_DISABLE_TCP_TX_CHECKSUM** _ и _*_NX_DISABLE_TCP_RX_CHECKSUM_**. В этом случае код для вычисления контрольной суммы TCP не компилируется. Однако следует соблюдать осторожность, если установлен необязательный пакет IPsec NetX Duo, а для подключения TCP может потребоваться пройти по безопасному каналу. В этом случае данные в пакетах, принадлежащих TCP-соединению, уже зашифрованы, а большинство аппаратных модулей контрольной суммы TCP, имеющихся в сетевом драйвере, не могут формировать правильные значения контрольной суммы из зашифрованных полезных данных TCP.

Для решения этой проблемы приложение должно иметь доступ к логике контрольной суммы TCP в библиотеке и использовать функцию возможностей интерфейса. Если функция возможностей интерфейса включена, модуль TCP знает, как правильно обработать контрольную сумму TCP, если драйвер также может вычислить значение контрольной суммы:

1) Если пакет TCP не подлежит процессу IPsec, оборудование сетевого интерфейса может вычислить контрольную сумму. Поэтому модуль TCP не пытается вычислить контрольную сумму.

2) Если пакет IPsec установлен и пакет TCP подлежит процессу IPsec, то модуль TCP вычислит контрольную сумму в программном обеспечении перед отправкой пакета на уровень IPsec.

### <a name="tcp-port"></a>TCP-порт     
TCP-порт — это логическая точка подключения в протоколе TCP. В компоненте TCP NetX Duo имеется 65 535 допустимых портов в диапазоне от 1 до 0xFFFF. В отличие от протокола UDP, в котором данные с одного порта могут отправляться на любой другой порт назначения, один TCP-порт подключается к другому конкретному TCP-порту, а передача данных может осуществляться, только если это подключение установлено. При этом передача возможна только между двумя портами, между которыми установлено соединение.

> [!IMPORTANT]
> *TCP-порты полностью отделены от UDP-портов. Например, UDP-порт с номером 1 не связан с TCP-портом с номером 1*.

### <a name="client-server-model"></a>Модель "клиент — сервер"     
Чтобы использовать протокол TCP для передачи данных, необходимо сначала установить соединение между двумя сокетами TCP. Установка соединения выполняется на стороне клиента и на стороне сервера. Клиентская часть соединения — это сторона, которая инициирует соединение, а серверная часть просто ожидает запросы на подключение от клиента до завершения обработки.

> [!IMPORTANT]
> *Для устройств с поддержкой множественной адресации NetX Duo автоматически определяет исходный адрес, используемый для подключения, и адрес следующего прыжка на основе IP-адреса назначения соединения. Так как TCP ограничен отправкой пакетов на одноадресные (например, нешироковещательные) адреса назначения, NetX Duo не требует "подсказки" для выбора исходного адреса IPv6*.

### <a name="tcp-socket-state-machine"></a>Конечный автомат сокета TCP      
Соединение между двумя сокетами TCP (один клиент и один сервер) реализовать сложно. Для управления такими соединениями используется конечный автомат. Каждый сокет TCP запускается в состоянии CLOSED (ЗАКРЫТ). Через события подключения конечный автомат каждого сокета переводит его в состояние ESTABLISHED (УСТАНОВЛЕН), в котором выполняется основная часть передачи данных в TCP. Когда одной стороне соединения больше не требуется отправлять данные, она отключается. После отключения другой стороны сокет TCP фактически возвращается в состояние CLOSED (ЗАКРЫТ). Этот процесс повторяется всякий раз, когда клиент и сервер TCP устанавливают и закрывают соединение. На рис. 14 показаны различные состояния конечного автомата TCP.

### <a name="tcp-client-connection"></a>Подключение клиента TCP       
Как упоминалось ранее, клиентская сторона TCP-соединения инициирует запрос на подключение к серверу TCP. Перед запросом на подключение необходимо включить протокол TCP на клиентском IP-экземпляре. Кроме того, необходимо создать клиентский сокет TCP с помощью службы ***nx_tcp_socket_create** _ и привязать его к порту посредством службы _ *_nx_tcp_client_socket_bind_**.

После привязки клиентского сокета для установления соединения с TCP-сервером используется служба ***nxd_tcp_client_socket_connect***. Обратите внимание, что сокет должен находиться в состоянии CLOSED (ЗАКРЫТ) для инициации попытки подключения. Установка подключения начинается с выдачи пакета SYN NetX Duo, а затем ожидания передачи пакета подтверждения SYN с сервера, что означает принятие запроса на подключение. После получения подтверждения SYN NetX Duo реагирует на пакет подтверждения и переводит клиентский сокет в состояние ESTABLISHED (УСТАНОВЛЕН).

![Схема состояний конечного автомата TCP.](./media/user-guide/image24.png)   

**РИС. 14. Состояния конечного автомата TCP**


> [!WARNING]
> *Приложения должны использовать **nxd_tcp_client_socket_connect** для TCP-подключений и по протоколам IPv4 и IPv6. Приложения все еще могут использовать **nx_tcp_client_socket_connect** для TCP-подключений IPv4, но разработчикам рекомендуется использовать **nxd_tcp_client_socket_connect**, так как **nx_tcp_client_socket_connect** рано или поздно станет устаревшим*.

*Аналогичным образом, **nxd_tcp_socket_peer_info_get** работает с TCP-подключениями по протоколам IPv4 и IPv6. Однако **nx_tcp_socket_peer_info_get** по-прежнему доступен для устаревших приложений. Разработчикам рекомендуется использовать **nxd_tcp_socket_peer_info_get** в будущем*.

### <a name="tcp-client-disconnection"></a>Отключение клиента TCP    
Закрытие соединения выполняется путем вызова ***nx_tcp_socket_disconnect***. Если не задана приостановка, сокет клиента отправляет пакет RST на сокет сервера и переводит сокет в состояние CLOSED (ЗАКРЫТ). В противном случае при запросе приостановки выполняется полный протокол отключения TCP, как показано ниже. 

- Если сервер ранее инициировал запрос на отключение (клиентский сокет уже получил пакет FIN, ответил подтверждением и находится в состоянии CLOSE WAIT (ОЖИДАНИЕ ЗАКРЫТИЯ)), NetX Duo повышает состояние TCP-сокета клиента до состояния LAST ACK (ПОСЛЕДНЕЕ ПОДТВЕРЖДЕНИЕ) и отправляет пакет FIN. Затем он ожидает подтверждения от сервера перед завершением отключения и переходом в состояние CLOSED (ЗАКРЫТ).

- Если, с другой стороны, клиент первым инициирует запрос на отключение (сервер не был отключен, а сокет по-прежнему находится в состоянии ESTABLISHED (УСТАНОВЛЕН)), NetX Duo отправляет пакет FIN для инициации отключения и ждет получения сообщения FIN и подтверждения от сервера до завершения отключения и помещения сокета в состояние CLOSED (ЗАКРЫТ).

Если в очереди передачи сокета остались пакеты, NetX Duo приостанавливается на указанное время ожидания, чтобы обеспечить подтверждение этих пакетов. По истечении времени ожидания NetX Duo очищает очередь передачи сокета клиента. 

Чтобы отменить привязку порта к сокету клиента, приложение вызывает ***nx_tcp_client_socket_unbind***. Сокет должен находиться в состоянии CLOSED (ЗАКРЫТ) или в процессе отсоединения (т. е. в состоянии TIMED WAIT (ОЖИДАНИЕ С ПРИВЯЗКОЙ КО ВРЕМЕНИ)) до освобождения порта. В противном случае возвращается ошибка.

Наконец, если сокет клиента приложению больше не требуется, вызывается ***nx_tcp_socket_delete*** для удаления сокета.

### <a name="tcp-server-connection"></a>Подключение к серверу TCP      
Серверная сторона TCP-соединения является пассивной; т. е. сервер ожидает инициирования клиентом запроса на подключение. Чтобы принять клиентское подключение, необходимо сначала включить TCP в экземпляре IP, вызвав службу ***nx_tcp_enable** _. Затем приложение должно создать сокет TCP с помощью службы _ *_nx_tcp_socket_create_**.  

Сокет сервера также должен быть настроен для ожидания передачи данных запросов на подключение. Для этого используется служба ***nx_tcp_server_socket_listen***. Эта служба переводит сокет сервера в состояние LISTEN (ОЖИДАНИЕ ПЕРЕДАЧИ ДАННЫХ) и привязывает указанный порт сервера к сокету.

> [!NOTE] 
> *Чтобы задать подпрограммы обратного вызова для прослушивания сокета, приложение указывает соответствующую функцию обратного вызова для аргумента tcp_listen_callback службы **nx_tcp_server_socket_listen**. Эта функция обратного вызова приложения затем выполняется NetX Duo всякий раз, когда на этом порте сервера запрашивается новое подключение. Обработка в обратном вызове находится под управлением приложения.*

Чтобы принимать клиентские запросы на подключение, приложение вызывает службу ***nx_tcp_server_socket_accept** _. Для вызова службы принятия сокет сервера должен находиться в состоянии LISTEN (ОЖИДАНИЕ ПЕРЕДАЧИ ДАННЫХ) или состоянии SYN RECEIVED (ПОЛУЧЕН ЗАПРОС СИНХРОНИЗАЦИИ) (т. е. сервер находится в состоянии LISTEN (ОЖИДАНИЕ ПЕРЕДАЧИ ДАННЫХ) и получил пакет SYN от клиента, запросившего соединение). Состояние успешного возврата из _ *_nx_tcp_server_socket_accept_** указывает, что подключение установлено, а сокет сервера находится в состоянии ESTABLISHED (УСТАНОВЛЕН).

Когда сокет сервера будет иметь допустимое подключение, дополнительные запросы на подключение клиентов будут помещаться в очередь, пока она не будет полностью занята. Длина очереди определяется параметром *listen_queue_size, передаваемым в службу*  ***nx_tcp_server_socket_listen** _. Для обработки последующих соединений на порте сервера приложение должно вызвать _ *_nx_tcp_server_socket_relisten_** с доступным сокетом (т е. сокетом в состоянии CLOSED (ЗАКРЫТ)). Обратите внимание, что при этом может использоваться тот же сокет сервера, если связанное с ним предыдущее соединение завершено, а сокет находится в состоянии CLOSED (ЗАКРЫТ).

### <a name="tcp-server-disconnection"></a>Отключение сервера TCP     
Закрытие соединения выполняется путем вызова ***nx_tcp_socket_disconnect***. Если не задана приостановка, сокет сервера отправляет пакет RST на сокет клиента и переводит сокет в состояние CLOSED (ЗАКРЫТ). В противном случае при запросе приостановки выполняется полный протокол отключения TCP, как показано ниже.

- Если клиент ранее инициировал запрос на отключение (серверный сокет уже получил пакет FIN, ответил подтверждением и находится в состоянии CLOSE WAIT (ОЖИДАНИЕ ЗАКРЫТИЯ)), NetX Duo повышает состояние TCP-сокета до состояния LAST ACK (ПОСЛЕДНЕЕ ПОДТВЕРЖДЕНИЕ) и отправляет пакет FIN. Затем он ожидает подтверждения от сервера перед завершением отключения и входом в состояние CLOSED (ЗАКРЫТ).

- Если, с другой стороны, сервер первым инициирует запрос на отключение (клиент не был отключен, а сокет по-прежнему находится в состоянии ESTABLISHED (УСТАНОВЛЕН)), NetX Duo отправляет пакет FIN для инициации отключения и ждет получения сообщения FIN и подтверждения от клиента до завершения отключения и помещения сокета в состояние CLOSED (ЗАКРЫТ).

Если в очереди передачи сокета остались пакеты, NetX Duo приостанавливается на указанное время ожидания, чтобы обеспечить подтверждение этих пакетов. По истечении времени ожидания NetX Duo освобождает очередь передачи сокета сервера.

После завершения обработки отключения и перехода сокета сервера в состояние CLOSED (ЗАКРЫТ) приложение должно вызвать службу ***nx_tcp_server_socket_unaccept** _, чтобы завершить сопоставление этого сокета с портом сервера. Примечание. Эта служба должна вызываться приложением, даже если _*_nx_tcp_socket_disconnect_*_ или _*_nx_tcp_server_socket_accept_*_ возвращает состояние ошибки. После возврата _*_nx_tcp_server_socket_unaccept_*_ сокет можно использовать в качестве сокета клиента или сервера или даже удалить, если он больше не требуется. Если требуется принять другое клиентское соединение на том же порте сервера, для этого сокета должна быть вызвана служба _ *_nx_tcp_server_socket_relisten_**.

В следующем сегменте кода показана последовательность вызовов типичного сервера TCP.

```c
/* Set up a previously created TCP socket to
   listen on port 12 */
nx_tcp_server_socket_listen()

/* Loop to make a (another) connection. */
while(1)
{
    /* Wait for a client socket connection request
       for 100 ticks. */
    nx_tcp_server_socket_accept();

    /* (Send and receive TCP messages with the TCP
       client) */

    /* Disconnect the server socket. */
    nx_tcp_socket_disconnect();

    /* Remove this server socket from listening on
       the port. */
    nx_tcp_server_socket_unaccept(&server_socket);
    /* Set up server socket to relisten on the
       same port for the next client. */
    nx_tcp_server_socket_relisten();
}
```

### <a name="mss-validation"></a>Проверка MSS      
Максимальный размер сегмента (MSS) — это максимальное количество байтов, которые может получить узел TCP без фрагментации с помощью базового уровня IP. На этапе установки TCP-соединения оба его конца обмениваются своим значением MSS для TCP, чтобы отправитель не отправлял сегмент данных TCP, превышающий размер MSS получателя. Модуль TCP NetX Duo при необходимости проверяет значение MSS, объявленное для однорангового узла, перед установкой соединения. По умолчанию NetX Duo не разрешает такую проверку. Приложения, желающие выполнять проверку MSS, должны определить ***NX_ENABLE_TCP_MSS_CHECK** _ при создании библиотеки NetX Duo, а минимальное значение должно быть определено в _*_NX_TCP_MSS_MINIMUM_*_. Входящие TCP-соединения со значениями MSS ниже _ *_NX_TCP_MSS_MINIMUM_** отбрасываются.

### <a name="stop-listening-on-a-server-port"></a>Прекращение прослушивания порта сервера    
Если приложению больше не требуется ожидать передачи данных для запросов клиентского соединения на порте сервера, который был ранее указан при вызове службы ***nx_tcp_server_socket_listen** _, приложение просто вызывает службу _ *_nx_tcp_server_socket_unlisten_**. Эта служба переводит любой сокет, ожидающий подключения, в состояние CLOSED (ЗАКРЫТ) и освобождает все пакеты запросов на подключение клиентов, помещенные в очередь. 

### <a name="tcp-window-size"></a>Размер окна TCP   
Во время этапов настройки соединения и передачи данных каждый порт сообщает объем данных, которые он может обработать. Этот объем называется размером окна. При получении и обработке данных размер этого окна корректируется динамически. В протоколе TCP отправитель может передавать только объем данных, помещающихся в окно получателя. По сути, размер окна обеспечивает управление потоком для передачи данных в каждом направлении соединения.   

### <a name="tcp-packet-send"></a>Отправка пакетов TCP     
Отправку данных TCP можно легко выполнить, вызвав функцию ***nx_tcp_socket_send***. Если размер передаваемых данных превышает значение MSS для сокета или текущий размер окна приема однорангового узла (в зависимости от того, какое из этих значений меньше), внутренняя логика TCP отсекает при передаче данные, выходящие за пределы этого меньшего значения (MSS или окна однорангового узла). Затем эта служба создает заголовок TCP перед пакетом (в том числе вычисляет контрольную сумму). Если размер окна получателя не равен нулю, вызывающий объект будет передавать столько данных, сколько помещается в окно получателя. Если размер окна получения равен нулю, вызывающий объект может приостановить передачу и дождаться, пока размер окна получателя станет достаточно большим для отправки этого пакета. Если в какой-то момент времени несколько потоков попытаются отправить данные через один и тот же сокет, они могут быть приостановлены. 

> [!WARNING]  
> *Данные TCP, находящиеся в структуре NX_PACKET, должны располагаться на границе длинных слов. Кроме того, необходимо иметь достаточно места между открывающим указателем и указателем начала данных для размещения заголовков TCP, IP и физических носителей*.

### <a name="tcp-packet-retransmit"></a>Повторная отправка TCP-пакетов      
Ранее отправленные и переданные TCP-пакеты фактически хранятся внутри системы до тех пор, пока другая сторона соединения не возвратит пакет ACK. Если передача данных не подтверждается в течение времени ожидания, хранимый пакет отправляется повторно и задается следующий период времени ожидания. При получении пакета ACK окончательно освобождаются все пакеты, для которых действителен номер подтверждения во внутренней очереди передачи.  

> [!WARNING]   
> *Приложение не должно повторно использовать пакет или изменять содержимое пакета после того, как nx_tcp_socket_send() вернется с NX_SUCCESS. Переданный пакет в конечном итоге освобождается внутренней обработкой NetX Duo после того, как данные подтверждаются на другом конце*.

### <a name="tcp-keepalive"></a>Проверка активности TCP-соединения     
Функция проверки активности TCP-соединения позволяет сокету выявлять ситуации, когда его кэширующий узел отключается без правильного завершения (например, в случае аварийного завершения однорангового узла), а также предотвращать завершения подключения после длительных периодов бездействия определенными средствами мониторинга сетей. Функция проверки активности TCP-соединения периодически отправляет TCP-кадр без данных, а текущий порядковый номер уменьшается на единицу. При получении такого кадра проверки активности TCP-соединения получатель, если он по-прежнему активен, отвечает пакетом ACK для текущего порядкового номера. На этом транзакция проверки активности завершается.  

По умолчанию функция проверки активности не включена. Для использования этой функции библиотека NetX Duo должна быть создана с определенным ***NX_ENABLE_TCP_KEEPALIVE** _. Символ _ *_NX_TCP_KEEPALIVE_INITIAL_** указывает число секунд бездействия до инициирования кадра проверки активности.  

### <a name="tcp-packet-receive"></a>Получение TCP-пакетов   
Функция обработки получаемых TCP-пакетов (вызывается из вспомогательного потока IP) отвечает за обработку различных действий подключения и отключения, а также обработку подтверждения передачи. Кроме того, функция обработки получаемых TCP-пакетов отвечает за помещение пакетов с получаемыми данными в очередь получения соответствующего сокета TCP или доставку пакета первому приостановленному потоку, ожидающему пакет.

### <a name="tcp-receive-notify"></a>Уведомление о получении TCP-пакета     
Если поток приложения должен обрабатывать полученные данные из нескольких сокетов, следует использовать функцию ***nx_tcp_socket_receive_notify***. Эта функция регистрирует функцию обратного вызова получения пакетов для сокета. При каждом получении пакета сокетом выполняется функция обратного вызова.  

Содержимое функции обратного вызова зависит от конкретного приложения. Скорее всего, эта функция будет содержать логику для информирования потока обработки о том, что пакет доступен в соответствующем сокете. 

### <a name="thread-suspension"></a>Приостановка потока      
Как упоминалось ранее, потоки приложений могут быть приостановлены при попытке получить данные на определенном TCP-порте. После получения пакета на этом порте он передается первому приостановленному потоку, и этот поток возобновляется. Необязательное время ожидания при приостановке пакета приема TCP — это функция, доступная для большинства служб NetX Duo.  

Приостановка потока также доступна для подключения (как клиента, так и сервера), привязки клиента и служб отключения.  

### <a name="tcp-socket-statistics-and-errors"></a>Статистические показатели и ошибки сокета TCP     
Если этот параметр включен, программное обеспечение сокета TCP NetX Duo отслеживает несколько статистических показателей и ошибок, которые могут быть полезны для приложения. Для каждого IP/TCP-экземпляра поддерживаются следующие статистические показатели и отчеты об ошибках:   

- общее число отправленных TCP-пакетов;  
- общее число отправленных байтов TCP;  
- общее число полученных TCP-пакетов;   
- общее число полученных байтов TCP;   
- общее число недопустимых TCP-пакетов;   
- общее число отброшенных пакетов, получаемых по протоколу TCP;    
- общее число ошибок контрольной суммы при получении по протоколу TCP;   
- общее число TCP-соединений;   
- общее число отключений TCP-соединений;   
- общее число сброшенных TCP-соединений;    
- общее число повторно отправленных TCP-пакетов;   
- число отправленных пакетов сокета TCP;   
- число отправленных байтов сокета TCP;   
- число полученных пакетов сокета TCP;   
- число полученных байтов сокета TCP;   
- общее число повторно отправленных пакетов сокета TCP;    
- число поставленных в очередь пакетов сокета TCP;    
- число ошибок контрольной суммы сокета TCP;    
- состояние сокета TCP;    
- длина очереди передачи сокета TCP;    
- размер окна передачи сокета TCP;    
- размер окна получения сокета TCP.    

Все эти статистические показатели и отчеты об ошибках предоставляются приложению службой ***nx_tcp_info_get** _ (для общей статистики TCP) и службой _ *_nx_tcp_socket_info_get_** (для статистики TCP каждого отдельного сокета).

### <a name="tcp-socket-control-block-nx_tcp_socket"></a>Блок управления сокетом TCP NX_TCP_SOCKET      
Характеристики каждого из сокетов TCP находятся в связанном блоке управления *NX_TCP_SOCKET*, который содержит полезную информацию, такую как ссылка на структуру данных IP, интерфейс сетевого подключения, связанный порт и очередь получения пакетов. Эта структура определена в файле ***nx_api.h***.