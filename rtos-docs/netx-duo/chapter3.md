---
title: Глава 3. Функциональные компоненты ОСРВ Azure NetX Duo
description: В этой главе с точки зрения функциональности описывается высокопроизводительный стек TCP/IP ОСРВ Azure NetX Duo.
author: philmea
ms.author: philmea
ms.date: 05/19/2020
ms.topic: article
ms.service: rtos
ms.openlocfilehash: 31900c7b822c88079e4b9fe28a8a388d20f819aa
ms.sourcegitcommit: 60ad844b58639d88830f2660ab0c4ff86b92c10f
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/07/2021
ms.locfileid: "106549850"
---
# <a name="chapter-3---functional-components-of-azure-rtos-netx-duo"></a><span data-ttu-id="427f9-103">Глава 3. Функциональные компоненты ОСРВ Azure NetX Duo</span><span class="sxs-lookup"><span data-stu-id="427f9-103">Chapter 3 - Functional Components of Azure RTOS NetX Duo</span></span>

<span data-ttu-id="427f9-104">В этой главе с точки зрения функциональности описывается высокопроизводительный стек TCP/IP ОСРВ Azure NetX Duo.</span><span class="sxs-lookup"><span data-stu-id="427f9-104">This chapter contains a description of the high- performance Azure RTOS NetX Duo TCP/IP stack from a functional perspective.</span></span> 

## <a name="execution-overview"></a><span data-ttu-id="427f9-105">Общие сведения о выполнении</span><span class="sxs-lookup"><span data-stu-id="427f9-105">Execution Overview</span></span>

<span data-ttu-id="427f9-106">В приложении NetX Duo существует пять типов выполнения программы: инициализация, вызовы интерфейса приложения, внутренний IP-поток, периодические IP-таймеры и драйвер сети.</span><span class="sxs-lookup"><span data-stu-id="427f9-106">There are five types of program execution within a NetX Duo application: initialization, application interface calls, internal IP thread, IP periodic timers, and the network driver.</span></span>

> [!NOTE]
> <span data-ttu-id="427f9-107">*NetX Duo предполагает наличие системы ThreadX и использует ее выполнение потока, приостановку, периодические таймеры и средства взаимного исключения.*</span><span class="sxs-lookup"><span data-stu-id="427f9-107">*NetX Duo assumes the existence of ThreadX and depends on its thread execution, suspension, periodic timers, and mutual exclusion facilities.*</span></span>

### <a name="initialization"></a><span data-ttu-id="427f9-108">Инициализация</span><span class="sxs-lookup"><span data-stu-id="427f9-108">Initialization</span></span>

<span data-ttu-id="427f9-109">Службу \***nx_system_initialize** _ необходимо вызывать до вызова любой другой службы NetX Duo.</span><span class="sxs-lookup"><span data-stu-id="427f9-109">The service \***nx_system_initialize** _ must be called before any other NetX Duo service is called.</span></span> <span data-ttu-id="427f9-110">Инициализацию системы можно вызвать из функции ThreadX _ *_tx_application_define_*\* или из потоков приложения.</span><span class="sxs-lookup"><span data-stu-id="427f9-110">System initialization can be called either from the ThreadX _ *_tx_application_define_*\* function or from application threads.</span></span>

<span data-ttu-id="427f9-111">После возврата \***nx_system_initialize** _ система готова к созданию пулов пакетов и IP-экземпляров.</span><span class="sxs-lookup"><span data-stu-id="427f9-111">After \***nx_system_initialize** _ returns, the system is ready to create packet pools and IP instances.</span></span> <span data-ttu-id="427f9-112">Поскольку для создания IP-экземпляра требуется пул пакетов по умолчанию, на момент его создания должен существовать по крайней мере один пул пакетов NetX Duo.</span><span class="sxs-lookup"><span data-stu-id="427f9-112">Because creating an IP instance requires a default packet pool, at least one NetX Duo packet pool must exist prior to creating an IP instance.</span></span> <span data-ttu-id="427f9-113">Создавать пулы пакетов и IP-экземпляры разрешено из функции инициализации ThreadX _ *_tx_application_define_*\* и из потоков приложения.</span><span class="sxs-lookup"><span data-stu-id="427f9-113">Creating packet pools and IP instances are allowed from the ThreadX initialization function _ *_tx_application_define_*\* and from application threads.</span></span>

<span data-ttu-id="427f9-114">На внутреннем уровне создание экземпляра IP-адреса выполняется в два этапа: первая часть выполняется в контексте вызывающего объекта, из ***tx_application_define***, либо из контекста потока приложения.</span><span class="sxs-lookup"><span data-stu-id="427f9-114">Internally, creating an IP instance is accomplished in two parts: The first part is done within the context of the caller, either from ***tx_application_define*** or from an application thread's context.</span></span> <span data-ttu-id="427f9-115">Она предусматривает настройку структуры данных IP и создание различных ресурсов IP, в том числе внутреннего IP-потока.</span><span class="sxs-lookup"><span data-stu-id="427f9-115">This includes setting up the IP data structure and creating various IP resources, including the internal IP thread.</span></span> <span data-ttu-id="427f9-116">Вторая часть осуществляется во время начального выполнения из внутреннего IP-потока.</span><span class="sxs-lookup"><span data-stu-id="427f9-116">The second part is performed during the initial execution from the internal IP thread.</span></span> <span data-ttu-id="427f9-117">Именно на этом этапе первый раз вызывается драйвер сети, предоставляемый при выполнении первой части процесса создания IP-экземпляра.</span><span class="sxs-lookup"><span data-stu-id="427f9-117">This is where the network driver, supplied during the first part of IP creation, is first called.</span></span> <span data-ttu-id="427f9-118">Вызов сетевого драйвера из внутреннего IP-потока позволяет драйверу выполнять операции ввода-вывода и приостанавливать выполнение при обработке инициализации.</span><span class="sxs-lookup"><span data-stu-id="427f9-118">Calling the network driver from the internal IP thread enables the driver to perform I/O and suspend during its initialization processing.</span></span>

<span data-ttu-id="427f9-119">Когда сетевой драйвер возвращает результат обработки инициализации, создание IP-экземпляра завершается.</span><span class="sxs-lookup"><span data-stu-id="427f9-119">When the network driver returns from its initialization processing, the IP creation is complete.</span></span>

<span data-ttu-id="427f9-120">Инициализация IPv6 в NetX Duo требует наличия нескольких дополнительных служб NetX Duo.</span><span class="sxs-lookup"><span data-stu-id="427f9-120">Initialization of IPv6 in NetX Duo requires a few additional NetX Duo services.</span></span> <span data-ttu-id="427f9-121">Они описаны более подробно в разделе [IPv6 в NetX Duo](#ipv6-in-netx-duo) далее в этой главе.</span><span class="sxs-lookup"><span data-stu-id="427f9-121">These are described in greater detail in the section [IPv6 in NetX Duo](#ipv6-in-netx-duo) later in this chapter.</span></span>

> [!NOTE]
> <span data-ttu-id="427f9-122">*Служба NetX Duo **nx_ip_status_check** доступна для получения сведений об экземпляре IP и состоянии его основного интерфейса. Такие сведения о состоянии включают информацию о том, была ли ссылка инициализирована, включена и был ли разрешен IP-адрес. Эти сведения используются для синхронизации потоков приложений, которым нужно использовать только что созданный экземпляр IP. Для получения информации о системах с множественной адресацией см. раздел [Поддержка множественной адресации](#multihome-support). **nx_ip_interface_status_check** доступен для получения информации по указанному интерфейсу.*</span><span class="sxs-lookup"><span data-stu-id="427f9-122">*The NetX Duo service **nx_ip_status_check** is available to obtain information on the IP instance and its primary interface status. Such status information includes whether or not the link is initialized, enabled and IP address is resolved. This information is used to synchronize application threads needing to use a newly created IP instance. For multihome systems, see [Multihome Support](#multihome-support). **nx_ip_interface_status_check** is available to obtain 3information on the specified interface.*</span></span>

### <a name="application-interface-calls"></a><span data-ttu-id="427f9-123">Вызовы интерфейса приложения</span><span class="sxs-lookup"><span data-stu-id="427f9-123">Application Interface Calls</span></span>

<span data-ttu-id="427f9-124">Вызовы из приложения в основном выполняются из потоков приложений, работающих под управлением ОСРВ ThreadX.</span><span class="sxs-lookup"><span data-stu-id="427f9-124">Calls from the application are largely made from application threads running under the ThreadX RTOS.</span></span> <span data-ttu-id="427f9-125">Однако некоторые службы инициализации, создания и включения можно вызывать из ***tx_application_define***.</span><span class="sxs-lookup"><span data-stu-id="427f9-125">However, some initialization, create, and enable services may be called from ***tx_application_define***.</span></span> <span data-ttu-id="427f9-126">В разделах "Разрешено с" в [главе 4. Описание служб ОСРВ Azure NetX Duo](chapter4.md) указано, откуда можно вызывать каждую из служб NetX Duo.</span><span class="sxs-lookup"><span data-stu-id="427f9-126">The "Allowed From" sections in [Chapter 4 - Description of Azure RTOS NetX Duo Services](chapter4.md) indicate from which each NetX Duo service can be called.</span></span>

<span data-ttu-id="427f9-127">В большинстве случаев обработка ресурсоемких операций, таких как вычисление контрольных сумм, выполняется в контексте вызывающего потока и не приводит к блокированию доступ других потоков к IP-экземпляру.</span><span class="sxs-lookup"><span data-stu-id="427f9-127">For the most part, processing intensive activities such as computing checksums is done within the calling thread's context—without blocking access of other threads to the IP instance.</span></span> <span data-ttu-id="427f9-128">Например, при передаче перед вызовом базовой функции отправки IP-пакетов в службе \***nx_udp_socket_send** _ выполняется расчет контрольной суммы UDP.</span><span class="sxs-lookup"><span data-stu-id="427f9-128">For example, on transmission, the UDP checksum calculation is performed inside the \***nx_udp_socket_send** _ service, prior to calling the underlying IP send function.</span></span> <span data-ttu-id="427f9-129">Для полученного пакета контрольная сумма UDP вычисляется в службе _ \*_nx_udp_socket_receive_\*\*, которая выполняется в контексте потока приложения.</span><span class="sxs-lookup"><span data-stu-id="427f9-129">On a received packet, the UDP checksum is calculated in the _ *_nx_udp_socket_receive_*\* service, executed in the  of the application thread.</span></span> <span data-ttu-id="427f9-130">Это помогает предотвратить приостановку обработки сетевых запросов с более высоким приоритетом в связи с ресурсоемким вычислением контрольной суммы в потоках с более низким приоритетом.</span><span class="sxs-lookup"><span data-stu-id="427f9-130">This helps prevent stalling network requests of higher-priority threads because of processing intensive checksum computation in lower-priority threads.</span></span>

<span data-ttu-id="427f9-131">Такие значения, как IP-адреса и номера портов, передаются API в соответствии с порядком байтов узла.</span><span class="sxs-lookup"><span data-stu-id="427f9-131">Values, such as IP addresses and port numbers, are passed to APIs in host byte order.</span></span> <span data-ttu-id="427f9-132">Для внутренних целей эти значения также хранятся в соответствии с этим порядком.</span><span class="sxs-lookup"><span data-stu-id="427f9-132">Internally these values are stored in host byte order as well.</span></span> <span data-ttu-id="427f9-133">Это позволяет разработчикам легко просматривать значения с помощью отладчика.</span><span class="sxs-lookup"><span data-stu-id="427f9-133">This allows developers to easily view the values via a debugger.</span></span> <span data-ttu-id="427f9-134">Если эти значения запрограммированы в кадре для передачи, они преобразуются в сетевой порядок байтов.</span><span class="sxs-lookup"><span data-stu-id="427f9-134">When these values are programmed into a frame for transmission, they are converted to network byte order.</span></span>

### <a name="internal-ip-thread"></a><span data-ttu-id="427f9-135">Внутренний IP-поток</span><span class="sxs-lookup"><span data-stu-id="427f9-135">Internal IP Thread</span></span>

<span data-ttu-id="427f9-136">Как уже упоминалось, у каждого IP-экземпляра в NetX Duo имеется собственный поток.</span><span class="sxs-lookup"><span data-stu-id="427f9-136">As mentioned, each IP instance in NetX Duo has its own thread.</span></span> <span data-ttu-id="427f9-137">Приоритет и размер стека внутреннего IP-потока определяются в службе ***nx_ip_create***.</span><span class="sxs-lookup"><span data-stu-id="427f9-137">The priority and stack size of the internal IP thread is defined in the ***nx_ip_create*** service.</span></span> <span data-ttu-id="427f9-138">Внутренний IP-поток создается в режиме готовности к выполнению.</span><span class="sxs-lookup"><span data-stu-id="427f9-138">The internal IP thread is created in a ready-to-execute mode.</span></span> <span data-ttu-id="427f9-139">Если IP-поток имеет более высокий приоритет, чем вызывающий поток, при вызове операции создания IP-адреса может произойти вытеснение.</span><span class="sxs-lookup"><span data-stu-id="427f9-139">If the IP thread has a higher priority than the calling thread, preemption may occur inside the IP create call.</span></span>

<span data-ttu-id="427f9-140">Точка входа во внутренний IP-поток находится во внутренней функции ***_nx_ip_thread_entry***.</span><span class="sxs-lookup"><span data-stu-id="427f9-140">The entry point of the internal IP thread is at the internal function _ ***nx_ip_thread_entry***.</span></span> <span data-ttu-id="427f9-141">При запуске внутренний IP-поток сначала выполняет инициализацию драйвера сети, которая заключается в выполнении трех вызовов драйвера сети конкретного приложения.</span><span class="sxs-lookup"><span data-stu-id="427f9-141">When started, the internal IP thread first completes network driver initialization, which consists of making three calls to the application-specific network driver.</span></span> <span data-ttu-id="427f9-142">Первый вызов обеспечивает присоединение сетевого драйвера к IP-экземпляру. Далее следует вызов инициализации, который позволяет сетевому драйверу пройти процесс инициализации.</span><span class="sxs-lookup"><span data-stu-id="427f9-142">The first call is to attach the network driver to the IP instance, followed by an initialization call, which allows the network driver to go through the initialization process.</span></span> <span data-ttu-id="427f9-143">После того как сетевой драйвер возвращается из состояния инициализации (он может быть приостановлен, ожидая правильной настройки оборудования), внутренний IP-поток снова вызывает его, чтобы включить канал.</span><span class="sxs-lookup"><span data-stu-id="427f9-143">After the network driver returns from initialization (it may suspend while waiting for the hardware to be properly set up), the internal IP thread calls the network driver again to enable the link.</span></span> <span data-ttu-id="427f9-144">После возврата сетевого драйвера из вызова включения канала внутренний IP-поток переходит в бесконечный цикл проверки для различных событий, требующих обработки для данного IP-экземпляра.</span><span class="sxs-lookup"><span data-stu-id="427f9-144">After the network driver returns from the link enable call, the internal IP thread enters a forever loop checking for various events that need processing for this IP instance.</span></span> <span data-ttu-id="427f9-145">События, обрабатываемые в этом цикле, включают отложенное получение IP-пакетов, сборку фрагментов IP-пакетов, обработку проверки связи ICMP, обработку IGMP, обработку очереди пакетов TCP, периодическую обработку TCP, истечение времени ожидания сборки фрагментов IP-адресов и периодическую обработку IGMP.</span><span class="sxs-lookup"><span data-stu-id="427f9-145">Events processed in this loop include deferred IP packet reception, IP packet fragment assembly, ICMP ping processing, IGMP processing, TCP packet queue processing, TCP periodic processing, IP fragment assembly timeouts, and IGMP periodic processing.</span></span> <span data-ttu-id="427f9-146">События также включают действия по разрешению адресов; обработку пакетов ARP и периодическую обработку ARP в IPv4, обнаружение повторяющихся адресов, запрос маршрутизатора и обнаружение соседей в IPv6.</span><span class="sxs-lookup"><span data-stu-id="427f9-146">Events also include address resolution activities; ARP packet processing and ARP periodic processing in IPv4, Duplicate Address Detection, Router Solicitation, and Neighbor Discovery in IPv6.</span></span>

> [!CAUTION]
> <span data-ttu-id="427f9-147">*Функции обратного вызова NetX Duo, включая обратные вызовы операций ожидания передачи данных и отключения, вызываются не из исходного вызывающего потока, а из внутреннего IP-потока. В приложении должны быть приняты меры для предотвращения приостановки внутри любой функции обратного вызова NetX Duo.*</span><span class="sxs-lookup"><span data-stu-id="427f9-147">*The NetX Duo callback functions, including listen and disconnect callbacks, are called from the internal IP thread—not the original calling thread. The application must take care not to suspend inside any NetX Duo callback function.*</span></span>

### <a name="ip-periodic-timers"></a><span data-ttu-id="427f9-148">Периодические таймеры IP-экземпляра</span><span class="sxs-lookup"><span data-stu-id="427f9-148">IP Periodic Timers</span></span>

<span data-ttu-id="427f9-149">Для каждого IP-экземпляра используется два периодических таймера ThreadX.</span><span class="sxs-lookup"><span data-stu-id="427f9-149">There are two ThreadX periodic timers used for each IP instance.</span></span> <span data-ttu-id="427f9-150">Первый — это секундный таймер для времени ожидания ARP, IGMP и TCP, а также для инициализации обработки повторной сборки фрагмента IP-пакета.</span><span class="sxs-lookup"><span data-stu-id="427f9-150">The first one is a one-second timer for ARP, IGMP, TCP timeout, and it also drives IP fragment reassemble processing.</span></span> <span data-ttu-id="427f9-151">Второй таймер — это таймер на 100 мс, позволяющий управлять временем ожидания повторной отправки TCP-пакетов и операциями, связанными с IPv6.</span><span class="sxs-lookup"><span data-stu-id="427f9-151">The second timer is a 100ms timer to drive the TCP retransmission timeout and IPv6-related operations.</span></span>

### <a name="network-driver"></a><span data-ttu-id="427f9-152">Сетевой драйвер</span><span class="sxs-lookup"><span data-stu-id="427f9-152">Network Driver</span></span>

<span data-ttu-id="427f9-153">Каждый IP-экземпляр в NetX Duo имеет основной интерфейс, который определяется драйвером устройства, указанным в службе ***nx_ip_create***.</span><span class="sxs-lookup"><span data-stu-id="427f9-153">Each IP instance in NetX Duo has a primary interface, which is identified by its device driver specified in the ***nx_ip_create*** service.</span></span> <span data-ttu-id="427f9-154">Сетевой драйвер отвечает за обработку различных запросов NetX Duo, в том числе запросов на передачу и получение пакетов, а также запросов состояния и управления.</span><span class="sxs-lookup"><span data-stu-id="427f9-154">The network driver is responsible for handling various NetX Duo requests, including packet transmission, packet reception, and requests for status and control.</span></span> 

<span data-ttu-id="427f9-155">В системах с множественной адресацией IP-экземпляр имеет несколько интерфейсов, у каждого из которых имеется соответствующий сетевой драйвер, выполняющий эти задачи для соответствующего интерфейса.</span><span class="sxs-lookup"><span data-stu-id="427f9-155">For a multi-home system, the IP instance has multiple interfaces, each with an associated network driver that performs these tasks for the respective interface.</span></span>

<span data-ttu-id="427f9-156">Сетевой драйвер также должен обрабатывать асинхронные события, происходящие на носителе.</span><span class="sxs-lookup"><span data-stu-id="427f9-156">The network driver must also handle asynchronous events occurring on the media.</span></span> <span data-ttu-id="427f9-157">Асинхронные события с носителя включают в себя получение пакетов, завершение передачи пакетов и изменение состояния.</span><span class="sxs-lookup"><span data-stu-id="427f9-157">Asynchronous events from the media include packet reception, packet transmission completion, and status changes.</span></span> <span data-ttu-id="427f9-158">NetX Duo предоставляет сетевой драйвер с несколькими функциями доступа для управления различными событиями.</span><span class="sxs-lookup"><span data-stu-id="427f9-158">NetX Duo provides the network driver with several access functions to handle various events.</span></span> <span data-ttu-id="427f9-159">Эти функции предназначены для вызова из части сетевого драйвера, связанной с подпрограммой обработки прерываний.</span><span class="sxs-lookup"><span data-stu-id="427f9-159">These functions are designed to be called from the  interrupt service routine portion of the network driver.</span></span> <span data-ttu-id="427f9-160">Для сетей IPv4 сетевой драйвер должен пересылать все полученные ARP-пакеты внутренней функции ***_nx_arp_packet_deferred_receive***.</span><span class="sxs-lookup"><span data-stu-id="427f9-160">For IPv4 networks, the network driver should forward all ARP packets received to the ***_nx_arp_packet_deferred_receive*** internal function.</span></span> <span data-ttu-id="427f9-161">Все пакеты RARP должны перенаправляться внутренней функции \* **_nx_rarp_packet_deferred_receive** _.</span><span class="sxs-lookup"><span data-stu-id="427f9-161">All RARP packets should be forwarded to \***_nx_rarp_packet_deferred_receive** _ internal function.</span></span> <span data-ttu-id="427f9-162">Для IP-пакетов существует два варианта.</span><span class="sxs-lookup"><span data-stu-id="427f9-162">There are two options for IP packets.</span></span> <span data-ttu-id="427f9-163">Если требуется быстрая отправка IP-пакетов, входящие IP-пакеты должны перенаправляться в _ *_ _nx_ip_packet_receive_* _ для немедленной обработки.</span><span class="sxs-lookup"><span data-stu-id="427f9-163">If fast dispatch of IP packets is required, incoming IP packets should be forwarded to _ *_ _nx_ip_packet_receive_* _ for immediate processing.</span></span> <span data-ttu-id="427f9-164">Это значительно повышает производительность NetX Duo при обработке IP-пакетов.</span><span class="sxs-lookup"><span data-stu-id="427f9-164">This greatly improves NetX Duo performance in handling IP packets.</span></span> <span data-ttu-id="427f9-165">В противном случае следует пересылать IP-пакеты в _ \*_ _nx_ip_packet_deferred_receive_\*\*.</span><span class="sxs-lookup"><span data-stu-id="427f9-165">Otherwise, forwarding IP packets to _ *_ _nx_ip_packet_deferred_receive_*\* should be done.</span></span> <span data-ttu-id="427f9-166">Эта служба помещает IP-пакет в очередь отложенной обработки, где он обрабатывается внутренним IP-потоком, что обеспечивает минимальное время обработки ISR.</span><span class="sxs-lookup"><span data-stu-id="427f9-166">This service places the IP packet in the deferred processing queue where it is then handled by the internal IP thread, which results in the least amount of ISR processing time.</span></span>

<span data-ttu-id="427f9-167">Сетевой драйвер также может отложить обработку прерываний для выполнения вне контекста IP-потока.</span><span class="sxs-lookup"><span data-stu-id="427f9-167">The network driver can also defer interrupt processing to run out of the context of the IP thread.</span></span> <span data-ttu-id="427f9-168">В этом режиме ISR сохраняет необходимые сведения, вызывает внутреннюю функцию ***_nx_ip_driver_deferred_processing*** и подтверждает использование контроллера прерываний.</span><span class="sxs-lookup"><span data-stu-id="427f9-168">In this mode, the ISR shall save the necessary information, call the internal function ***_nx_ip_driver_deferred_processing***, and acknowledge the interrupt controller.</span></span> <span data-ttu-id="427f9-169">Эта служба уведомляет IP-поток о том, что необходимо запланировать обратный вызов драйвера устройства для завершения обработки события, вызывающего прерывание.</span><span class="sxs-lookup"><span data-stu-id="427f9-169">This service notifies IP thread to schedule a callback to the device driver to complete the process of the event that causes the interrupt.</span></span>

<span data-ttu-id="427f9-170">Некоторые сетевые контроллеры способны выполнять вычисление и проверку контрольной суммы заголовков TCP/IP аппаратными средствами, не расходуя ценные ресурсы ЦП.</span><span class="sxs-lookup"><span data-stu-id="427f9-170">Some network controllers are capable of performing TCP/IP header checksum computation and validation in hardware, without taking up valuable CPU resources.</span></span> <span data-ttu-id="427f9-171">Для использования функции возможностей оборудования NetX Duo предоставляет возможность включать или отключать различные вычисления контрольных сумм программного обеспечения во время компиляции, а также включать или отключать вычисления контрольных сумм во время выполнения, если драйвер устройства может сообщить IP-уровню возможности его оборудования.</span><span class="sxs-lookup"><span data-stu-id="427f9-171">To take advantage of the hardware capability feature, NetX Duo provides options to enable or disable various software checksum computation at compilation time, as well as turning on or off checksum computation at run time, if the device driver is able to communicate with the IP layer about is hardware capabilities.</span></span> <span data-ttu-id="427f9-172">Более подробные сведения о создании сетевых драйверов NetX Duo см. в главе 5 [Сетевые драйверы NetX Duo ОСРВ Azure](chapter5.md).</span><span class="sxs-lookup"><span data-stu-id="427f9-172">See [Chapter 5 - Azure RTOS NetX Duo Network Drivers](chapter5.md) for more detailed information on writing NetX Duo network drivers.</span></span>

### <a name="multihome-support"></a><span data-ttu-id="427f9-173">Поддержка множественной адресации</span><span class="sxs-lookup"><span data-stu-id="427f9-173">Multihome Support</span></span>

<span data-ttu-id="427f9-174">NetX Duo поддерживает системы, подключенные к нескольким физическим устройствам с помощью одного экземпляра IP.</span><span class="sxs-lookup"><span data-stu-id="427f9-174">NetX Duo supports systems connected to multiple physical devices using a single IP instance.</span></span> <span data-ttu-id="427f9-175">Каждый физический интерфейс назначается блоку управления взаимодействием в IP-экземпляре.</span><span class="sxs-lookup"><span data-stu-id="427f9-175">Each physical interface is assigned to an interface control block in the IP instance.</span></span> <span data-ttu-id="427f9-176">Приложения, желающие использовать систему с несколькими домашними устройствами, должны устанавливать значение \***NX_MAX_PHSYCIAL_INTERFACES** _, равное количеству физических устройств, подключенных к системе, и перестраивать библиотеку NetX Duo.</span><span class="sxs-lookup"><span data-stu-id="427f9-176">Applications wishing to use a multihome system must define the value for \***NX_MAX_PHSYCIAL_INTERFACES** _ to the number of physical devices attached to the system, and rebuild NetX Duo library.</span></span> <span data-ttu-id="427f9-177">По умолчанию значение _ *_NX_MAX_PHYSICAL_INTERFACES_*\* равно единице, что обеспечивает создание одного блока управления взаимодействием в IP-экземпляре.</span><span class="sxs-lookup"><span data-stu-id="427f9-177">By default _ *_NX_MAX_PHYSICAL_INTERFACES_*\* is set to one, creating one interface control block in the IP instance.</span></span>

<span data-ttu-id="427f9-178">Приложение NetX Duo создает один экземпляр IP-адреса для основного устройства с помощью службы \***nx_ip_create** _.</span><span class="sxs-lookup"><span data-stu-id="427f9-178">The NetX Duo application creates a single IP instance for the primary device using the \***nx_ip_create** _ service.</span></span> <span data-ttu-id="427f9-179">Для каждого дополнительного сетевого устройства приложение подключает устройство к IP-экземпляру с помощью службы _ \*_nx_ip_interface_attach_\*\*.</span><span class="sxs-lookup"><span data-stu-id="427f9-179">For each additional network devices, the application attaches the device to the IP instance using the _ *_nx_ip_interface_attach_*\* service.</span></span>

<span data-ttu-id="427f9-180">Каждая структура сетевого интерфейса содержит подмножество сетевых сведений о сетевом интерфейсе, который содержится в блоке управления IP-экземпляра, в том числе адрес IPv4 интерфейса, маску подсети, размер MTU IP-экземпляра и сведения об адресе MAC-уровня.</span><span class="sxs-lookup"><span data-stu-id="427f9-180">Each network interface structure contains a subset of network information about the network interface that is contained in the IP control block, including interface IPv4 address, subnet mask, IP MTU size, and MAC-layer address information.</span></span>

> [!NOTE]
> <span data-ttu-id="427f9-181">*NetX Duo с поддержкой множественной адресации обеспечивает обратную совместимость с более ранними версиями NetX Duo. Службы, которые не принимают явные сведения об интерфейсе, используют в качестве устройства по умолчанию основное сетевое устройство.*</span><span class="sxs-lookup"><span data-stu-id="427f9-181">*NetX Duo with multihome support is backward compatible with earlier versions of NetX Duo. Services that do not take explicit interface information default to the primary network device.*</span></span>

<span data-ttu-id="427f9-182">Первичный интерфейс имеет нулевой индекс в списке IP-экземпляров.</span><span class="sxs-lookup"><span data-stu-id="427f9-182">The primary interface has index zero in the IP instance list.</span></span> <span data-ttu-id="427f9-183">Каждому последующему устройству, подключенному к IP-экземпляру, присваивается следующий индекс.</span><span class="sxs-lookup"><span data-stu-id="427f9-183">Each subsequent device attached to the IP instance is assigned the next index.</span></span>

<span data-ttu-id="427f9-184">Все службы протокола верхнего уровня, для которых включен экземпляр IP-адресов, включая TCP, UDP, ICMP и IGMP, доступны для всех подключенных устройств.</span><span class="sxs-lookup"><span data-stu-id="427f9-184">All upper layer protocol services for which the IP instance is enabled, including TCP, UDP, ICMP, and IGMP, are available to all the attached devices.</span></span>

<span data-ttu-id="427f9-185">В большинстве случаев NetX Duo может определить оптимальный исходный адрес, который будет использоваться при передаче пакета.</span><span class="sxs-lookup"><span data-stu-id="427f9-185">In most cases, NetX Duo can determine the best source address to use when transmitting a packet.</span></span> <span data-ttu-id="427f9-186">Адрес источника выбирается на основе адреса назначения.</span><span class="sxs-lookup"><span data-stu-id="427f9-186">The source address selection is based on the destination address.</span></span> <span data-ttu-id="427f9-187">Службы NetX Duo добавляются, чтобы разрешить приложениям указывать конкретный адрес источника для использования в тех случаях, когда наиболее подходящий адрес источника не может быть определен адресом назначения.</span><span class="sxs-lookup"><span data-stu-id="427f9-187">NetX Duo services are added to allow applications to specify a specific source address to use, in cases where the most suitable one cannot be determined by the destination address.</span></span> <span data-ttu-id="427f9-188">Например, в системе с множественной адресацией приложение должно отправлять пакет на широковещательный адрес IPv4 или адрес назначения многоадресной рассылки.</span><span class="sxs-lookup"><span data-stu-id="427f9-188">An example would be in a multihome system, an application needs to send a packet to an IPv4 broadcast or multicast destination addresses.</span></span>

<span data-ttu-id="427f9-189">Ниже перечислены службы, предназначенные специально для разработки приложений с множественной адресацией.</span><span class="sxs-lookup"><span data-stu-id="427f9-189">Services specifically for developing multihome applications include the following:</span></span>

- <span data-ttu-id="427f9-190">*nx_igmp_multicast_interface_join*</span><span class="sxs-lookup"><span data-stu-id="427f9-190">*nx_igmp_multicast_interface_join*</span></span>
- <span data-ttu-id="427f9-191">*nx_igmp_multicast_interface_leave*</span><span class="sxs-lookup"><span data-stu-id="427f9-191">*nx_igmp_multicast_interface_leave*</span></span>
- <span data-ttu-id="427f9-192">*nx_ip_driver_interface_direct_command*</span><span class="sxs-lookup"><span data-stu-id="427f9-192">*nx_ip_driver_interface_direct_command*</span></span>
- <span data-ttu-id="427f9-193">*nx_ip_interface_address_get*</span><span class="sxs-lookup"><span data-stu-id="427f9-193">*nx_ip_interface_address_get*</span></span>
- <span data-ttu-id="427f9-194">*nx_ip_interface_address_mapping_configure*</span><span class="sxs-lookup"><span data-stu-id="427f9-194">*nx_ip_interface_address_mapping_configure*</span></span>
- <span data-ttu-id="427f9-195">*nx_ip_interface_address_set*</span><span class="sxs-lookup"><span data-stu-id="427f9-195">*nx_ip_interface_address_set*</span></span>  
- <span data-ttu-id="427f9-196">*nx_ip_interface_attach*</span><span class="sxs-lookup"><span data-stu-id="427f9-196">*nx_ip_interface_attach*</span></span>
- <span data-ttu-id="427f9-197">*nx_ip_interface_capability_get*</span><span class="sxs-lookup"><span data-stu-id="427f9-197">*nx_ip_interface_capability_get*</span></span> 
- <span data-ttu-id="427f9-198">*nx_ip_interface_capability_set*</span><span class="sxs-lookup"><span data-stu-id="427f9-198">*nx_ip_interface_capability_set*</span></span>
- <span data-ttu-id="427f9-199">*nx_ip_interface_detach*</span><span class="sxs-lookup"><span data-stu-id="427f9-199">*nx_ip_interface_detach*</span></span>
- <span data-ttu-id="427f9-200">*nx_ip_interface_info_get*</span><span class="sxs-lookup"><span data-stu-id="427f9-200">*nx_ip_interface_info_get*</span></span>
- <span data-ttu-id="427f9-201">*nx_ip_interface_mtu_set*</span><span class="sxs-lookup"><span data-stu-id="427f9-201">*nx_ip_interface_mtu_set*</span></span>
- <span data-ttu-id="427f9-202">*nx_ip_interface_physical_address_get*</span><span class="sxs-lookup"><span data-stu-id="427f9-202">*nx_ip_interface_physical_address_get*</span></span>
- <span data-ttu-id="427f9-203">*nx_ip_interface_physical_address_set*</span><span class="sxs-lookup"><span data-stu-id="427f9-203">*nx_ip_interface_physical_address_set*</span></span>
- <span data-ttu-id="427f9-204">*nx_ip_interface_status_check*</span><span class="sxs-lookup"><span data-stu-id="427f9-204">*nx_ip_interface_status_check*</span></span>
- <span data-ttu-id="427f9-205">*nx_ip_raw_packet_source_send*</span><span class="sxs-lookup"><span data-stu-id="427f9-205">*nx_ip_raw_packet_source_send*</span></span>
- <span data-ttu-id="427f9-206">*nx_ipv4_multicast_interface_join*</span><span class="sxs-lookup"><span data-stu-id="427f9-206">*nx_ipv4_multicast_interface_join*</span></span>
- <span data-ttu-id="427f9-207">*nx_ipv4_multicast_interface_leave*</span><span class="sxs-lookup"><span data-stu-id="427f9-207">*nx_ipv4_multicast_interface_leave*</span></span>
- <span data-ttu-id="427f9-208">*nx_udp_socket_source_send*</span><span class="sxs-lookup"><span data-stu-id="427f9-208">*nx_udp_socket_source_send*</span></span>
- <span data-ttu-id="427f9-209">*nxd_ipv6_multicast_interface_join*</span><span class="sxs-lookup"><span data-stu-id="427f9-209">*nxd_ipv6_multicast_interface_join*</span></span>
- <span data-ttu-id="427f9-210">*nxd_ipv6_multicast_interface_leave*</span><span class="sxs-lookup"><span data-stu-id="427f9-210">*nxd_ipv6_multicast_interface_leave*</span></span> 
- <span data-ttu-id="427f9-211">*nxd_udp_socket_source_send*</span><span class="sxs-lookup"><span data-stu-id="427f9-211">*nxd_udp_socket_source_send*</span></span>
- <span data-ttu-id="427f9-212">*nxd_icmp_source_ping*</span><span class="sxs-lookup"><span data-stu-id="427f9-212">*nxd_icmp_source_ping*</span></span>
- <span data-ttu-id="427f9-213">*nxd_ip_raw_packet_source_send*</span><span class="sxs-lookup"><span data-stu-id="427f9-213">*nxd_ip_raw_packet_source_send*</span></span>
- <span data-ttu-id="427f9-214">*nxd_udp_socket_source_send*</span><span class="sxs-lookup"><span data-stu-id="427f9-214">*nxd_udp_socket_source_send*</span></span>

<span data-ttu-id="427f9-215">Эти службы более подробно описаны в [Описании служб NetX Duo](chapter4.md).</span><span class="sxs-lookup"><span data-stu-id="427f9-215">These services are explained in greater detail in [Description of NetX Duo Services](chapter4.md).</span></span>

### <a name="loopback-interface"></a><span data-ttu-id="427f9-216">Интерфейс замыкания на себя</span><span class="sxs-lookup"><span data-stu-id="427f9-216">Loopback Interface</span></span>

<span data-ttu-id="427f9-217">Интерфейс замыкания на себя — это специальный сетевой интерфейс без подключения физического канала.</span><span class="sxs-lookup"><span data-stu-id="427f9-217">The loopback interface is a special network interface without an physical link attached to.</span></span> <span data-ttu-id="427f9-218">Интерфейс замыкания на себя позволяет приложениям обмениваться данными с помощью петлевого адреса IPv4 127.0.0.1. Для использования логического интерфейса замыкания на себя убедитесь, что настраиваемый параметр ***NX_DISABLE_LOOPBACK_INTERFACE*** не задан.</span><span class="sxs-lookup"><span data-stu-id="427f9-218">The loopback interface allows applications to communicate using the IPv4 loopback address 127.0.0.1 To utilize a logical loopback interface, ensure the configurable option ***NX_DISABLE_LOOPBACK_INTERFACE*** is not set.</span></span>

### <a name="interface-control-blocks"></a><span data-ttu-id="427f9-219">Блоки управления взаимодействием</span><span class="sxs-lookup"><span data-stu-id="427f9-219">Interface Control Blocks</span></span>

<span data-ttu-id="427f9-220">Количество блоков управления взаимодействием в IP-экземпляре — это число физических интерфейсов (определяемое \***NX_MAX_PHYSICAL_INTERFACES** _), плюс интерфейс замыкания на себя, если он включен.</span><span class="sxs-lookup"><span data-stu-id="427f9-220">The number of interface control blocks in the IP instance is the number of physical interfaces (defined by \***NX_MAX_PHYSICAL_INTERFACES** _) plus the loopback interface if it is enabled.</span></span> <span data-ttu-id="427f9-221">Общее число интерфейсов определяется в _\*_NX_MAX_IP_INTERFACES_\*\*.</span><span class="sxs-lookup"><span data-stu-id="427f9-221">The total number of interfaces is defined in _\*_NX_MAX_IP_INTERFACES_\*\*.</span></span>

## <a name="protocol-layering"></a><span data-ttu-id="427f9-222">Разделение протокола на уровни</span><span class="sxs-lookup"><span data-stu-id="427f9-222">Protocol Layering</span></span>

<span data-ttu-id="427f9-223">Протокол TCP/IP, реализованный в NetX Duo, является многоуровневым протоколом. Это означает, что более сложные протоколы основаны на более простых базовых протоколах.</span><span class="sxs-lookup"><span data-stu-id="427f9-223">The TCP/IP implemented by NetX Duo is a layered protocol, which means more complex protocols are built on top of simpler underlying protocols.</span></span> <span data-ttu-id="427f9-224">В протоколе TCP/IP протокол самого низкого уровня находится на *канальном уровне* и обрабатывается сетевым драйвером.</span><span class="sxs-lookup"><span data-stu-id="427f9-224">In TCP/IP, the lowest layer protocol is at the *link level* and is handled by the network driver.</span></span> <span data-ttu-id="427f9-225">Этот уровень обычно предназначен для Ethernet, но он также может быть реализован на базе оптоволоконного или последовательного канала или практически любого физического носителя.</span><span class="sxs-lookup"><span data-stu-id="427f9-225">This level is typically targeted towards Ethernet, but it could also be fiber, serial, or virtually any physical media.</span></span>

<span data-ttu-id="427f9-226">Над канальным уровнем находится *сетевой*.</span><span class="sxs-lookup"><span data-stu-id="427f9-226">On top of the link layer is the *network layer*.</span></span> <span data-ttu-id="427f9-227">В TCP/IP это IP-интерфейс, который, по сути, отвечает за отправку и получение простых пакетов по сети по принципу наименьших затрат.</span><span class="sxs-lookup"><span data-stu-id="427f9-227">In TCP/IP, this is the IP, which is basically responsible for sending and receiving simple packets—in a best-effort manner—across the network.</span></span> <span data-ttu-id="427f9-228">Протоколы типов управления, такие как ICMP и IGMP, обычно также делятся на сетевые уровни, хотя и используют IP-протокол для отправки и получения.</span><span class="sxs-lookup"><span data-stu-id="427f9-228">Management-type protocols like ICMP and IGMP are typically also categorized as network layers, even though they rely on IP for sending and receiving.</span></span>

<span data-ttu-id="427f9-229">*Транспортный уровень* располагается поверх сетевого.</span><span class="sxs-lookup"><span data-stu-id="427f9-229">The *transport layer* rests on top of the network layer.</span></span> <span data-ttu-id="427f9-230">Этот уровень отвечает за управление потоком данных между узлами в сети.</span><span class="sxs-lookup"><span data-stu-id="427f9-230">This layer is responsible for managing the flow of data between hosts on the network.</span></span> <span data-ttu-id="427f9-231">Существует два типа транспортных служб, поддерживаемых NetX Duo: UDP и TCP.</span><span class="sxs-lookup"><span data-stu-id="427f9-231">There are two types of transport services supported by NetX Duo: UDP and TCP.</span></span> <span data-ttu-id="427f9-232">Службы UDP обеспечивают отправку и получение данных между двумя узлами по принципу наименьших затрат без установки подключения, в то время как TCP обеспечивает надежное обслуживание с ориентацией на подключение для передачи данных между двумя сущностями узла.</span><span class="sxs-lookup"><span data-stu-id="427f9-232">UDP services provide best-effort sending and receiving of data between two hosts in a connectionless manner, while TCP provides reliable connection-oriented service between two host entities.</span></span>

<span data-ttu-id="427f9-233">Это разделение на уровни отражается на фактических пакетах сетевых данных.</span><span class="sxs-lookup"><span data-stu-id="427f9-233">This layering is reflected in the actual network data packets.</span></span> <span data-ttu-id="427f9-234">Каждый слой в TCP/IP содержит блок данных, называемый заголовком.</span><span class="sxs-lookup"><span data-stu-id="427f9-234">Each layer in TCP/IP contains a block of information called a header.</span></span> <span data-ttu-id="427f9-235">Такой метод заключения данных (и, возможно, сведений о протоколе) в заголовок обычно называется инкапсуляцией данных.</span><span class="sxs-lookup"><span data-stu-id="427f9-235">This technique of surrounding data (and possibly protocol information) with a header is typically called data encapsulation.</span></span> <span data-ttu-id="427f9-236">На рис. 1 показан пример многоуровневого NetX Duo, а на рис. 2 показана полученная инкапсуляция данных для отправляемых данных UDP.</span><span class="sxs-lookup"><span data-stu-id="427f9-236">Figure 1 shows an example of NetX Duo layering and Figure 2 shows the resulting data encapsulation for UDP data being sent.</span></span>

![Разделение протокола на уровни](./media/user-guide/image12.jpg)

<span data-ttu-id="427f9-238">**РИС. 1. Разделение протокола на уровни**</span><span class="sxs-lookup"><span data-stu-id="427f9-238">**FIGURE 1. Protocol Layering**</span></span>

## <a name="packet-pools"></a><span data-ttu-id="427f9-239">Пулы пакетов</span><span class="sxs-lookup"><span data-stu-id="427f9-239">Packet Pools</span></span>

<span data-ttu-id="427f9-240">Быстрое и детерминированное выделение пакетов — вечная проблема в сетевых приложениях реального времени.</span><span class="sxs-lookup"><span data-stu-id="427f9-240">Allocating packets in a fast and deterministic manner is always a challenge in real-time networking applications.</span></span> <span data-ttu-id="427f9-241">Ввиду этого NetX Duo предоставляет возможность создать и администрировать несколько пулов сетевых пакетов фиксированного размера.</span><span class="sxs-lookup"><span data-stu-id="427f9-241">With this in mind, NetX Duo provides the ability to create and manage multiple pools of fixed-size network packets.</span></span>

<span data-ttu-id="427f9-242">Так как пулы пакетов NetX Duo состоят из блоков памяти фиксированного размера, никаких внутренних проблем фрагментации не возникает.</span><span class="sxs-lookup"><span data-stu-id="427f9-242">Because NetX Duo packet pools consist of fixed-size memory blocks, there are never any internal fragmentation problems.</span></span> <span data-ttu-id="427f9-243">Конечно, фрагментация приводит к поведению, которое, по сути, является недетерминированным.</span><span class="sxs-lookup"><span data-stu-id="427f9-243">Of course, fragmentation causes behavior that is inherently nondeterministic.</span></span> <span data-ttu-id="427f9-244">Кроме того, время, необходимое для выделения и освобождения пакета NetX Duo, соответствует времени простой операции со связанным списком.</span><span class="sxs-lookup"><span data-stu-id="427f9-244">In addition, the time required to allocate and free a NetX Duo packet amounts to simple linked-list manipulation.</span></span> <span data-ttu-id="427f9-245">Более того, выделение и освобождение пакета выполняется на уровне заголовка списка доступных ресурсов.</span><span class="sxs-lookup"><span data-stu-id="427f9-245">Furthermore, packet allocation and deallocation is done at the head of the available list.</span></span> <span data-ttu-id="427f9-246">Это обеспечивает максимально быструю обработку связанного списка.</span><span class="sxs-lookup"><span data-stu-id="427f9-246">This provides the fastest possible linked list processing.</span></span>

![Инкапсуляция данных UDP](./media/user-guide/image13.png)

<span data-ttu-id="427f9-248">**РИС. 2. Инкапсуляция данных UDP**</span><span class="sxs-lookup"><span data-stu-id="427f9-248">**FIGURE 2. UDP Data Encapsulation**</span></span>

<span data-ttu-id="427f9-249">Отсутствие гибкости обычно является основным недостатком пулов пакетов фиксированного размера.</span><span class="sxs-lookup"><span data-stu-id="427f9-249">Lack of flexibility is typically the main drawback of fixed-size packet pools.</span></span> <span data-ttu-id="427f9-250">Определение оптимального размера полезных данных пакета, который также позволит обрабатывать входящие пакеты в худшем случае, — сложная задача.</span><span class="sxs-lookup"><span data-stu-id="427f9-250">Determining the optimal packet payload size that also handles the worst-case incoming packet is a difficult task.</span></span> <span data-ttu-id="427f9-251">Пакеты NetX Duo устраняют эту проблему с помощью необязательного компонента, называемого цепочкой пакетов.</span><span class="sxs-lookup"><span data-stu-id="427f9-251">NetX Duo packets address this problem with an optional feature called packet chaining.</span></span> <span data-ttu-id="427f9-252">Фактический сетевой пакет может состоять из одного или нескольких пакетов NetX Duo, связанных друг с другом.</span><span class="sxs-lookup"><span data-stu-id="427f9-252">An actual network packet can be made of one or more NetX Duo packets linked together.</span></span> <span data-ttu-id="427f9-253">Кроме того, в заголовке пакета хранится указатель на верхнюю часть пакета.</span><span class="sxs-lookup"><span data-stu-id="427f9-253">In addition, the packet header maintains a pointer to the top of the packet.</span></span> <span data-ttu-id="427f9-254">По мере добавления дополнительных протоколов этот указатель просто смещается назад, а непосредственно перед данными записывается новый заголовок.</span><span class="sxs-lookup"><span data-stu-id="427f9-254">As additional protocols are added, this pointer is simply moved backwards and the new header is written directly in front of the data.</span></span> <span data-ttu-id="427f9-255">Без технологии гибких пакетов стеку пришлось бы выделить другой буфер и скопировать данные в новый буфер с новым заголовком, а это весьма ресурсоемкая задача.</span><span class="sxs-lookup"><span data-stu-id="427f9-255">Without the flexible packet technology, the stack would have to allocate another buffer and copy the data into a new buffer with the new header, which is processing intensive.</span></span>

<span data-ttu-id="427f9-256">Так как размер полезных данных каждого пакета фиксирован для заданного пула пакетов, данные приложения, превышающие размер полезных данных, потребуют объединения нескольких пакетов в цепочку.</span><span class="sxs-lookup"><span data-stu-id="427f9-256">Since each packet payload size is fixed for a given packet pool, application data larger than the payload size would require multiple packets chained together.</span></span> <span data-ttu-id="427f9-257">При заполнении пакета данными пользователя приложение должно использовать службу ***nx_packet_data_append***.</span><span class="sxs-lookup"><span data-stu-id="427f9-257">When filling a packet with user data, the application shall use the service ***nx_packet_data_append***.</span></span> <span data-ttu-id="427f9-258">Эта служба перемещает данные приложения в пакет.</span><span class="sxs-lookup"><span data-stu-id="427f9-258">This service moves application data into a packet.</span></span> <span data-ttu-id="427f9-259">В ситуациях, когда пакета недостаточно для хранения пользовательских данных, для них выделяются дополнительные пакеты.</span><span class="sxs-lookup"><span data-stu-id="427f9-259">In situations where a packet is not enough to hold user data, additional packets are allocated to store user data.</span></span> <span data-ttu-id="427f9-260">Чтобы использовать цепочку пакетов, у драйвера должна быть возможность получения и передачи данных в объединенных в цепочку пакетах.</span><span class="sxs-lookup"><span data-stu-id="427f9-260">To use packet chaining, the driver must be able to receive into or transmit from chained packets.</span></span>

<span data-ttu-id="427f9-261">Для встроенных систем, которым не нужно использовать функцию создания цепочек пакетов, библиотеку NetX Duo можно построить с помощью \***NX_DISABLE_PACKET_CHAIN** _, чтобы удалить логику цепочки пакетов.</span><span class="sxs-lookup"><span data-stu-id="427f9-261">For embedded systems that do not need to use the packet chaining feature, the NetX Duo library can be built with \***NX_DISABLE_PACKET_CHAIN** _ to remove the packet chaining logic.</span></span> <span data-ttu-id="427f9-262">Обратите внимание, что для возможности фрагментации и пересборки IP-адресов может быть необходимо использовать функцию сцепленных пакетов.</span><span class="sxs-lookup"><span data-stu-id="427f9-262">Note that the IP fragmentation and reassembly feature may need to utilize the chained packet feature.</span></span> <span data-ttu-id="427f9-263">Поэтому для определения _*_NX_DISABLE_PACKET_CHAIN_*_ необходимо также определить _ \*_NX_DISABLE_FRAGMENTATION_\*\*.</span><span class="sxs-lookup"><span data-stu-id="427f9-263">Therefore defining _*_NX_DISABLE_PACKET_CHAIN_*_ requires _ *_NX_DISABLE_FRAGMENTATION_*\* also be defined.</span></span> 

<span data-ttu-id="427f9-264">Каждый пул памяти пакетов NetX Duo является общедоступным ресурсом.</span><span class="sxs-lookup"><span data-stu-id="427f9-264">Each NetX Duo packet memory pool is a public resource.</span></span> <span data-ttu-id="427f9-265">NetX Duo не накладывает ограничений на то, как используются пулы пакетов.</span><span class="sxs-lookup"><span data-stu-id="427f9-265">NetX Duo places no constraints on how packet pools are used.</span></span> 

### <a name="packet-pool-memory-area"></a><span data-ttu-id="427f9-266">Область памяти пула пакетов</span><span class="sxs-lookup"><span data-stu-id="427f9-266">Packet Pool Memory Area</span></span>

<span data-ttu-id="427f9-267">Область памяти для пула пакетов задается во время его создания.</span><span class="sxs-lookup"><span data-stu-id="427f9-267">The memory area for the packet pool is specified during creation.</span></span> <span data-ttu-id="427f9-268">Как и в случае с другими областями памяти для объектов ThreadX и NetX Duo, она может находиться в любом месте целевого адресного пространства.</span><span class="sxs-lookup"><span data-stu-id="427f9-268">Like other memory areas for ThreadX and NetX Duo objects, it can be located anywhere in the target's address space.</span></span> 

<span data-ttu-id="427f9-269">Это важная возможность, так как она обеспечивает значительную гибкость для приложения.</span><span class="sxs-lookup"><span data-stu-id="427f9-269">This is an important feature because of the considerable flexibility it gives the application.</span></span> <span data-ttu-id="427f9-270">Например, предположим, что у продукта взаимодействия имеется высокоскоростная область памяти для операций сетевых буферов.</span><span class="sxs-lookup"><span data-stu-id="427f9-270">For example, suppose that a communication product has a high-speed memory area for network buffers.</span></span> <span data-ttu-id="427f9-271">Эту область памяти можно легко использовать, превратив ее в пул памяти пакетов NetX Duo.</span><span class="sxs-lookup"><span data-stu-id="427f9-271">This memory area is easily utilized by making it into a NetX Duo packet memory pool.</span></span>

### <a name="creating-packet-pools"></a><span data-ttu-id="427f9-272">Создание пулов пакетов</span><span class="sxs-lookup"><span data-stu-id="427f9-272">Creating Packet Pools</span></span>

<span data-ttu-id="427f9-273">Пулы пакетов создаются во время инициализации или выполнения потоками приложения.</span><span class="sxs-lookup"><span data-stu-id="427f9-273">Packet pools are created either during initialization or during runtime by  application threads.</span></span> <span data-ttu-id="427f9-274">Количество пулов памяти пакетов в приложении NetX Duo не ограничено.</span><span class="sxs-lookup"><span data-stu-id="427f9-274">There are no limits on the number of packet memory pools in a NetX Duo application.</span></span>

### <a name="dual-packet-pool"></a><span data-ttu-id="427f9-275">Двойной пул пакетов</span><span class="sxs-lookup"><span data-stu-id="427f9-275">Dual Packet Pool</span></span>

<span data-ttu-id="427f9-276">Обычно размер полезных данных пула IP-пакетов по умолчанию достаточно велик, чтобы допускать размер кадра вплоть до MTU сетевого интерфейса.</span><span class="sxs-lookup"><span data-stu-id="427f9-276">Typically the payload size of the default IP packet pool is large enough to accommodate frame size up to the network interface MTU.</span></span> <span data-ttu-id="427f9-277">Во время нормальной работы потоку IP необходимо отправлять такие сообщения, как ARP, управляющие сообщения TCP, IGMP-сообщения, ICMPv6-сообщения.</span><span class="sxs-lookup"><span data-stu-id="427f9-277">During normal operation, the IP thread needs to send messages such as ARP, TCP control messages, IGMP messages, ICMPv6 messages.</span></span> <span data-ttu-id="427f9-278">Эти сообщения используют пакеты, выделенные из пула пакетов по умолчанию в экземпляре IP.</span><span class="sxs-lookup"><span data-stu-id="427f9-278">These messages use the packets allocated from the default packet pool in the IP instance.</span></span> <span data-ttu-id="427f9-279">В системе с ограниченным объемом памяти, в которой объем доступной памяти для пула пакетов также ограничен, использование одного пула пакетов (с большим объемом полезных данных для соответствия размеру MTU) может оказаться неоптимальным решением.</span><span class="sxs-lookup"><span data-stu-id="427f9-279">On a memory-constrained system where the amount of memory available for packet pool is limited, using a single packet pool (with the large payload size to match MTU size) may not be an optimal solution.</span></span> <span data-ttu-id="427f9-280">NetX Duo позволяет приложению установить вспомогательный пул пакетов, где размер полезных данных меньше.</span><span class="sxs-lookup"><span data-stu-id="427f9-280">NetX Duo allows application to install an auxiliary packet pool, where the payload size is smaller.</span></span> <span data-ttu-id="427f9-281">После установки вспомогательного пула пакетов вспомогательный поток IP будет выделять пакеты из пула пакетов по умолчанию или из вспомогательного пула в зависимости от размера передаваемого сообщения.</span><span class="sxs-lookup"><span data-stu-id="427f9-281">Once the auxiliary packet pool is installed, the IP helper thread would allocate packets from either the default packet pool or the auxiliary pool, depending on the size of the message it transmits.</span></span> <span data-ttu-id="427f9-282">Для вспомогательного пула пакетов размер полезных данных в 200 байт будет работать для большинства сообщений, передаваемых вспомогательным потоком IP.</span><span class="sxs-lookup"><span data-stu-id="427f9-282">For an auxiliary packet pool, a payload size of 200 bytes would work with most of the messages the IP helper thread transmits.</span></span>

<span data-ttu-id="427f9-283">По умолчанию библиотека NetX Duo создается без включения двойного пула пакетов.</span><span class="sxs-lookup"><span data-stu-id="427f9-283">By default NetX Duo library is built without enabling dual packet pool.</span></span> <span data-ttu-id="427f9-284">Чтобы включить эту функцию, создайте библиотеку с определенным \***NX_DUAL_PACKET_POOL_ENABLE** _.</span><span class="sxs-lookup"><span data-stu-id="427f9-284">To enable the feature, build the library with \***NX_DUAL_PACKET_POOL_ENABLE** _ defined.</span></span> <span data-ttu-id="427f9-285">Затем можно задать вспомогательный пул пакетов, вызвав _\*_nx_ip_auxiliary_packet_pool_set_\*\*.</span><span class="sxs-lookup"><span data-stu-id="427f9-285">Then the auxiliary packet pool can be set by calling _\*_nx_ip_auxiliary_packet_pool_set_\*\*.</span></span>

<span data-ttu-id="427f9-286">Существует также возможность создания более одного пула пакетов.</span><span class="sxs-lookup"><span data-stu-id="427f9-286">There is also the option of creating more than one packet pool.</span></span> <span data-ttu-id="427f9-287">Например, пул пакетов передачи создается с оптимальным размером полезных данных для ожидаемых размеров сообщений.</span><span class="sxs-lookup"><span data-stu-id="427f9-287">For example a transmit packet pool is created with optimal payload size for expected message sizes.</span></span> <span data-ttu-id="427f9-288">Пул пакетов получения создается в драйвере с размером полезных данных, установленным на MTU драйвера, так как предсказать размер получаемых пакетов невозможно.</span><span class="sxs-lookup"><span data-stu-id="427f9-288">A receive packet pool is created in the driver with a payload size set to the driver MTU, since one cannot predict the size of received packets.</span></span>

### <a name="packet-header-nx_packet"></a><span data-ttu-id="427f9-289">Заголовок пакета NX_PACKET</span><span class="sxs-lookup"><span data-stu-id="427f9-289">Packet Header NX_PACKET</span></span>   
<span data-ttu-id="427f9-290">По умолчанию NetX Duo размещает заголовок пакета непосредственно перед областью полезных данных пакета.</span><span class="sxs-lookup"><span data-stu-id="427f9-290">By default, NetX Duo places the packet header immediately before the packet payload area.</span></span> <span data-ttu-id="427f9-291">Пул памяти пакетов — это, по сути, ряд, состоящий из пакетов: заголовков, непосредственно за которыми следуют полезные данные пакета.</span><span class="sxs-lookup"><span data-stu-id="427f9-291">The packet memory pool is basically a series of packets— headers followed immediately by the packet payload.</span></span> <span data-ttu-id="427f9-292">Заголовок пакета (***NX_PACKET***) и макет пула пакетов изображены на рис. 3.</span><span class="sxs-lookup"><span data-stu-id="427f9-292">The packet header (***NX_PACKET***) and the layout of the packet pool are pictured in Figure 3.</span></span>

<span data-ttu-id="427f9-293">Обычно для драйвера сетевых устройств, который может выполнять операции без копирования, начальный адрес области полезных данных пакета запрограммирован в логике DMA.</span><span class="sxs-lookup"><span data-stu-id="427f9-293">For network devices driver that are able to perform zero copy operations, typically the starting address of the packet payload area is programmed into the DMA logic.</span></span> <span data-ttu-id="427f9-294">Некоторые модули DMA имеют требование к выравниванию для области полезных данных.</span><span class="sxs-lookup"><span data-stu-id="427f9-294">Certain DMA engines have alignment requirement on the payload area.</span></span> <span data-ttu-id="427f9-295">Чтобы обеспечить правильное выведение начального адреса области полезных данных для модуля DMA или операции кэширования, пользователь может определить символ ***NX_PACKET_ALIGNMENT***.</span><span class="sxs-lookup"><span data-stu-id="427f9-295">To make the starting address of the payload area align properly for the DMA engine, or the cache operation, the user can define the symbol ***NX_PACKET_ALIGNMENT***.</span></span>

> [!WARNING]
> <span data-ttu-id="427f9-296">*При завершении передачи пакета важно, чтобы сетевой драйвер использовал функцию **nx_packet_transmit_release**. Эта функция проверяет, что пакет не входит в очередь вывода TCP, прежде чем он фактически помещается обратно в пул доступных.*</span><span class="sxs-lookup"><span data-stu-id="427f9-296">*It is important for the network driver to use the **nx_packet_transmit_release** function when transmission of a packet is complete. This function checks to make sure the packet is not part of a TCP output queue before it is actually placed back in the available pool.*</span></span>

![Заголовок пакета и макет пула пакетов](./media/user-guide/image14.jpg)

<span data-ttu-id="427f9-298">**РИС. 3. Заголовок пакета и макет пула пакетов**</span><span class="sxs-lookup"><span data-stu-id="427f9-298">**FIGURE 3. Packet Header and Packet Pool Layout**</span></span>

<span data-ttu-id="427f9-299">Ниже приведены определения полей заголовка пакета.</span><span class="sxs-lookup"><span data-stu-id="427f9-299">The fields of the packet header are defined as follows.</span></span> <span data-ttu-id="427f9-300">Обратите внимание, что эта таблица не является исчерпывающим списком всех элементов структуры *NX_PACKET*.</span><span class="sxs-lookup"><span data-stu-id="427f9-300">Note that this table is not a comprehensive list of all the members in the *NX_PACKET* structure.</span></span>

|<span data-ttu-id="427f9-301">Заголовок пакета</span><span class="sxs-lookup"><span data-stu-id="427f9-301">Packet header</span></span> | <span data-ttu-id="427f9-302">Назначение</span><span class="sxs-lookup"><span data-stu-id="427f9-302">Purpose</span></span> |
|---|---|
|<span data-ttu-id="427f9-303">***nx_packet_pool_owner***</span><span class="sxs-lookup"><span data-stu-id="427f9-303">***nx_packet_pool_owner***</span></span>|<span data-ttu-id="427f9-304">Это поле указывает на пул пакетов, которому принадлежит этот конкретный пакет.</span><span class="sxs-lookup"><span data-stu-id="427f9-304">This field points to the packet pool that owns this particular packet.</span></span> <span data-ttu-id="427f9-305">После освобождения пакета он становится доступным в этом конкретном пуле.</span><span class="sxs-lookup"><span data-stu-id="427f9-305">When the packet is released, it is released to this particular pool.</span></span> <span data-ttu-id="427f9-306">Когда владение пулом находится внутри каждого пакета, датаграмма может охватывать несколько пакетов из нескольких пулов пакетов.</span><span class="sxs-lookup"><span data-stu-id="427f9-306">With the pool ownership inside each packet, it is possible for a datagram to span multiple packets from multiple packet pools.</span></span>|
|<span data-ttu-id="427f9-307">\***nx_packet_next** _</span><span class="sxs-lookup"><span data-stu-id="427f9-307">\***nx_packet_next** _</span></span>|<span data-ttu-id="427f9-308">Это поле указывает на следующий пакет в том же кадре.</span><span class="sxs-lookup"><span data-stu-id="427f9-308">This field points to the next packet within the same frame.</span></span> <span data-ttu-id="427f9-309">Если значение равно NULL, дополнительные пакеты, которые являются частью кадра, отсутствуют.</span><span class="sxs-lookup"><span data-stu-id="427f9-309">If NULL, there are no additional packets that are part of the frame.</span></span> <span data-ttu-id="427f9-310">Это поле используется для хранения фрагментированных пакетов до тех пор, пока не выполнена повторная сборка всего пакета.</span><span class="sxs-lookup"><span data-stu-id="427f9-310">This field is also used to hold fragmented packets until the entire packet can be re-assembled.</span></span> <span data-ttu-id="427f9-311">оно удаляется, если определен _\*_NX_DISABLE_PACKET_CHAIN_\*\*.</span><span class="sxs-lookup"><span data-stu-id="427f9-311">it is removed if _\*_NX_DISABLE_PACKET_CHAIN_\*\*is defined.</span></span>|
|<span data-ttu-id="427f9-312">\***nx_packet_last** _</span><span class="sxs-lookup"><span data-stu-id="427f9-312">\***nx_packet_last** _</span></span>|<span data-ttu-id="427f9-313">Это поле указывает на последний пакет в том же сетевом пакете.</span><span class="sxs-lookup"><span data-stu-id="427f9-313">This field points to the last packet within the same network packet.</span></span> <span data-ttu-id="427f9-314">Если значение равно NULL, этот пакет представляет весь сетевой пакет.</span><span class="sxs-lookup"><span data-stu-id="427f9-314">If NULL, this packet represents the entire network packet.</span></span> <span data-ttu-id="427f9-315">Это поле удаляется, если определено значение _\*_NX_DISABLE_PACKET_CHAIN_\*\*.</span><span class="sxs-lookup"><span data-stu-id="427f9-315">This field is removed if _\*_NX_DISABLE_PACKET_CHAIN_\*\*is defined.</span></span>|
|<span data-ttu-id="427f9-316">\***nx_packet_length** _</span><span class="sxs-lookup"><span data-stu-id="427f9-316">\***nx_packet_length** _</span></span>| <span data-ttu-id="427f9-317">Это поле содержит общее число байтов во всем сетевом пакете, включая общее количество байтов во всех пакетах, связанных в цепочку с помощью элемента _nx_packet_next\*.</span><span class="sxs-lookup"><span data-stu-id="427f9-317">This field contains the total number of bytes in the entire network packet, including the total of all bytes in all packets chained together by the _nx_packet_next\*member.</span></span>|
|<span data-ttu-id="427f9-318">***nx_packet_ip_interface***</span><span class="sxs-lookup"><span data-stu-id="427f9-318">***nx_packet_ip_interface***</span></span>| <span data-ttu-id="427f9-319">Это поле является блоком управления интерфейсом, который назначается пакету при его получении драйвером интерфейса и его получении NetX Duo для исходящих пакетов.</span><span class="sxs-lookup"><span data-stu-id="427f9-319">This field is the interface control block which is assigned to the packet when it is received by the interface driver, and by NetX Duo for outgoing packets.</span></span> <span data-ttu-id="427f9-320">Блок управления взаимодействием описывает интерфейс, например сетевой адрес, MAC-адрес, IP-адрес и состояние интерфейса, скажем, указывает, включена ли связь и требуется ли физическое сопоставление.</span><span class="sxs-lookup"><span data-stu-id="427f9-320">An interface control block describes the interface e.g. network address, MAC address, IP address and interface status such as link enabled and physical mapping required.</span></span>|
|<span data-ttu-id="427f9-321">\***nx_packet_data_start** _</span><span class="sxs-lookup"><span data-stu-id="427f9-321">\***nx_packet_data_start** _</span></span>| <span data-ttu-id="427f9-322">Это поле указывает на начало физической области полезных данных этого пакета.</span><span class="sxs-lookup"><span data-stu-id="427f9-322">This field points to the start of the physical payload area of this packet.</span></span> <span data-ttu-id="427f9-323">Заголовок NX_PACKET не обязательно должен следовать непосредственно за ним, но для службы _ *_nx_packet_pool_create_*\* такая схема используется по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="427f9-323">It does not have to be immediately following the NX_PACKET header, but that is the default for the _ *_nx_packet_pool_create_*\* service.</span></span>|
|<span data-ttu-id="427f9-324">\***nx_packet_data_end** _</span><span class="sxs-lookup"><span data-stu-id="427f9-324">\***nx_packet_data_end** _</span></span>|<span data-ttu-id="427f9-325">Это поле указывает на конец физической области полезных данных этого пакета.</span><span class="sxs-lookup"><span data-stu-id="427f9-325">This field points to the end of the physical payload area of this packet.</span></span> <span data-ttu-id="427f9-326">Разница между этим полем и полем _nx_packet_data_start\* соответствует размеру полезных данных.</span><span class="sxs-lookup"><span data-stu-id="427f9-326">The difference between this field and the _nx_packet_data_start\* field represents the payload size.</span></span>|
|<span data-ttu-id="427f9-327">\***nx_packet_prepend_ptr** _</span><span class="sxs-lookup"><span data-stu-id="427f9-327">\***nx_packet_prepend_ptr** _</span></span>|<span data-ttu-id="427f9-328">Это поле указывает на расположение данных пакетов (заголовка протокола либо фактических данных), добавленных перед имеющимися данными пакета (если таковые имеются) в области полезных данных пакета.</span><span class="sxs-lookup"><span data-stu-id="427f9-328">This field points to the location of where packet data, either protocol header or actual data, is added in front of the existing packet data (if any) in the packet payload area.</span></span> <span data-ttu-id="427f9-329">Его значение должно быть большим или равным значению положения указателя _nx_packet_data_start\* и меньшим или равным значению указателя *nx_packet_append_ptr*.</span><span class="sxs-lookup"><span data-stu-id="427f9-329">It must be greater than or equal to the _nx_packet_data_start\* pointer location and less than or equal to the *nx_packet_append_ptr* pointer.</span></span>|
> [!CAUTION]
> <span data-ttu-id="427f9-330">*В целях повышения производительности NetX Duo предполагает, что когда пакет передается в службы NetX Duo для передачи, то указатель в начале указывает на длинный адрес, выровненный по словам.*</span><span class="sxs-lookup"><span data-stu-id="427f9-330">*For performance reasons, NetX Duo assumes that when the packet is passed into NetX Duo services for transmission, the prepend pointer points to long word aligned address.*</span></span>

| <span data-ttu-id="427f9-331">Заголовок пакета</span><span class="sxs-lookup"><span data-stu-id="427f9-331">Packet header</span></span> | <span data-ttu-id="427f9-332">Назначение</span><span class="sxs-lookup"><span data-stu-id="427f9-332">Purpose</span></span> |
|---|---|
|<span data-ttu-id="427f9-333">\***nx_packet_append_ptr** _</span><span class="sxs-lookup"><span data-stu-id="427f9-333">\***nx_packet_append_ptr** _</span></span>|<span data-ttu-id="427f9-334">Это поле указывает на конец данных, находящихся в данный момент в области полезных данных пакета.</span><span class="sxs-lookup"><span data-stu-id="427f9-334">This field points to the end of the data currently in the packet payload area.</span></span> <span data-ttu-id="427f9-335">Он должен находиться между расположением в памяти, на которое указывает _nx_packet_prepend_ptr\* и *nx_packet_data_end.*</span><span class="sxs-lookup"><span data-stu-id="427f9-335">It must be in between the memory location pointed to by _nx_packet_prepend_ptr\* and *nx_packet_data_end.*</span></span> <span data-ttu-id="427f9-336">Разница между этим полем и полем *nx_packet_prepend_ptr* соответствует количеству данных в этом пакете.</span><span class="sxs-lookup"><span data-stu-id="427f9-336">The difference between this field and the *nx_packet_prepend_ptr* field represents the amount of data in this packet.</span></span>|
|<span data-ttu-id="427f9-337">\***nx_packet_packet_pad** _</span><span class="sxs-lookup"><span data-stu-id="427f9-337">\***nx_packet_packet_pad** _</span></span>|<span data-ttu-id="427f9-338">Эти поля определяют длину заполнения (в 4-байтовых словах) для обеспечения требуемого выравнивания.</span><span class="sxs-lookup"><span data-stu-id="427f9-338">This fields defines the length of padding in 4-byte words to achieve the desired alignment requirement.</span></span> <span data-ttu-id="427f9-339">Это поле удаляется, если значение _*_NX_PACKET_HEADER_PAD_*_ не определено.</span><span class="sxs-lookup"><span data-stu-id="427f9-339">This field is removed if _*_NX_PACKET_HEADER_PAD_*_ is not defined.</span></span> <span data-ttu-id="427f9-340">Вместо определения _nx_packet_header_pad можно использовать _*_NX_PACKET_ALIGNMENT_*_.\*</span><span class="sxs-lookup"><span data-stu-id="427f9-340">Alternatively _*_NX_PACKET_ALIGNMENT_*_ can be used instead of defining _nx_packet_header_pad.\*</span></span>|

### <a name="packet-header-offsets"></a><span data-ttu-id="427f9-341">Отступ для заголовка пакета</span><span class="sxs-lookup"><span data-stu-id="427f9-341">Packet Header Offsets</span></span>

<span data-ttu-id="427f9-342">Чтобы обеспечить достаточно места для размещения заголовка определенного размера, необходимо определить этот размер.</span><span class="sxs-lookup"><span data-stu-id="427f9-342">Packet header size is defined to allow enough room  to accommodate the size of the header.</span></span> <span data-ttu-id="427f9-343">Служба ***nx_packet_allocate*** используется для выделения пакета и корректирует положение указателя, находящегося в начале в пакете, в соответствии с заданным типом пакета.</span><span class="sxs-lookup"><span data-stu-id="427f9-343">The ***nx_packet_allocate*** service is used to allocate a packet and adjusts the prepend pointer in the packet according to the type of packet specified.</span></span> <span data-ttu-id="427f9-344">Тип пакета указывает NetX Duo отступ, необходимый для вставки заголовка протокола (например, UDP, TCP или ICMP) перед данными протокола.</span><span class="sxs-lookup"><span data-stu-id="427f9-344">The packet type tells NetX Duo the offset required for inserting the protocol header (such as UDP, TCP, or ICMP) in front of the protocol data.</span></span>

<span data-ttu-id="427f9-345">Следующие типы определяются в NetX Duo, чтобы учитывать заголовок IP и заголовок физического уровня (Ethernet) в пакете.</span><span class="sxs-lookup"><span data-stu-id="427f9-345">The following types are defined in NetX Duo to take into account the IP header and physical layer (Ethernet) header in the packet.</span></span> <span data-ttu-id="427f9-346">В последнем случае предполагается, что отступ равен 16 байтам при условии 4-байтового выравнивания.</span><span class="sxs-lookup"><span data-stu-id="427f9-346">In the latter case, it is assumed to be 16 bytes taking the required 4-byte alignment into consideration.</span></span> <span data-ttu-id="427f9-347">Пакеты IPv4 по-прежнему определяются в NetX Duo, чтобы приложения выделяли пакеты для сетей IPv4.</span><span class="sxs-lookup"><span data-stu-id="427f9-347">IPv4 packets are still defined in NetX Duo for applications to allocate packets for IPv4 networks.</span></span> <span data-ttu-id="427f9-348">Обратите внимание, что если библиотека NetX Duo создана с включенным протоколом IPv6, универсальные типы пакетов (такие как NX_IP_PACKET) сопоставляются с версией IPv6.</span><span class="sxs-lookup"><span data-stu-id="427f9-348">Note that if the NetX Duo library is built with IPv6 enabled, the generic packet types (such as NX_IP_PACKET) are mapped to the IPv6 version.</span></span> <span data-ttu-id="427f9-349">Если библиотека NetX Duo создана без включенного протокола IPv6, универсальные типы пакетов сопоставляются с версией IPv4.</span><span class="sxs-lookup"><span data-stu-id="427f9-349">If the NetX Duo Library is built without IPv6 enabled, these generic packet types are mapped to the IPv4 version.</span></span>

<span data-ttu-id="427f9-350">В следующей таблице показаны символы, определенные при включенном протоколе IPv6.</span><span class="sxs-lookup"><span data-stu-id="427f9-350">The following table shows symbols defined with IPv6 enabled:</span></span>

|<span data-ttu-id="427f9-351">**Тип пакета**</span><span class="sxs-lookup"><span data-stu-id="427f9-351">**Packet Type**</span></span> |<span data-ttu-id="427f9-352">**Значение**</span><span class="sxs-lookup"><span data-stu-id="427f9-352">**Value**</span></span> |
|---|---|
|<span data-ttu-id="427f9-353">NX_IPv6_PACKET (NX_IP_PACKET)</span><span class="sxs-lookup"><span data-stu-id="427f9-353">NX_IPv6_PACKET (NX_IP_PACKET)</span></span> | <span data-ttu-id="427f9-354">0x38</span><span class="sxs-lookup"><span data-stu-id="427f9-354">0x38</span></span> |
|<span data-ttu-id="427f9-355">NX_UDPv6_PACKET (NX_UDP_PACKET)</span><span class="sxs-lookup"><span data-stu-id="427f9-355">NX_UDPv6_PACKET (NX_UDP_PACKET)</span></span> |<span data-ttu-id="427f9-356">0x40</span><span class="sxs-lookup"><span data-stu-id="427f9-356">0x40</span></span> |
|<span data-ttu-id="427f9-357">NX_TCPv6_PACKET (NX_TCP_PACKET)</span><span class="sxs-lookup"><span data-stu-id="427f9-357">NX_TCPv6_PACKET (NX_TCP_PACKET)</span></span> |<span data-ttu-id="427f9-358">0x4c</span><span class="sxs-lookup"><span data-stu-id="427f9-358">0x4c</span></span> |
|<span data-ttu-id="427f9-359">NX_IPv4_PACKET</span><span class="sxs-lookup"><span data-stu-id="427f9-359">NX_IPv4_PACKET</span></span> |<span data-ttu-id="427f9-360">0x24</span><span class="sxs-lookup"><span data-stu-id="427f9-360">0x24</span></span> |
|<span data-ttu-id="427f9-361">NX_IPv4_UDP_PACKET</span><span class="sxs-lookup"><span data-stu-id="427f9-361">NX_IPv4_UDP_PACKET</span></span> |<span data-ttu-id="427f9-362">0x2c</span><span class="sxs-lookup"><span data-stu-id="427f9-362">0x2c</span></span> |
|<span data-ttu-id="427f9-363">NX_IPv4_TCP_PACKET</span><span class="sxs-lookup"><span data-stu-id="427f9-363">NX_IPv4_TCP_PACKET</span></span> |<span data-ttu-id="427f9-364">0x38</span><span class="sxs-lookup"><span data-stu-id="427f9-364">0x38</span></span> |

<span data-ttu-id="427f9-365">В следующей таблице показаны символы, определенные при отключенном протоколе IPv6.</span><span class="sxs-lookup"><span data-stu-id="427f9-365">The following table shows symbols defined with IPv6 disabled:</span></span>

|<span data-ttu-id="427f9-366">**Тип пакета**</span><span class="sxs-lookup"><span data-stu-id="427f9-366">**Packet Type**</span></span> |<span data-ttu-id="427f9-367">**Значение**</span><span class="sxs-lookup"><span data-stu-id="427f9-367">**Value**</span></span> |
|---|---|
|<span data-ttu-id="427f9-368">NX_IPv4_PACKET (NX_IP_PACKET)</span><span class="sxs-lookup"><span data-stu-id="427f9-368">NX_IPv4_PACKET (NX_IP_PACKET)</span></span> |<span data-ttu-id="427f9-369">0x24</span><span class="sxs-lookup"><span data-stu-id="427f9-369">0x24</span></span> |
|<span data-ttu-id="427f9-370">NX_IPv4_UDP_PACKET (NX_UDP_PACKET)</span><span class="sxs-lookup"><span data-stu-id="427f9-370">NX_IPv4_UDP_PACKET (NX_UDP_PACKET)</span></span> |<span data-ttu-id="427f9-371">0x2c</span><span class="sxs-lookup"><span data-stu-id="427f9-371">0x2c</span></span> |
|<span data-ttu-id="427f9-372">NX_IPv4_TCP_PACKET (NX_TCP_PACKET)</span><span class="sxs-lookup"><span data-stu-id="427f9-372">NX_IPv4_TCP_PACKET (NX_TCP_PACKET)</span></span> |<span data-ttu-id="427f9-373">0x38</span><span class="sxs-lookup"><span data-stu-id="427f9-373">0x38</span></span> |

<span data-ttu-id="427f9-374">Обратите внимание, что эти значения изменятся при определенном *NX_IPSEC_ENABLE*.</span><span class="sxs-lookup"><span data-stu-id="427f9-374">Note that these values will change if *NX_IPSEC_ENABLE* is defined.</span></span> <span data-ttu-id="427f9-375">Дополнительные сведения о приложениях, использующих IPsec, см. в Руководстве пользователя IPsec NetX Duo.</span><span class="sxs-lookup"><span data-stu-id="427f9-375">For application using IPsec, refer to NetX Duo IPsec User Guide for more information.</span></span>

### <a name="pool-capacity"></a><span data-ttu-id="427f9-376">Емкость пула</span><span class="sxs-lookup"><span data-stu-id="427f9-376">Pool Capacity</span></span>

<span data-ttu-id="427f9-377">Количество пакетов в пуле пакетов — это функция размера полезных данных, а также общего числа байтов в области памяти, предоставляемой службе создания пула пакетов.</span><span class="sxs-lookup"><span data-stu-id="427f9-377">The number of packets in a packet pool is a function of the payload size and the total number of bytes in the memory area supplied to the packet pool create service.</span></span> <span data-ttu-id="427f9-378">Емкость пула вычисляется путем деления размера пакета (с учетом размера заголовка NX_PACKET, размера полезных данных и правильного выравнивания) на общее число байтов в указанной области памяти.</span><span class="sxs-lookup"><span data-stu-id="427f9-378">The capacity of the pool is calculated by dividing the packet size (including the size of the NX_PACKET header, the payload size, and proper alignment) into the total number of bytes in the supplied memory area.</span></span>

### <a name="payload-area-alignment"></a><span data-ttu-id="427f9-379">Выравнивание области полезных данных</span><span class="sxs-lookup"><span data-stu-id="427f9-379">Payload Area Alignment</span></span>

<span data-ttu-id="427f9-380">Структура пула пакетов в NetX Duo поддерживает нулевое копирование.</span><span class="sxs-lookup"><span data-stu-id="427f9-380">Packet pool design in NetX Duo supports zero-copy.</span></span> <span data-ttu-id="427f9-381">На уровне драйвера устройства драйвер может назначить область полезных данных непосредственно в дескрипторах буфера для приема данных.</span><span class="sxs-lookup"><span data-stu-id="427f9-381">At the device driver level, the driver is able to assign the payload area directly into buffer descriptors for data reception.</span></span> <span data-ttu-id="427f9-382">Иногда обработчику DMA или механизму синхронизации кэша требуется, чтобы начальный адрес области полезных данных имел определенное требование выравнивания.</span><span class="sxs-lookup"><span data-stu-id="427f9-382">Sometimes the DMA engine or the cache synchronization mechanism requires the starting address of the payload area to have a certain alignment requirement.</span></span> <span data-ttu-id="427f9-383">Этого можно достигнуть, определив требуемое требование выравнивания (в байтах) в ***NX_PACKET_ALIGNMENT***.</span><span class="sxs-lookup"><span data-stu-id="427f9-383">This can be achieved by defining the desired alignment requirement (in bytes) in ***NX_PACKET_ALIGNMENT***.</span></span> <span data-ttu-id="427f9-384">При создании пула пакетов начальный адрес области полезных данных будет согласовываться с этим значением.</span><span class="sxs-lookup"><span data-stu-id="427f9-384">When creating a packet pool, the starting address of the payload area will aligned to this value.</span></span> <span data-ttu-id="427f9-385">По умолчанию начальный адрес имеет значение в байтах, являющееся производным 4.</span><span class="sxs-lookup"><span data-stu-id="427f9-385">By default, starting address is 4-byte aligned.</span></span>

### <a name="thread-suspension"></a><span data-ttu-id="427f9-386">Приостановка потока</span><span class="sxs-lookup"><span data-stu-id="427f9-386">Thread Suspension</span></span>

<span data-ttu-id="427f9-387">Потоки приложения могут быть приостановлены при ожидании пакета из пустого пула.</span><span class="sxs-lookup"><span data-stu-id="427f9-387">Application threads can suspend while waiting for a packet from an empty pool.</span></span> <span data-ttu-id="427f9-388">Когда пакет возвращается в пул, приостановленный поток получает этот пакет и его выполнение возобновляется.</span><span class="sxs-lookup"><span data-stu-id="427f9-388">When a packet is returned to the pool, the suspended thread is given this packet and resumed.</span></span>

<span data-ttu-id="427f9-389">Если на одного пула пакетов приостанавливается несколько потоков, они возобновляются в том же порядке, в котором были приостановлены (FIFO).</span><span class="sxs-lookup"><span data-stu-id="427f9-389">If multiple threads are suspended on the same packet pool, they  resumed in the order they were suspended (FIFO).</span></span>

### <a name="pool-statistics-and-errors"></a><span data-ttu-id="427f9-390">Статистические показатели и ошибки пула</span><span class="sxs-lookup"><span data-stu-id="427f9-390">Pool Statistics and Errors</span></span>

<span data-ttu-id="427f9-391">Если этот параметр включен, программное обеспечение для управления пакетами NetX Duo отслеживает несколько статистических показателей и ошибок, которые могут быть полезны для приложения.</span><span class="sxs-lookup"><span data-stu-id="427f9-391">If enabled, the NetX Duo packet management software keeps track of several statistics and errors that may be useful to the application.</span></span> <span data-ttu-id="427f9-392">Для пулов пакетов поддерживаются следующие статистические показатели и отчеты об ошибках:</span><span class="sxs-lookup"><span data-stu-id="427f9-392">The following statistics and error reports are maintained for packet pools:</span></span>

- <span data-ttu-id="427f9-393">общее количество пакетов в пуле;</span><span class="sxs-lookup"><span data-stu-id="427f9-393">Total Packets in Pool</span></span>
- <span data-ttu-id="427f9-394">количество свободных пакетов в пуле;</span><span class="sxs-lookup"><span data-stu-id="427f9-394">Free Packets in Pool</span></span>
- <span data-ttu-id="427f9-395">всего выделений пакетов;</span><span class="sxs-lookup"><span data-stu-id="427f9-395">Total Packet Allocations</span></span>
- <span data-ttu-id="427f9-396">запросов на выделение из пустого пула;</span><span class="sxs-lookup"><span data-stu-id="427f9-396">Pool Empty Allocation Requests</span></span>
- <span data-ttu-id="427f9-397">приостановок выделения из пустого пула;</span><span class="sxs-lookup"><span data-stu-id="427f9-397">Pool Empty Allocation Suspensions</span></span>
- <span data-ttu-id="427f9-398">освобождений недопустимых пакетов.</span><span class="sxs-lookup"><span data-stu-id="427f9-398">Invalid Packet Releases</span></span>

<span data-ttu-id="427f9-399">Все эти статистические показатели и отчеты об ошибках, за исключением общего числа и количества свободных пакетов в пуле, встроены в библиотеку NetX Duo, если не определено значение \***NX_DISABLE_PACKET_INFO** _.</span><span class="sxs-lookup"><span data-stu-id="427f9-399">All of these statistics and error reports, except for total and free packet count in pool, are built into NetX Duo library unless \***NX_DISABLE_PACKET_INFO** _ is defined.</span></span> <span data-ttu-id="427f9-400">Эти данные предоставляет приложению служба _ \*_nx_packet_pool_info_get_\*\*.</span><span class="sxs-lookup"><span data-stu-id="427f9-400">This data is available to the application with the _ *_nx_packet_pool_info_get_*\* service.</span></span>

### <a name="packet-pool-control-block-nx_packet_pool"></a><span data-ttu-id="427f9-401">Блок управления пула пакетов NX_PACKET_POOL</span><span class="sxs-lookup"><span data-stu-id="427f9-401">Packet Pool Control Block NX_PACKET_POOL</span></span>

<span data-ttu-id="427f9-402">Характеристики каждого пула памяти пакетов находятся в его блоке управления.</span><span class="sxs-lookup"><span data-stu-id="427f9-402">The characteristics of each packet memory pool are found in its control block.</span></span> <span data-ttu-id="427f9-403">Он содержит полезную информацию, в том числе связанный список свободных пакетов, число свободных пакетов и размер полезных данных в пакетах этого пула.</span><span class="sxs-lookup"><span data-stu-id="427f9-403">It contains useful information such as the linked list of free packets, the number of free packets, and the payload size for packets in this pool.</span></span> <span data-ttu-id="427f9-404">Эта структура определена в файле ***nx_api.h***.</span><span class="sxs-lookup"><span data-stu-id="427f9-404">This structure is defined in the ***nx_api.h*** file.</span></span>

<span data-ttu-id="427f9-405">Блоки управления пула пакетов могут размещаться в любом месте в памяти, но чаще всего они определяются вне области какой-либо функции, благодаря чему функционируют как глобальная структура.</span><span class="sxs-lookup"><span data-stu-id="427f9-405">Packet pool control blocks can be located anywhere in memory, but it is most common to make the control block a global structure by defining it outside the scope of any function.</span></span>

## <a name="ipv4-protocol"></a><span data-ttu-id="427f9-406">Протокол IPv4</span><span class="sxs-lookup"><span data-stu-id="427f9-406">IPv4 Protocol</span></span>

<span data-ttu-id="427f9-407">Компонент протокола Интернета (IP) NetX Duo отвечает за отправку и получение пакетов IPv4 в Интернете.</span><span class="sxs-lookup"><span data-stu-id="427f9-407">The Internet Protocol (IP) component of NetX Duo is responsible for sending and receiving IPv4 packets on the Internet.</span></span> <span data-ttu-id="427f9-408">В NetX Duo этот компонент, в конечном итоге, отвечает за отправку и получение сообщений TCP, UDP, ICMP и IGMP с помощью базового драйвера сети.</span><span class="sxs-lookup"><span data-stu-id="427f9-408">In NetX Duo, it is the component ultimately responsible for sending and receiving TCP, UDP, ICMP, and IGMP messages, utilizing the underlying network driver.</span></span>

<span data-ttu-id="427f9-409">NetX Duo поддерживает как протокол IPv4 (RFC 791), так и протокол IPv6 (RFC 2460).</span><span class="sxs-lookup"><span data-stu-id="427f9-409">NetX Duo supports both IPv4 protocol (RFC 791) and IPv6 protocol (RFC 2460).</span></span> <span data-ttu-id="427f9-410">В этом разделе рассматривается IPv4.</span><span class="sxs-lookup"><span data-stu-id="427f9-410">This section discusses IPv4.</span></span> <span data-ttu-id="427f9-411">IPv6 рассматривается в следующем разделе.</span><span class="sxs-lookup"><span data-stu-id="427f9-411">IPv6 is discussed in the next section.</span></span>

### <a name="ipv4-addresses"></a><span data-ttu-id="427f9-412">IPv4-адреса</span><span class="sxs-lookup"><span data-stu-id="427f9-412">IPv4 Addresses</span></span>

<span data-ttu-id="427f9-413">Каждый узел в Интернете имеет уникальный 32-разрядный идентификатор, называемый IP-адресом.</span><span class="sxs-lookup"><span data-stu-id="427f9-413">Each host on the Internet has a unique 32-bit identifier called an IP address.</span></span> <span data-ttu-id="427f9-414">Существует пять классов адресов IPv4, которые продемонстрированы на рис. 4.</span><span class="sxs-lookup"><span data-stu-id="427f9-414">There are five classes of IPv4 addresses as described in Figure 4.</span></span> <span data-ttu-id="427f9-415">Ниже перечислены диапазоны этих пяти классов адресов IPv4.</span><span class="sxs-lookup"><span data-stu-id="427f9-415">The ranges of the five IPv4 address classes are as follows:</span></span>

|<span data-ttu-id="427f9-416">Class</span><span class="sxs-lookup"><span data-stu-id="427f9-416">Class</span></span>|<span data-ttu-id="427f9-417">Диапазон</span><span class="sxs-lookup"><span data-stu-id="427f9-417">Range</span></span>|
|---|---|
|<span data-ttu-id="427f9-418">Объект</span><span class="sxs-lookup"><span data-stu-id="427f9-418">A</span></span> |<span data-ttu-id="427f9-419">От 0.0.0.0 до 127.255.255.255</span><span class="sxs-lookup"><span data-stu-id="427f9-419">0.0.0.0 to 127.255.255.255</span></span>|
|<span data-ttu-id="427f9-420">B</span><span class="sxs-lookup"><span data-stu-id="427f9-420">B</span></span> |<span data-ttu-id="427f9-421">От 128.0.0.0 до 191.255.255.255</span><span class="sxs-lookup"><span data-stu-id="427f9-421">128.0.0.0 to 191.255.255.255</span></span>|
|<span data-ttu-id="427f9-422">C</span><span class="sxs-lookup"><span data-stu-id="427f9-422">C</span></span> |<span data-ttu-id="427f9-423">От 192.0.0.0 до 223.255.255.255</span><span class="sxs-lookup"><span data-stu-id="427f9-423">192.0.0.0 to 223.255.255.255</span></span>|
|<span data-ttu-id="427f9-424">D</span><span class="sxs-lookup"><span data-stu-id="427f9-424">D</span></span> |<span data-ttu-id="427f9-425">От 224.0.0.0 до 239.255.255.255</span><span class="sxs-lookup"><span data-stu-id="427f9-425">224.0.0.0 to 239.255.255.255</span></span>|
|<span data-ttu-id="427f9-426">E</span><span class="sxs-lookup"><span data-stu-id="427f9-426">E</span></span> |<span data-ttu-id="427f9-427">От 240.0.0.0 до 247.255.255.255</span><span class="sxs-lookup"><span data-stu-id="427f9-427">240.0.0.0 to 247.255.255.255</span></span>|

![Схема структуры адресов IPv4.](./media/user-guide/ipv4-address-structure.png)

### <a name="figure-4-ipv4-address-structure"></a><span data-ttu-id="427f9-429">РИС. 4.</span><span class="sxs-lookup"><span data-stu-id="427f9-429">FIGURE 4.</span></span> <span data-ttu-id="427f9-430">Структура адресов IPv4</span><span class="sxs-lookup"><span data-stu-id="427f9-430">IPv4 Address Structure</span></span>

<span data-ttu-id="427f9-431">Существует также три типа спецификаций адресов: *одноадресная*, *широковещательная* и *многоадресная рассылка*.</span><span class="sxs-lookup"><span data-stu-id="427f9-431">There are also three types of address specifications: *unicast*, *broadcast*, and *multicast*.</span></span> <span data-ttu-id="427f9-432">Адреса одноадресной рассылки — это адреса IPv4, которые определяют конкретный узел в Интернете.</span><span class="sxs-lookup"><span data-stu-id="427f9-432">Unicast addresses are those IPv4 addresses that identify a specific host on the Internet.</span></span> <span data-ttu-id="427f9-433">Они могут быть адресами IPv4 источника или места назначения.</span><span class="sxs-lookup"><span data-stu-id="427f9-433">Unicast addresses can be either a source or a destination IPv4 address.</span></span> <span data-ttu-id="427f9-434">Широковещательный адрес позволяет идентифицировать все узлы в определенной сети или подсети и может использоваться только в качестве адреса назначения.</span><span class="sxs-lookup"><span data-stu-id="427f9-434">A broadcast address identifies all hosts on a specific network or sub-network and can only be used as destination addresses.</span></span> <span data-ttu-id="427f9-435">Чтобы задать широковещательные адреса, необходимо заполнить ту их часть, которая представляет идентификатор узла, единицами.</span><span class="sxs-lookup"><span data-stu-id="427f9-435">Broadcast addresses are specified by having the host ID portion of the address set to ones.</span></span> <span data-ttu-id="427f9-436">Адреса многоадресной рассылки (класс D) задают динамическую группу узлов в Интернете.</span><span class="sxs-lookup"><span data-stu-id="427f9-436">Multicast addresses (Class D) specify a dynamic group of hosts on the Internet.</span></span> <span data-ttu-id="427f9-437">Члены группы многоадресной рассылки могут присоединяться к группе и выходить из нее по мере необходимости.</span><span class="sxs-lookup"><span data-stu-id="427f9-437">Members of the multicast group may join and leave whenever they wish.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="427f9-438">*Только протоколы без подключения, такие как UDP через IPv4, могут использовать широковещательную рассылку и ограниченные возможности широковещательной рассылки группы многоадресной рассылки.*</span><span class="sxs-lookup"><span data-stu-id="427f9-438">*Only connectionless protocols like UDP over IPv4 can utilize broadcast and the limited broadcast capability of the multicast group.*</span></span>

> [!IMPORTANT]
> <span data-ttu-id="427f9-439">\* Макрос *IP_ADDRESS* определен в \***nx_api.h** _.</span><span class="sxs-lookup"><span data-stu-id="427f9-439">\*The macro *IP_ADDRESS* is defined in \***nx_api.h** _.</span></span> <span data-ttu-id="427f9-440">Это позволяет легко определить адреса IPv4, используя запятые вместо точек.</span><span class="sxs-lookup"><span data-stu-id="427f9-440">It allows easy specification of IPv4 addresses using commas instead of a periods.</span></span> <span data-ttu-id="427f9-441">Например, IP_ADDRESS (128,0,0,0)\* задает первый адрес класса B, показанный на рис. 4\*.</span><span class="sxs-lookup"><span data-stu-id="427f9-441">For example, _IP_ADDRESS(128,0,0,0)\* specifies the first class B address shown in Figure 4.\*</span></span>

### <a name="ipv4-gateway-address"></a><span data-ttu-id="427f9-442">Адрес шлюза IPv4</span><span class="sxs-lookup"><span data-stu-id="427f9-442">IPv4 Gateway Address</span></span>

<span data-ttu-id="427f9-443">Сетевые шлюзы помогают узлам в своих сетях передавать пакеты, предназначенные для мест назначений, находящихся за пределами локального домена.</span><span class="sxs-lookup"><span data-stu-id="427f9-443">Network gateways assist hosts on their networks to relay packets destined to destinations outside the local domain.</span></span> <span data-ttu-id="427f9-444">У каждого узла имеются определенные сведения о следующем прыжке для отправки (к месту назначения либо на один из соседних узлов) либо возможность воспользоваться предварительно запрограммированной статической таблицей маршрутизации.</span><span class="sxs-lookup"><span data-stu-id="427f9-444">Each node has some knowledge of which next hop to send to, either the destination one of its neighbors, or through a pre-programmed static routing table.</span></span> <span data-ttu-id="427f9-445">Но если эти подходы не работают, узел должен переадресовать пакет шлюзу по умолчанию, который содержит больше сведений о маршрутизации пакета к месту назначения.</span><span class="sxs-lookup"><span data-stu-id="427f9-445">However if these approaches fail, the node should forward the packet to its default gateway which has better knowledge on how to route the packet to its destination.</span></span> <span data-ttu-id="427f9-446">Обратите внимание, что шлюз по умолчанию должен быть напрямую доступен через один из физических интерфейсов, подключенных к IP-экземпляру.</span><span class="sxs-lookup"><span data-stu-id="427f9-446">Note that the default gateway must be directly accessible through one of the physical interfaces attached to the IP instance.</span></span> <span data-ttu-id="427f9-447">Приложение вызывает \***nx_ip_gateway_address_set** _, чтобы настроить адрес IPv4 шлюза по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="427f9-447">The application calls \***nx_ip_gateway_address_set** _ to configure IPv4 default gateway address.</span></span> <span data-ttu-id="427f9-448">Используйте службу _*_nx_ip_gateway_address_get_*_ для получения текущих параметров шлюза IPv4.</span><span class="sxs-lookup"><span data-stu-id="427f9-448">Use the service _*_nx_ip_gateway_address_get_*_ to retrieve the current IPv4 gateway settings.</span></span> <span data-ttu-id="427f9-449">Для очистки параметра шлюза приложению следует использовать службу _ \*_nx_ip_gateway_address_clear_\*\*.</span><span class="sxs-lookup"><span data-stu-id="427f9-449">Application shall use the service _ *_nx_ip_gateway_address_clear_*\* to clear the gateway setting.</span></span>

### <a name="ipv4-header"></a><span data-ttu-id="427f9-450">Заголовок IPv4</span><span class="sxs-lookup"><span data-stu-id="427f9-450">IPv4 Header</span></span>

<span data-ttu-id="427f9-451">Для отправки любого пакета IPv4 через Интернет у него должен быть заголовок IPv4.</span><span class="sxs-lookup"><span data-stu-id="427f9-451">For any IPv4 packet to be sent on the Internet, it must have an IPv4 header.</span></span> <span data-ttu-id="427f9-452">Когда протоколы более высокого уровня (UDP, TCP, ICMP или IGMP) вызывают компонент IP для отправки пакета, модуль передачи пакетов IPv4 помещает заголовок IPv4 перед данными.</span><span class="sxs-lookup"><span data-stu-id="427f9-452">When higher-level protocols (UDP, TCP, ICMP, or IGMP) call the IP component to send a packet, the IPv4 transmit module places an IPv4 header in front of the data.</span></span> <span data-ttu-id="427f9-453">И наоборот, при получении IP-пакетов из сети компонент IP удаляет заголовок IPv4 из пакета перед его доставкой протоколам более высокого уровня.</span><span class="sxs-lookup"><span data-stu-id="427f9-453">Conversely, when IP packets are received from the network, the IP component removes the IPv4 header from the packet before delivery to the higher-level protocols.</span></span> <span data-ttu-id="427f9-454">На рис. 5 показан формат IP-заголовка.</span><span class="sxs-lookup"><span data-stu-id="427f9-454">Figure 5 shows the format of the IP header.</span></span>

![Формат заголовка IPv4](./media/user-guide/ipv4-header-format.png)

### <a name="figure-5-ipv4-header-format"></a><span data-ttu-id="427f9-456">РИС. 5.</span><span class="sxs-lookup"><span data-stu-id="427f9-456">FIGURE 5.</span></span> <span data-ttu-id="427f9-457">Формат заголовка IPv4</span><span class="sxs-lookup"><span data-stu-id="427f9-457">IPv4 Header Format</span></span>

> [!IMPORTANT]
> <span data-ttu-id="427f9-458">*Все заголовки в реализации TCP/IP должны быть представлены в формате **с обратным порядком байтов**. В этом формате наиболее значимый байт слова размещается по наименьшему байтовому адресу. Например, в IP-адресе поля "4-разрядное поле версии" и "4-разрядное поле длины заголовка" должны располагаться в первом байте заголовка.*</span><span class="sxs-lookup"><span data-stu-id="427f9-458">*All headers in the TCP/IP implementation are expected to be in **big endian** format. In this format, the most significant byte of the word resides at the lowest byte address. For example, the 4-bit version and the 4-bit header length of the IP header must be located on the first byte of the header.*</span></span>

<span data-ttu-id="427f9-459">Ниже приведены определения полей заголовка IPv4.</span><span class="sxs-lookup"><span data-stu-id="427f9-459">The fields of the IPv4 header are defined as follows:</span></span>

|<span data-ttu-id="427f9-460">Поле &nbsp;заголовка&nbsp; IPv4</span><span class="sxs-lookup"><span data-stu-id="427f9-460">IPv4&nbsp;Header&nbsp;Field</span></span> |<span data-ttu-id="427f9-461">Назначение</span><span class="sxs-lookup"><span data-stu-id="427f9-461">Purpose</span></span> |
|---|---|
|<span data-ttu-id="427f9-462">***4-разрядная версия***</span><span class="sxs-lookup"><span data-stu-id="427f9-462">***4-bit version***</span></span> |<span data-ttu-id="427f9-463">Это поле содержит версию IP-адреса, которую представляет этот заголовок.</span><span class="sxs-lookup"><span data-stu-id="427f9-463">This field contains the version of IP this header represents.</span></span> <span data-ttu-id="427f9-464">Для IP версии 4, которую поддерживает NetX Duo, значение этого поля равно 4.</span><span class="sxs-lookup"><span data-stu-id="427f9-464">For IP version 4, which is what NetX Duo supports, the value of this field is 4.</span></span> |
|<span data-ttu-id="427f9-465">***4-разрядная длина заголовка***</span><span class="sxs-lookup"><span data-stu-id="427f9-465">***4-bit header length***</span></span> |<span data-ttu-id="427f9-466">В этом поле указывается число 32-разрядных слов в IP-заголовке.</span><span class="sxs-lookup"><span data-stu-id="427f9-466">This field specifies the number of 32-bit words in the IP header.</span></span> <span data-ttu-id="427f9-467">Если необязательные слова отсутствуют, значение этого поля равно 5.</span><span class="sxs-lookup"><span data-stu-id="427f9-467">If no option words are present, the value for this field is 5.</span></span> |
|<span data-ttu-id="427f9-468">***8-разрядный тип службы (TOS)***</span><span class="sxs-lookup"><span data-stu-id="427f9-468">***8-bit type of service (TOS)***</span></span> |<span data-ttu-id="427f9-469">В этом поле указывается тип службы, запрошенной для этого IP-пакета.</span><span class="sxs-lookup"><span data-stu-id="427f9-469">This field specifies the type of service requested for this IP packet.</span></span> <span data-ttu-id="427f9-470">Допустимые запросы приведены ниже:</span><span class="sxs-lookup"><span data-stu-id="427f9-470">Valid requests are as follows:</span></span><br /><span data-ttu-id="427f9-471">— Обычная: 0x00</span><span class="sxs-lookup"><span data-stu-id="427f9-471">- Normal: 0x00</span></span> <br /><span data-ttu-id="427f9-472">— Минимальная задержка: 0x00</span><span class="sxs-lookup"><span data-stu-id="427f9-472">- Minimum Delay: 0x00</span></span><br /><span data-ttu-id="427f9-473">— Максимальный размер данных: 0x08</span><span class="sxs-lookup"><span data-stu-id="427f9-473">- Maximum Data: 0x08</span></span><br /><span data-ttu-id="427f9-474">— Максимальная надежность: 0x04</span><span class="sxs-lookup"><span data-stu-id="427f9-474">- Maximum Reliability: 0x04</span></span><br /><span data-ttu-id="427f9-475">— Минимальная стоимость: 0x02</span><span class="sxs-lookup"><span data-stu-id="427f9-475">- Minimum Cost: 0x02</span></span> |
|<span data-ttu-id="427f9-476">***16-разрядная общая длина***</span><span class="sxs-lookup"><span data-stu-id="427f9-476">***16-bit total length***</span></span> |<span data-ttu-id="427f9-477">Это поле содержит общую длину IP-датаграммы в байтах, включая IP-заголовок.</span><span class="sxs-lookup"><span data-stu-id="427f9-477">This field contains the total length of the IP datagram in bytes, including the IP header.</span></span> <span data-ttu-id="427f9-478">IP-датаграмма — это основная единица информации, передаваемая в Интернете по протоколу TCP/IP.</span><span class="sxs-lookup"><span data-stu-id="427f9-478">An IP datagram is the basic unit of information found on a TCP/IP Internet.</span></span> <span data-ttu-id="427f9-479">Помимо данных, она содержит адреса источника и назначения.</span><span class="sxs-lookup"><span data-stu-id="427f9-479">It contains a destination and source address in addition to data.</span></span> <span data-ttu-id="427f9-480">Поскольку это 16-разрядное поле, максимальный размер IP-датаграммы составляет 65 535 байт.</span><span class="sxs-lookup"><span data-stu-id="427f9-480">Because it is a 16-bit field, the maximum size of an IP datagram is 65,535 bytes.</span></span>|
|<span data-ttu-id="427f9-481">***16-разрядная идентификация***</span><span class="sxs-lookup"><span data-stu-id="427f9-481">***16-bit identification***</span></span> |<span data-ttu-id="427f9-482">Значение этого поля равно числу, используемому для уникальной идентификации каждой IP-датаграммы, отправленной с узла.</span><span class="sxs-lookup"><span data-stu-id="427f9-482">The field is a number used to uniquely identify each IP datagram sent from a host.</span></span> <span data-ttu-id="427f9-483">Это число обычно увеличивается после отправки IP-датаграммы.</span><span class="sxs-lookup"><span data-stu-id="427f9-483">This number is typically incremented after an IP datagram is sent.</span></span> <span data-ttu-id="427f9-484">Оно играет важную роль при сборке полученных фрагментов IP-пакетов.</span><span class="sxs-lookup"><span data-stu-id="427f9-484">It is especially useful in assembling received IP packet fragments.</span></span>|
|<span data-ttu-id="427f9-485">***3-разрядные флаги***</span><span class="sxs-lookup"><span data-stu-id="427f9-485">***3-bit flags***</span></span> |<span data-ttu-id="427f9-486">Это поле содержит сведения о фрагментации IP-пакетов.</span><span class="sxs-lookup"><span data-stu-id="427f9-486">This field contains IP fragmentation information.</span></span> <span data-ttu-id="427f9-487">14-й бит — это бит, требующий отсутствия фрагментации.</span><span class="sxs-lookup"><span data-stu-id="427f9-487">Bit 14 is the "don't fragment" bit.</span></span> <span data-ttu-id="427f9-488">Если этот бит задан, исходящая IP-датаграмма не фрагментируется.</span><span class="sxs-lookup"><span data-stu-id="427f9-488">If this bit is set, the outgoing IP datagram will not be fragmented.</span></span> <span data-ttu-id="427f9-489">13-й бит — это бит, требующий дополнительных фрагментов.</span><span class="sxs-lookup"><span data-stu-id="427f9-489">Bit 13 is the "more fragments" bit.</span></span> <span data-ttu-id="427f9-490">Если этот бит задан, то существуют дополнительные фрагменты.</span><span class="sxs-lookup"><span data-stu-id="427f9-490">If this bit is set, there are more fragments.</span></span> <span data-ttu-id="427f9-491">Если этот бит очищен, это последний фрагмент IP-пакета.</span><span class="sxs-lookup"><span data-stu-id="427f9-491">If this bit is clear, this is the last fragment of the IP packet.</span></span>|
|<span data-ttu-id="427f9-492">***13-разрядное смещение фрагмента***</span><span class="sxs-lookup"><span data-stu-id="427f9-492">***13-bit fragment offset***</span></span> |<span data-ttu-id="427f9-493">Это поле содержит верхние 13 бит смещения фрагмента.</span><span class="sxs-lookup"><span data-stu-id="427f9-493">This field contains the upper 13-bits of the fragment offset.</span></span> <span data-ttu-id="427f9-494">По этой причине смещения фрагментов разрешены только для 8-байтовых границ.</span><span class="sxs-lookup"><span data-stu-id="427f9-494">Because of this, fragment offsets are only allowed on 8-byte boundaries.</span></span> <span data-ttu-id="427f9-495">В первом фрагменте фрагментированной IP-датаграммы будет установлен бит наличия дополнительных фрагментов, а смещение будет равно 0.</span><span class="sxs-lookup"><span data-stu-id="427f9-495">The first fragment of a fragmented IP datagram will have the "more fragments" bit set and have an offset of 0.</span></span>|
|<span data-ttu-id="427f9-496">***8-разрядный срок жизни (TTL)***</span><span class="sxs-lookup"><span data-stu-id="427f9-496">***8-bit time to live (TTL)***</span></span> |<span data-ttu-id="427f9-497">Это поле содержит число маршрутизаторов, через которые может быть передана эта датаграмма, которое, по сути, ограничивает время ее существования.</span><span class="sxs-lookup"><span data-stu-id="427f9-497">This field contains the number of routers this datagram can pass, which basically limits the lifetime of the datagram.</span></span>|
|<span data-ttu-id="427f9-498">***8-разрядный протокол***</span><span class="sxs-lookup"><span data-stu-id="427f9-498">***8-bit protocol***</span></span>|<span data-ttu-id="427f9-499">В этом поле указывается, какой протокол использует IP-датаграмму.</span><span class="sxs-lookup"><span data-stu-id="427f9-499">This field specifies which protocol is using the IP datagram.</span></span> <span data-ttu-id="427f9-500">Ниже приведен список допустимых протоколов и их значения:</span><span class="sxs-lookup"><span data-stu-id="427f9-500">The following is a list of valid protocols and their values:</span></span><br /><span data-ttu-id="427f9-501">— ICMP: 0x01</span><span class="sxs-lookup"><span data-stu-id="427f9-501">- ICMP: 0x01</span></span> <br /><span data-ttu-id="427f9-502">— IGMP: 0x02</span><span class="sxs-lookup"><span data-stu-id="427f9-502">- IGMP: 0x02</span></span><br /><span data-ttu-id="427f9-503">— TCP: 0X06</span><span class="sxs-lookup"><span data-stu-id="427f9-503">- TCP: 0X06</span></span><br /><span data-ttu-id="427f9-504">— UDP: 0X11</span><span class="sxs-lookup"><span data-stu-id="427f9-504">- UDP: 0X11</span></span> |
|<span data-ttu-id="427f9-505">***16-разрядная контрольная сумма***</span><span class="sxs-lookup"><span data-stu-id="427f9-505">***16-bit checksum***</span></span> |<span data-ttu-id="427f9-506">Это поле содержит 16-разрядное значение контрольной суммы, охватывающее только IP-заголовок.</span><span class="sxs-lookup"><span data-stu-id="427f9-506">This field contains the 16-bit checksum that covers the IP header only.</span></span> <span data-ttu-id="427f9-507">В протоколах более высокого уровня имеются дополнительные контрольные суммы, охватывающие полезные данные IP.</span><span class="sxs-lookup"><span data-stu-id="427f9-507">There are additional checksums in the higher level protocols that cover the IP payload.</span></span> |
|<span data-ttu-id="427f9-508">***32-разрядный IP-адрес источника***</span><span class="sxs-lookup"><span data-stu-id="427f9-508">***32-bit source IP address***</span></span> |<span data-ttu-id="427f9-509">Это поле содержит IP-адрес отправителя и всегда является адресом узла.</span><span class="sxs-lookup"><span data-stu-id="427f9-509">This field contains the IP address of the sender and is always a host address.</span></span> |
|<span data-ttu-id="427f9-510">***32-разрядный IP-адрес назначения***</span><span class="sxs-lookup"><span data-stu-id="427f9-510">***32-bit destination IP address***</span></span> |<span data-ttu-id="427f9-511">Это поле содержит IP-адрес одного или нескольких (если это широковещательный адрес или адрес многоадресной рассылки) получателей.</span><span class="sxs-lookup"><span data-stu-id="427f9-511">This field contains the IP address of the receiver or receivers if the address is a broadcast or multicast address.</span></span> |

### <a name="creating-ip-instances"></a><span data-ttu-id="427f9-512">Создание IP-экземпляров</span><span class="sxs-lookup"><span data-stu-id="427f9-512">Creating IP Instances</span></span>

<span data-ttu-id="427f9-513">IP-экземпляры создаются во время инициализации или выполнения потоками приложения.</span><span class="sxs-lookup"><span data-stu-id="427f9-513">IP instances are created either during initialization or during runtime by application threads.</span></span> <span data-ttu-id="427f9-514">Начальный адрес IPv4, маска сети, пул пакетов по умолчанию, драйвер носителя, а также память и приоритет внутреннего потока IP определяются службой ***nx_ip_create***, даже если в приложении планируется использовать только сети IPv6.</span><span class="sxs-lookup"><span data-stu-id="427f9-514">The initial IPv4 address, network mask, default packet pool, media driver, and memory and priority of the internal IP thread are defined by the ***nx_ip_create*** service even if the application intends to use IPv6 networks only.</span></span> <span data-ttu-id="427f9-515">Если приложение инициализирует IP-экземпляр с адресом IPv4, значение которого недопустимо (0.0.0.0), предполагается, что адрес интерфейса будет позже разрешен вручную, с помощью RARP, либо через DHCP или аналогичный протокол.</span><span class="sxs-lookup"><span data-stu-id="427f9-515">If the application initializes the IP instance with its IPv4 address set to an invalid address(0.0.0.0), it is assumed that the interface address is going to resolved by manual configuration later, via RARP, or through DHCP or similar protocols.</span></span>

<span data-ttu-id="427f9-516">Для систем с несколькими сетевыми интерфейсами основной интерфейс назначается при вызове \***nx_ip_create** _.</span><span class="sxs-lookup"><span data-stu-id="427f9-516">For systems with multiple network interfaces, the primary interface is designated when calling \***nx_ip_create** _.</span></span> <span data-ttu-id="427f9-517">Все дополнительные интерфейсы можно подключить к одному и тому же IP-экземпляру, вызвав _\*_nx_ip_interface_attach_\*\*.</span><span class="sxs-lookup"><span data-stu-id="427f9-517">Each additional interface can be attached to the same IP instance by calling _\*_nx_ip_interface_attach_\*\*.</span></span> <span data-ttu-id="427f9-518">Эта служба хранит сведения о сетевом интерфейсе (например, IP-адрес, маску сети) в блоке управления взаимодействием и связывает экземпляр драйвера с блоком управления взаимодействием в IP-экземпляре.</span><span class="sxs-lookup"><span data-stu-id="427f9-518">This service stores information about the network interface (such as IP address, network mask) in the interface control block, and associates the driver instance with the interface control block in the IP instance.</span></span> <span data-ttu-id="427f9-519">Когда драйвер получает пакет данных, ему необходимо сохранить сведения об интерфейсе в структуре NX_PACKET перед отправкой в логику приема IP-пакетов.</span><span class="sxs-lookup"><span data-stu-id="427f9-519">As the driver receives a data packet, it needs to store the interface information in the NX_PACKET structure before forwarding it to the IP receive logic.</span></span> <span data-ttu-id="427f9-520">Обратите внимание, что перед присоединением интерфейсов необходимо сначала создать IP-экземпляр.</span><span class="sxs-lookup"><span data-stu-id="427f9-520">Note an IP instance must already be created before attaching any interfaces.</span></span>

<span data-ttu-id="427f9-521">Службы IPv6 не запускаются после вызова \***nx_ip_create** _.</span><span class="sxs-lookup"><span data-stu-id="427f9-521">IPv6 services are not started after calling \***nx_ip_create** _.</span></span> <span data-ttu-id="427f9-522">Приложения, желающие использовать службы IPv6, должны вызывать службу _ *_nx_ipv6_enable_*\* для запуска протокола IPv6.</span><span class="sxs-lookup"><span data-stu-id="427f9-522">Applications wishing to use IPv6 services must call the service _ *_nx_ipv6_enable_*\* to start IPv6.</span></span>

<span data-ttu-id="427f9-523">В сети IPv6 каждый интерфейс в экземпляре IP может иметь несколько глобальных адресов IPv6.</span><span class="sxs-lookup"><span data-stu-id="427f9-523">On the IPv6 network, each interface in an IP instance may have multiple IPv6 global addresses.</span></span> <span data-ttu-id="427f9-524">Кроме использования протокола DHCPv6 для назначения адресов IPv6, устройство может также использовать автонастройку адресов без отслеживания состояния.</span><span class="sxs-lookup"><span data-stu-id="427f9-524">In addition to using DHCPv6 for IPv6 address assignment, a device may also use Stateless Address Autoconfiguration.</span></span> <span data-ttu-id="427f9-525">Дополнительные сведения см. в разделах "Блок управления IP" и "Разрешение адресов IPv6" далее в этой главе.</span><span class="sxs-lookup"><span data-stu-id="427f9-525">More information is available in the "IP Control Block" and "IPv6 Address Resolution" sections later in this chapter.</span></span>

### <a name="ip-send"></a><span data-ttu-id="427f9-526">Отправка IP-пакетов</span><span class="sxs-lookup"><span data-stu-id="427f9-526">IP Send</span></span>

<span data-ttu-id="427f9-527">Обработка IP-отправки в NetX Duo очень проста.</span><span class="sxs-lookup"><span data-stu-id="427f9-527">The IP send processing in NetX Duo is very streamlined.</span></span> <span data-ttu-id="427f9-528">Указатель в начале пакета перемещается назад для размещения IP-заголовка.</span><span class="sxs-lookup"><span data-stu-id="427f9-528">The prepend pointer in the packet is moved backwards to accommodate the IP header.</span></span> <span data-ttu-id="427f9-529">Заголовок IP-адреса готов (содержит все параметры, заданные на уровне вызывающего протокола), контрольная сумма IP вычисляется в строке (только для пакетов IPv4), а пакет отправляется в соответствующий драйвер сети.</span><span class="sxs-lookup"><span data-stu-id="427f9-529">The IP header is completed (with all the options specified by the calling protocol layer), the IP checksum is computed in-line (for IPv4 packets only), and the packet is dispatched to the associated network driver.</span></span> <span data-ttu-id="427f9-530">Кроме того, исходящая фрагментация также координируется в рамках обработки отправки IP-пакетов.</span><span class="sxs-lookup"><span data-stu-id="427f9-530">In addition, outgoing fragmentation is also coordinated from within the IP send processing.</span></span>

<span data-ttu-id="427f9-531">Для IPv4 NetX Duo инициирует запросы ARP, если для целевого IP-адреса требуется физическое сопоставление.</span><span class="sxs-lookup"><span data-stu-id="427f9-531">For IPv4, NetX Duo initiates ARP requests if physical mapping is needed for the destination IP address.</span></span> <span data-ttu-id="427f9-532">IPv6 использует обнаружение соседей для сопоставления адресов IPv6 с физическими адресами.</span><span class="sxs-lookup"><span data-stu-id="427f9-532">IPv6 uses Neighbor Discovery for IPv6-address-tophysical-address mapping.</span></span>

> [!NOTE]
> <span data-ttu-id="427f9-533">*Для подключений по протоколу IPv4 пакеты, требующие разрешения IP-адресов (т. е. физического сопоставления), помещаются в очередь ARP до тех пор, пока число пакетов в очереди не превысит глубину очереди ARP (определяется символом **NX_ARP_MAX_QUEUE_DEPTH**). Если глубина очереди достигнута, NetX Duo удалит самый старый пакет в очереди и продолжит ожидание разрешения адреса для оставшихся пакетов, поставленных в очередь. С другой стороны, если разрешение записи ARP не выполнено, ожидающие пакеты в записи ARP освобождаются после истечения времени ожидания записи ARP.*</span><span class="sxs-lookup"><span data-stu-id="427f9-533">*For IPv4 connectivity, packets that require IP address resolution (i.e., physical mapping) are enqueued on the ARP queue until the number of packets queued exceeds the ARP queue depth (defined by the symbol **NX_ARP_MAX_QUEUE_DEPTH**). If the queue depth is reached, NetX Duo will remove the oldest packet on the queue and continue waiting for address resolution for the remaining packets enqueued. On the other hand, if an ARP entry is not resolved, the pending packets on the ARP entry are released upon ARP entry timeout.*</span></span>

<span data-ttu-id="427f9-534">Для систем с несколькими сетевыми интерфейсами NetX Duo выбирает интерфейс на основе IP-адреса назначения.</span><span class="sxs-lookup"><span data-stu-id="427f9-534">For systems with multiple network interfaces, NetX Duo chooses an interface based on the destination IP address.</span></span> <span data-ttu-id="427f9-535">В процессе выбора применяется следующая процедура.</span><span class="sxs-lookup"><span data-stu-id="427f9-535">The following procedure applies to the selection process:</span></span>

1. <span data-ttu-id="427f9-536">Если отправитель указывает исходящий интерфейс и интерфейс является допустимым, используйте этот интерфейс.</span><span class="sxs-lookup"><span data-stu-id="427f9-536">If the sender specifies an outgoing interface and the interface is valid, use that interface.</span></span>
2. <span data-ttu-id="427f9-537">Если адрес назначения является широковещательной или многоадресной рассылкой по протоколу IPv4, используется первый включенный физический интерфейс.</span><span class="sxs-lookup"><span data-stu-id="427f9-537">If a destination address is IPv4 broadcast or multicast, the first enabled physical interface is used.</span></span>
3. <span data-ttu-id="427f9-538">Если адрес назначения присутствует в таблице статической маршрутизации, используется интерфейс, связанный со шлюзом.</span><span class="sxs-lookup"><span data-stu-id="427f9-538">If the destination address is found in the static routing table, the interface associated with the gateway is used.</span></span>
4. <span data-ttu-id="427f9-539">Если назначением является адрес с прямым подключением, используется интерфейс прямого подключения.</span><span class="sxs-lookup"><span data-stu-id="427f9-539">If the destination is on-link, the on-link interface is used.</span></span>
5. <span data-ttu-id="427f9-540">Если адрес назначения является адресом локальной связи (169.254.0.0/16), то используется первый допустимый интерфейс.</span><span class="sxs-lookup"><span data-stu-id="427f9-540">If the destination address is a link-local address (169.254.0.0/16), the first valid interface is used.</span></span>
6. <span data-ttu-id="427f9-541">Если шлюз по умолчанию настроен, для передачи пакета используется интерфейс, связанный со шлюзом по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="427f9-541">If the default gateway is configured, use the interface associated with the default gateway to transmit the packet.</span></span>
7. <span data-ttu-id="427f9-542">Наконец, если один из допустимых IP-адресов интерфейса является адресом локальной связи (169.254.0.0/16), этот интерфейс используется в качестве исходного адреса для передачи.</span><span class="sxs-lookup"><span data-stu-id="427f9-542">Finally, if one of the valid interface IP address is link-local address (169.254.0.0/16), this interface is used as source address for the transmission.</span></span>
8. <span data-ttu-id="427f9-543">Выходной пакет удаляется, если все вышеуказанные сбои завершились ошибкой.</span><span class="sxs-lookup"><span data-stu-id="427f9-543">The output packet is dropped if all above fails.</span></span>

### <a name="ip-receive"></a><span data-ttu-id="427f9-544">Получение IP-пакетов</span><span class="sxs-lookup"><span data-stu-id="427f9-544">IP Receive</span></span>

<span data-ttu-id="427f9-545">Обработка получения IP-пакетов вызывается либо из сетевого драйвера, либо из внутреннего IP-потока (для обработки пакетов в очереди пакетов с отложенным получением).</span><span class="sxs-lookup"><span data-stu-id="427f9-545">The IP receive processing is either called from the network driver or the internal IP thread (for processing packets on the deferred received packet queue).</span></span> <span data-ttu-id="427f9-546">При обработке получения IP-пакетов проверяется поле протокола и предпринимается попытка отправить пакет в соответствующий компонент протокола.</span><span class="sxs-lookup"><span data-stu-id="427f9-546">The IP receive processing examines the protocol field and attempts to dispatch the packet to the proper protocol component.</span></span> <span data-ttu-id="427f9-547">Перед тем как пакет будет фактически отправлен, IP-заголовок удаляется путем перемещения расположенного в начале пакета указателя за IP-заголовок.</span><span class="sxs-lookup"><span data-stu-id="427f9-547">Before the packet is actually dispatched, the IP header is removed by advancing the prepend pointer past the IP header.</span></span>

<span data-ttu-id="427f9-548">При обработке получения IP-пакетов также обнаруживаются фрагментированные IP-пакеты и, если включена фрагментация, выполняются необходимые действия для их сборки.</span><span class="sxs-lookup"><span data-stu-id="427f9-548">IP receive processing also detects fragmented IP packets and performs the necessary steps to reassemble them if fragmentation is enabled.</span></span> <span data-ttu-id="427f9-549">Если требуется фрагментация, но она не включена, пакет удаляется.</span><span class="sxs-lookup"><span data-stu-id="427f9-549">If fragmentation is needed but not enabled, the packet is dropped.</span></span>

<span data-ttu-id="427f9-550">NetX Duo определяет соответствующий сетевой интерфейс на основе интерфейса, указанного в пакете.</span><span class="sxs-lookup"><span data-stu-id="427f9-550">NetX Duo determines the appropriate network interface based on the interface specified in the packet.</span></span> <span data-ttu-id="427f9-551">Если интерфейс пакета имеет значение NULL, по умолчанию NetX Duo будет использовать основной интерфейс.</span><span class="sxs-lookup"><span data-stu-id="427f9-551">If the packet interface is NULL, NetX Duo defaults to the primary interface.</span></span> <span data-ttu-id="427f9-552">Это делается для обеспечения совместимости с устаревшими драйверами Ethernet NetX Duo.</span><span class="sxs-lookup"><span data-stu-id="427f9-552">This is done to guarantee compatibility with legacy NetX Duo Ethernet drivers.</span></span>

### <a name="raw-ip-send"></a><span data-ttu-id="427f9-553">Отправка необработанных IP-пакетов</span><span class="sxs-lookup"><span data-stu-id="427f9-553">Raw IP Send</span></span>

<span data-ttu-id="427f9-554">Необработанный IP-пакет — это IP-кадр, который содержит полезные данные протокола верхнего уровня, которые не поддерживаются напрямую (и не обрабатываются) NetX Duo.</span><span class="sxs-lookup"><span data-stu-id="427f9-554">A raw IP packet is an IP frame that contains upper layer protocol payload not directly supported (and processed) by NetX Duo.</span></span> <span data-ttu-id="427f9-555">Необработанный пакет позволяет разработчикам определять собственные приложения на основе протокола IP.</span><span class="sxs-lookup"><span data-stu-id="427f9-555">A raw packet allows developers to define their own IP-based applications.</span></span> <span data-ttu-id="427f9-556">Приложение может отправлять необработанные IP-пакеты напрямую с помощью службы ***nxd_ip_raw_packet_send** _, если в службе _*_nx_ip_raw_packet_enabled_\*_ включена их обработка.</span><span class="sxs-lookup"><span data-stu-id="427f9-556">An application may send raw IP packets directly using the ***nxd_ip_raw_packet_send** _ service if raw IP packet processing has been enabled with the _*_nx_ip_raw_packet_enabled_\*_ service.</span></span> <span data-ttu-id="427f9-557">При передаче одноадресного пакета в сети IPv6 NetX Duo автоматически определяет оптимальный исходный IPv6-адрес, который будет использоваться для отправки пакетов, на основе адреса назначения.</span><span class="sxs-lookup"><span data-stu-id="427f9-557">When transmitting a unicast packet on an IPv6 network, NetX Duo automatically determines the best source IPv6 address to use to send the packets out on, based on the destination address.</span></span> <span data-ttu-id="427f9-558">Однако если адрес назначения является адресом многоадресной рассылки (или широковещательной рассылки для IPv4), NetX Duo по умолчанию будет использовать первый (основной) интерфейс.</span><span class="sxs-lookup"><span data-stu-id="427f9-558">If the destination address is a multicast (or broadcast for IPv4) address, however, NetX Duo will default to the first (primary) interface.</span></span> <span data-ttu-id="427f9-559">Таким образом, чтобы отправить такие пакеты во вторичные интерфейсы, приложение должно воспользоваться службой _ \*_nx_ip_raw_packet_source_send_\*\*, чтобы задать исходный адрес, используемый для исходящего пакета.</span><span class="sxs-lookup"><span data-stu-id="427f9-559">Therefore, to send such packets out on secondary interfaces, the application must use the _ *_nx_ip_raw_packet_source_send_*\* service to specify the source address to use for the outgoing packet.</span></span>

### <a name="raw-ip-receive"></a><span data-ttu-id="427f9-560">Получение необработанных IP-пакетов</span><span class="sxs-lookup"><span data-stu-id="427f9-560">Raw IP Receive</span></span>

<span data-ttu-id="427f9-561">Если включена обработка необработанных IP-пакетов, приложение может получать необработанные IP-пакеты с помощью службы \***nx_ip_raw_packet_receive** _.</span><span class="sxs-lookup"><span data-stu-id="427f9-561">If raw IP packet processing is enabled, the application may receive raw IP packets through the \***nx_ip_raw_packet_receive** _ service.</span></span> <span data-ttu-id="427f9-562">Все входящие пакеты обрабатываются в соответствии с протоколом, указанным в IP-заголовке.</span><span class="sxs-lookup"><span data-stu-id="427f9-562">All incoming packets are processed according to the protocol specified in the IP header.</span></span> <span data-ttu-id="427f9-563">Если протокол указывает UDP, TCP, IGMP или ICMP, NetX Duo обработает пакет, используя соответствующий обработчик для типа протокола пакетов.</span><span class="sxs-lookup"><span data-stu-id="427f9-563">If the protocol specifies UDP, TCP, IGMP or ICMP, NetX Duo will process the packet using the appropriate handler for the packet protocol type.</span></span> <span data-ttu-id="427f9-564">Если протокол не является одним из этих протоколов и включен режим получения необработанных IP-пакетов, входящий пакет будет помещен в очередь необработанных пакетов, ожидая, когда приложение получит его через _службу \*_nx_ip_raw_packet_receive_\*\*. Кроме того, потоки приложений могут быть приостановлены с необязательным временем ожидания при ожидании необработанного IP-пакета. Количество пакетов, которые могут быть поставлены в очередь необработанных пакетов, ограничено. Максимальное значение определяется в \***NX_IP_RAW_MAX_QUEUE_DEPTH**_, значение по умолчанию — 20.</span><span class="sxs-lookup"><span data-stu-id="427f9-564">If the protocol is not one of these protocols, and raw IP receive is enabled, the incoming packet will be put into the raw packet queue waiting for the application to receive it via the _*_nx_ip_raw_packet_receive_*\* service. In addition, application threads may suspend with an optional timeout while waiting for a raw IP packet. The number of packets that can be queued on the raw packet queue is limited. The maximum value is defined in \***NX_IP_RAW_MAX_QUEUE_DEPTH**_, whose default value is 20.</span></span> <span data-ttu-id="427f9-565">Приложение может изменить максимальное значение, вызвав службу _ \*_nx_ip_raw_receive_queue_max_set_\*\*.</span><span class="sxs-lookup"><span data-stu-id="427f9-565">An application may change the maximum value by calling the _ *_nx_ip_raw_receive_queue_max_set_*\* service.</span></span>

<span data-ttu-id="427f9-566">Кроме того, библиотеку NetX Duo можно создать с помощью \*\**NX_ENABLE_IP_RAW_PACKET_FILTER *.**</span><span class="sxs-lookup"><span data-stu-id="427f9-566">Alternatively, the NetX Duo library may be built with \***NX_ENABLE_IP_RAW_PACKET_FILTER\*.**</span></span> <span data-ttu-id="427f9-567">В этом режиме работы приложение предоставляет функцию обратного вызова, которая вызывается каждый раз при получении пакета с необработанным типом протокола.</span><span class="sxs-lookup"><span data-stu-id="427f9-567">In this mode of operation, the application provides a callback function that is invoked every time a packet with an unhandled protocol type is received.</span></span> <span data-ttu-id="427f9-568">Логика приема IP-адресов пересылает пакет в определенную пользователем подпрограмму фильтра получения необработанных пакетов.</span><span class="sxs-lookup"><span data-stu-id="427f9-568">The IP receive logic forwards the packet to the user-defined raw packet receive filter routine.</span></span> <span data-ttu-id="427f9-569">Подпрограмма фильтра определяет, необходимо ли сохранить необработанный пакет для будущего процесса.</span><span class="sxs-lookup"><span data-stu-id="427f9-569">The filter routine decides whether or not to keep the raw packet for future process.</span></span> <span data-ttu-id="427f9-570">Возвращаемое значение из подпрограммы обратного вызова указывает, был ли пакет обработан фильтром получения необработанных пакетов.</span><span class="sxs-lookup"><span data-stu-id="427f9-570">The return value from the callback routine indicates whether the packet has been processed by the raw packet receive filter.</span></span> <span data-ttu-id="427f9-571">Если пакет обрабатывается функцией обратного вызова, пакет должен быть освобожден после завершения работы приложения с пакетом.</span><span class="sxs-lookup"><span data-stu-id="427f9-571">If the packet is processed by the callback function, the packet should be released after the application is done with the packet.</span></span> <span data-ttu-id="427f9-572">В ином случае NetX Duo отвечает за освобождение пакета.</span><span class="sxs-lookup"><span data-stu-id="427f9-572">Otherwise, NetX Duo is responsible for releasing the packet.</span></span> <span data-ttu-id="427f9-573">Дополнительные сведения об использовании функции фильтрации необработанных пакетов см. в **_nx_ip_raw_packet_filter_set_**.</span><span class="sxs-lookup"><span data-stu-id="427f9-573">Refer to the **_nx_ip_raw_packet_filter_set_** for more information on how to use the raw packet filter function.</span></span>

> [!NOTE]
> <span data-ttu-id="427f9-574">\* Функция-оболочка BSD для NetX Duo использует функцию фильтрации необработанных пакетов для обработки необработанных сокетов BSD.</span><span class="sxs-lookup"><span data-stu-id="427f9-574">\*The BSD wrapper function for NetX Duo relies on the raw packet filter function to handle BSD raw sockets.</span></span> <span data-ttu-id="427f9-575">Таким образом, для поддержки необработанного сокета в оболочке BSD библиотека NetX Duo должна быть построена с помощью ***NX_ENABLE_IP_RAW_PACKET_FILTER** _, а приложение не должно использовать _*_nx_ip_raw_packet_filter_set_\*_ для установки собственного фильтра необработанных пакетов functions._</span><span class="sxs-lookup"><span data-stu-id="427f9-575">Therefore, to support raw socket in the BSD wrapper, the NetX Duo library must be built with ***NX_ENABLE_IP_RAW_PACKET_FILTER** _ defined, and the application should not use the _*_nx_ip_raw_packet_filter_set_\*_ to install its own raw packet filter functions._</span></span>

### <a name="default-packet-pool"></a><span data-ttu-id="427f9-576">Пул пакетов по умолчанию</span><span class="sxs-lookup"><span data-stu-id="427f9-576">Default Packet Pool</span></span>

<span data-ttu-id="427f9-577">Каждый IP-экземпляр получает во время создания пул пакетов по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="427f9-577">Each IP instance is given a default packet pool during creation.</span></span> <span data-ttu-id="427f9-578">Этот пул пакетов используется, чтобы выделять пакеты для ARP, RARP, ICMP, IGMP, различных пакетов управления TCP (SYN, ACK и т. д.), обнаружения соседей, маршрутизатора и повторяющихся адресов.</span><span class="sxs-lookup"><span data-stu-id="427f9-578">This packet pool is used to allocate packets for ARP, RARP, ICMP, IGMP, various TCP control packets (SYN, ACK, and so on), Neighbor Discovery, Router Discovery, and Duplicate Address Detection.</span></span> <span data-ttu-id="427f9-579">Если пул пакетов по умолчанию пуст, когда NetX Duo должно выделить пакет, NetX Duo может прервать эту конкретную операцию и по возможности возвратит сообщение об ошибке.</span><span class="sxs-lookup"><span data-stu-id="427f9-579">If the default packet pool is empty when NetX Duo needs to allocate a packet, NetX Duo may have to abort the particular operation, and will return an error message if possible.</span></span>

### <a name="ip-helper-thread"></a><span data-ttu-id="427f9-580">Вспомогательный IP-поток</span><span class="sxs-lookup"><span data-stu-id="427f9-580">IP Helper Thread</span></span>

<span data-ttu-id="427f9-581">Каждый IP-экземпляр имеет вспомогательный поток.</span><span class="sxs-lookup"><span data-stu-id="427f9-581">Each IP instance has a helper thread.</span></span> <span data-ttu-id="427f9-582">Этот поток отвечает за выполнение обработки всех отложенных пакетов и периодическую обработку.</span><span class="sxs-lookup"><span data-stu-id="427f9-582">This thread is responsible for handling all deferred packet processing and all periodic processing.</span></span> <span data-ttu-id="427f9-583">Вспомогательный поток IP-адресов создается в ***nx_ip_create.*** Именно там потоку даются его стек и приоритет.</span><span class="sxs-lookup"><span data-stu-id="427f9-583">The IP helper thread is created in ***nx_ip_create.*** This is where the thread is given its stack and priority.</span></span> <span data-ttu-id="427f9-584">Обратите внимание, что первая обработка во вспомогательном IP-потоке заключается в завершении инициализации сетевого драйвера, связанного со службой создания IP-экземпляра.</span><span class="sxs-lookup"><span data-stu-id="427f9-584">Note that the first processing in the IP helper thread is to finish the network driver initialization associated with the IP create service.</span></span> <span data-ttu-id="427f9-585">После завершения инициализации сетевого драйвера вспомогательный поток запускает бесконечный цикл обработки пакетов и периодических запросов.</span><span class="sxs-lookup"><span data-stu-id="427f9-585">After the network driver initialization is complete, the helper thread starts an endless loop to process packet and periodic requests.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="427f9-586">*Если во вспомогательном IP-потоке наблюдается необъяснимое поведение, первым этапом отладки будет увеличение размера стека во время работы службы создания IP-экземпляра. Если стек слишком мал, вспомогательный IP-поток может перезаписывать память, что может вызвать необычные проблемы.*</span><span class="sxs-lookup"><span data-stu-id="427f9-586">*If unexplained behavior is seen within the IP helper thread, increasing its stack size during the IP create service is the first debugging step. If the stack is too small, the IP helper thread could possibly be overwriting memory, which may cause unusual problems.*</span></span>

### <a name="thread-suspension"></a><span data-ttu-id="427f9-587">Приостановка потока</span><span class="sxs-lookup"><span data-stu-id="427f9-587">Thread Suspension</span></span>

<span data-ttu-id="427f9-588">При попытке получения необработанных IP-пакетов потоки приложения могут быть приостановлены.</span><span class="sxs-lookup"><span data-stu-id="427f9-588">Application threads can suspend while attempting to receive raw IP packets.</span></span> <span data-ttu-id="427f9-589">После получения необработанного пакета первому приостановленному потоку присваивается новый пакет, и этот поток возобновляется.</span><span class="sxs-lookup"><span data-stu-id="427f9-589">After a raw packet is received, the new packet is given to the first thread suspended and that thread is resumed.</span></span> <span data-ttu-id="427f9-590">У всех служб получения пакетов NetX Duo имеется дополнительная функция времени ожидания приостановки.</span><span class="sxs-lookup"><span data-stu-id="427f9-590">NetX Duo services for receiving packets all have an optional suspension timeout.</span></span> <span data-ttu-id="427f9-591">При получении пакета или истечении времени ожидания выполнение потока приложения возобновляется с соответствующим состоянием завершения.</span><span class="sxs-lookup"><span data-stu-id="427f9-591">When a packet is received or the timeout expires, the application thread is resumed with the appropriate completion status.</span></span>

### <a name="ip-statistics-and-errors"></a><span data-ttu-id="427f9-592">Статистические показатели и ошибки IP-экземпляра</span><span class="sxs-lookup"><span data-stu-id="427f9-592">IP Statistics and Errors</span></span>

<span data-ttu-id="427f9-593">Если этот параметр включен, NetX Duo отслеживает несколько статистических показателей и ошибок, которые могут быть полезны для приложения.</span><span class="sxs-lookup"><span data-stu-id="427f9-593">If enabled, the NetX Duo keeps track of several statistics and errors that may be useful to the application.</span></span> <span data-ttu-id="427f9-594">Для каждого IP-экземпляра поддерживаются следующие статистические показатели и отчеты об ошибках:</span><span class="sxs-lookup"><span data-stu-id="427f9-594">The following statistics and error reports are maintained for each IP instance:</span></span>

- <span data-ttu-id="427f9-595">общее число отправленных IP-пакетов;</span><span class="sxs-lookup"><span data-stu-id="427f9-595">Total IP Packets Sent</span></span>
- <span data-ttu-id="427f9-596">общее число байтов, отправленных по протоколу IP;</span><span class="sxs-lookup"><span data-stu-id="427f9-596">Total IP Bytes Sent</span></span>
- <span data-ttu-id="427f9-597">общее число полученных IP-пакетов;</span><span class="sxs-lookup"><span data-stu-id="427f9-597">Total IP Packets Received</span></span>
- <span data-ttu-id="427f9-598">общее число байтов, полученных по протоколу IP;</span><span class="sxs-lookup"><span data-stu-id="427f9-598">Total IP Bytes Received</span></span>
- <span data-ttu-id="427f9-599">общее число недопустимых IP-пакетов;</span><span class="sxs-lookup"><span data-stu-id="427f9-599">Total IP Invalid Packets</span></span>
- <span data-ttu-id="427f9-600">общее число отброшенных пакетов, получаемых по протоколу IP;</span><span class="sxs-lookup"><span data-stu-id="427f9-600">Total IP Receive Packets Dropped</span></span>
- <span data-ttu-id="427f9-601">общее число ошибок контрольной суммы при получении по протоколу IP;</span><span class="sxs-lookup"><span data-stu-id="427f9-601">Total IP Receive Checksum Errors</span></span>
- <span data-ttu-id="427f9-602">общее число отброшенных пакетов, отправляемых по протоколу IP;</span><span class="sxs-lookup"><span data-stu-id="427f9-602">Total IP Send Packets Dropped</span></span>
- <span data-ttu-id="427f9-603">общее число отправленных фрагментов IP-пакетов;</span><span class="sxs-lookup"><span data-stu-id="427f9-603">Total IP Fragments Sent</span></span>
- <span data-ttu-id="427f9-604">общее число полученных фрагментов IP-пакетов.</span><span class="sxs-lookup"><span data-stu-id="427f9-604">Total IP Fragments Received</span></span>

<span data-ttu-id="427f9-605">Все эти статистические показатели и отчеты об ошибках предоставляются приложению службой ***nx_ip_info_get***.</span><span class="sxs-lookup"><span data-stu-id="427f9-605">All of these statistics and error reports are available to the application with the ***nx_ip_info_get*** service.</span></span>

### <a name="ip-control-block-nx_ip"></a><span data-ttu-id="427f9-606">Блок управления IP NX_IP</span><span class="sxs-lookup"><span data-stu-id="427f9-606">IP Control Block NX_IP</span></span>

<span data-ttu-id="427f9-607">Характеристики каждого IP-экземпляра находятся в его блоке управления.</span><span class="sxs-lookup"><span data-stu-id="427f9-607">The characteristics of each IP instance are found in its control block.</span></span> <span data-ttu-id="427f9-608">Он содержит такие полезные сведения, как IP-адреса и маски сети каждого сетевого устройства, а также таблицу соседних IP-адресов и сопоставления адресов физического оборудования.</span><span class="sxs-lookup"><span data-stu-id="427f9-608">It contains useful information such as the IP addresses and network masks of each network device, and a table of neighbor IP and physical hardware address mapping.</span></span> <span data-ttu-id="427f9-609">Эта структура определена в файле \***nx_api.h** _.</span><span class="sxs-lookup"><span data-stu-id="427f9-609">This structure is defined in the \***nx_api.h** _file.</span></span> <span data-ttu-id="427f9-610">Если протокол IPv6 включен, он также содержит массив IPv6-адресов, число которых указывается пользователем с помощью параметра _\*_NX_MAX_IPV6_ADDRESSES_\*\*.</span><span class="sxs-lookup"><span data-stu-id="427f9-610">If IPv6 is enabled, it also contains an array of IPv6 address, the number of which is specified by the user configurable option _\*_NX_MAX_IPV6_ADDRESSES_\*\*.</span></span> <span data-ttu-id="427f9-611">Значение по умолчанию позволяет каждому физическому сетевому интерфейсу иметь три адреса IPv6.</span><span class="sxs-lookup"><span data-stu-id="427f9-611">The default value allows each physical network interface to have three IPv6 addresses.</span></span>

<span data-ttu-id="427f9-612">Блоки управления экземпляра IP могут размещаться в любом месте в памяти, но чаще всего они определяются вне области какой-либо функции, благодаря чему функционируют как глобальная структура.</span><span class="sxs-lookup"><span data-stu-id="427f9-612">IP instance control blocks can be located anywhere in memory, but it is most common to make the control block a global structure by defining it outside the scope of any function.</span></span>

### <a name="static-ipv4-routing"></a><span data-ttu-id="427f9-613">Статическая маршрутизация IPv4</span><span class="sxs-lookup"><span data-stu-id="427f9-613">Static IPv4 Routing</span></span>

<span data-ttu-id="427f9-614">Функция статической маршрутизации позволяет приложению указать сеть IPv4 и адрес следующего прыжка для конкретных IP-адресов назначения вне сети.</span><span class="sxs-lookup"><span data-stu-id="427f9-614">The static routing feature allows an application to specify an IPv4 network and next hop address for specific out of network destination IP addresses.</span></span> <span data-ttu-id="427f9-615">Если включена статическая маршрутизация, NetX Duo выполняет поиск записи, соответствующей адресу назначения отправляемого пакета, в статической таблице маршрутизации.</span><span class="sxs-lookup"><span data-stu-id="427f9-615">If static routing is enabled, NetX Duo searches through the static routing table for an entry matching the destination address of the packet to send.</span></span> <span data-ttu-id="427f9-616">Если совпадений не найдено, NetX Duo выполняет поиск по списку физических интерфейсов и выбирает исходный IP-адрес и адрес следующего прыжка на основе IP-адреса назначения и маски сети.</span><span class="sxs-lookup"><span data-stu-id="427f9-616">If no match is found, NetX Duo searches through the list of physical interfaces and chooses a source IP address and next hop address based on the destination IP address and the network mask.</span></span> <span data-ttu-id="427f9-617">Если назначение не соответствует ни одному из IP-адресов сетевых драйверов, подключенных к экземпляру IP-адреса, NetX Duo выбирает интерфейс, напрямую подключенный к шлюзу по умолчанию, и использует IP-адрес интерфейса в качестве исходного адреса, а шлюз по умолчанию — в качестве следующего прыжка.</span><span class="sxs-lookup"><span data-stu-id="427f9-617">If the destination does not match any of the IP addresses of the network drivers attached to the IP instance, NetX Duo chooses an interface that is directly connected to the default gateway, and uses the IP address of the interface as source address, and the default gateway as the next hop.</span></span>

<span data-ttu-id="427f9-618">Записи можно добавлять и удалять из таблицы статической маршрутизации с помощью служб \***nx_ip_static_route_add** _ и _ \*_nx_ip_static_route_delete_\*\*, соответственно.</span><span class="sxs-lookup"><span data-stu-id="427f9-618">Entries can be added and removed from the static routing table using the ***nx_ip_static_route_add** _ and _ *_nx_ip_static_route_delete_** services, respectively.</span></span> <span data-ttu-id="427f9-619">Чтобы использовать статическую маршрутизацию, ведущее приложение должно включить эту функцию, определив значение ***NX_ENABLE_IP_STATIC_ROUTING.***</span><span class="sxs-lookup"><span data-stu-id="427f9-619">To use static routing, the host application must enable this feature by defining ***NX_ENABLE_IP_STATIC_ROUTING.***</span></span>

> [!NOTE]
> <span data-ttu-id="427f9-620">*При добавлении записи в таблицу статической маршрутизации NetX Duo проверяет наличие соответствующей записи для указанного адреса назначения, уже находящегося в таблице. Если таковая существует, NetX Duo дает предпочтение записи с меньшей сетью (более длинным префиксом) в маске сети.*</span><span class="sxs-lookup"><span data-stu-id="427f9-620">*When adding an entry to the static routing table, NetX Duo checks for a matching entry for the specified destination address already in the table. If one exists, it gives preference to the entry with the smaller network (longer prefix) in the network mask.*</span></span>

### <a name="ipv4-forwarding"></a><span data-ttu-id="427f9-621">Пересылка IPv4</span><span class="sxs-lookup"><span data-stu-id="427f9-621">IPv4 Forwarding</span></span>

<span data-ttu-id="427f9-622">Если входящий пакет IPv4 не предназначен для этого узла и включена функция переадресации IPv4, NetX Duo пытается перенаправить пакет через другие интерфейсы.</span><span class="sxs-lookup"><span data-stu-id="427f9-622">If the incoming IPv4 packet is not destined for this node and IPv4 forwarding feature is enabled, NetX Duo attempts to forward the packet out via the other interfaces.</span></span>  

### <a name="ip-fragmentation"></a><span data-ttu-id="427f9-623">Фрагментация IP-пакетов</span><span class="sxs-lookup"><span data-stu-id="427f9-623">IP Fragmentation</span></span>

<span data-ttu-id="427f9-624">У сетевого устройства могут быть ограничения на размер исходящих пакетов.</span><span class="sxs-lookup"><span data-stu-id="427f9-624">The network device may have limits on the size of outgoing packets.</span></span> <span data-ttu-id="427f9-625">Это ограничение называется максимальной единицей передачи данных (MTU).</span><span class="sxs-lookup"><span data-stu-id="427f9-625">This limit is called the maximum transmission unit (MTU).</span></span> <span data-ttu-id="427f9-626">Значение MTU для протокола IP равно размеру наибольшего IP-кадра, который драйвер канального уровня может передавать без фрагментации IP-пакета.</span><span class="sxs-lookup"><span data-stu-id="427f9-626">IP MTU is the largest IP frame size a link layer driver is able to transmit without fragmenting the IP packet.</span></span> <span data-ttu-id="427f9-627">На этапе инициализации драйвера устройства модуль драйвера должен настроить его размер MTU для протокола IP с помощью службы ***nx_ip_interface_mtu_set.***</span><span class="sxs-lookup"><span data-stu-id="427f9-627">During a device driver initialization phase, the driver module must configure its IP MTU size via the service ***nx_ip_interface_mtu_set.***</span></span>

<span data-ttu-id="427f9-628">Хотя это и не рекомендуется, приложение может формировать датаграммы, размер которых превышает базовый размер MTU для протокола IP, поддерживаемый устройством.</span><span class="sxs-lookup"><span data-stu-id="427f9-628">Although not recommended, the application may generate datagrams larger than the underlying IP MTU supported by the device.</span></span> <span data-ttu-id="427f9-629">Перед передачей такой IP-датаграммы эти пакеты должны быть фрагментированы на уровне IP.</span><span class="sxs-lookup"><span data-stu-id="427f9-629">Before transmitting such IP datagram, the IP layer must fragment these packets.</span></span> <span data-ttu-id="427f9-630">При получении фрагментированных IP-кадров принимающая конечная точка должна хранить все фрагментированные кадры IP-адресов с одинаковым идентификатором фрагментации и повторно собирать их по порядку.</span><span class="sxs-lookup"><span data-stu-id="427f9-630">On receiving fragmented IP frames, the receiving end must store all fragmented IP frames with the same fragmentation ID, and reassemble them in order.</span></span> <span data-ttu-id="427f9-631">Если логике получения IP-пакетов не удается вовремя собрать все фрагменты для восстановления исходного IP-кадра, все фрагменты освобождаются.</span><span class="sxs-lookup"><span data-stu-id="427f9-631">If the IP receive logic is unable to collect all the fragments to restore the original IP frame in time, all the fragments are released.</span></span> <span data-ttu-id="427f9-632">За обнаружение потери пакетов и их восстановление отвечает протокол верхнего уровня.</span><span class="sxs-lookup"><span data-stu-id="427f9-632">It is up to the upper layer protocol to detect such packet loss and recover from it.</span></span>

<span data-ttu-id="427f9-633">Фрагментация IP-адресов применима к пакетам и IPv4, и IPv6.</span><span class="sxs-lookup"><span data-stu-id="427f9-633">The IP fragmentation applies to both IPv4 and IPv6 packets.</span></span>

<span data-ttu-id="427f9-634">Для поддержки фрагментации IP-адресов и операции пересборки конструктор систем должен включить функцию фрагментации IP-адресов в NetX Duo с помощью службы ***nx_ip_fragment_enable***.</span><span class="sxs-lookup"><span data-stu-id="427f9-634">In order to support IP fragmentation and reassembly operation, the system designer must enable the IP fragmentation feature in NetX Duo using the ***nx_ip_fragment_enable*** service.</span></span> <span data-ttu-id="427f9-635">Если эта функция не включена, входящие фрагментированные IP-пакеты отклоняются, как и пакеты, превышающие MTU сетевого драйвера.</span><span class="sxs-lookup"><span data-stu-id="427f9-635">If this feature is not enabled, incoming fragmented IP packets are discarded, as well as packets that exceed the network driver's MTU.</span></span>

> [!NOTE]
> <span data-ttu-id="427f9-636">\* Логика фрагментации IP-адресов может быть полностью удалена путем определения \***NX_DISABLE_FRAGMENTATION** _ при создании библиотеки NetX Duo.</span><span class="sxs-lookup"><span data-stu-id="427f9-636">\*The IP Fragmentation logic can be removed completely by defining \***NX_DISABLE_FRAGMENTATION** _ when building the NetX Duo library.</span></span> <span data-ttu-id="427f9-637">Это помогает сократить размер кода NetX Duo.</span><span class="sxs-lookup"><span data-stu-id="427f9-637">Doing so helps reduce the code size of NetX Duo.</span></span> <span data-ttu-id="427f9-638">Обратите внимание, что в этом случае функции фрагментации и пересборки IPv4 и IPv6 отключены._</span><span class="sxs-lookup"><span data-stu-id="427f9-638">Note that in this situation, both the IPv4 and IPv6 fragmentation/reassembly functions are disabled._</span></span>

> [!NOTE]
> <span data-ttu-id="427f9-639">*Если определен **NX_DISABLE_CHAINED_PACKET**, фрагментация IP-адресов должна быть отключена.*</span><span class="sxs-lookup"><span data-stu-id="427f9-639">*If **NX_DISABLE_CHAINED_PACKET** is defined, IP fragmentation must be disabled.*</span></span>

> [!NOTE]
> <span data-ttu-id="427f9-640">*В сети IPv6 маршрутизаторы не выполняют фрагментацию датаграмм, если размер датаграммы превышает ее минимальный размер MTU. Таким образом, отправляющее устройство должно определить минимальный MTU между источником и назначением и убедиться, что размер датаграммы IP не превышает MTU пути. В NetX Duo обнаружение MTU пути IPv6 можно включить, создав библиотеку NetX Duo с определенным символом **NX_ENABLE_IPV6_PATH_MTU_DISCOVERY**.*</span><span class="sxs-lookup"><span data-stu-id="427f9-640">*In an IPv6 network, routers do not fragment a datagram if the size of the datagram exceeds its minimum MTU size. Therefore, it is up to the sending device to determine the minimum MTU between the source and the destination, and to ensure the IP datagram size does not exceed the path MTU. In NetX Duo, IPv6 PATH MTU discovery can be enabled by building NetX Duo library with the symbol **NX_ENABLE_IPV6_PATH_MTU_DISCOVERY** defined.*</span></span>

## <a name="address-resolution-protocol-arp-in-ipv4"></a><span data-ttu-id="427f9-641">Протокол разрешения адресов в экземпляре IPv4</span><span class="sxs-lookup"><span data-stu-id="427f9-641">Address Resolution Protocol (ARP) in IPv4</span></span>

<span data-ttu-id="427f9-642">Протокол разрешения адресов (ARP) отвечает за динамическое сопоставление 32-разрядных адресов IPv4 с базовыми физическими носителями (RFC 826).</span><span class="sxs-lookup"><span data-stu-id="427f9-642">The Address Resolution Protocol (ARP) is responsible for dynamically mapping 32-bit IPv4 addresses to those of the underlying physical media (RFC 826).</span></span> <span data-ttu-id="427f9-643">Ethernet — это наиболее распространенный физический носитель, который поддерживает 48-разрядные адреса.</span><span class="sxs-lookup"><span data-stu-id="427f9-643">Ethernet is the most typical physical media, and it supports 48-bit addresses.</span></span> <span data-ttu-id="427f9-644">Необходимость в ARP определяется драйвером сети, предоставленным службе \***nx_ip_create** _.</span><span class="sxs-lookup"><span data-stu-id="427f9-644">The need for ARP is determined by the network driver supplied to the \***nx_ip_create** _ service.</span></span> <span data-ttu-id="427f9-645">Если требуется физическое сопоставление, сетевой драйвер должен использовать службу _ *_nx_interface_address_mapping_needed_*\* для правильной настройки интерфейса драйвера.</span><span class="sxs-lookup"><span data-stu-id="427f9-645">If physical mapping is required, the network driver must use the _ *_nx_interface_address_mapping_needed_*\* service to configure the driver interface properly.</span></span>

### <a name="arp-enable"></a><span data-ttu-id="427f9-646">Включение ARP</span><span class="sxs-lookup"><span data-stu-id="427f9-646">ARP Enable</span></span>

<span data-ttu-id="427f9-647">Чтобы протокол ARP правильно функционировал, он должен быть включен приложением с помощью службы ***nx_arp_enable***.</span><span class="sxs-lookup"><span data-stu-id="427f9-647">For ARP to function properly, it must first be enabled by the application with the ***nx_arp_enable*** service.</span></span> <span data-ttu-id="427f9-648">Эта служба настраивает различные структуры данных для обработки ARP, включая создание области кэша ARP из памяти, предоставляемой службе включения ARP.</span><span class="sxs-lookup"><span data-stu-id="427f9-648">This service sets up various data structures for ARP processing, including the creation of an ARP cache area from the memory supplied to the ARP enable service.</span></span>

### <a name="arp-cache"></a><span data-ttu-id="427f9-649">Кэш ARP</span><span class="sxs-lookup"><span data-stu-id="427f9-649">ARP Cache</span></span>

<span data-ttu-id="427f9-650">Кэш ARP можно рассматривать как массив внутренних структур данных сопоставления ARP.</span><span class="sxs-lookup"><span data-stu-id="427f9-650">The ARP cache can be viewed as an array of internal ARP mapping data structures.</span></span> <span data-ttu-id="427f9-651">Каждая внутренняя структура может поддерживать связь между IP-адресом и адресом физического оборудования.</span><span class="sxs-lookup"><span data-stu-id="427f9-651">Each internal structure is capable of maintaining the relationship between an IP address and a physical hardware address.</span></span> <span data-ttu-id="427f9-652">Кроме того, каждая структура данных имеет указатели на каналы, поэтому она может быть включена в несколько связанных списков.</span><span class="sxs-lookup"><span data-stu-id="427f9-652">In addition, each data structure has link pointers so it can be part of multiple linked lists.</span></span>

<span data-ttu-id="427f9-653">Если сопоставление присутствует в таблице ARP, приложение может найти IP-адрес в кэше ARP, указав MAC-адрес оборудования с помощью службы \***nx_arp_ip_address_find** _.</span><span class="sxs-lookup"><span data-stu-id="427f9-653">Application can look up an IP address from the ARP cache by supplying hardware MAC address using the service \***nx_arp_ip_address_find** _ if the mapping exists in the ARP table.</span></span> <span data-ttu-id="427f9-654">Аналогичным образом служба _ *_nx_arp_hardware_address_find_*\* возвращает MAC-адрес для заданного IP-адреса.</span><span class="sxs-lookup"><span data-stu-id="427f9-654">Similarly, the service _ *_nx_arp_hardware_address_find_*\* returns the MAC address for a given IP address.</span></span>

### <a name="arp-dynamic-entries"></a><span data-ttu-id="427f9-655">Динамические записи ARP</span><span class="sxs-lookup"><span data-stu-id="427f9-655">ARP Dynamic Entries</span></span>

<span data-ttu-id="427f9-656">По умолчанию служба включения ARP размещает все записи в кэше ARP в списке доступных динамических записей ARP.</span><span class="sxs-lookup"><span data-stu-id="427f9-656">By default, the ARP enable service places all entries in the ARP cache on the list of available dynamic ARP entries.</span></span> <span data-ttu-id="427f9-657">При обнаружении запроса на отправку в несопоставленный IP-адрес NetX Duo выделяет из этого списка динамические записи ARP.</span><span class="sxs-lookup"><span data-stu-id="427f9-657">A dynamic ARP entry is allocated from this list by NetX Duo when a send request to an unmapped IP address is detected.</span></span> <span data-ttu-id="427f9-658">После выделения настраивается запись ARP, а на физический носитель отправляется запрос ARP.</span><span class="sxs-lookup"><span data-stu-id="427f9-658">After allocation, the ARP entry is set up and an ARP request is sent to the physical media.</span></span>

<span data-ttu-id="427f9-659">Динамическая запись также может быть создана службой ***nx_arp_dynamic_entry_setом***.</span><span class="sxs-lookup"><span data-stu-id="427f9-659">A dynamic entry can also be created by the service ***nx_arp_dynamic_entry_set***.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="427f9-660">*Если используются все динамические записи ARP, то по крайней мере недавно использованная запись ARP заменяется новым сопоставлением.*</span><span class="sxs-lookup"><span data-stu-id="427f9-660">*If all dynamic ARP entries are in use, the least recently used ARP entry is replaced with a new mapping.*</span></span>

### <a name="arp-static-entries"></a><span data-ttu-id="427f9-661">Статические записи ARP</span><span class="sxs-lookup"><span data-stu-id="427f9-661">ARP Static Entries</span></span>

<span data-ttu-id="427f9-662">Приложение также может настроить статическое сопоставление ARP с помощью службы \***nx_arp_static_entry_create** _.</span><span class="sxs-lookup"><span data-stu-id="427f9-662">The application can also set up static ARP mapping by using the \***nx_arp_static_entry_create** _service.</span></span> <span data-ttu-id="427f9-663">Эта служба выделяет запись ARP из динамического списка записей ARP и помещает ее в статический список с информацией о сопоставлении, предоставленной приложением.</span><span class="sxs-lookup"><span data-stu-id="427f9-663">This service allocates an ARP entry from the dynamic ARP entry list and places it on the static list with the mapping information supplied by the application.</span></span> <span data-ttu-id="427f9-664">Статические записи ARP не предусматривают повторное использование или устаревание.</span><span class="sxs-lookup"><span data-stu-id="427f9-664">Static ARP entries are not subject to reuse or aging.</span></span> <span data-ttu-id="427f9-665">Приложение может удалить статическую запись с помощью службы _*_nx_arp_static_entry_delete_*_.</span><span class="sxs-lookup"><span data-stu-id="427f9-665">The application can delete a static entry by using the service _*_nx_arp_static_entry_delete_*_.</span></span> <span data-ttu-id="427f9-666">Чтобы удалить все статические записи в таблице ARP, приложение может использовать службу _\*_nx_arp_static_entries_delete_\*\*.</span><span class="sxs-lookup"><span data-stu-id="427f9-666">To remove all static entries in the ARP table, the application may use the service _\*_nx_arp_static_entries_delete_\*\*.</span></span>

### <a name="automatic-arp-entry"></a><span data-ttu-id="427f9-667">Автоматическая запись ARP</span><span class="sxs-lookup"><span data-stu-id="427f9-667">Automatic ARP Entry</span></span>

<span data-ttu-id="427f9-668">NetX Duo записывает сопоставление IP/MAC-адресов однорангового узла после одноранговых ответов на запрос ARP.</span><span class="sxs-lookup"><span data-stu-id="427f9-668">NetX Duo records the peer's IP/MAC mapping after the peer responses to the ARP request.</span></span> <span data-ttu-id="427f9-669">NetX Duo также реализует функцию автоматического входа в систему ARP, где она записывает сопоставление одноранговых IP/MAC-адресов на основе непрошенных запросов ARP из сети.</span><span class="sxs-lookup"><span data-stu-id="427f9-669">NetX Duo also implements the automatic ARP entry feature where it records peer IP/MAC address mapping based on unsolicited ARP requests from the network.</span></span> <span data-ttu-id="427f9-670">Эта функция позволяет заполнить таблицу ARP данными однорангового узла, уменьшая задержку, возникающую при прохождении цикла запросов и ответов ARP.</span><span class="sxs-lookup"><span data-stu-id="427f9-670">This feature allows the ARP table to be populated with peer information, reducing the delay needed to go through the ARP request/response cycle.</span></span> <span data-ttu-id="427f9-671">Однако у автоматической записи ARP есть и свой недостаток. Он заключается в том, что при включении этой функции в загруженной сети с большим количеством узлов на локальном канале таблица ARP быстро заполняется, что в конечном итоге приводит к замене записи ARP.</span><span class="sxs-lookup"><span data-stu-id="427f9-671">However the downside with enabling automatic ARP is that the ARP table tend to fill up quickly on a busy network with many nodes on the local link, which would eventually lead to ARP entry replacement.</span></span>

<span data-ttu-id="427f9-672">Эта функция включена по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="427f9-672">This feature is enabled by default.</span></span> <span data-ttu-id="427f9-673">Чтобы отключить ее, необходимо скомпилировать библиотеку NetX Duo, где определен символ ***NX_DISABLE_ARP_AUTO_ENTRY***.</span><span class="sxs-lookup"><span data-stu-id="427f9-673">To disable it, the NetX Duo library must be compiled with the symbol ***NX_DISABLE_ARP_AUTO_ENTRY*** defined.</span></span></p>

### <a name="arp-messages"></a><span data-ttu-id="427f9-674">Сообщения ARP</span><span class="sxs-lookup"><span data-stu-id="427f9-674">ARP Messages</span></span>

<span data-ttu-id="427f9-675">Как упоминалось ранее, если при выполнении задачи IP-экземпляра обнаруживается, что для IP-адреса требуется сопоставление, отправляется сообщение запроса ARP.</span><span class="sxs-lookup"><span data-stu-id="427f9-675">As mentioned previously, an ARP request message is sent when the IP task detects that mapping is needed for an IP address.</span></span> <span data-ttu-id="427f9-676">Запросы ARP отправляются периодически (каждые \***NX_ARP_UPDATE_RATE** _ секунд), пока не будет получен соответствующий ответ ARP.</span><span class="sxs-lookup"><span data-stu-id="427f9-676">ARP requests are sent periodically (every \***NX_ARP_UPDATE_RATE** _ seconds) until a corresponding ARP response is received.</span></span> <span data-ttu-id="427f9-677">Попытки ARP прекращаются после того, как общее количество запросов ARP достигает _ \*_NX_ARP_MAXIMUM_RETRIES_\*\*.</span><span class="sxs-lookup"><span data-stu-id="427f9-677">A total of _ *_NX_ARP_MAXIMUM_RETRIES_*\* ARP requests are made before the ARP attempt is abandoned.</span></span> <span data-ttu-id="427f9-678">При получении ответа ARP сведения о связанном физическом адресе сохраняются в записи ARP, которая находится в кэше.</span><span class="sxs-lookup"><span data-stu-id="427f9-678">When an ARP response is received, the associated physical address information is stored in the ARP entry that is in the cache.</span></span>

<span data-ttu-id="427f9-679">Для систем с множественной адресацией NetX Duo определяет, какой интерфейс будет отправлять запросы и ответы ARP, на основе указанного адреса назначения.</span><span class="sxs-lookup"><span data-stu-id="427f9-679">For multihome systems, NetX Duo determines which interface to send the ARP requests and responses based on destination address specified.</span></span>

> [!NOTE]
> <span data-ttu-id="427f9-680">*Исходящие пакеты IP помещаются в очередь, пока NetX Duo ожидает ответа ARP. Число исходящих IP-пакетов в очереди определяется константой **NX_ARP_MAX_QUEUE_DEPTH**.*</span><span class="sxs-lookup"><span data-stu-id="427f9-680">*Outgoing IP packets are queued while NetX Duo waits for the ARP response. The number of outgoing IP packets queued is defined by the constant **NX_ARP_MAX_QUEUE_DEPTH**.*</span></span>

<span data-ttu-id="427f9-681">NetX Duo также отвечает на запросы ARP от других узлов локальной сети IPv4.</span><span class="sxs-lookup"><span data-stu-id="427f9-681">NetX Duo also responds to ARP requests from other nodes on the local IPv4 network.</span></span> <span data-ttu-id="427f9-682">Когда выполняется внешний запрос ARP, совпадающий с текущим IP-адресом интерфейса, получающего запрос ARP, NetX Duo создает ответное сообщение ARP, содержащее текущий физический адрес.</span><span class="sxs-lookup"><span data-stu-id="427f9-682">When an external ARP request is made that matches the current IP address of the interface that receives the ARP request, NetX Duo builds an ARP response message that contains the current physical address.</span></span>

<span data-ttu-id="427f9-683">Форматы запросов и ответов ARP в Ethernet показаны на рис. 6 и описаны ниже.</span><span class="sxs-lookup"><span data-stu-id="427f9-683">The formats of Ethernet ARP requests and responses are shown in Figure 6 and are described below.</span></span>

| <span data-ttu-id="427f9-684">**Поле&nbsp;запроса/ответа**</span><span class="sxs-lookup"><span data-stu-id="427f9-684">**Request/Response&nbsp;Field**</span></span>         | <span data-ttu-id="427f9-685">**Назначение**</span><span class="sxs-lookup"><span data-stu-id="427f9-685">**Purpose**</span></span>            |
| ---------------------------------- | ---------------------- |
| <span data-ttu-id="427f9-686">***Адрес назначения в Ethernet***</span><span class="sxs-lookup"><span data-stu-id="427f9-686">***Ethernet Destination Address***</span></span> | <span data-ttu-id="427f9-687">Это поле размером 6 байт содержит адрес назначения для ответа ARP и является широковещательным для запросов ARP (применяется для всех).</span><span class="sxs-lookup"><span data-stu-id="427f9-687">This 6-byte field contains the destination address for the ARP response and is a broadcast (all ones) for ARP requests.</span></span> <span data-ttu-id="427f9-688">Это поле настраивается сетевым драйвером.</span><span class="sxs-lookup"><span data-stu-id="427f9-688">This field is setup by the network driver.</span></span> 
| <span data-ttu-id="427f9-689">***Адрес источника в Ethernet***</span><span class="sxs-lookup"><span data-stu-id="427f9-689">***Ethernet Source Address***</span></span>      | <span data-ttu-id="427f9-690">Это поле размером 6 байт содержит адрес отправителя запроса или ответа ARP и настраивается сетевым драйвером.</span><span class="sxs-lookup"><span data-stu-id="427f9-690">This 6-byte field contains the address of the sender of the ARP request or response and is set up by the network driver.</span></span> |
| <span data-ttu-id="427f9-691">***Тип кадра***</span><span class="sxs-lookup"><span data-stu-id="427f9-691">***Frame Type***</span></span> | <span data-ttu-id="427f9-692">Это поле размером 2 байта содержит тип представления кадра Ethernet. Для запросов и ответов ARP его значение равно 0x0806.</span><span class="sxs-lookup"><span data-stu-id="427f9-692">This 2-byte field contains the type of Ethernet frame present and, for ARP requests and responses, this is equal to 0x0806.</span></span> <span data-ttu-id="427f9-693">Это последнее поле, за настройку которого отвечает сетевой драйвер.</span><span class="sxs-lookup"><span data-stu-id="427f9-693">This is the last field the network driver is responsible for setting up.</span></span> |
| <span data-ttu-id="427f9-694">***Тип оборудования***</span><span class="sxs-lookup"><span data-stu-id="427f9-694">***Hardware Type***</span></span> | <span data-ttu-id="427f9-695">Это поле размером 2 байта содержит тип оборудования и имеет значение 0x0001 для Ethernet.</span><span class="sxs-lookup"><span data-stu-id="427f9-695">This 2-byte field contains the hardware type, which is 0x0001 for Ethernet.</span></span> |
| <span data-ttu-id="427f9-696">***Тип протокола***</span><span class="sxs-lookup"><span data-stu-id="427f9-696">***Protocol Type***</span></span> | <span data-ttu-id="427f9-697">Это поле размером 2 байта содержит тип протокола, для IP-адресов оно имеет значение 0x0800.</span><span class="sxs-lookup"><span data-stu-id="427f9-697">This 2-byte field contains the protocol type, which is 0x0800 for IP addresses.</span></span> |
| <span data-ttu-id="427f9-698">***Размер оборудования***</span><span class="sxs-lookup"><span data-stu-id="427f9-698">***Hardware Size***</span></span> | <span data-ttu-id="427f9-699">Это поле размером 1 байт содержит размер аппаратного адреса (6 для адресов Ethernet).</span><span class="sxs-lookup"><span data-stu-id="427f9-699">This 1-byte field contains the hardware address size, which is 6 for Ethernet addresses.</span></span> |

![Схема формата пакета ARP.](./media/user-guide/arp-packet-format.png)

<span data-ttu-id="427f9-701">**РИС. 6. Формат пакетов ARP**</span><span class="sxs-lookup"><span data-stu-id="427f9-701">**FIGURE 6. ARP Packet Format**</span></span>

| <span data-ttu-id="427f9-702">Поле&nbsp;запроса/ответа</span><span class="sxs-lookup"><span data-stu-id="427f9-702">Request/Response&nbsp;Field</span></span> | <span data-ttu-id="427f9-703">Назначение</span><span class="sxs-lookup"><span data-stu-id="427f9-703">Purpose</span></span> |
|---|---|
| <span data-ttu-id="427f9-704">***Размер протокола***</span><span class="sxs-lookup"><span data-stu-id="427f9-704">***Protocol Size***</span></span> | <span data-ttu-id="427f9-705">Это поле размером 1 байт содержит размер IP-адреса, который равен 4 для IP-адресов.</span><span class="sxs-lookup"><span data-stu-id="427f9-705">This 1-byte field contains the IP address size, which is 4 for IP addresses.</span></span> |
| <span data-ttu-id="427f9-706">***Код операции***</span><span class="sxs-lookup"><span data-stu-id="427f9-706">***Operation Code***</span></span> | <span data-ttu-id="427f9-707">Это поле размером 2 байта содержит операцию для этого пакета ARP.</span><span class="sxs-lookup"><span data-stu-id="427f9-707">This 2-byte field contains the operation for this ARP packet.</span></span> <span data-ttu-id="427f9-708">Запрос ARP задается значением 0x0001, а ответ ARP представляется значением 0x0002.</span><span class="sxs-lookup"><span data-stu-id="427f9-708">An ARP request is specified with the value of 0x0001, while an ARP response is represented by a value of 0x0002.</span></span> |
| <span data-ttu-id="427f9-709">***Адрес Ethernet отправителя***</span><span class="sxs-lookup"><span data-stu-id="427f9-709">***Sender Ethernet Address***</span></span> | <span data-ttu-id="427f9-710">Это поле размером 6 байт содержит адрес Ethernet отправителя.</span><span class="sxs-lookup"><span data-stu-id="427f9-710">This 6-byte field contains the sender's Ethernet address.</span></span> |
| <span data-ttu-id="427f9-711">***IP-адрес отправителя***</span><span class="sxs-lookup"><span data-stu-id="427f9-711">***Sender IP Address***</span></span> | <span data-ttu-id="427f9-712">Это поле размером 4 байта содержит IP-адрес отправителя.</span><span class="sxs-lookup"><span data-stu-id="427f9-712">This 4-byte field contains the sender's IP address.</span></span> |
| <span data-ttu-id="427f9-713">***Целевой адрес Ethernet***</span><span class="sxs-lookup"><span data-stu-id="427f9-713">***Target Ethernet Address***</span></span> | <span data-ttu-id="427f9-714">Это поле размером 6 байт содержит целевой адрес Ethernet.</span><span class="sxs-lookup"><span data-stu-id="427f9-714">This 6-byte field contains the target's Ethernet address.</span></span> |
| <span data-ttu-id="427f9-715">***Целевой IP-адрес***</span><span class="sxs-lookup"><span data-stu-id="427f9-715">***Target IP Address***</span></span> | <span data-ttu-id="427f9-716">Это поле размером 4 байта содержит целевой IP-адрес.</span><span class="sxs-lookup"><span data-stu-id="427f9-716">This 4-byte field contains the target's IP address.</span></span> |

> [!NOTE]
> <span data-ttu-id="427f9-717">*Запросы и ответы ARP — это пакеты уровня Ethernet. Все остальные пакеты TCP/IP инкапсулируются в заголовке IP-пакета.*</span><span class="sxs-lookup"><span data-stu-id="427f9-717">*ARP requests and responses are Ethernet-level packets. All other TCP/IP packets are encapsulated by an IP packet header.*</span></span>

> [!NOTE]
> <span data-ttu-id="427f9-718">*Все сообщения ARP в реализации TCP/IP должны быть представлены в формате с **обратным порядком байтов**. В этом формате наиболее значимый байт слова размещается по наименьшему байтовому адресу.*</span><span class="sxs-lookup"><span data-stu-id="427f9-718">*All ARP messages in the TCP/IP implementation are expected to be in **big endian** format. In this format, the most significant byte of the word resides at the lowest byte address.*</span></span>

### <a name="arp-aging"></a><span data-ttu-id="427f9-719">Устаревание ARP</span><span class="sxs-lookup"><span data-stu-id="427f9-719">ARP Aging</span></span>

<span data-ttu-id="427f9-720">NetX поддерживает автоматическое аннулирование динамической записи ARP.</span><span class="sxs-lookup"><span data-stu-id="427f9-720">NetX supports automatic dynamic ARP entry invalidation.</span></span><span data-ttu-id="427f9-721">\ ***NX_ARP_EXPIRATION_RATE** _ задает время (в секундах), в течение которого установленное сопоставление IP-адреса с физическим адресом остается действительным.</span><span class="sxs-lookup"><span data-stu-id="427f9-721">\ ***NX_ARP_EXPIRATION_RATE** _ specifies the number of seconds an established IP address to physical mapping stays valid.</span></span> <span data-ttu-id="427f9-722">После истечения срока действия запись ARP удаляется из кэша ARP.</span><span class="sxs-lookup"><span data-stu-id="427f9-722">After expiration, the ARP entry is removed from the ARP cache.</span></span> <span data-ttu-id="427f9-723">Следующая попытка отправить на соответствующий IP-адрес приведет к появлению нового запроса ARP.</span><span class="sxs-lookup"><span data-stu-id="427f9-723">The next attempt to send to the corresponding IP address will result in a new ARP request.</span></span> <span data-ttu-id="427f9-724">Установка нулевого значения для _ *_NX_ARP_EXPIRATION_RATE_*\* отключает устаревание ARP (конфигурация по умолчанию).</span><span class="sxs-lookup"><span data-stu-id="427f9-724">Setting _ *_NX_ARP_EXPIRATION_RATE_*\* to zero disables ARP aging, which is the default configuration.</span></span>

### <a name="arp-defend"></a><span data-ttu-id="427f9-725">Защита ARP</span><span class="sxs-lookup"><span data-stu-id="427f9-725">ARP Defend</span></span>

<span data-ttu-id="427f9-726">Когда получен запрос ARP или пакет ответа ARP, а отправитель имеет тот же IP-адрес, который конфликтует с IP-адресом этого узла, NetX Duo отправляет запрос ARP для этого адреса в качестве защиты.</span><span class="sxs-lookup"><span data-stu-id="427f9-726">When an ARP request or ARP response packet is received and the sender has the same IP address, which conflicts with the IP address of this node, NetX Duo sends an ARP request for that address as a defense.</span></span> <span data-ttu-id="427f9-727">Если конфликтный пакет ARP получен более одного раза в течение 10 секунд, NetX Duo не отправляет больше пакетов защиты.</span><span class="sxs-lookup"><span data-stu-id="427f9-727">If the conflict ARP packet is received more than once in 10 seconds, NetX Duo does not send more defend packets.</span></span> <span data-ttu-id="427f9-728">Заданный по умолчанию интервал в 10 секунд можно переопределить с помощью \***NX_ARP_DEFEND_INTERVAL** _.</span><span class="sxs-lookup"><span data-stu-id="427f9-728">The default interval 10 seconds can be redefined by \***NX_ARP_DEFEND_INTERVAL** _.</span></span> <span data-ttu-id="427f9-729">Это поведение соответствует политике, заданной в разделе 2.4(c) RFC5227.</span><span class="sxs-lookup"><span data-stu-id="427f9-729">This behavior follows the policy specified in 2.4(c) of RFC5227.</span></span> <span data-ttu-id="427f9-730">Так как Windows XP игнорирует объявление ARP как ответ на пробу ARP, пользователь может определить _ *_NX_ARP_DEFEND_BY_REPLY_*\* для отправки ответа ARP в качестве дополнительной защиты.</span><span class="sxs-lookup"><span data-stu-id="427f9-730">Since Windows XP ignores ARP announcement as a response for its ARP probe, user can define _ *_NX_ARP_DEFEND_BY_REPLY_*\* to send ARP response as additional defence.</span></span>

### <a name="arp-statistics-and-errors"></a><span data-ttu-id="427f9-731">Статистические показатели и ошибки ARP</span><span class="sxs-lookup"><span data-stu-id="427f9-731">ARP Statistics and Errors</span></span>

<span data-ttu-id="427f9-732">Если этот параметр включен, программное обеспечение ARP NetX Duo отслеживает несколько статистических показателей и ошибок, которые могут быть полезны для приложения.</span><span class="sxs-lookup"><span data-stu-id="427f9-732">If enabled, the NetX Duo ARP software keeps track of several statistics and errors that may be useful to the application.</span></span> <span data-ttu-id="427f9-733">Для каждой обработки ARP в IP-экземпляре поддерживаются следующие статистические показатели и отчеты об ошибках:</span><span class="sxs-lookup"><span data-stu-id="427f9-733">The following statistics and error reports are maintained for each IP's ARP processing:</span></span>

- <span data-ttu-id="427f9-734">общее число отправленных запросов ARP;</span><span class="sxs-lookup"><span data-stu-id="427f9-734">Total ARP Requests Sent</span></span>
- <span data-ttu-id="427f9-735">общее число полученных запросов ARP;</span><span class="sxs-lookup"><span data-stu-id="427f9-735">Total ARP Requests Received</span></span>
- <span data-ttu-id="427f9-736">общее число отправленных ответов ARP;</span><span class="sxs-lookup"><span data-stu-id="427f9-736">Total ARP Responses Sent</span></span> 
- <span data-ttu-id="427f9-737">общее число полученных ответов ARP;</span><span class="sxs-lookup"><span data-stu-id="427f9-737">Total ARP Responses Received</span></span> 
- <span data-ttu-id="427f9-738">общее число динамических записей ARP;</span><span class="sxs-lookup"><span data-stu-id="427f9-738">Total ARP Dynamic Entries</span></span> 
- <span data-ttu-id="427f9-739">общее число статических записей ARP;</span><span class="sxs-lookup"><span data-stu-id="427f9-739">Total ARP Static Entries</span></span> 
- <span data-ttu-id="427f9-740">общее число устаревших записей ARP;</span><span class="sxs-lookup"><span data-stu-id="427f9-740">Total ARP Aged Entries</span></span> 
- <span data-ttu-id="427f9-741">общее число недопустимых сообщений ARP.</span><span class="sxs-lookup"><span data-stu-id="427f9-741">Total ARP Invalid Messages</span></span> 

<span data-ttu-id="427f9-742">Все эти статистические показатели и отчеты об ошибках предоставляются приложению службой ***nx_ip_info_get***.</span><span class="sxs-lookup"><span data-stu-id="427f9-742">All these statistics and error reports are available to the application with the ***nx_arp_info_get*** service.</span></span>

## <a name="reverse-address-resolution-protocol-rarp-in-ipv4"></a><span data-ttu-id="427f9-743">Протокол обратного разрешения адресов (RARP) в экземпляре IPv4</span><span class="sxs-lookup"><span data-stu-id="427f9-743">Reverse Address Resolution Protocol (RARP) in IPv4</span></span>

<span data-ttu-id="427f9-744">Протокол обратного разрешения адресов (RARP) — это протокол для запроса сетевого назначения 32-разрядных IP-адресов узла (RFC 903).</span><span class="sxs-lookup"><span data-stu-id="427f9-744">The Reverse Address Resolution Protocol (RARP) is the protocol for requesting network assignment of the host's 32-bit IP addresses (RFC 903).</span></span> <span data-ttu-id="427f9-745">Для этого используется запрос RARP, который периодически повторяется, пока элемент сети не присвоит IP-адрес сетевому интерфейсу узла в ответе RARP.</span><span class="sxs-lookup"><span data-stu-id="427f9-745">This is done through an RARP request and continues periodically until a network member assigns an IP address to the host network interface in an RARP response.</span></span> <span data-ttu-id="427f9-746">Приложение создает IP-экземпляр с нулевым IP-адресом с помощью службы ***nx_ip_create***.</span><span class="sxs-lookup"><span data-stu-id="427f9-746">The application creates an IP instance by the service ***nx_ip_create*** with a zero IP address.</span></span> <span data-ttu-id="427f9-747">Если в приложении включен протокол RARP, оно может использовать протокол RARP для запроса IP-адреса у сетевого сервера, доступного через интерфейс с нулевым IP-адресом.</span><span class="sxs-lookup"><span data-stu-id="427f9-747">If RARP is enabled by the application, it can use the RARP protocol to request an IP address from the network server accessible through the interface that has a zero IP address.</span></span>

### <a name="rarp-enable"></a><span data-ttu-id="427f9-748">Включение RARP</span><span class="sxs-lookup"><span data-stu-id="427f9-748">RARP Enable</span></span>

<span data-ttu-id="427f9-749">Чтобы использовать RARP, приложение должно создать IP-экземпляр с нулевым IP-адресом, а затем включить RARP с помощью службы ***nx_rarp_enable***.</span><span class="sxs-lookup"><span data-stu-id="427f9-749">To use RARP, the application must create the IP instance with an IP address of zero, then enable RARP using the service ***nx_rarp_enable***.</span></span> <span data-ttu-id="427f9-750">Для систем с множественной адресацией по крайней мере одно сетевое устройство, связанное с IP-экземпляром, должно иметь IP-адрес, равный нулю.</span><span class="sxs-lookup"><span data-stu-id="427f9-750">For multihome systems, at least one network device associated with the IP instance must have an IP address of zero.</span></span> <span data-ttu-id="427f9-751">Обработка RARP периодически отправляет сообщения запроса RARP для системы NetX Duo, требуя IP-адрес, пока не будет получен допустимый RARP ответ с назначенным сетевым IP-адресом.</span><span class="sxs-lookup"><span data-stu-id="427f9-751">The RARP processing periodically sends RARP request messages for the NetX Duo system requiring an IP address until a valid RARP reply with the network designated IP address is received.</span></span> <span data-ttu-id="427f9-752">На этом обработка RARP завершается.</span><span class="sxs-lookup"><span data-stu-id="427f9-752">At this point, RARP processing is complete.</span></span>

<span data-ttu-id="427f9-753">После включения протокола RARP он автоматически отключается после разрешения всех адресов интерфейсов.</span><span class="sxs-lookup"><span data-stu-id="427f9-753">After RARP has been enabled, it is disabled automatically after all interface addresses are resolved.</span></span> <span data-ttu-id="427f9-754">Приложение может принудительно завершить использование RARP с помощью службы ***nx_rarp_disable***.</span><span class="sxs-lookup"><span data-stu-id="427f9-754">The application may force RARP to terminate by using the service ***nx_rarp_disable***.</span></span>

### <a name="rarp-request"></a><span data-ttu-id="427f9-755">Запрос RARP</span><span class="sxs-lookup"><span data-stu-id="427f9-755">RARP Request</span></span>

<span data-ttu-id="427f9-756">Формат пакета запроса службы практически идентичен формату пакета ARP, показанному на [рис. 6](#arp-messages). Единственное отличие заключается в том, что значение поля типа кадра равно 0x8035, а значение поля *Код операции* равно 3, что соответствует запросу RARP.</span><span class="sxs-lookup"><span data-stu-id="427f9-756">The format of an RARP request packet is almost identical to the ARP packet shown in [Figure 6](#arp-messages).The only difference is the frame type field is 0x8035 and the *Operation Code* field is 3, designating an RARP request.</span></span> <span data-ttu-id="427f9-757">Как упоминалось ранее, запросы RARP будут отправляться периодически (каждые ***NX_RARP_UPDATE_RATE*** секунд) до получения ответа RARP с назначенным сетью IP-адресом.</span><span class="sxs-lookup"><span data-stu-id="427f9-757">As mentioned previously, RARP requests will be sent periodically (every ***NX_RARP_UPDATE_RATE*** seconds) until a RARP reply with the network assigned IP address is received.</span></span>

> [!NOTE]
> <span data-ttu-id="427f9-758">*Все сообщения RARP в реализации TCP/IP должны быть представлены в формате с **обратным порядком байтов**. В этом формате наиболее значимый байт слова размещается по наименьшему байтовому адресу.*</span><span class="sxs-lookup"><span data-stu-id="427f9-758">*All RARP messages in the TCP/IP implementation are expected to be in **big endian** format. In this format, the most significant byte of the word resides at the lowest byte address.*</span></span>

### <a name="rarp-reply"></a><span data-ttu-id="427f9-759">Ответ RARP</span><span class="sxs-lookup"><span data-stu-id="427f9-759">RARP Reply</span></span>

<span data-ttu-id="427f9-760">Сообщения с ответами RARP принимаются из сети и содержат IP-адрес, назначенный сетью этому узлу.</span><span class="sxs-lookup"><span data-stu-id="427f9-760">RARP reply messages are received from the network and contain the network assigned IP address for this host.</span></span> <span data-ttu-id="427f9-761">Формат пакета ответа RARP практически идентичен формату пакета ARP, показанному на рис. 6.</span><span class="sxs-lookup"><span data-stu-id="427f9-761">The format of an RARP reply packet is almost identical to the ARP packet shown in Figure 6.</span></span> <span data-ttu-id="427f9-762">Единственное отличие заключается в том, что значение поля типа кадра равно 0x8035, а значение поля *Код операции* равно 4, что соответствует ответу RARP.</span><span class="sxs-lookup"><span data-stu-id="427f9-762">The only difference is the frame type field is 0x8035 and the *Operation Code* field is 4, which designates an RARP reply.</span></span> <span data-ttu-id="427f9-763">После получения ответа в IP-экземпляре настраивается IP-адрес, отключается периодическая отправка запроса RARP, а IP-экземпляр переходит в состояние готовности к нормальной работе в сети.</span><span class="sxs-lookup"><span data-stu-id="427f9-763">After received, the IP address is setup in the IP instance, the periodic RARP request is disabled, and the IP instance is now ready for normal network operation.</span></span>

<span data-ttu-id="427f9-764">Для узлов с множественной адресацией IP-адрес применяется к запрашивающему сетевому интерфейсу.</span><span class="sxs-lookup"><span data-stu-id="427f9-764">For multihome hosts, the IP address is applied to the requesting network interface.</span></span> <span data-ttu-id="427f9-765">Если есть другие сетевые интерфейсы, которые по-прежнему запрашивают назначение IP-адресов, периодическое обслуживание RARP продолжается до тех пор, пока не будут разрешены все запросы IP-адресов интерфейса.</span><span class="sxs-lookup"><span data-stu-id="427f9-765">If there are other network interfaces still requesting an IP address assignment, the periodic RARP service continues until all interface IP address requests are resolved.</span></span>

> [!NOTE]
> <span data-ttu-id="427f9-766">*Приложение не должно использовать IP-экземпляр до завершения обработки RARP. Приложения могут использовать **nx_ip_status_check** для ожидания завершения RARP. Для систем с множественной адресацией приложение не должно использовать запрашивающий интерфейс до завершения обработки RARP на этом интерфейсе. Состояние IP-адреса на вторичном устройстве можно проверить с помощью службы **nx_ip_interface_status_check**.*</span><span class="sxs-lookup"><span data-stu-id="427f9-766">*The application should not use the IP instance until the RARP processing is complete. The **nx_ip_status_check** may be used by applications to wait for the RARP completion. For multihome systems, the application should not use the requesting interface until the RARP processing is complete on that interface. Status of the IP address on the secondary device can be checked with the **nx_ip_interface_status_check** service.*</span></span>

### <a name="rarp-statistics-and-errors"></a><span data-ttu-id="427f9-767">Статистические показатели и ошибки RARP</span><span class="sxs-lookup"><span data-stu-id="427f9-767">RARP Statistics and Errors</span></span>

<span data-ttu-id="427f9-768">Если этот параметр включен, программное обеспечение RARP NetX Duo отслеживает несколько статистических показателей и ошибок, которые могут быть полезны для приложения.</span><span class="sxs-lookup"><span data-stu-id="427f9-768">If enabled, the NetX Duo RARP software keeps track of several statistics and errors that may be useful to the application.</span></span> <span data-ttu-id="427f9-769">Для каждой обработки RARP в IP-экземпляре поддерживаются следующие статистические показатели и отчеты об ошибках:</span><span class="sxs-lookup"><span data-stu-id="427f9-769">The following statistics and error reports are maintained for each IP's RARP processing:</span></span>

- <span data-ttu-id="427f9-770">общее число отправленных запросов RARP;</span><span class="sxs-lookup"><span data-stu-id="427f9-770">Total RARP Requests Sent</span></span>
- <span data-ttu-id="427f9-771">общее число полученных ответов RARP;</span><span class="sxs-lookup"><span data-stu-id="427f9-771">Total RARP Responses Received</span></span>
- <span data-ttu-id="427f9-772">общее число недопустимых сообщений RARP.</span><span class="sxs-lookup"><span data-stu-id="427f9-772">Total RARP Invalid Messages</span></span>

<span data-ttu-id="427f9-773">Все эти статистические показатели и отчеты об ошибках предоставляются приложению службой ***nx_rarp_info_get***.</span><span class="sxs-lookup"><span data-stu-id="427f9-773">All these statistics and error reports are available to the application with the ***nx_rarp_info_get*** service.</span></span>

## <a name="internet-control-message-protocol-icmp"></a><span data-ttu-id="427f9-774">Протокол межсетевых управляющих сообщений (ICMP)</span><span class="sxs-lookup"><span data-stu-id="427f9-774">Internet Control Message Protocol (ICMP)</span></span>

<span data-ttu-id="427f9-775">Применение протокола межсетевых управляющих сообщений для IPv4 (ICMP) ограничивается передачей сведений об ошибках и управлении между элементами IP-сети.</span><span class="sxs-lookup"><span data-stu-id="427f9-775">Internet Control Message Protocol for IPv4 (ICMP) is limited to passing error and control information between IP network members.</span></span> <span data-ttu-id="427f9-776">Протокол обмена сообщениями в Интернете для протокола IPv6 (ICMPv6) также обрабатывает сведения об ошибках и управлении и требуется для протоколов разрешения адресов, таких как обнаружение повторяющихся адресов (DAD) и автонастройка адресов без отслеживания состояния.</span><span class="sxs-lookup"><span data-stu-id="427f9-776">Internet Control Message Protocol for IPv6 (ICMPv6) also handles error and control information and is required for address resolution protocols such as Duplicate Address Detection (DAD) and stateless address autoconfiguration.</span></span>

<span data-ttu-id="427f9-777">Как и на большинстве других уровней приложений (например, TCP/IP), сообщения ICMP и ICMPv6 инкапсулируются в заголовке IP с помощью обозначения протокола ICMP (или ICMPv6).</span><span class="sxs-lookup"><span data-stu-id="427f9-777">Like most other application layer (e.g., TCP/IP) messages, ICMP and ICMPv6 messages are encapsulated by an IP header with the ICMP (or ICMPv6) protocol designation.</span></span>

### <a name="icmp-statistics-and-errors"></a><span data-ttu-id="427f9-778">Статистические показатели и ошибки ICMP</span><span class="sxs-lookup"><span data-stu-id="427f9-778">ICMP Statistics and Errors</span></span>

<span data-ttu-id="427f9-779">Если этот параметр включен, NetX Duo отслеживает несколько статистических показателей ICMP и ошибок, которые могут быть полезны для приложения.</span><span class="sxs-lookup"><span data-stu-id="427f9-779">If enabled, NetX Duo keeps track of several ICMP statistics and errors that may be useful to the application.</span></span> <span data-ttu-id="427f9-780">Для каждой обработки ICMP в IP-экземпляре поддерживаются следующие статистические показатели и отчеты об ошибках:</span><span class="sxs-lookup"><span data-stu-id="427f9-780">The following statistics and error reports are maintained for each IP's ICMP processing:</span></span> 

- <span data-ttu-id="427f9-781">общее число отправленных запросов проверки связи ICMP;</span><span class="sxs-lookup"><span data-stu-id="427f9-781">Total ICMP Pings Sent</span></span>  
- <span data-ttu-id="427f9-782">общее число случаев истечения времени ожидания проверки связи ICMP;</span><span class="sxs-lookup"><span data-stu-id="427f9-782">Total ICMP Ping Timeouts</span></span> 
- <span data-ttu-id="427f9-783">общее число приостановленных потоков проверки связи ICMP;</span><span class="sxs-lookup"><span data-stu-id="427f9-783">Total ICMP Ping Threads Suspended</span></span> 
- <span data-ttu-id="427f9-784">общее число полученных ответов проверки связи ICMP;</span><span class="sxs-lookup"><span data-stu-id="427f9-784">Total ICMP Ping Responses Received</span></span> 
- <span data-ttu-id="427f9-785">общее число ошибок контрольной суммы ICMP;</span><span class="sxs-lookup"><span data-stu-id="427f9-785">Total ICMP Checksum Errors</span></span> 
- <span data-ttu-id="427f9-786">общее число необработанных сообщений ICMP.</span><span class="sxs-lookup"><span data-stu-id="427f9-786">Total ICMP Unhandled Messages</span></span> 

<span data-ttu-id="427f9-787">Все эти статистические показатели и отчеты об ошибках предоставляются приложению службой ***nx_icmp_info_get***.</span><span class="sxs-lookup"><span data-stu-id="427f9-787">All these statistics and error reports are available to the application with the ***nx_icmp_info_get*** service.</span></span>

## <a name="icmpv4-services-in-netx-duo"></a><span data-ttu-id="427f9-788">Службы ICMPv4 в NetX Duo</span><span class="sxs-lookup"><span data-stu-id="427f9-788">ICMPv4 Services in NetX Duo</span></span>

### <a name="icmpv4-enable"></a><span data-ttu-id="427f9-789">Включение ICMPv4</span><span class="sxs-lookup"><span data-stu-id="427f9-789">ICMPv4 Enable</span></span>

<span data-ttu-id="427f9-790">Прежде чем сообщения ICMPv4 могут быть обработаны NetX Duo, приложение должно вызвать службу ***nx_icmp_enable***, чтобы включить обработку ICMPv4.</span><span class="sxs-lookup"><span data-stu-id="427f9-790">Before ICMPv4 messages can be processed by NetX Duo, the application must call the ***nx_icmp_enable*** service to enable ICMPv4 processing.</span></span> <span data-ttu-id="427f9-791">После этого приложение может отправить запросы проверки связи и принять входящие пакеты проверки связи.</span><span class="sxs-lookup"><span data-stu-id="427f9-791">After this is done, the application can issue ping requests and field incoming ping packets.</span></span>  

### <a name="icmpv4-echo-request"></a><span data-ttu-id="427f9-792">Эхо-запрос ICMPv4</span><span class="sxs-lookup"><span data-stu-id="427f9-792">ICMPv4 Echo Request</span></span>

<span data-ttu-id="427f9-793">Запрос проверки связи — это один из типов сообщений ICMPv4, который обычно используется для проверки существования определенного узла в сети, идентифицируемого по IP-адресу узла.</span><span class="sxs-lookup"><span data-stu-id="427f9-793">An echo request is one type of ICMPv4 message that is typically used to check for the existence of a specific node on the network, as identified by its host IP address.</span></span> <span data-ttu-id="427f9-794">Популярная команда проверки связи реализуется с помощью сообщений с запросами проверки связи и ответами на них.</span><span class="sxs-lookup"><span data-stu-id="427f9-794">The popular ping command is implemented using ICMP echo request/echo reply messages.</span></span> <span data-ttu-id="427f9-795">При наличии конкретного узла его сетевой стек обрабатывает запрос проверки связи и ответы на него с помощью ответа на команду проверки связи.</span><span class="sxs-lookup"><span data-stu-id="427f9-795">If the specific host is present, its network stack processes the ping request and responses with a ping response.</span></span> <span data-ttu-id="427f9-796">На рис. 7 подробно описывается формат сообщения проверки связи ICMPv4.</span><span class="sxs-lookup"><span data-stu-id="427f9-796">Figure 7 details the ICMPv4 ping message format.</span></span>

![Сообщение проверки связи ICMPv4](./media/user-guide/icmpv4-ping-message.png)  

<span data-ttu-id="427f9-798">**РИС. 7. Сообщение проверки связи ICMPv4**</span><span class="sxs-lookup"><span data-stu-id="427f9-798">**FIGURE 7. ICMPv4 Ping Message**</span></span>

> [!NOTE]
> <span data-ttu-id="427f9-799">*Все сообщения ICMPv4 в реализации TCP/IP должны быть представлены в формате с **обратным порядком байтов**. В этом формате наиболее значимый байт слова размещается по наименьшему байтовому адресу.*</span><span class="sxs-lookup"><span data-stu-id="427f9-799">*All ICMPv4 messages in the TCP/IP implementation are expected to be in **big endian** format. In this format, the most significant byte of the word resides at the lowest byte address.*</span></span>

<span data-ttu-id="427f9-800">В следующей таблице описывается формат заголовка ICMPv4.</span><span class="sxs-lookup"><span data-stu-id="427f9-800">The following describes the ICMPv4 header format:</span></span>

|<span data-ttu-id="427f9-801">Поле заголовка</span><span class="sxs-lookup"><span data-stu-id="427f9-801">Header Field</span></span> |<span data-ttu-id="427f9-802">Назначение</span><span class="sxs-lookup"><span data-stu-id="427f9-802">Purpose</span></span> |
|---|---|
|<span data-ttu-id="427f9-803">**Тип**</span><span class="sxs-lookup"><span data-stu-id="427f9-803">**Type**</span></span> |<span data-ttu-id="427f9-804">В этом поле указывается сообщение ICMPv4 (биты 31–24).</span><span class="sxs-lookup"><span data-stu-id="427f9-804">This field specifies the ICMPv4 message (bits 31-24).</span></span> <span data-ttu-id="427f9-805">Чаще всего эти следующие сообщения:</span><span class="sxs-lookup"><span data-stu-id="427f9-805">The most common are:</span></span><br /><span data-ttu-id="427f9-806">0: ответ на запрос проверки связи;</span><span class="sxs-lookup"><span data-stu-id="427f9-806">-  0: Echo Reply</span></span><br /><span data-ttu-id="427f9-807">3: назначение недоступно;</span><span class="sxs-lookup"><span data-stu-id="427f9-807">- 3: Destination Unreachable</span></span><br /><span data-ttu-id="427f9-808">8: запрос проверки связи;</span><span class="sxs-lookup"><span data-stu-id="427f9-808">- 8: Echo Request</span></span><br /><span data-ttu-id="427f9-809">11: превышение времени;</span><span class="sxs-lookup"><span data-stu-id="427f9-809">- 11: Time Exceeded</span></span><br /><span data-ttu-id="427f9-810">12: проблема с параметром.</span><span class="sxs-lookup"><span data-stu-id="427f9-810">- 12: Parameter Problem</span></span> |
|<span data-ttu-id="427f9-811">**Код**</span><span class="sxs-lookup"><span data-stu-id="427f9-811">**Code**</span></span> |<span data-ttu-id="427f9-812">Это поле зависит от контекста в поле типа (биты 23–16).</span><span class="sxs-lookup"><span data-stu-id="427f9-812">This field is context specific on the type field (bits 23-16).</span></span> <span data-ttu-id="427f9-813">Для запроса проверки связи или ответа на него код имеет значение 0.</span><span class="sxs-lookup"><span data-stu-id="427f9-813">For an echo request or reply the code is set to zero.</span></span>|
|<span data-ttu-id="427f9-814">**Контрольная сумма**</span><span class="sxs-lookup"><span data-stu-id="427f9-814">**Checksum**</span></span> |<span data-ttu-id="427f9-815">Это поле содержит 16-разрядную контрольную сумму для суммы, дополняющей единицу, в сообщении ICMPv4, включая весь заголовок ICMPv4, начинающийся с поля типа.</span><span class="sxs-lookup"><span data-stu-id="427f9-815">This field contains the 16-bit checksum of the one's complement sum of the ICMPv4 message including the entire the ICMPv4 header starting with the Type field.</span></span> <span data-ttu-id="427f9-816">Перед созданием контрольной суммы поле контрольной суммы очищается.</span><span class="sxs-lookup"><span data-stu-id="427f9-816">Before generating the checksum, the checksum field is cleared.</span></span>|
|<span data-ttu-id="427f9-817">**Идентификация**</span><span class="sxs-lookup"><span data-stu-id="427f9-817">**Identification**</span></span> | <span data-ttu-id="427f9-818">Это поле содержит значение идентификатора, по которому можно определить узел. Для узла должен использоваться идентификатор, извлеченный из запроса проверки связи и ответа на него (биты 31–16).</span><span class="sxs-lookup"><span data-stu-id="427f9-818">This field contains an ID value identifying the host; a host should use the ID extracted from an ECHO request in the ECHO REPLY (bits 31-16).</span></span>|
|<span data-ttu-id="427f9-819">**Порядковый номер**</span><span class="sxs-lookup"><span data-stu-id="427f9-819">**Sequence number**</span></span> |<span data-ttu-id="427f9-820">Это поле содержит значение идентификатора. Для узла должен использоваться идентификатор, извлеченный из запроса проверки связи и ответа на него (биты 31–16).</span><span class="sxs-lookup"><span data-stu-id="427f9-820">This field contains an ID value; a host should use the ID extracted from an ECHO request in the ECHO REPLY (bits 31-16).</span></span> <span data-ttu-id="427f9-821">В отличие от поля идентификатора, это значение изменится в последующем запросе проверки связи, отправленном с того же узла (биты 15–0).</span><span class="sxs-lookup"><span data-stu-id="427f9-821">Unlike the identifier field, this value will change in a subsequent Echo request from the same host (bits 15-0).</span></span>|

### <a name="icmpv4-echo-response"></a><span data-ttu-id="427f9-822">Эхо-ответ ICMPv4</span><span class="sxs-lookup"><span data-stu-id="427f9-822">ICMPv4 Echo Response</span></span>    
<span data-ttu-id="427f9-823">Ответ на запрос проверки связи — это еще один тип сообщения ICMP, который создается внутренними средствами с помощью компонента ICMP в ответ на внешний запрос проверки связи.</span><span class="sxs-lookup"><span data-stu-id="427f9-823">A ping response is another type of ICMP message that is generated internally by the ICMP component in response to an external ping request.</span></span> <span data-ttu-id="427f9-824">Кроме подтверждения, ответ на запрос проверки связи также содержит копию данных пользователя, содержащихся в запросе проверки связи.</span><span class="sxs-lookup"><span data-stu-id="427f9-824">In addition to acknowledgement, the ping response also contains a copy of the user data supplied in the ping request.</span></span>

### <a name="icmpv4-error-messages"></a><span data-ttu-id="427f9-825">Сообщения об ошибках ICMPv4</span><span class="sxs-lookup"><span data-stu-id="427f9-825">ICMPv4 Error Messages</span></span>   
<span data-ttu-id="427f9-826">В NetX Duo поддерживаются следующие сообщения об ошибках ICMPv4:</span><span class="sxs-lookup"><span data-stu-id="427f9-826">The following ICMPv4 error messages are supported in NetX Duo:</span></span> 
- <span data-ttu-id="427f9-827">Объект назначения недоступен</span><span class="sxs-lookup"><span data-stu-id="427f9-827">Destination Unreachable</span></span> 
- <span data-ttu-id="427f9-828">Время превышено</span><span class="sxs-lookup"><span data-stu-id="427f9-828">Time Exceed</span></span> 
- <span data-ttu-id="427f9-829">Проблема с параметром</span><span class="sxs-lookup"><span data-stu-id="427f9-829">Parameter Problem</span></span>

## <a name="internet-group-management-protocol-igmp"></a><span data-ttu-id="427f9-830">протокол управления группами Интернета (IGMP)</span><span class="sxs-lookup"><span data-stu-id="427f9-830">Internet Group Management Protocol (IGMP)</span></span>

<span data-ttu-id="427f9-831">Протокол управления группами Интернета (IGMP) предоставляет устройству возможность взаимодействовать с его соседями и маршрутизаторами, связь с которыми он намеревается установить. Иными словами, он позволяет присоединиться к группе многоадресной рассылки по протоколу IPv4 (RFC 1112 и RFC 2236).</span><span class="sxs-lookup"><span data-stu-id="427f9-831">The Internet Group Management Protocol (IGMP) provides a device to communicate with its neighbors and its routers that it intends to receive, or join, an IPv4 multicast group (RFC 1112 and RFC 2236).</span></span> <span data-ttu-id="427f9-832">Группа многоадресной рассылки, по сути, является динамической коллекцией сетевых элементов и представляется IP-адресом класса D.</span><span class="sxs-lookup"><span data-stu-id="427f9-832">A multicast group is basically a dynamic collection of network members and is represented by a Class D IP address.</span></span> <span data-ttu-id="427f9-833">Группа многоадресной рассылки поддерживает исключение из нее текущих элементов и присоединение новых в любое время.</span><span class="sxs-lookup"><span data-stu-id="427f9-833">Members of the multicast group may leave at any time, and new members may join at any time.</span></span> <span data-ttu-id="427f9-834">За координацию, связанную с присоединением к группе и выходом из нее, отвечает IGMP.</span><span class="sxs-lookup"><span data-stu-id="427f9-834">The coordination involved in joining and leaving the group is the responsibility of IGMP.</span></span>

> [!NOTE]
> <span data-ttu-id="427f9-835">*Протокол IGMP предназначен только для групп многоадресной рассылки IPv4. Его нельзя использовать в сети IPv6.*</span><span class="sxs-lookup"><span data-stu-id="427f9-835">*IGMP is designed only for IPv4 multicast groups. It cannot be used on the IPv6 network.*</span></span>

### <a name="igmp-enable"></a><span data-ttu-id="427f9-836">Включение IGMP</span><span class="sxs-lookup"><span data-stu-id="427f9-836">IGMP Enable</span></span>     
<span data-ttu-id="427f9-837">Прежде чем выполнить какую-либо многоадресную операцию в NetX Duo, приложение должно вызвать службу ***nx_igmp_enable***.</span><span class="sxs-lookup"><span data-stu-id="427f9-837">Before any multicasting activity can take place in NetX Duo, the application must call the ***nx_igmp_enable*** service.</span></span> <span data-ttu-id="427f9-838">Эта служба выполняет базовую инициализацию IGMP при подготовке запросов многоадресной рассылки.</span><span class="sxs-lookup"><span data-stu-id="427f9-838">This service performs basic IGMP initialization in preparation for multicast requests.</span></span>

### <a name="multicast-ipv4-addressing"></a><span data-ttu-id="427f9-839">Многоадресная адресация IPv4</span><span class="sxs-lookup"><span data-stu-id="427f9-839">Multicast IPv4 Addressing</span></span>  
<span data-ttu-id="427f9-840">Как упоминалось ранее, адреса многоадресной рассылки фактически представляют собой IP-адреса класса D, как показано на [рис. 4](#ipv4-addresses).</span><span class="sxs-lookup"><span data-stu-id="427f9-840">As mentioned previously, multicast addresses are actually Class D IP addresses as shown in [Figure 4](#ipv4-addresses).</span></span> <span data-ttu-id="427f9-841">Младшие 28 разрядов адреса класса D соответствуют идентификатору группы многоадресной рассылки.</span><span class="sxs-lookup"><span data-stu-id="427f9-841">The lower 28-bits of the Class D address correspond to the multicast group ID.</span></span> <span data-ttu-id="427f9-842">Существует ряд предварительно определенных адресов многоадресной рассылки. Однако *адрес всех узлов* (244.0.0.1) особенно важен для обработки IGMP.</span><span class="sxs-lookup"><span data-stu-id="427f9-842">There are a series of pre-defined multicast addresses; however, the *all hosts address* (244.0.0.1) is particularly important to IGMP processing.</span></span> <span data-ttu-id="427f9-843">*Адрес всех узлов* используется маршрутизаторами для запроса у участников многоадресной рассылки отчетов о том, к каким группам многоадресной рассылки они принадлежат.</span><span class="sxs-lookup"><span data-stu-id="427f9-843">The *all hosts address* is used by routers to query all multicast members to report on which multicast groups they belong to.</span></span>  

### <a name="physical-address-mapping-in-ipv4"></a><span data-ttu-id="427f9-844">Сопоставление физических адресов в IPv4</span><span class="sxs-lookup"><span data-stu-id="427f9-844">Physical Address Mapping in IPv4</span></span>
<span data-ttu-id="427f9-845">Адреса многоадресной рассылки класса D сопоставляются непосредственно с физическими адресами Ethernet в диапазоне от 01.00.5e.00.00.00 до 01.00.5e.7f.ff.ff.</span><span class="sxs-lookup"><span data-stu-id="427f9-845">Class D multicast addresses map directly to physical Ethernet addresses ranging from 01.00.5e.00.00.00 through 01.00.5e.7f.ff.ff.</span></span> <span data-ttu-id="427f9-846">Младшие 23 бита IP-адреса многоадресной рассылки сопоставляются непосредственно с младшими 23 битами адреса Ethernet.</span><span class="sxs-lookup"><span data-stu-id="427f9-846">The lower 23 bits of the IP multicast address map directly to the lower 23 bits of the Ethernet address.</span></span>

### <a name="multicast-group-join"></a><span data-ttu-id="427f9-847">Присоединение к группе многоадресной рассылки</span><span class="sxs-lookup"><span data-stu-id="427f9-847">Multicast Group Join</span></span>
<span data-ttu-id="427f9-848">Приложения, которым необходимо присоединиться к определенной группе многоадресной рассылки, могут сделать это, вызвав службу ***nx_igmp_multicast_join***.</span><span class="sxs-lookup"><span data-stu-id="427f9-848">Applications that need to join a particular multicast group may do so by calling the ***nx_igmp_multicast_join*** service.</span></span> <span data-ttu-id="427f9-849">Эта служба отслеживает количество запросов на присоединение к данной группе многоадресной рассылки.</span><span class="sxs-lookup"><span data-stu-id="427f9-849">This service keeps track of the number of requests to join this multicast group.</span></span> <span data-ttu-id="427f9-850">Если это первый запрос приложения на присоединение к группе многоадресной рассылки, то в основной сети отправляется отчет IGMP, указывающий на то, что этот узел намерен присоединиться к группе.</span><span class="sxs-lookup"><span data-stu-id="427f9-850">If this is the first application requestto join the multicast group, an IGMP report is sent out on the primary network indicating this host's intention to join the group.</span></span> <span data-ttu-id="427f9-851">Затем, чтобы настроить ожидание передачи данных пакетов с адресом Ethernet для этой группы многоадресной рассылки, вызывается драйвер сети.</span><span class="sxs-lookup"><span data-stu-id="427f9-851">Next, the network driver is called to set up for listening for packets with the Ethernet address for this multicast group.</span></span>

<span data-ttu-id="427f9-852">Если в системе с множественной адресацией группа многоадресной рассылки доступна через конкретный интерфейс, приложение должно использовать службу ***nx_igmp_multicast_interface_join** _ вместо службы _*_nx_igmp_multicast_join_\*\*, действие которой ограничено группами многоадресной рассылки в основной сети.</span><span class="sxs-lookup"><span data-stu-id="427f9-852">In a multihome system, if the multicast group is accessible via a specific interface, application shall use the service ***nx_igmp_multicast_interface_join** _ instead of _*_nx_igmp_multicast_join_\*\*, which is limited to multicast groups on the primary network.</span></span>

### <a name="multicast-group-leave"></a><span data-ttu-id="427f9-853">Выход из группы многоадресной рассылки</span><span class="sxs-lookup"><span data-stu-id="427f9-853">Multicast Group Leave</span></span>   
<span data-ttu-id="427f9-854">Приложения, которым необходимо выйти из группы многоадресной рассылки, к которой они присоединились ранее, могут сделать это, вызвав службу ***nx_igmp_multicast_leave***.</span><span class="sxs-lookup"><span data-stu-id="427f9-854">Applications that need to leave a previously joined multicast group may do so by calling the ***nx_igmp_multicast_leave*** service.</span></span> <span data-ttu-id="427f9-855">Эта служба уменьшает значение внутреннего счетчика, связанного с числом операций присоединения к группе.</span><span class="sxs-lookup"><span data-stu-id="427f9-855">This service reduces the internal count associated with how many times the group was joined.</span></span> <span data-ttu-id="427f9-856">При отсутствии необработанных запросов на присоединение к группе вызывается драйвер сети для отключения ожидания передачи данных пакетов с адресом Ethernet этой группы многоадресной рассылки.</span><span class="sxs-lookup"><span data-stu-id="427f9-856">If there are no outstanding join requests for a group, the network driver is called to disable listening for packets with this multicast group's Ethernet address.</span></span>

### <a name="multicast-loopback"></a><span data-ttu-id="427f9-857">Многоадресное замыкание на себя</span><span class="sxs-lookup"><span data-stu-id="427f9-857">Multicast Loopback</span></span>    
<span data-ttu-id="427f9-858">Приложению может потребоваться получать трафик многоадресной рассылки из одного из источников, находящихся на том же узле.</span><span class="sxs-lookup"><span data-stu-id="427f9-858">An application may wish to receive multicast traffic originated from one of the sources on the same node.</span></span> <span data-ttu-id="427f9-859">Для этого требуется включить для компонента многоадресной рассылки в IP-экземпляре замыкание на себя с помощью службы ***nx_igmp_loopback_enable***.</span><span class="sxs-lookup"><span data-stu-id="427f9-859">This requires the IP multicast component to have loopback enabled by using the service ***nx_igmp_loopback_enable***.</span></span>

### <a name="igmp-report-message"></a><span data-ttu-id="427f9-860">Сообщение с отчетом IGMP</span><span class="sxs-lookup"><span data-stu-id="427f9-860">IGMP Report Message</span></span>      
<span data-ttu-id="427f9-861">Когда приложение присоединяется к группе многоадресной рассылки, в сети отправляется сообщение с отчетом IGMP, указывающее на намерение узла присоединиться к определенной группе многоадресной рассылки.</span><span class="sxs-lookup"><span data-stu-id="427f9-861">When the application joins a multicast group, an IGMP report message is sent via the network to indicate the host's intention to join a particular multicast group.</span></span> <span data-ttu-id="427f9-862">Формат сообщения с отчетом IGMP показан на рис. 8.</span><span class="sxs-lookup"><span data-stu-id="427f9-862">The format of the IGMP report message is shown in Figure 8.</span></span> <span data-ttu-id="427f9-863">Для сообщения группы в сообщении с отчетом IGMP и IP-адреса назначения используется адрес группы многоадресной рассылки.</span><span class="sxs-lookup"><span data-stu-id="427f9-863">The multicast group address is used for both the group message in the IGMP report message and the destination IP address.</span></span>

<span data-ttu-id="427f9-864">На рисунке выше (рис. 8) заголовок IGMP содержит поле версии/типа, максимальный ответ</span><span class="sxs-lookup"><span data-stu-id="427f9-864">In the figure above (Figure 8), the IGMP header contains a version/type field, maximum response</span></span>

![Схема сообщения отчета IGMP.](./media/user-guide/image17.jpg)

<span data-ttu-id="427f9-866">**РИС. 8. Сообщение с отчетом IGMP**</span><span class="sxs-lookup"><span data-stu-id="427f9-866">**FIGURE 8. IGMP Report Message**</span></span>

<span data-ttu-id="427f9-867">время, поле контрольной суммы и поле адреса группы многоадресной рассылки.</span><span class="sxs-lookup"><span data-stu-id="427f9-867">time, a checksum field, and a multicast group address field.</span></span> <span data-ttu-id="427f9-868">Для сообщений IGMPv1 значение поля максимального времени ответа всегда равно 0, так как оно не предусмотрено в протоколе IGMPv1.</span><span class="sxs-lookup"><span data-stu-id="427f9-868">For IGMPv1 messages, the Maximum Response Time field is always set to zero, as this is not part of the IGMPv1 protocol.</span></span> <span data-ttu-id="427f9-869">Поле максимального времени ответа задается, когда узел получает сообщение IGMP с типом запроса, и удаляется, когда узел получает сообщение с типом отчета другого узла, что предусмотрено определением протокола IGMPv2.</span><span class="sxs-lookup"><span data-stu-id="427f9-869">The Maximum Response Time field is set when the host receives a Query type IGMP message and cleared when a host receives another host's Report type message as defined by the IGMPv2 protocol.</span></span>

<span data-ttu-id="427f9-870">В следующей таблице описывается формат заголовка IGMP.</span><span class="sxs-lookup"><span data-stu-id="427f9-870">The following describes the IGMP header format:</span></span>

|<span data-ttu-id="427f9-871">Поле заголовка</span><span class="sxs-lookup"><span data-stu-id="427f9-871">Header Field</span></span>|<span data-ttu-id="427f9-872">Назначение</span><span class="sxs-lookup"><span data-stu-id="427f9-872">Purpose</span></span>|
|---|---|
|<span data-ttu-id="427f9-873">**Версия**</span><span class="sxs-lookup"><span data-stu-id="427f9-873">**Version**</span></span> |<span data-ttu-id="427f9-874">В этом поле указывается версия протокола IGMP (биты 31–28).</span><span class="sxs-lookup"><span data-stu-id="427f9-874">This field specifies the IGMP version (bits 31- 28).</span></span>|
|<span data-ttu-id="427f9-875">**Тип**</span><span class="sxs-lookup"><span data-stu-id="427f9-875">**Type**</span></span> |<span data-ttu-id="427f9-876">В этом поле указывается тип сообщения IGMP (биты 27–24).</span><span class="sxs-lookup"><span data-stu-id="427f9-876">This field specifies the type of IGMP message (bits 27 -24).</span></span>|
|<span data-ttu-id="427f9-877">**Максимальное время ответа**</span><span class="sxs-lookup"><span data-stu-id="427f9-877">**Maximum Response Time**</span></span> |<span data-ttu-id="427f9-878">Не используется в IGMP версии 1.</span><span class="sxs-lookup"><span data-stu-id="427f9-878">Not used in IGMP v1.</span></span> <span data-ttu-id="427f9-879">В IGMP версии 2 это поле служит для определения максимального времени ответа.</span><span class="sxs-lookup"><span data-stu-id="427f9-879">In IGMP v2 this field serves as the maximum response time.</span></span>|
|<span data-ttu-id="427f9-880">**Контрольная сумма**</span><span class="sxs-lookup"><span data-stu-id="427f9-880">**Checksum**</span></span> |<span data-ttu-id="427f9-881">Это поле содержит 16-разрядную контрольную сумму для суммы, дополняющей единицу, для сообщения IGMP, начинающегося с версии IGMP (биты 0–15).</span><span class="sxs-lookup"><span data-stu-id="427f9-881">This field contains the 16-bit checksum of the one's complement sum of the IGMP message starting with the IGMP version (bits 0-15)</span></span>|
|<span data-ttu-id="427f9-882">**Адрес группы**</span><span class="sxs-lookup"><span data-stu-id="427f9-882">**Group Address**</span></span> |<span data-ttu-id="427f9-883">32-разрядный IP-адрес группы класса D.</span><span class="sxs-lookup"><span data-stu-id="427f9-883">32-bit class D group IP address</span></span>|

<span data-ttu-id="427f9-884">Сообщения с отчетами IGMP отправляются в ответ на сообщения с запросами IGMP, отправляемые маршрутизатором многоадресной рассылки.</span><span class="sxs-lookup"><span data-stu-id="427f9-884">IGMP report messages are also sent in response to IGMP query messages sent by a multicast router.</span></span> <span data-ttu-id="427f9-885">Маршрутизаторы многоадресной рассылки периодически отправляют сообщения с запросами, чтобы установить, какие узлы все еще остаются в группе.</span><span class="sxs-lookup"><span data-stu-id="427f9-885">Multicast routers periodically send query messages out to see which hosts still require group membership.</span></span> <span data-ttu-id="427f9-886">Как показано на рис. 8, сообщения с запросами имеют тот же формат, что и сообщение с отчетами IGMP.</span><span class="sxs-lookup"><span data-stu-id="427f9-886">Query messages have the same format as the IGMP Report message shown in Figure 8.</span></span> <span data-ttu-id="427f9-887">Единственное отличие состоит в том, что тип IGMP равен 1, а поле адреса группы имеет значение 0.</span><span class="sxs-lookup"><span data-stu-id="427f9-887">The only differences are the IGMP type is equal to 1 and the group address field is set to 0.</span></span> <span data-ttu-id="427f9-888">Сообщения с запросами IGMP отправляются маршрутизатором многоадресной рассылки на IP-адрес *всех узлов*.</span><span class="sxs-lookup"><span data-stu-id="427f9-888">IGMP Query messages are sent to the *all hosts* IP address by the multicast router.</span></span> <span data-ttu-id="427f9-889">Узел, который по-прежнему хочет сохранить членство в группе, отправляет в ответ еще одно сообщение с отчетом IGMP.</span><span class="sxs-lookup"><span data-stu-id="427f9-889">A host that still wishes to maintain group membership responds by sending another IGMP Report message.</span></span>

> [!NOTE]
> <span data-ttu-id="427f9-890">*Все сообщения в реализации TCP/IP должны быть представлены в формате с **обратным порядком байтов**. В этом формате наиболее значимый байт слова размещается по наименьшему байтовому адресу.*</span><span class="sxs-lookup"><span data-stu-id="427f9-890">*All messages in the TCP/IP implementation are expected to be in **big endian** format. In this format, the most significant byte of the word resides at the lowest byte address.*</span></span>

### <a name="igmp-statistics-and-errors"></a><span data-ttu-id="427f9-891">Статистические показатели и ошибки IGMP</span><span class="sxs-lookup"><span data-stu-id="427f9-891">IGMP Statistics and Errors</span></span>    
<th><p><span data-ttu-id="427f9-892">Если этот параметр включен, программное обеспечение IGMP NetX Duo отслеживает несколько статистических показателей и ошибок, которые могут быть полезны для приложения.</span><span class="sxs-lookup"><span data-stu-id="427f9-892">If enabled, the NetX Duo IGMP software keeps track of several statistics and errors that may be useful to the application.</span></span> <span data-ttu-id="427f9-893">Для каждой обработки IGMP в IP-экземпляре поддерживаются следующие статистические показатели и отчеты об ошибках:</span><span class="sxs-lookup"><span data-stu-id="427f9-893">The following statistics and error reports are maintained for each IP's IGMP processing:</span></span> 

- <span data-ttu-id="427f9-894">общее число отправленных отчетов IGMP;</span><span class="sxs-lookup"><span data-stu-id="427f9-894">Total IGMP Reports Sent</span></span> 
- <span data-ttu-id="427f9-895">общее число полученных запросов IGMP;</span><span class="sxs-lookup"><span data-stu-id="427f9-895">Total IGMP Queries Received</span></span> 
- <span data-ttu-id="427f9-896">общее число ошибок контрольной суммы IGMP;</span><span class="sxs-lookup"><span data-stu-id="427f9-896">Total IGMP Checksum Errors</span></span> 
- <span data-ttu-id="427f9-897">общее число элементов, присоединившихся к текущей группе IGMP.</span><span class="sxs-lookup"><span data-stu-id="427f9-897">Total IGMP Current Groups Joined</span></span> 

<span data-ttu-id="427f9-898">Все эти статистические показатели и отчеты об ошибках предоставляются приложению службой ***nx_igmp_info_get***.</span><span class="sxs-lookup"><span data-stu-id="427f9-898">All these statistics and error reports are available to the application with the ***nx_igmp_info_get*** service.</span></span> 

### <a name="multicast-without-igmp"></a><span data-ttu-id="427f9-899">Многоадресная рассылка без IGMP</span><span class="sxs-lookup"><span data-stu-id="427f9-899">Multicast without IGMP</span></span>  
<span data-ttu-id="427f9-900">Приложение, ожидающее многоадресный трафик IPv4, может присоединиться к адресу группы многоадресной рассылки без вызова IGMP-сообщений с помощью службы ***nx_ipv4_multicast_interface_join***.</span><span class="sxs-lookup"><span data-stu-id="427f9-900">Application expecting IPv4 multicast traffic can join a multicast group address without invoking IGMP messages by using the service ***nx_ipv4_multicast_interface_join***.</span></span> <span data-ttu-id="427f9-901">Эта служба указывает уровню IPv4 и драйверу базового интерфейса принимать пакеты от указанного адреса многоадресной рассылки IPv4.</span><span class="sxs-lookup"><span data-stu-id="427f9-901">This service instructs the IPv4 layer and the underlying interface driver to accept packets from the designated IPv4 multicast address.</span></span> <span data-ttu-id="427f9-902">Но для этой группы не отправляются и не обрабатываются сообщения управления группами IGMP.</span><span class="sxs-lookup"><span data-stu-id="427f9-902">However there is no IGMP group management messages being sent or processed for this group.</span></span>

<span data-ttu-id="427f9-903">Приложение, которому больше не следует принимать трафик из группы, может использовать службу ***nx_ipv4_multicast_interface_leave.***</span><span class="sxs-lookup"><span data-stu-id="427f9-903">Application no longer wish to receive traffic from the group can use the service ***nx_ipv4_multicast_interface_leave.***</span></span>

## <a name="ipv6-in-netx-duo"></a><span data-ttu-id="427f9-904">IPv6 в NetX Duo</span><span class="sxs-lookup"><span data-stu-id="427f9-904">IPv6 in NetX Duo</span></span>

### <a name="ipv6-addresses"></a><span data-ttu-id="427f9-905">IPv6-адреса</span><span class="sxs-lookup"><span data-stu-id="427f9-905">IPv6 Addresses</span></span>   
<span data-ttu-id="427f9-906">Адреса IPv6 — 128-разрядные.</span><span class="sxs-lookup"><span data-stu-id="427f9-906">IPv6 addresses are 128 bits.</span></span> <span data-ttu-id="427f9-907">Архитектура адреса IPv6 описана в документе RFC 4291.</span><span class="sxs-lookup"><span data-stu-id="427f9-907">The architecture of IPv6 address is described in RFC 4291.</span></span> <span data-ttu-id="427f9-908">Адрес делится на префикс, содержащий наиболее значимые биты и адрес узла, содержащий младшие биты.</span><span class="sxs-lookup"><span data-stu-id="427f9-908">The address is divided into a prefix containing the most significant bits and a host address containing the lower bits.</span></span> <span data-ttu-id="427f9-909">Префикс указывает тип адреса и примерно аналогичен сетевому адресу в сети IPv4.</span><span class="sxs-lookup"><span data-stu-id="427f9-909">The prefix indicates the type of address and is roughly the equivalent of the network address in IPv4 network.</span></span>

<span data-ttu-id="427f9-910">IPv6 имеет три типа спецификаций адресов: одноадресная рассылка, произвольная рассылка (не поддерживается в NetX Duo) и многоадресная рассылка.</span><span class="sxs-lookup"><span data-stu-id="427f9-910">IPv6 has three types of address specifications: unicast, anycast (not supported in NetX Duo), and multicast.</span></span> <span data-ttu-id="427f9-911">Адреса одноадресной рассылки — это IP-адреса, которые определяют конкретный узел в Интернете.</span><span class="sxs-lookup"><span data-stu-id="427f9-911">Unicast addresses are those IP addresses that identify a specific host on the Internet.</span></span> <span data-ttu-id="427f9-912">Они могут быть IP-адресами источника или назначения.</span><span class="sxs-lookup"><span data-stu-id="427f9-912">Unicast addresses can be either a source or a destination IP address.</span></span> <span data-ttu-id="427f9-913">Адреса многоадресной рассылки задают динамическую группу узлов в Интернете.</span><span class="sxs-lookup"><span data-stu-id="427f9-913">Multicast addresses specify a dynamic group of hosts on the Internet.</span></span> <span data-ttu-id="427f9-914">Члены группы многоадресной рассылки могут присоединяться к группе и выходить из нее по мере необходимости.</span><span class="sxs-lookup"><span data-stu-id="427f9-914">Members of the multicast group may join and leave whenever they wish.</span></span>

<span data-ttu-id="427f9-915">У протокола IPv6 нет эквивалента механизма широковещательной рассылки IPv4.</span><span class="sxs-lookup"><span data-stu-id="427f9-915">IPv6 does not have the equivalent of the IPv4 broadcast mechanism.</span></span> <span data-ttu-id="427f9-916">Возможность отправки пакета всем узлам может быть достигнута путем отправки пакета по адресу локальной связи группы многоадресной рассылки для всех узлов.</span><span class="sxs-lookup"><span data-stu-id="427f9-916">The ability to send a packet to all hosts can be achieved by sending a packet to the link-local all hosts multicast group.</span></span>

<span data-ttu-id="427f9-917">IPv6 использует адреса многоадресной рассылки для процедур обнаружения соседей, обнаружения маршрутизатора и автоматической настройки адресов без отслеживания состояния.</span><span class="sxs-lookup"><span data-stu-id="427f9-917">IPv6 utilizes multicast addresses to perform Neighbor Discovery, Router Discovery, and Stateless Address Auto Configuration procedures.</span></span>

<span data-ttu-id="427f9-918">Существует два типа адресов одноадресной рассылки IPv6: адреса локальной связи, обычно создаваемые путем объединения хорошо известного префикса локальной связи с MAC-адресом интерфейса, и глобальные IP-адреса, которые также состоят из префиксной части и части идентификатора узла.</span><span class="sxs-lookup"><span data-stu-id="427f9-918">There are two types of IPv6 unicast addresses: link local addresses, typically constructed by combining the well-known link local prefix with the interface MAC address, and global IP addresses, which also has the prefix portion and the host ID portion.</span></span> <span data-ttu-id="427f9-919">Глобальный адрес можно настроить вручную или с помощью автонастройки адресов без отслеживания состояния либо DHCPv6.</span><span class="sxs-lookup"><span data-stu-id="427f9-919">A global address may be configured manually, or through the Stateless Address Autoconfiguration or DHCPv6.</span></span> <span data-ttu-id="427f9-920">NetX Duo поддерживает как локальные, так и глобальные адреса связи.</span><span class="sxs-lookup"><span data-stu-id="427f9-920">NetX Duo supports both link local address and global address.</span></span>

<span data-ttu-id="427f9-921">Чтобы поддержать форматы IPv4 и IPv6, NetX Duo предоставляет новый тип данных NXD_ADDRESS для хранения адресов IPv4 и IPv6.</span><span class="sxs-lookup"><span data-stu-id="427f9-921">To accommodate both IPv4 and IPv6 formats, NetX Duo provides a new data type, NXD_ADDRESS, for holding IPv4 and IPv6 addresses.</span></span> <span data-ttu-id="427f9-922">Определение этой структуры показано ниже.</span><span class="sxs-lookup"><span data-stu-id="427f9-922">The definition of this structure is shown below.</span></span> <span data-ttu-id="427f9-923">Поле адреса представляет собой объединение адресов IPv4 и IPv6.</span><span class="sxs-lookup"><span data-stu-id="427f9-923">The address field is a union of IPv4 and IPv6 addresses.</span></span>

```c
typedef struct NXD_ADDRESS_STRUCT
{
    ULONG nxd_ip_version;
    union
    {
        ULONG v4;
        ULONG v6[4];
    } nxd_ip_address;
} NXD_ADDRESS;
```

<span data-ttu-id="427f9-924">В структуре NXD_ADDRESS первый элемент, *nxd_ip_version*, указывает версию IPv4 или IPv6.</span><span class="sxs-lookup"><span data-stu-id="427f9-924">In the NXD_ADDRESS structure, the first element, *nxd_ip_version*, indicates IPv4 or IPv6 version.</span></span> <span data-ttu-id="427f9-925">Поддерживаемые значения: NX_IP_VERSION_V4 или NX_IP_VERSION_V6.</span><span class="sxs-lookup"><span data-stu-id="427f9-925">Supported values are either NX_IP_VERSION_V4 or NX_IP_VERSION_V6.</span></span> <span data-ttu-id="427f9-926">*nxd_ip_version* указывает, какое поле в объединении *nxd_ip_address* следует использовать в качестве IP-адреса.</span><span class="sxs-lookup"><span data-stu-id="427f9-926">*nxd_ip_version* indicates which field in the *nxd_ip_address* union to use as the IP address.</span></span> <span data-ttu-id="427f9-927">Службы API NetX Duo обычно принимают указатель на структуру NXD_ADDRESS в качестве входного аргумента вместо IP-адреса ULONG (32-битного).</span><span class="sxs-lookup"><span data-stu-id="427f9-927">NetX Duo API services typically take a pointer to NXD_ADDRESS structure as input argument in lieu of the ULONG (32 bit) IP address.</span></span>

### <a name="link-local-addresses"></a><span data-ttu-id="427f9-928">Адреса локальной связи</span><span class="sxs-lookup"><span data-stu-id="427f9-928">Link Local Addresses</span></span>     
<span data-ttu-id="427f9-929">Адрес локальной связи действителен только в локальной сети.</span><span class="sxs-lookup"><span data-stu-id="427f9-929">A link-local address is only valid on the local network.</span></span> <span data-ttu-id="427f9-930">Устройство может отправлять и получать пакеты на другое устройство в той же сети после назначения ему действительного адреса локальной связи.</span><span class="sxs-lookup"><span data-stu-id="427f9-930">A device can send and receive packets to another device on the same network after a valid link local address is assigned to it.</span></span> <span data-ttu-id="427f9-931">Приложение назначает адрес локальной связи путем вызова службы NetX Duo ***nxd_ipv6_address_set***, с параметром длины префикса, равным 10.</span><span class="sxs-lookup"><span data-stu-id="427f9-931">An application assigns a link-local address by calling the NetX Duo service ***nxd_ipv6_address_set***, with the prefix length parameter set to 10.</span></span> <span data-ttu-id="427f9-932">Приложение может предоставить службе адрес локальной связи или просто использовать NX_NULL в качестве адреса локальной связи и разрешить NetX Duo создавать адрес локальной связи на основе MAC-адреса устройства.</span><span class="sxs-lookup"><span data-stu-id="427f9-932">The application may supply a link-local address to the service, or it may simply use NX_NULL as the link-local address and allow NetX Duo to construct a link-local address based on the device's MAC address.</span></span>

<span data-ttu-id="427f9-933">В следующем примере NetX Duo настраивает адрес локальной связи с длиной префикса 10 на основном устройстве (индекс 0), используя его MAC-адрес:</span><span class="sxs-lookup"><span data-stu-id="427f9-933">The following example instructs NetX Duo to configure the link-local address with a prefix length of 10 on the primary device (index 0) using its MAC address:</span></span>

```c
nxd_ipv6_address_set(ip_ptr, 0, NX_NULL, 10, NX_NULL);
```
<span data-ttu-id="427f9-934">В приведенном выше примере, если MAC-адрес интерфейса — 54:32:10:1A:BC:67, соответствующий адрес локальной связи будет следующим:</span><span class="sxs-lookup"><span data-stu-id="427f9-934">In the example above, if the MAC address of the interface is 54:32:10:1A:BC:67, the corresponding link-local address would be:</span></span>

```c
FE80::5632:10FF:FE1A:BC67
```
<span data-ttu-id="427f9-935">Обратите внимание, что часть идентификатора узла IPv6-адреса (**5632:10ff: FE1A: BC67**) состоит из 6-байтного МАС-адреса со следующими изменениями:</span><span class="sxs-lookup"><span data-stu-id="427f9-935">Note that the host ID portion of the IPv6 address (**5632:10FF:FE1A:BC67**) is made up of the 6-byte MAC address, with the following modifications:</span></span>

- <span data-ttu-id="427f9-936">**0xFFFE** вставлен между байтами 3 и 4 MAC-адреса.</span><span class="sxs-lookup"><span data-stu-id="427f9-936">**0xFFFE** inserted between byte 3 and byte 4 of the MAC address</span></span>
- <span data-ttu-id="427f9-937">Второй самый младший бит первого байта MAC-адреса (бит U/L) имеет значение 1.</span><span class="sxs-lookup"><span data-stu-id="427f9-937">Second lowest bit of the first byte of the MAC address (U/L bit) is set to 1</span></span>

<span data-ttu-id="427f9-938">Дополнительные сведения о том, как создать часть адреса IPv6, касающуюся узла, с помощью MAC-адреса интерфейса, см. в RFC 2464 (Передача пакетов IPv6 по сети Ethernet).</span><span class="sxs-lookup"><span data-stu-id="427f9-938">Refer to RFC 2464 (Transmission of IPv6 Packets over Ethernet Network) for more information on how to construct the host portion of an IPv6 address from its interface MAC address.</span></span>

<span data-ttu-id="427f9-939">Существует несколько специальных адресов многоадресной рассылки для отправки многоадресных сообщений на один или несколько узлов в IPv6:</span><span class="sxs-lookup"><span data-stu-id="427f9-939">There are a few special multicast addresses for sending multicast messages to one or more hosts in IPv6:</span></span>

| <span data-ttu-id="427f9-940">Group</span><span class="sxs-lookup"><span data-stu-id="427f9-940">Group</span></span>  | <span data-ttu-id="427f9-941">Адрес</span><span class="sxs-lookup"><span data-stu-id="427f9-941">Address</span></span>   | <span data-ttu-id="427f9-942">Описание</span><span class="sxs-lookup"><span data-stu-id="427f9-942">Description</span></span>  |
|---|---|---|
|<span data-ttu-id="427f9-943">Группа всех узлов</span><span class="sxs-lookup"><span data-stu-id="427f9-943">All nodes group</span></span> |<span data-ttu-id="427f9-944">**FF02::1**</span><span class="sxs-lookup"><span data-stu-id="427f9-944">**FF02::1**</span></span> |<span data-ttu-id="427f9-945">Все узлы в локальной сети</span><span class="sxs-lookup"><span data-stu-id="427f9-945">All hosts on the local network</span></span>|
|<span data-ttu-id="427f9-946">Группа всех маршрутизаторов</span><span class="sxs-lookup"><span data-stu-id="427f9-946">All routers group</span></span> |<span data-ttu-id="427f9-947">**FF02::2**</span><span class="sxs-lookup"><span data-stu-id="427f9-947">**FF02::2**</span></span> |<span data-ttu-id="427f9-948">Все маршрутизаторы в локальной сети</span><span class="sxs-lookup"><span data-stu-id="427f9-948">All routers on the local network</span></span>|
|<span data-ttu-id="427f9-949">Запрашиваемый узел</span><span class="sxs-lookup"><span data-stu-id="427f9-949">Solicited-node</span></span> |<span data-ttu-id="427f9-950">**FF02::1:FF00:0/104**</span><span class="sxs-lookup"><span data-stu-id="427f9-950">**FF02::1:FF00:0/104**</span></span> |<span data-ttu-id="427f9-951">Пояснения приведены ниже</span><span class="sxs-lookup"><span data-stu-id="427f9-951">Explained below</span></span>|

<span data-ttu-id="427f9-952">Адрес многоадресной рассылки запрашиваемого узла предназначен для конкретных узлов по локальной ссылке, а не для всех узлов IPv6.</span><span class="sxs-lookup"><span data-stu-id="427f9-952">A solicited-node multicast address targets specific hosts on the local link rather than all the IPv6 hosts.</span></span> <span data-ttu-id="427f9-953">Он состоит из префикса **FF02::1:FF00:0/104**, который составляет 104 бита и последних 24 битов целевого IPv6-адреса.</span><span class="sxs-lookup"><span data-stu-id="427f9-953">It consists of the prefix **FF02::1:FF00:0/104**, which is 104 bits and the last 24-bits of the target IPv6 address.</span></span> <span data-ttu-id="427f9-954">Например, адрес IPv6 **205B:209D:D028::F058:D1C8:1024** имеет адрес многоадресной рассылки запрашиваемого узла **FF02::1:FFC8:1024**.</span><span class="sxs-lookup"><span data-stu-id="427f9-954">For example, an IPv6 address **205B:209D:D028::F058:D1C8:1024** has a solicitednode multicast address of address **FF02::1:FFC8:1024**.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="427f9-955">*Нотация с двойным двоеточием указывает, что все промежуточные биты являются нулями. **FF02::1:FF00:0/104** в полностью развернутом виде выглядит как* **FF02:0000:0000:0000:0000:0001:FF00:0000**.</span><span class="sxs-lookup"><span data-stu-id="427f9-955">*The double colon notation indicates the intervening bits are all zeroes. **FF02::1:FF00:0/104** fully expanded looks like* **FF02:0000:0000:0000:0000:0001:FF00:0000**</span></span>

### <a name="global-addresses"></a><span data-ttu-id="427f9-956">Глобальные адреса</span><span class="sxs-lookup"><span data-stu-id="427f9-956">Global Addresses</span></span>    
<span data-ttu-id="427f9-957">Пример глобального адреса IPv6 — **2001:0123:4567:89AB:CDEF::1**, NetX Duo хранит адреса IPv6 в структуре NXD_ADDRESS.</span><span class="sxs-lookup"><span data-stu-id="427f9-957">An example of an IPv6 global address is **2001:0123:4567:89AB:CDEF::1** NetX Duo stores IPv6 addresses in the NXD_ADDRESS structure.</span></span> <span data-ttu-id="427f9-958">В приведенном ниже примере переменная NXD_ADDRESS **global_ipv6_address** содержит адрес IPv6 для одноадресной рассылки.</span><span class="sxs-lookup"><span data-stu-id="427f9-958">In the example below, the NXD_ADDRESS variable **global_ipv6_address** contains a unicast IPv6 address.</span></span> <span data-ttu-id="427f9-959">В следующем примере показано устройство NetX Duo, создающее конкретный глобальный адрес IPv6 для своего основного устройства:</span><span class="sxs-lookup"><span data-stu-id="427f9-959">The following example demonstrates a NetX Duo device creating a specific IPv6 global address for its primary device:</span></span>

```c
NXD_ADDRESS global_ipv6_address;
UINT        primary_interface_index = 0;

global_ipv6_address.nxd_ip_version = NX_IP_VERSION_V6;
global_ipv6_address.nxd_ip_address.v6[0] = 0x20010123;
global_ipv6_address.nxd_ip_address.v6[1] = 0x456789AB;
global_ipv6_address.nxd_ip_address.v6[2] = 0xCDEF0000;
global_ipv6_address.nxd_ip_address.v6[3] = 0x00000001;

status = nxd_ipv6_address_set(
            &ip_0,
            primary_interface_index,
            &global_ipv6_address,
            64,
            NX_NULL);
```
<span data-ttu-id="427f9-960">Обратите внимание, что префикс IPv6-адреса — **2001:0123:4567:89AB**. Он имеет длину 64 бит и является общей длиной префикса для глобальных адресов одноадресной рассылки IPv6 в Ethernet.</span><span class="sxs-lookup"><span data-stu-id="427f9-960">Note that the prefix of this IPv6 address is **2001:0123:4567:89AB**, which is 64 bits long and is a common prefix length for global unicast IPv6 addresses on Ethernet.</span></span>

<span data-ttu-id="427f9-961">Структура NXD_ADDRESS также содержит адреса IPv4.</span><span class="sxs-lookup"><span data-stu-id="427f9-961">The NXD_ADDRESS structure also holds IPv4 addresses.</span></span> <span data-ttu-id="427f9-962">IP-адрес **192.1.168.10** (**0xC001A80A**), хранящийся в global_ipv4_address, будет иметь следующую организацию памяти:</span><span class="sxs-lookup"><span data-stu-id="427f9-962">An IP address of **192.1.168.10** (**0xC001A80A**) stored in global_ipv4_address would have the following memory layout:</span></span>

|<span data-ttu-id="427f9-963">Поле</span><span class="sxs-lookup"><span data-stu-id="427f9-963">Field</span></span> |<span data-ttu-id="427f9-964">Значение</span><span class="sxs-lookup"><span data-stu-id="427f9-964">Value</span></span> |
|---|---|
|<span data-ttu-id="427f9-965">global_ipv4_address.nxd_ip_version</span><span class="sxs-lookup"><span data-stu-id="427f9-965">global_ipv4_address.nxd_ip_version</span></span> |<span data-ttu-id="427f9-966">NX_IP_VERSION_V4</span><span class="sxs-lookup"><span data-stu-id="427f9-966">NX_IP_VERSION_V4</span></span>|
|<span data-ttu-id="427f9-967">global_ipv4_address.nxd_ip_address.v4</span><span class="sxs-lookup"><span data-stu-id="427f9-967">global_ipv4_address.nxd_ip_address.v4</span></span> |<span data-ttu-id="427f9-968">0xC001A80A</span><span class="sxs-lookup"><span data-stu-id="427f9-968">0xC001A80A</span></span>|

<span data-ttu-id="427f9-969">Когда приложение передает адрес в службы NetX Duo, в поле *nxd_ip_version* необходимо указать правильную версию IP-адреса для правильной обработки пакетов.</span><span class="sxs-lookup"><span data-stu-id="427f9-969">When an application passes an address to NetX Duo services, the *nxd_ip_version* field must specify the correct IP version for proper packet handling.</span></span>

<span data-ttu-id="427f9-970">Чтобы обеспечить обратную совместимость с существующими приложениями NetX, NetX Duo поддерживает все службы NetX.</span><span class="sxs-lookup"><span data-stu-id="427f9-970">To be backward compatible with existing NetX applications, NetX Duo supports all NetX services.</span></span> <span data-ttu-id="427f9-971">На внутреннем уровне NetX Duo преобразует тип адресов IPv4 ULONG в тип данных NXD_ADDRESS, прежде чем пересылать его в фактическую службу NetX Duo.</span><span class="sxs-lookup"><span data-stu-id="427f9-971">Internally, NetX Duo converts the IPv4 address type ULONG to an NXD_ADDRESS data type before forwarding it to the actual NetX Duo service.</span></span>

<span data-ttu-id="427f9-972">В следующем примере показаны сходства и различия между службами в NetX и NetX Duo.</span><span class="sxs-lookup"><span data-stu-id="427f9-972">The following example illustrates the similarity and the differences between services in NetX and NetX Duo.</span></span>

```c
/* Make a connection to the destination IPv4 address
   192.1.168.12 through an already created TCP socket bound
   to the well known HTTP port number 80. */

global_ipv4_address.nxd_ip_version = NX_IP_VERSION_V4;
global_ipv4_address.nxd_ip_address.v4 = 0xC001A80C;

nxd_tcp_client_socket_connect(&tcp_socket,
                              &global_ipv4_address,
                              port_number,
                              NX_WAIT_FOREVER);
```

<span data-ttu-id="427f9-973">Ниже приведен эквивалентный API NetX:</span><span class="sxs-lookup"><span data-stu-id="427f9-973">The following is the equivalent NetX API:</span></span>

```c
ULONG         server_ip = 0xC001A80C;
NX_TCP_SOCKET tcp_socket;
UINT          port_number = 80;

nx_tcp_client_socket_connect(&tcp_socket,
                             server_ip,
                             port_number,
                             NX_WAIT_FOREVER); 
```

> [!IMPORTANT]
> <span data-ttu-id="427f9-974">*Разработчикам приложений рекомендуется использовать nxd-версии этих API*.</span><span class="sxs-lookup"><span data-stu-id="427f9-974">*Application developers are encouraged to use the nxd version of these APIs*.</span></span>

### <a name="ipv6-default-routers"></a><span data-ttu-id="427f9-975">Маршрутизаторы по умолчанию IPv6</span><span class="sxs-lookup"><span data-stu-id="427f9-975">IPv6 Default Routers</span></span>    
<span data-ttu-id="427f9-976">IPv6 использует маршрутизатор по умолчанию для пересылки пакетов назначениям, являющимся транспортными каналами.</span><span class="sxs-lookup"><span data-stu-id="427f9-976">IPv6 uses a default router to forward packets to offlink destinations.</span></span> <span data-ttu-id="427f9-977">Служба NetX Duo ***Nxd_ipv6_default_router_add*** позволяет приложению добавить маршрутизатор IPv6 в таблицу маршрутизатора по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="427f9-977">The NetX Duo service ***nxd_ipv6_default_router_add*** enables an application to add an IPv6 router to the default router table.</span></span> <span data-ttu-id="427f9-978">Дополнительные службы маршрутизатора по умолчанию, предлагаемые NetX Duo, см. в главе 4 "Описание служб".</span><span class="sxs-lookup"><span data-stu-id="427f9-978">See Chapter 4 "Description of Services" for more default router services offered by NetX Duo.</span></span>  

<span data-ttu-id="427f9-979">При пересылке пакетов IPv6 NetX Duo сначала проверяет, находится ли назначение пакета по ссылке.</span><span class="sxs-lookup"><span data-stu-id="427f9-979">When forwarding IPv6 packets, NetX Duo first checks if the packet destination is on-link.</span></span> <span data-ttu-id="427f9-980">Если нет, NetX Duo проверяет таблицу маршрутизации по умолчанию на предмет допустимого маршрутизатора, которому можно перенаправить пакет транспортного канала.</span><span class="sxs-lookup"><span data-stu-id="427f9-980">If not, NetX Duo checks the default routing table for a valid router to forward the off-link packet to.</span></span>  

<span data-ttu-id="427f9-981">Чтобы удалить маршрутизатор из таблицы маршрутизаторов IPv6 по умолчанию, приложение должно использовать службу \***nxd_ipv6_default_router_delete** _.</span><span class="sxs-lookup"><span data-stu-id="427f9-981">To remove a router from the IPv6 default router table, application shall use the service \***nxd_ipv6_default_router_delete** _.</span></span> <span data-ttu-id="427f9-982">Чтобы получить записи о таблице маршрутизаторов IPv6 по умолчанию, используйте службу _\*_nxd_ipv6_default_router_entry_get_\*\*.</span><span class="sxs-lookup"><span data-stu-id="427f9-982">To obtain entries of the IPv6 default router table, use the service _\*_nxd_ipv6_default_router_entry_get_\*\*.</span></span>

### <a name="ipv6-header"></a><span data-ttu-id="427f9-983">Заголовок IPv6</span><span class="sxs-lookup"><span data-stu-id="427f9-983">IPv6 Header</span></span>    
<span data-ttu-id="427f9-984">Заголовок IPv6 — это измененный заголовок IPv4.</span><span class="sxs-lookup"><span data-stu-id="427f9-984">The IPv6 header has been modified from the IPv4 header.</span></span> <span data-ttu-id="427f9-985">При выделении пакета, вызывающий объект указывает протокол приложения (например, UDP, TCP), размер буфера в байтах и ограничение числа прыжков.</span><span class="sxs-lookup"><span data-stu-id="427f9-985">When allocating a packet, the caller specifies the application protocol (e.g., UDP, TCP), buffer size in bytes, and hop limit.</span></span>   

<span data-ttu-id="427f9-986">На рис. 9 показан формат заголовка IPv6, а в таблице перечислены компоненты заголовка.</span><span class="sxs-lookup"><span data-stu-id="427f9-986">Figure 9 shows the format of the IPv6 header and the table lists the header components.</span></span>

![Схема формата заголовка IPv6.](./media/user-guide/image18.png)

<span data-ttu-id="427f9-988">**РИС. 9. Формат заголовка IPv6**</span><span class="sxs-lookup"><span data-stu-id="427f9-988">**FIGURE 9. IPv6 Header Format**</span></span>

|<span data-ttu-id="427f9-989">Заголовок IP</span><span class="sxs-lookup"><span data-stu-id="427f9-989">IP header</span></span> | <span data-ttu-id="427f9-990">Назначение</span><span class="sxs-lookup"><span data-stu-id="427f9-990">Purpose</span></span> |
|---|---|
|<span data-ttu-id="427f9-991">Версия</span><span class="sxs-lookup"><span data-stu-id="427f9-991">Version</span></span> |<span data-ttu-id="427f9-992">4-разрядное поле для версии IP.</span><span class="sxs-lookup"><span data-stu-id="427f9-992">4-bit field for IP version.</span></span> <span data-ttu-id="427f9-993">Для сетей IPv6 значение в этом поле должно быть 6; для сетей IPv4 оно должно быть равно 4.</span><span class="sxs-lookup"><span data-stu-id="427f9-993">For IPv6 networks, the value in this field must be 6; For IPv4 networks it must be 4.</span></span>|
|<span data-ttu-id="427f9-994">Класс трафика</span><span class="sxs-lookup"><span data-stu-id="427f9-994">Traffic Class</span></span> |<span data-ttu-id="427f9-995">8-разрядное поле, в котором хранятся сведения о классе трафика.</span><span class="sxs-lookup"><span data-stu-id="427f9-995">8-bit field that stores the traffic class information.</span></span> <span data-ttu-id="427f9-996">Это поле не используется NetX Duo.</span><span class="sxs-lookup"><span data-stu-id="427f9-996">This field is not used by NetX Duo.</span></span>|
|<span data-ttu-id="427f9-997">Метка потока</span><span class="sxs-lookup"><span data-stu-id="427f9-997">Flow Label</span></span> |<span data-ttu-id="427f9-998">20-разрядное поле для уникальной идентификации потока (при наличии), с которым связан пакет.</span><span class="sxs-lookup"><span data-stu-id="427f9-998">20-bit field to uniquely identify the flow, if any, that a packet is associated with.</span></span> <span data-ttu-id="427f9-999">Нулевое значение указывает, что пакет не принадлежит определенному потоку.</span><span class="sxs-lookup"><span data-stu-id="427f9-999">A value of zero indicates the packet does not belong to a particular flow.</span></span> <span data-ttu-id="427f9-1000">Это поле заменяет поле *TOS* в IPv4.</span><span class="sxs-lookup"><span data-stu-id="427f9-1000">This field replaces the *TOS* field in IPv4.</span></span>|
|<span data-ttu-id="427f9-1001">Длина полезных данных</span><span class="sxs-lookup"><span data-stu-id="427f9-1001">Payload Length</span></span> |<span data-ttu-id="427f9-1002">16-разрядное поле, указывающее объем данных в байтах пакета IPv6, который следует за базовым заголовком IPv6.</span><span class="sxs-lookup"><span data-stu-id="427f9-1002">16-bit field indicating the amount of data in bytes of the IPv6 packet following the IPv6 base header.</span></span> <span data-ttu-id="427f9-1003">Сюда входят все заголовки и данные инкапсулированного протокола.</span><span class="sxs-lookup"><span data-stu-id="427f9-1003">This includes all encapsulated protocol header and data.</span></span>|
|<span data-ttu-id="427f9-1004">Следующий заголовок</span><span class="sxs-lookup"><span data-stu-id="427f9-1004">Next Header</span></span> | <span data-ttu-id="427f9-1005">8-разрядное поле, указывающее тип заголовка расширения, который следует за базовым заголовком IPv6.</span><span class="sxs-lookup"><span data-stu-id="427f9-1005">8-bit field indicating the type of the extension header that follows the IPv6 base header.</span></span> <span data-ttu-id="427f9-1006">Это поле заменяет поле *Protocol* в IPv4.</span><span class="sxs-lookup"><span data-stu-id="427f9-1006">This field replaces the *Protocol* field in IPv4.</span></span>|
|<span data-ttu-id="427f9-1007">Предел числа прыжков</span><span class="sxs-lookup"><span data-stu-id="427f9-1007">Hop Limit</span></span> |<span data-ttu-id="427f9-1008">8-разрядное поле, ограничивающее количество маршрутизаторов, через которые может проходить пакет.</span><span class="sxs-lookup"><span data-stu-id="427f9-1008">8-bit field that limits the number of routers the packet is allowed to go through.</span></span> <span data-ttu-id="427f9-1009">Это поле заменяет поле *TTL* в IPv4.</span><span class="sxs-lookup"><span data-stu-id="427f9-1009">This field replaces the *TTL* field in IPv4.</span></span>|
|<span data-ttu-id="427f9-1010">Исходный адрес</span><span class="sxs-lookup"><span data-stu-id="427f9-1010">Source Address</span></span> |<span data-ttu-id="427f9-1011">128-разрядное поле, в котором хранится IPv6-адрес отправителя.</span><span class="sxs-lookup"><span data-stu-id="427f9-1011">128-bit field that stores the IPv6 address of the sender.</span></span>|
|<span data-ttu-id="427f9-1012">Адрес назначения</span><span class="sxs-lookup"><span data-stu-id="427f9-1012">Destination Address</span></span> |<span data-ttu-id="427f9-1013">128-разрядное поле, в котором хранится IPv6-адрес назначения.</span><span class="sxs-lookup"><span data-stu-id="427f9-1013">128-bit field that sores the IPv6 address of the destination.</span></span>|

### <a name="enabling-ipv6-in-netx-duo"></a><span data-ttu-id="427f9-1014">Включение IPv6 в NetX Duo</span><span class="sxs-lookup"><span data-stu-id="427f9-1014">Enabling IPv6 in NetX Duo</span></span>    
<span data-ttu-id="427f9-1015">По умолчанию IPv6 включен в NetX Duo.</span><span class="sxs-lookup"><span data-stu-id="427f9-1015">By default IPv6 is enabled in NetX Duo.</span></span> <span data-ttu-id="427f9-1016">Службы IPv6 включены в NetX Duo, если настраиваемый параметр ***NX_DISABLE_IPV6** _ в _nx_user.h* не определен.</span><span class="sxs-lookup"><span data-stu-id="427f9-1016">IPv6 services are enabled in NetX Duo if the configurable option ***NX_DISABLE_IPV6** _ in _nx_user.h* is not defined.</span></span> <span data-ttu-id="427f9-1017">Если определено ***NX_DISABLE_IPV6***, NetX Duo будет предоставлять только службы IPv4, а все связанные с IPv6 модули и службы не встроены в библиотеку NetX Duo.</span><span class="sxs-lookup"><span data-stu-id="427f9-1017">If ***NX_DISABLE_IPV6*** is defined, NetX Duo will only offer IPv4 services, and all the IPv6-related modules and services are not built into NetX Duo library.</span></span>

<span data-ttu-id="427f9-1018">Для настройки адреса IPv6 устройства в приложениях предусмотрена следующая служба: ***nxd_ipv6_address_set***</span><span class="sxs-lookup"><span data-stu-id="427f9-1018">The following service is provided for applications to configure the device IPv6 address: ***nxd_ipv6_address_set***</span></span>

<span data-ttu-id="427f9-1019">Помимо задания адреса IPv6в устройства вручную, система также может использовать автонастройку адресов без отслеживания состояния.</span><span class="sxs-lookup"><span data-stu-id="427f9-1019">In addition to manually setting the device's IPv6 addresses, the system may also use Stateless Address Autoconfiguration.</span></span> <span data-ttu-id="427f9-1020">Чтобы использовать этот параметр, приложение должно вызвать \***nxd_ipv6_enable** _ для запуска служб IPv6 на устройстве.</span><span class="sxs-lookup"><span data-stu-id="427f9-1020">To use this option, the application must call \***nxd_ipv6_enable** _ to start IPv6 services on the device.</span></span> <span data-ttu-id="427f9-1021">Кроме того, службы ICMPv6 необходимо запускать путем вызова _*_nxd_icmp_enable_*_, что позволяет NetX Duo оказывать такие услуги, как запрос маршрутизатора, обнаружение соседей и обнаружение повторяющихся адресов.</span><span class="sxs-lookup"><span data-stu-id="427f9-1021">In addition, ICMPv6 services must be started by calling _*_nxd_icmp_enable_*_, which enables NetX Duo to perform services such as Router Solicitation, Neighbor Discovery, and Duplicate Address Detection.</span></span> <span data-ttu-id="427f9-1022">Обратите внимание, что _*_nx_icmp_enable_*_ запускает протокол ICMP только для служб IPv4.</span><span class="sxs-lookup"><span data-stu-id="427f9-1022">Note that _*_nx_icmp_enable_*_ only starts ICMP for IPv4 services.</span></span> <span data-ttu-id="427f9-1023">_*_nxd_icmp_enable_*_ запускает службы ICMP как для IPv4, так и для IPv6.</span><span class="sxs-lookup"><span data-stu-id="427f9-1023">_*_nxd_icmp_enable_*_ starts ICMP services for both IPv4 and IPv6.</span></span> <span data-ttu-id="427f9-1024">Если системе не требуются службы ICMPv6, то можно использовать _ \*_nx_icmp_enable_\*\*, чтобы модуль ICMPv6 не был связан с системой.</span><span class="sxs-lookup"><span data-stu-id="427f9-1024">If the system does not need ICMPv6 services, then _ *_nx_icmp_enable_*\* can be used so the ICMPv6 module is not linked into the system.</span></span>

<span data-ttu-id="427f9-1025">В следующем примере показана типичная процедура инициализации IPv6 NetX Duo.</span><span class="sxs-lookup"><span data-stu-id="427f9-1025">The following example shows a typical NetX Duo IPv6 initialization procedure.</span></span>

```c
/* Assume ip_0 has been created and IPv4 services (such as ARP,
   ICMP, have been enabled. */
#define SECONDARY_INTERFACE 1

/* Enable IPv6 */
status = nxd_ipv6_enable(&ip_0);

if(status != NX_SUCCESS)
{
    /* nxd_ipv6_enable failed. */
}

/* Enable ICMPv6 */
status = nxd_icmp_enable(&ip_0);
if(status != NX_SUCCESS)
{
    /* nxd_icmp_enable failed. */
}

/* Configure the link local address on the primary interface. */
status = nxd_ipv6_address_set(&ip_0, 0, NX_NULL, 10, NX_NULL);

/* Configure ip_0 primary interface global address. */
ip_address.nxd_ip_version = NX_IP_VERSION_V6
ip_address.nxd_ip_address.v6[0] = 0x20010db8;
ip_address.nxd_ip_address.v6[1] = 0x0000f101;
ip_address.nxd_ip_address.v6[2] = 0;
ip_address.nxd_ip_address.v6[3] = 0x202;

/* Configure global address of the primary interface. */
status = nxd_ipv6_address_set(&ip_0, SECONDARY_INTERFACE,
                              &ip_address, 64, NX_NULL);
```                              

<span data-ttu-id="427f9-1026">Протоколы верхнего уровня (например, TCP и UDP) можно включить либо до, либо после запуска IPv6.</span><span class="sxs-lookup"><span data-stu-id="427f9-1026">Upper layer protocols (such as TCP and UDP) can be enabled either before or after IPv6 starts.</span></span>

> [!IMPORTANT]  
> <span data-ttu-id="427f9-1027">*Службы IPv6 доступны только после инициализации IP-потока и включения устройства.*</span><span class="sxs-lookup"><span data-stu-id="427f9-1027">*IPv6 services are available only after IP thread is initialized and the device is enabled.*</span></span>

<span data-ttu-id="427f9-1028">Когда интерфейс будет включен (т. е. драйвер устройства интерфейса готов к отправке и получению данных и получен допустимый адрес локальной связи), устройство может получить глобальные IPv6-адреса одним из следующих способов:</span><span class="sxs-lookup"><span data-stu-id="427f9-1028">After the interface is enabled (i.e.,the interface device driver is ready to send and receive data, and a valid link local address has been obtained), the device may obtain global IPv6 addresses by one of the these methods:</span></span>

- <span data-ttu-id="427f9-1029">автоматическая настройка адресов без отслеживания состояния;</span><span class="sxs-lookup"><span data-stu-id="427f9-1029">Stateless Address Auto Configuration;</span></span>  
- <span data-ttu-id="427f9-1030">настройка адресов IPv6 вручную;</span><span class="sxs-lookup"><span data-stu-id="427f9-1030">Manual IPv6 address configuration;</span></span>  
- <span data-ttu-id="427f9-1031">настройка адресов по протоколу DHCPv6 (с помощью дополнительного пакета DHCPv6).</span><span class="sxs-lookup"><span data-stu-id="427f9-1031">Address configuration via DHCPv6 (with optional DHCPv6 package)</span></span>

<span data-ttu-id="427f9-1032">Первые два метода описаны ниже.</span><span class="sxs-lookup"><span data-stu-id="427f9-1032">The first two methods are described below.</span></span> <span data-ttu-id="427f9-1033">Третий метод (DHCPv6) описан в пакете DHCP.</span><span class="sxs-lookup"><span data-stu-id="427f9-1033">The 3rd method (DHCPv6) is described in the DHCP package.</span></span>

### <a name="stateless-address-autoconfiguration-using-router-solicitation"></a><span data-ttu-id="427f9-1034">Автоматическая настройка адресов без отслеживания состояния с помощью запроса маршрутизатора</span><span class="sxs-lookup"><span data-stu-id="427f9-1034">Stateless Address Autoconfiguration Using Router Solicitation</span></span>      
<span data-ttu-id="427f9-1035">Устройства NetX Duo могут автоматически настраивать свои интерфейсы при подключении к сети IPv6 с помощью маршрутизатора, предоставляющего сведения о префиксе.</span><span class="sxs-lookup"><span data-stu-id="427f9-1035">NetX Duo devices can configure their interfaces automatically when connected to an IPv6 network with a router that supplies prefix information.</span></span> <span data-ttu-id="427f9-1036">Устройства, которым требуется автоматическая настройка адресов без отслеживания состояния, отправляют сообщения о запросе маршрутизатора (RS).</span><span class="sxs-lookup"><span data-stu-id="427f9-1036">Devices that require Stateless Address Autoconfiguration send out router solicitation (RS) messages.</span></span> <span data-ttu-id="427f9-1037">Маршрутизаторы в сети отвечают отправкой запрошенных сообщений объявления маршрутизатора (RA).</span><span class="sxs-lookup"><span data-stu-id="427f9-1037">Routers on the network respond with solicited router advertisement (RA) messages.</span></span> <span data-ttu-id="427f9-1038">Сообщения RA объявляют префиксы, указывающие сетевые адреса, связанные с ссылкой.</span><span class="sxs-lookup"><span data-stu-id="427f9-1038">RA messages advertise prefixes that identify the network addresses associated with a link.</span></span> <span data-ttu-id="427f9-1039">Затем устройства создают уникальный идентификатор сети, к которой подключено устройство.</span><span class="sxs-lookup"><span data-stu-id="427f9-1039">Devices then generate a unique identifier for the network the device is attached to.</span></span> <span data-ttu-id="427f9-1040">Адрес формируется путем объединения префикса и его уникального идентификатора.</span><span class="sxs-lookup"><span data-stu-id="427f9-1040">The address is formed by combining the prefix and its unique identifier.</span></span> <span data-ttu-id="427f9-1041">Таким образом, при получении сообщений RA узлы создают их IP-адреса.</span><span class="sxs-lookup"><span data-stu-id="427f9-1041">In this manner on receiving the RA messages, hosts generate their IP address.</span></span> <span data-ttu-id="427f9-1042">Маршрутизаторы также могут периодически отправлять незапрошенные сообщения RA.</span><span class="sxs-lookup"><span data-stu-id="427f9-1042">Routers may also send periodic unsolicited RA messages.</span></span> 

> [!WARNING]
> <span data-ttu-id="427f9-1043">*NetX Duo позволяет приложению включать и отключать автоматическую настройку адресов без отслеживания состояния во время выполнения. Чтобы включить эту функцию, необходимо скомпилировать библиотеку NetX Duo с определенным **NX_IPV6_STATELESS_AUTOCONFIG_CONTROL**. После включения этой функции приложения могут использовать **nxd_ipv6_stateless_address_autoconfigure_enable** и **nxd_ipv6_stateless_address_autocofigure_disable** для включения и отключения автоматической настройки адресов IPv6 без отслеживания состояния*.</span><span class="sxs-lookup"><span data-stu-id="427f9-1043">*NetX Duo allows an application to enable or disable Stateless Address Autoconfiguration at run time. To enable this feature, NetX Duo library must be compiled with **NX_IPV6_STATELESS_AUTOCONFIG_CONTROL** defined. Once this feature is enabled, applications may use **nxd_ipv6_stateless_address_autoconfigure_enable** and **nxd_ipv6_stateless_address_autocofigure_disable** to enable or disable IPv6 stateless address autoconfiguration*.</span></span>

### <a name="manual-ipv6-address-configuration"></a><span data-ttu-id="427f9-1044">Настройка адресов IPv6 вручную</span><span class="sxs-lookup"><span data-stu-id="427f9-1044">Manual IPv6 Address Configuration</span></span>     
<span data-ttu-id="427f9-1045">Если необходим конкретный адрес IPv6, приложение может использовать ***nxd_ipv6_address_set***, чтобы вручную настроить адрес IPv6.</span><span class="sxs-lookup"><span data-stu-id="427f9-1045">If a specific IPv6 address is needed, the application may use ***nxd_ipv6_address_set*** to manually configure an IPv6 address.</span></span> <span data-ttu-id="427f9-1046">Сетевой интерфейс может иметь несколько адресов IPv6.</span><span class="sxs-lookup"><span data-stu-id="427f9-1046">A network interface may have multiple IPv6 addresses.</span></span> <span data-ttu-id="427f9-1047">Однако следует помнить, что общее число адресов IPv6 в системе, полученных с помощью автоматической настройки адресов без отслеживания состояния, либо с помощью ручной настройки, не может превышать число в ***NX_MAX_IPV6_ADDRESSES***.</span><span class="sxs-lookup"><span data-stu-id="427f9-1047">However keep in mind that the total number of IPv6 addresses in a system, either obtained through Stateless Address Autoconfiguration, or through the Manual Configuration, cannot exceed ***NX_MAX_IPV6_ADDRESSES***.</span></span>

<span data-ttu-id="427f9-1048">В следующем примере показано, как вручную настроить глобальный адрес на основном интерфейсе (устройство 0) в ip_0.</span><span class="sxs-lookup"><span data-stu-id="427f9-1048">The following example illustrates how to manually configure a global address on the primary interface (device 0) in ip_0:</span></span>

```c
NXD_ADDRESS global_address;
global_address.nxd_ip_version = NX_IP_VERSION_V6;
global_address.nxd_ip_address.v6[0] = 0x20010000;
global_address.nxd_ip_address.v6[1] = 0x00000000;
global_address.nxd_ip_address.v6[2] = 0x00000000;
global_address.nxd_ip_address.v6[3] = 0x0000ABCD;
```

<span data-ttu-id="427f9-1049">Затем узел вызывает следующую службу NetX Duo, чтобы сделать этот адрес своим глобальным IP-адресом:</span><span class="sxs-lookup"><span data-stu-id="427f9-1049">The host then calls the following NetX Duo service to assign this address as its global IP address:</span></span>

```c
status = nxd_ipv6_address_set(&ip_0, 0,  
                              &global_address, 64
                              NX_NULL);
```

### <a name="duplicate-address-detection-dad"></a><span data-ttu-id="427f9-1050">Обнаружение повторяющихся адресов (DAD)</span><span class="sxs-lookup"><span data-stu-id="427f9-1050">Duplicate Address Detection (DAD)</span></span>    
<span data-ttu-id="427f9-1051">После того как система настроила IPv6-адрес, адрес помечается как *TENTATIVE* (предварительный).</span><span class="sxs-lookup"><span data-stu-id="427f9-1051">After a system configures its IPv6 address, the address is marked as *TENTATIVE*.</span></span> <span data-ttu-id="427f9-1052">Если функция обнаружения повторяющихся адресов (DAD), описанная в RFC 4862, включена, NetX Duo автоматически отправляет сообщения запроса соседей (NS) с этим пробным адресом в качестве места назначения.</span><span class="sxs-lookup"><span data-stu-id="427f9-1052">If Duplicate Address Detection (DAD), described in RFC 4862, is enabled, NetX Duo automatically sends neighbor solicitation (NS) messages with this tentative address as the destination.</span></span> <span data-ttu-id="427f9-1053">Если ни один из узлов в сети не отвечает на эти сообщения NS в течение заданного периода времени, то предполагается, что этот адрес уникален в рамках локальной связи и его состояние переходит к состоянию VALID (допустимое).</span><span class="sxs-lookup"><span data-stu-id="427f9-1053">If no hosts on the network respond to these NS messages within a given period of time, the address is assumed to be unique on the local link, and its state transits to the VALID state.</span></span> <span data-ttu-id="427f9-1054">На этом этапе приложение может начать использовать этот IP-адрес для обмена данными.</span><span class="sxs-lookup"><span data-stu-id="427f9-1054">At this point the application may start using this IP address for communication.</span></span>  

<span data-ttu-id="427f9-1055">Функция DAD является частью модуля ICMPv6.</span><span class="sxs-lookup"><span data-stu-id="427f9-1055">The DAD functionality is part of the ICMPv6 module.</span></span> <span data-ttu-id="427f9-1056">Поэтому приложение должно включить службы ICMPv6, прежде чем новый настроенный адрес сможет пройти через процесс DAD.</span><span class="sxs-lookup"><span data-stu-id="427f9-1056">Therefore, the application must enable ICMPv6 services before a newly configured address can go through the DAD process.</span></span> <span data-ttu-id="427f9-1057">Кроме того, процесс DAD может быть отключен путем определения параметра ***NX_DISABLE_IPV6_DAD** _ в среде сборки библиотеки NetX Duo (определяется как _*_nx_user.h_\*_).</span><span class="sxs-lookup"><span data-stu-id="427f9-1057">Alternatively, the DAD process may be turned off by defining ***NX_DISABLE_IPV6_DAD** _ option in the NetX Duo library build environment (defined as _*_nx_user.h_\*_).</span></span> <span data-ttu-id="427f9-1058">В процессе DAD параметр _*_NX_IPV6_DAD_TRANSMITS_*_ определяет количество сообщений NS, отправленных NetX Duo, без получения ответа для определения уникальности адреса.</span><span class="sxs-lookup"><span data-stu-id="427f9-1058">During the DAD process, the _*_NX_IPV6_DAD_TRANSMITS_*_ parameter determines the number of NS messages sent by NetX Duo without receiving a response to determine that the address is unique.</span></span> <span data-ttu-id="427f9-1059">По умолчанию и согласно рекомендациям RFC 4862, значение _ *_NX_IPV6_DAD_TRANSMITS_*\* установлено на 3.</span><span class="sxs-lookup"><span data-stu-id="427f9-1059">By default and recommended by RFC 4862, _ *_NX_IPV6_DAD_TRANSMITS_*\* is set at 3.</span></span> <span data-ttu-id="427f9-1060">Установка этого символа равным нулю позволяет по сути отключить DAD.</span><span class="sxs-lookup"><span data-stu-id="427f9-1060">Setting this symbol to zero effectively disables DAD.</span></span>

<span data-ttu-id="427f9-1061">Если ICMPv6 или DAD не включены в момент, когда приложение назначает IPv6-адрес, DAD не выполняется, а NetX Duo немедленно устанавливает для IPv6-адреса состояние VALID.</span><span class="sxs-lookup"><span data-stu-id="427f9-1061">If ICMPv6 or DAD is not enabled at the time the application assigns an IPv6 address, DAD is not performed and NetX Duo sets the state of the IPv6 address to VALID immediately.</span></span>

<span data-ttu-id="427f9-1062">NetX Duo не может связаться с сетью IPv6, пока его локальный или глобальный адрес не станет допустимым.</span><span class="sxs-lookup"><span data-stu-id="427f9-1062">NetX Duo cannot communicate on the IPv6 network until its link local and/or global address is valid.</span></span> <span data-ttu-id="427f9-1063">После получения допустимого адреса NetX Duo пытается сопоставить адрес назначения входящего пакета с одним из настроенных адресов IPv6 или включенным адресом многоадресной рассылки.</span><span class="sxs-lookup"><span data-stu-id="427f9-1063">After a valid address is obtained, NetX Duo attempts to match the destination address of an incoming packet against one of its configured IPv6 address or an enabled multicast address.</span></span> <span data-ttu-id="427f9-1064">Если совпадений не найдено, пакет удаляется.</span><span class="sxs-lookup"><span data-stu-id="427f9-1064">If no matches are found, the packet is dropped.</span></span> 

> [!WARNING]  
> <span data-ttu-id="427f9-1065">\* В ходе процесса DAD число передаваемых пакетов DAD NS определяется \***NX_IPV6_DAD_TRANSMITS** _, значение которого по умолчанию — 3. По умолчанию задержка между сообщениями DAD NS составляет одну секунду. Таким образом, в системе с использованием DAD после назначения IPv6-адреса (при условии, что он не является дублированным адресом) будет наблюдаться задержка примерно в 3 секунды, прежде чем этот адрес окажется в состоянии VALID и будет готов к обмену данными._</span><span class="sxs-lookup"><span data-stu-id="427f9-1065">\*During the DAD process, the number of DAD NS packets to be transmitted is defined by \***NX_IPV6_DAD_TRANSMITS**_, which defaults to 3, and by default there is a one second delay between each DAD NS message is sent. Therefore, in a system with DAD enabled, after an IPv6 address is assigned (and assuming this is not a duplicated address), there is approximately 3 seconds delay before the IP address is in a VALID state and is ready for communication._</span></span>

<span data-ttu-id="427f9-1066">Приложениям может потребоваться получать уведомления при изменении адресов IPv6 в системе.</span><span class="sxs-lookup"><span data-stu-id="427f9-1066">Applications may want to receive notifications when IPv6 addresses in the system are changed.</span></span> <span data-ttu-id="427f9-1067">Чтобы включить функцию уведомлений об изменении адресов IPv6, библиотеку NetX Duo следует создавать с определенным символом **NX_ENABLE_IPV6_ADDRESS_CHANGE_NOTIFY**.</span><span class="sxs-lookup"><span data-stu-id="427f9-1067">To enable the IPv6 address change notification feature, the NetX Duo library must be built with the symbol **NX_ENABLE_IPV6_ADDRESS_CHANGE_NOTIFY** defined.</span></span> <span data-ttu-id="427f9-1068">После включения функции приложения могут установить функцию обратного вызова с помощью службы **_nxd_ipv6_address_change_notify_**.</span><span class="sxs-lookup"><span data-stu-id="427f9-1068">Once the feature is enabled, applications may install the callback function by using the **_nxd_ipv6_address_change_notify_** service.</span></span>

<span data-ttu-id="427f9-1069">Когда адрес IPv6 меняется или становится недействительным, вызывается предоставляемая пользователем функция обратного вызова со следующими сведениями:</span><span class="sxs-lookup"><span data-stu-id="427f9-1069">Once an IPv6 address is changed, or becomes invalid, the user-supplied callback function is invoked with the following information:</span></span>

| <span data-ttu-id="427f9-1070">Функция</span><span class="sxs-lookup"><span data-stu-id="427f9-1070">Function</span></span>  | <span data-ttu-id="427f9-1071">Описание</span><span class="sxs-lookup"><span data-stu-id="427f9-1071">Description</span></span>  |
|---|---|
|<span data-ttu-id="427f9-1072">ip_ptr</span><span class="sxs-lookup"><span data-stu-id="427f9-1072">ip_ptr</span></span> |<span data-ttu-id="427f9-1073">Указатель на экземпляр IP.</span><span class="sxs-lookup"><span data-stu-id="427f9-1073">Pointer to the IP instance</span></span>|
|<span data-ttu-id="427f9-1074">interface_index</span><span class="sxs-lookup"><span data-stu-id="427f9-1074">interface_index</span></span> |<span data-ttu-id="427f9-1075">Индекс сетевого интерфейса, с которым связан этот адрес IPv6.</span><span class="sxs-lookup"><span data-stu-id="427f9-1075">Index to the network interface that this IPv6 address is associated with</span></span>
|<span data-ttu-id="427f9-1076">ipv6_addr_index</span><span class="sxs-lookup"><span data-stu-id="427f9-1076">ipv6_addr_index</span></span> |<span data-ttu-id="427f9-1077">Индекс таблицы адресов IPv6.</span><span class="sxs-lookup"><span data-stu-id="427f9-1077">Index to the IPv6 address table</span></span>|
|<span data-ttu-id="427f9-1078">ipv6_address</span><span class="sxs-lookup"><span data-stu-id="427f9-1078">ipv6_address</span></span> |<span data-ttu-id="427f9-1079">Указатель на IPv6-адрес в виде массива из четырех целых чисел ULONG.</span><span class="sxs-lookup"><span data-stu-id="427f9-1079">Pointer to the IPv6 address, in the form of an array of four ULONG integers.</span></span> <span data-ttu-id="427f9-1080">Адреса Pv6 представлены в порядке байтов узла.</span><span class="sxs-lookup"><span data-stu-id="427f9-1080">Pv6 addresses are presented in host byte order.</span></span>|

### <a name="ipv6-multicast-support-in-netx-duo"></a><span data-ttu-id="427f9-1081">Поддержка многоадресной рассылки IPv6 в NetX Duo</span><span class="sxs-lookup"><span data-stu-id="427f9-1081">IPv6 Multicast Support In NetX Duo</span></span>      
<span data-ttu-id="427f9-1082">Адреса многоадресной рассылки задают динамическую группу узлов в Интернете.</span><span class="sxs-lookup"><span data-stu-id="427f9-1082">Multicast addresses specify a dynamic group of hosts on the Internet.</span></span> <span data-ttu-id="427f9-1083">Члены группы многоадресной рассылки могут присоединяться к группе и выходить из нее по мере необходимости.</span><span class="sxs-lookup"><span data-stu-id="427f9-1083">Members of the multicast group may join and leave whenever they wish.</span></span> <span data-ttu-id="427f9-1084">NetX Duo реализует несколько протоколов ICMPv6, включая обнаружение повторяющихся адресов, обнаружение соседей и обнаружение маршрутизатора, для чего требуется возможность многоадресной рассылки IP.</span><span class="sxs-lookup"><span data-stu-id="427f9-1084">NetX Duo implements several ICMPv6 protocols, including Duplicate Address Detection, Neighbor Discovery, and Router Discovery, which require IP multicast capability.</span></span> <span data-ttu-id="427f9-1085">Поэтому NetX Duo ожидает от драйвера базового устройства поддержки операций с многоадресной рассылкой.</span><span class="sxs-lookup"><span data-stu-id="427f9-1085">Therefore, NetX Duo expects the underlying device driver to support multicast operations.</span></span>

<span data-ttu-id="427f9-1086">Когда NetX Duo необходимо присоединиться к группе многоадресной рассылки (например, адресу многоадресной рассылки для всех узлов и адресу многоадресной рассылки для *запрошенного узла*) или выйти из нее, он отправляет драйверу устройства команду на присоединение к МАС-адресу многоадресной рассылки или выход из него.</span><span class="sxs-lookup"><span data-stu-id="427f9-1086">When NetX Duo needs to join or leave a multicast group (such as the all-node multicast address, and the *solicited-node* multicast address), it issues a driver command to the device driver to join or leave a multicast MAC address.</span></span> <span data-ttu-id="427f9-1087">Команда драйвера для соединения с адресом многоадресной рассылки — \***NX_LINK_MULTICAST_JOIN** _.</span><span class="sxs-lookup"><span data-stu-id="427f9-1087">The driver command for joining the multicast address is \***NX_LINK_MULTICAST_JOIN** _.</span></span> <span data-ttu-id="427f9-1088">Чтобы оставить адрес многоадресной рассылки, NetX Duo выдает команду драйвера _\*_NX_LINK_MULTICAST_LEAVE_\*\*.</span><span class="sxs-lookup"><span data-stu-id="427f9-1088">To leave a multicast address, NetX Duo issues the driver command _\*_NX_LINK_MULTICAST_LEAVE_\*\*.</span></span> <span data-ttu-id="427f9-1089">Чтобы протоколы ICMPv6 работали правильно, драйвер устройства должен реализовать эти две команды.</span><span class="sxs-lookup"><span data-stu-id="427f9-1089">The device driver must implement these two commands for ICMPv6 protocols to work properly.</span></span>

<span data-ttu-id="427f9-1090">Приложения могут присоединяться к группе многоадресной рассылки IPv6 с помощью службы \***nxd_ipv6_multicast_interface_join\*.**</span><span class="sxs-lookup"><span data-stu-id="427f9-1090">Applications may join an IPv6 multicast group by using the service \***nxd_ipv6_multicast_interface_join\*.**</span></span> <span data-ttu-id="427f9-1091">Эта служба регистрирует адрес многоадресной рассылки с помощью стека IP-адресов, а затем уведомляет указанный драйвер устройства об адресе многоадресной рассылки IPv6.</span><span class="sxs-lookup"><span data-stu-id="427f9-1091">This service registers the multicast address with the IP stack, and then notifies the specified device driver of the IPv6 multicast address.</span></span> <span data-ttu-id="427f9-1092">Чтобы выйти из группы многоадресной рассылки, приложения используют службу ***nxd_ipv6_multicast_interface_leave***.</span><span class="sxs-lookup"><span data-stu-id="427f9-1092">To leave a multicast group, applications use the service ***nxd_ipv6_multicast_interface_leave.***</span></span>

### <a name="neighbor-discovery-nd"></a><span data-ttu-id="427f9-1093">Обнаружение соседей (ND)</span><span class="sxs-lookup"><span data-stu-id="427f9-1093">Neighbor Discovery (ND)</span></span>    
<span data-ttu-id="427f9-1094">Обнаружение соседей — это протокол в сетях IPv6 для сопоставления физических адресов с IPv6-адресами (глобальный адрес или адрес локальной связи).</span><span class="sxs-lookup"><span data-stu-id="427f9-1094">Neighbor Discovery is a protocol in IPv6 networks for mapping physical addresses to the IPv6 addresses (global address or link-local address).</span></span> <span data-ttu-id="427f9-1095">Это сопоставление сохраняется в кэше обнаружения соседей (кэш ND).</span><span class="sxs-lookup"><span data-stu-id="427f9-1095">This mapping is maintained in the Neighbor Discovery Cache (ND Cache).</span></span> <span data-ttu-id="427f9-1096">Процесс ND эквивалентен процессу ARP в IPv4, а кэш ND аналогичен таблице ARP.</span><span class="sxs-lookup"><span data-stu-id="427f9-1096">The ND process is the equivalent of the ARP process in IPv4, and the ND Cache is similar to the ARP table.</span></span> <span data-ttu-id="427f9-1097">Узел IPv6 может получить MAC-адрес его соседа по протоколу обнаружения соседей (ND).</span><span class="sxs-lookup"><span data-stu-id="427f9-1097">An IPv6 node can obtain its neighbor's MAC address using the Neighbor Discovery (ND) protocol.</span></span> <span data-ttu-id="427f9-1098">Он отправляет сообщение запроса соседей (NS) по адресу многоадресной рассылки запрошенного узла, а затем ожидает соответствующее сообщение объявления соседа (NA).</span><span class="sxs-lookup"><span data-stu-id="427f9-1098">It sends out a neighbor solicitation (NS) message to the all-node solicited node multicast address, and waits for a corresponding neighbor advertisement (NA) message.</span></span> <span data-ttu-id="427f9-1099">MAC-адрес, полученный с помощью этого процесса, хранится в кэше ND.</span><span class="sxs-lookup"><span data-stu-id="427f9-1099">The MAC address obtained through this process is stored in the ND Cache.</span></span>

<span data-ttu-id="427f9-1100">У каждого экземпляра IP есть один кэш ND.</span><span class="sxs-lookup"><span data-stu-id="427f9-1100">Each IP instance has one ND cache.</span></span> <span data-ttu-id="427f9-1101">Кэш ND хранится в виде массива записей.</span><span class="sxs-lookup"><span data-stu-id="427f9-1101">The ND Cache is maintained as an array of entries.</span></span> <span data-ttu-id="427f9-1102">Размер массива определяется во время компиляции с помощью параметра ***NX_IPV6_NEIGHBOR_CACHE_SIZE** _, который находится в _*_nx_user.h_\*\*.</span><span class="sxs-lookup"><span data-stu-id="427f9-1102">The size of the array is defined at compilation time by setting the option ***NX_IPV6_NEIGHBOR_CACHE_SIZE** _ which in _*_nx_user.h_\*\*.</span></span> <span data-ttu-id="427f9-1103">Обратите внимание, что все интерфейсы, подключенные к экземпляру IP, имеют общий кэш ND.</span><span class="sxs-lookup"><span data-stu-id="427f9-1103">Note that all interfaces attached to an IP instance share the same ND cache.</span></span>

<span data-ttu-id="427f9-1104">При запуске NetX Duo весь кэш ND пуст.</span><span class="sxs-lookup"><span data-stu-id="427f9-1104">The entire ND Cache is empty when NetX Duo starts up.</span></span> <span data-ttu-id="427f9-1105">По ходу работы системы NetX Duo автоматически обновляет кэш ND, добавляя и удаляя записи в соответствии с протоколом ND.</span><span class="sxs-lookup"><span data-stu-id="427f9-1105">As the system runs, NetX Duo automatically updates the ND Cache, adding and deleting entries as per ND protocol.</span></span> <span data-ttu-id="427f9-1106">Однако приложение также может обновлять кэш ND, добавляя и удаляя записи кэша вручную, используя следующие службы NetX Duo:</span><span class="sxs-lookup"><span data-stu-id="427f9-1106">However, an application may also update the ND Cache by manually adding and deleting cache entries using the following NetX Duo services:</span></span>

- <span data-ttu-id="427f9-1107">***nxd_nd_cache_entry_delete***</span><span class="sxs-lookup"><span data-stu-id="427f9-1107">***nxd_nd_cache_entry_delete***</span></span>  
- <span data-ttu-id="427f9-1108">***nxd_nd_cache_entry_set***</span><span class="sxs-lookup"><span data-stu-id="427f9-1108">***nxd_nd_cache_entry_set***</span></span>   
- <span data-ttu-id="427f9-1109">***nxd_nd_cache_invalidate***</span><span class="sxs-lookup"><span data-stu-id="427f9-1109">***nxd_nd_cache_invalidate***</span></span>

<span data-ttu-id="427f9-1110">При отправке и получении пакетов IPv6 NetX Duo автоматически обновляет таблицу кэша ND.</span><span class="sxs-lookup"><span data-stu-id="427f9-1110">When sending and receiving IPv6 packets, NetX Duo automatically updates the ND Cache table.</span></span>

## <a name="internet-control-message-protocol-in-ipv6-icmpv6"></a><span data-ttu-id="427f9-1111">Протокол межсетевых управляющих сообщений в IPv6 (ICMPv6)</span><span class="sxs-lookup"><span data-stu-id="427f9-1111">Internet Control Message Protocol in IPv6 (ICMPv6)</span></span>  

<span data-ttu-id="427f9-1112">Роль ICMPv6 в IPv6 была значительно расширена для поддержки сопоставления IPv6-адресов и обнаружения маршрутизатора.</span><span class="sxs-lookup"><span data-stu-id="427f9-1112">The role of ICMPv6 in IPv6 has been greatly expanded to support IPv6 address mapping and router discovery.</span></span> <span data-ttu-id="427f9-1113">Кроме того, ICMPv6 NetX Duo поддерживает эхо-запросы и ответы, отчеты об ошибках ICMPv6 и сообщения перенаправления ICMPv6.</span><span class="sxs-lookup"><span data-stu-id="427f9-1113">In addition, NetX Duo ICMPv6 supports echo request and response, ICMPv6 error reports, and ICMPv6 redirect messages.</span></span>

### <a name="icmpv6-enable"></a><span data-ttu-id="427f9-1114">Включение ICMPv6</span><span class="sxs-lookup"><span data-stu-id="427f9-1114">ICMPv6 Enable</span></span>    
<span data-ttu-id="427f9-1115">Прежде чем сообщения ICMPv6 смогут быть обработаны NetX Duo, приложение должно вызвать службу ***nxd_icmp_enable***, чтобы включить обработку ICMPv6, как описано выше.</span><span class="sxs-lookup"><span data-stu-id="427f9-1115">Before ICMPv6 messages can be processed by NetX Duo, the application must call the ***nxd_icmp_enable*** service to enable ICMPv6 processing as explained previously.</span></span> 

### <a name="icmpv6-messages"></a><span data-ttu-id="427f9-1116">Сообщения ICMPv6</span><span class="sxs-lookup"><span data-stu-id="427f9-1116">ICMPv6 Messages</span></span>     
<span data-ttu-id="427f9-1117">Структура заголовка ICMPv6 аналогична структуре заголовка ICMPv4.</span><span class="sxs-lookup"><span data-stu-id="427f9-1117">The ICMPv6 header structure is similar to the ICMPv4 header structure.</span></span> <span data-ttu-id="427f9-1118">Как показано ниже, базовый заголовок ICMPv6 содержит три поля, тип, код и контрольную сумму, а также переменную длину данных параметра ICMPv6.</span><span class="sxs-lookup"><span data-stu-id="427f9-1118">As shown below, the basic ICMPv6 header contains the three fields, type, code, and checksum, plus variable length of ICMPv6 option data.</span></span> 

![Схема базового заголовка ICMPv6.](./media/user-guide/image19.png)

<span data-ttu-id="427f9-1120">**РИС. 10. Базовый заголовок ICMPv6**</span><span class="sxs-lookup"><span data-stu-id="427f9-1120">**FIGURE 10. Basic ICMPv6 Header**</span></span>

|<span data-ttu-id="427f9-1121">Поле</span><span class="sxs-lookup"><span data-stu-id="427f9-1121">Field</span></span> |<span data-ttu-id="427f9-1122">Размер (байт)</span><span class="sxs-lookup"><span data-stu-id="427f9-1122">Size(bytes)</span></span> |<span data-ttu-id="427f9-1123">Описание</span><span class="sxs-lookup"><span data-stu-id="427f9-1123">Description</span></span> |
|-----|-----|-----|
|     | <span data-ttu-id="427f9-1124">1</span><span class="sxs-lookup"><span data-stu-id="427f9-1124">1</span></span>   |<span data-ttu-id="427f9-1125">Определяет тип сообщения ICMPv6:</span><span class="sxs-lookup"><span data-stu-id="427f9-1125">Identifies the ICMPv6 message type;</span></span> |
|     |     |<span data-ttu-id="427f9-1126">1 Назначение недоступно</span><span class="sxs-lookup"><span data-stu-id="427f9-1126">1 Destination Unreachable</span></span> |
|     |     |<span data-ttu-id="427f9-1127">2 Пакет слишком велик</span><span class="sxs-lookup"><span data-stu-id="427f9-1127">2 Packet Too Big</span></span> |
|     |     |<span data-ttu-id="427f9-1128">3 Превышение времени</span><span class="sxs-lookup"><span data-stu-id="427f9-1128">3 Time Exceeded</span></span> |
|     |     |<span data-ttu-id="427f9-1129">4 Проблема с параметром</span><span class="sxs-lookup"><span data-stu-id="427f9-1129">4 Parameter Problem</span></span> |
|     |     |<span data-ttu-id="427f9-1130">128 Запрос проверки связи</span><span class="sxs-lookup"><span data-stu-id="427f9-1130">128 Echo Request</span></span> |
|     |     |<span data-ttu-id="427f9-1131">129 Ответ на запрос проверки связи</span><span class="sxs-lookup"><span data-stu-id="427f9-1131">129 Echo Reply</span></span> |
|     |     |<span data-ttu-id="427f9-1132">133 Запрос маршрутизатора</span><span class="sxs-lookup"><span data-stu-id="427f9-1132">133 Router Solicitation</span></span> |
|     |     |<span data-ttu-id="427f9-1133">134 Объявление маршрутизатора</span><span class="sxs-lookup"><span data-stu-id="427f9-1133">134 Router Advertisement</span></span> |
|     |     |<span data-ttu-id="427f9-1134">135 Запрос соседей</span><span class="sxs-lookup"><span data-stu-id="427f9-1134">135 Neighbor Solicitation</span></span> |
|     |     |<span data-ttu-id="427f9-1135">136 Объявление соседа</span><span class="sxs-lookup"><span data-stu-id="427f9-1135">136 Neighbor Advertisement</span></span> |
|     |     |<span data-ttu-id="427f9-1136">137 Сообщение о перенаправлении</span><span class="sxs-lookup"><span data-stu-id="427f9-1136">137 Redirect Message</span></span> |
|<span data-ttu-id="427f9-1137">Код</span><span class="sxs-lookup"><span data-stu-id="427f9-1137">Code</span></span> | <span data-ttu-id="427f9-1138">1</span><span class="sxs-lookup"><span data-stu-id="427f9-1138">1</span></span>   |<span data-ttu-id="427f9-1139">Дополнительно определяет тип сообщения ICMPv6.</span><span class="sxs-lookup"><span data-stu-id="427f9-1139">Further qualifies the ICMPv6 message type.</span></span> <span data-ttu-id="427f9-1140">Обычно используется с сообщениями об ошибках.</span><span class="sxs-lookup"><span data-stu-id="427f9-1140">Generally used with error messages.</span></span> <span data-ttu-id="427f9-1141">Если не используется, значение устанавливается на ноль.</span><span class="sxs-lookup"><span data-stu-id="427f9-1141">If not used, it is set to zero.</span></span> <span data-ttu-id="427f9-1142">Запросы проверки связи, ответы на них и сообщения NS не используют его.</span><span class="sxs-lookup"><span data-stu-id="427f9-1142">Echo request/reply and NS messages do not use it.</span></span>|
|<span data-ttu-id="427f9-1143">Контрольная сумма</span><span class="sxs-lookup"><span data-stu-id="427f9-1143">Checksum</span></span> | <span data-ttu-id="427f9-1144">2</span><span class="sxs-lookup"><span data-stu-id="427f9-1144">2</span></span> |<span data-ttu-id="427f9-1145">16-разрядное поле контрольной суммы для заголовка ICMP.</span><span class="sxs-lookup"><span data-stu-id="427f9-1145">16-bit checksum field for the ICMP Header.</span></span> <span data-ttu-id="427f9-1146">Это 16-разрядное дополнение для всего сообщения ICMPv6, включая заголовок ICMPv6.</span><span class="sxs-lookup"><span data-stu-id="427f9-1146">This is a 16-bit complement of the entire ICMPv6 message, including the ICMPv6 header.</span></span> <span data-ttu-id="427f9-1147">Оно также включает в себя псевдозаголовок исходного адреса IPv6, адрес назначения и длину полезных данных пакета.</span><span class="sxs-lookup"><span data-stu-id="427f9-1147">It also includes a pseudo-header of the IPv6 source address, destination address, and packet payload length.</span></span> |

<span data-ttu-id="427f9-1148">Ниже приведен пример заголовка запроса соседей.</span><span class="sxs-lookup"><span data-stu-id="427f9-1148">An example Neighbor Solicitation header is shown below.</span></span>

![Схема примера заголовка запроса соседей.](./media/user-guide/image20.jpg)

<span data-ttu-id="427f9-1150">**РИС. 11. Заголовок ICMPv6 для сообщения запроса соседей**</span><span class="sxs-lookup"><span data-stu-id="427f9-1150">**FIGURE 11. ICMPv6 Header for a Neighbor Solicitation Message**</span></span>

|<span data-ttu-id="427f9-1151">Поле</span><span class="sxs-lookup"><span data-stu-id="427f9-1151">Field</span></span> |<span data-ttu-id="427f9-1152">Размер (байт)</span><span class="sxs-lookup"><span data-stu-id="427f9-1152">Size(bytes)</span></span> |<span data-ttu-id="427f9-1153">Описание</span><span class="sxs-lookup"><span data-stu-id="427f9-1153">Description</span></span> |
|-----|-----|-----|
|<span data-ttu-id="427f9-1154">Тип</span><span class="sxs-lookup"><span data-stu-id="427f9-1154">Type</span></span> | <span data-ttu-id="427f9-1155">1</span><span class="sxs-lookup"><span data-stu-id="427f9-1155">1</span></span>   |<span data-ttu-id="427f9-1156">Определяет тип сообщения ICMPv6 для сообщений запроса соседей.</span><span class="sxs-lookup"><span data-stu-id="427f9-1156">Identifies the ICMPv6 message type for neighbor solicitation messages.</span></span> <span data-ttu-id="427f9-1157">Значение равно 135.</span><span class="sxs-lookup"><span data-stu-id="427f9-1157">Value is 135.</span></span> |
|<span data-ttu-id="427f9-1158">Код</span><span class="sxs-lookup"><span data-stu-id="427f9-1158">Code</span></span> | <span data-ttu-id="427f9-1159">1</span><span class="sxs-lookup"><span data-stu-id="427f9-1159">1</span></span>   |<span data-ttu-id="427f9-1160">Не используется.</span><span class="sxs-lookup"><span data-stu-id="427f9-1160">Not used.</span></span> <span data-ttu-id="427f9-1161">Задайте значение 0.</span><span class="sxs-lookup"><span data-stu-id="427f9-1161">Set to 0.</span></span> |
|<span data-ttu-id="427f9-1162">Контрольная сумма</span><span class="sxs-lookup"><span data-stu-id="427f9-1162">Checksum</span></span> | <span data-ttu-id="427f9-1163">2</span><span class="sxs-lookup"><span data-stu-id="427f9-1163">2</span></span>  |<span data-ttu-id="427f9-1164">16-разрядное поле контрольной суммы для заголовка ICMPv6.</span><span class="sxs-lookup"><span data-stu-id="427f9-1164">16-bit checksum field for the ICMPv6 header.</span></span> |
|<span data-ttu-id="427f9-1165">Зарезервировано</span><span class="sxs-lookup"><span data-stu-id="427f9-1165">Reserved</span></span> | <span data-ttu-id="427f9-1166">4</span><span class="sxs-lookup"><span data-stu-id="427f9-1166">4</span></span>  |<span data-ttu-id="427f9-1167">4 зарезервированных байта имеют значение 0.</span><span class="sxs-lookup"><span data-stu-id="427f9-1167">4 reserved bytes set to 0.</span></span> |
|<span data-ttu-id="427f9-1168">Целевой адрес</span><span class="sxs-lookup"><span data-stu-id="427f9-1168">Target Address</span></span> | <span data-ttu-id="427f9-1169">16</span><span class="sxs-lookup"><span data-stu-id="427f9-1169">16</span></span>  |<span data-ttu-id="427f9-1170">Адрес IPv6 цели запроса.</span><span class="sxs-lookup"><span data-stu-id="427f9-1170">IPv6 address of target of the solicitation.</span></span> <span data-ttu-id="427f9-1171">Для разрешения адресов IPv6 это фактический IP-адрес устройства, для которого необходимо разрешить адрес канального уровня.</span><span class="sxs-lookup"><span data-stu-id="427f9-1171">For IPv6 address resolution, this is the actual unicast IP address of the device whose link layer address needs to be resolved.</span></span> |
|<span data-ttu-id="427f9-1172">Параметры</span><span class="sxs-lookup"><span data-stu-id="427f9-1172">Options</span></span> | <span data-ttu-id="427f9-1173">Переменная</span><span class="sxs-lookup"><span data-stu-id="427f9-1173">Variable</span></span> |<span data-ttu-id="427f9-1174">Дополнительные сведения, заданные протоколом обнаружения соседей.</span><span class="sxs-lookup"><span data-stu-id="427f9-1174">Optional information specified by the Neighbor Discovery Protocol.</span></span> |

### <a name="icmpv6-ping-request"></a><span data-ttu-id="427f9-1175">Запрос проверки связи ICMPv6</span><span class="sxs-lookup"><span data-stu-id="427f9-1175">ICMPv6 Ping Request</span></span>
<span data-ttu-id="427f9-1176">В приложениях NetX Duo используйте ***nxd_icmp_ping***, чтобы выдавать запросы проверки связи IPv6 или IPv4 на основе IP-адреса назначения, указанного в параметрах.</span><span class="sxs-lookup"><span data-stu-id="427f9-1176">In NetX Duo applications use ***nxd_icmp_ping*** to issue either IPv6 or IPv4 ping requests, based on the destination IP address specified in the parameters.</span></span>  

### <a name="icmpv6-ping-response"></a><span data-ttu-id="427f9-1177">Запрос проверки связи ICMPv6</span><span class="sxs-lookup"><span data-stu-id="427f9-1177">ICMPv6 Ping Response</span></span>
<span data-ttu-id="427f9-1178">Ответ на запрос проверки связи ICMPv6 — это еще один тип сообщения ICMPv6, который создается внутри компонента ICMPv6 в ответ на внешний запрос проверки связи ICMPv6.</span><span class="sxs-lookup"><span data-stu-id="427f9-1178">An ICMPv6 ping response is another type of ICMPv6 message that is generated internally by the ICMPv6 component in response to an external ICMPv6 ping request.</span></span> <span data-ttu-id="427f9-1179">Кроме подтверждения, ответ на запрос проверки связи ICMPv6 также содержит копию данных пользователя, содержащихся в запросе проверки связи ICMPv6.</span><span class="sxs-lookup"><span data-stu-id="427f9-1179">In additional to acknowledgement, the ICMPv6 ping response also contains a copy of the user data supplied in the ICMPv6 ping request.</span></span>  

### <a name="thread-suspension"></a><span data-ttu-id="427f9-1180">Приостановка потока</span><span class="sxs-lookup"><span data-stu-id="427f9-1180">Thread Suspension</span></span>
<span data-ttu-id="427f9-1181">Потоки приложения могут быть приостановлены во время попыток проверить связь с другим членом сети.</span><span class="sxs-lookup"><span data-stu-id="427f9-1181">Application threads can suspend while attempting to ping another network member.</span></span> <span data-ttu-id="427f9-1182">После получения ответа на запрос проверки связи сообщение об этом ответе выдается первому приостановленному потоку, и этот поток возобновляется.</span><span class="sxs-lookup"><span data-stu-id="427f9-1182">After a ping response is received, the ping response message is given to the first thread suspended and that thread is resumed.</span></span> <span data-ttu-id="427f9-1183">Как и все службы NetX Duo, приостановка в запросе проверки связи имеет необязательное время ожидания.</span><span class="sxs-lookup"><span data-stu-id="427f9-1183">Like all NetX Duo services, suspending on a ping request has an optional timeout.</span></span>  

### <a name="other-icmpv6-messages"></a><span data-ttu-id="427f9-1184">Другие сообщения ICMPv6</span><span class="sxs-lookup"><span data-stu-id="427f9-1184">Other ICMPv6 Messages</span></span>
<span data-ttu-id="427f9-1185">Сообщения ICMPv6 необходимы для следующих функций:</span><span class="sxs-lookup"><span data-stu-id="427f9-1185">ICMPv6 messages are required for the following features:</span></span>  

- <span data-ttu-id="427f9-1186">Обнаружение окружения</span><span class="sxs-lookup"><span data-stu-id="427f9-1186">Neighbor Discovery</span></span>  
- <span data-ttu-id="427f9-1187">Автоматическая настройка адресов без отслеживания состояния</span><span class="sxs-lookup"><span data-stu-id="427f9-1187">Stateless Address Autoconfiguration</span></span> 
- <span data-ttu-id="427f9-1188">Обнаружение маршрутизатора</span><span class="sxs-lookup"><span data-stu-id="427f9-1188">Router Discovery</span></span> 
- <span data-ttu-id="427f9-1189">Обнаружение недостижимости соседа</span><span class="sxs-lookup"><span data-stu-id="427f9-1189">Neighbor Unreachability Detection</span></span>  

### <a name="neighbor-unreachability-router-and-prefix-discovery"></a><span data-ttu-id="427f9-1190">Недостижимость соседа, обнаружение маршрутизатора и префикса</span><span class="sxs-lookup"><span data-stu-id="427f9-1190">Neighbor Unreachability, Router and Prefix Discovery</span></span>    
<span data-ttu-id="427f9-1191">Обнаружение недостижимости соседа, обнаружение маршрутизатора и обнаружение префикса основаны на протоколе обнаружения соседей и описаны ниже.</span><span class="sxs-lookup"><span data-stu-id="427f9-1191">Neighbor Unreachability Detection, Router Discovery, and Prefix Discovery are based on the Neighbor Discovery protocol and are described below.</span></span> 

<span data-ttu-id="427f9-1192">***Обнаружение недостижимости соседа:*** устройство IPv6 выполняет поиск целевого адреса канального уровня в кэше обнаружения соседей (ND), когда необходимо отправить пакет.</span><span class="sxs-lookup"><span data-stu-id="427f9-1192">***Neighbor Unreachability Detection:*** An IPv6 device searches its Neighbor Discovery (ND) Cache for the destination link layer address when it wishes to send a packet.</span></span> <span data-ttu-id="427f9-1193">Немедленное место назначения, которое иногда называют "следующим прыжком", может быть фактическим местом назначения по той же ссылке или маршрутизатором, если назначением является транспортный канал.</span><span class="sxs-lookup"><span data-stu-id="427f9-1193">The immediate destination, sometimes referred to as the 'next hop,' may be the actual destination on the same link or it may be a router if the destination is off link.</span></span> <span data-ttu-id="427f9-1194">Запись кэша ND содержит состояние доступности соседа.</span><span class="sxs-lookup"><span data-stu-id="427f9-1194">An ND cache entry contains the status on a neighbor's reachability.</span></span>

<span data-ttu-id="427f9-1195">Состояние REACHABLE (достижим) указывает, что сосед считается достижимым.</span><span class="sxs-lookup"><span data-stu-id="427f9-1195">A REACHABLE status indicates the neighbor is considered reachable.</span></span> <span data-ttu-id="427f9-1196">Сосед доступен, если он недавно получил подтверждение о получении пакетов, отправленных соседу.</span><span class="sxs-lookup"><span data-stu-id="427f9-1196">A neighbor is reachable if it has recently received confirmation that packets sent to the neighbor have been received.</span></span> <span data-ttu-id="427f9-1197">Подтверждение в NetX Duo принимает сообщение Н/Д от соседа в ответ на сообщение NS, отправленное устройством NetX Duo.</span><span class="sxs-lookup"><span data-stu-id="427f9-1197">Confirmation in NetX Duo take the form of receiving an NA message from the neighbor in response to an NS message sent by the NetX Duo device.</span></span> <span data-ttu-id="427f9-1198">NetX Duo также изменит состояние соседа на REACHABLE, если приложение вызывает службу NetX Duo ***nxd_nd_cache_entry_set***, чтобы вручную ввести запись кэша.</span><span class="sxs-lookup"><span data-stu-id="427f9-1198">NetX Duo will also change the state of the neighbor status to REACHABLE if the application calls the NetX Duo service ***nxd_nd_cache_entry_set*** to manually enter a cache record.</span></span>

<span data-ttu-id="427f9-1199">***Обнаружение маршрутизатора:*** устройство IPv6 использует маршрутизатор для пересылки всех пакетов, отправляемых транспортным каналам.</span><span class="sxs-lookup"><span data-stu-id="427f9-1199">***Router Discovery:*** An IPv6 device uses a router to forward all packets intended for off link destinations.</span></span> <span data-ttu-id="427f9-1200">Кроме того, для настройки глобальных IPv6-адресов может использоваться информация, передаваемая маршрутизатором, например сообщения объявлений маршрутизатора (RA).</span><span class="sxs-lookup"><span data-stu-id="427f9-1200">It may also use information sent by the router, such as router advertisement (RA) messages, to configure its global IPv6 addresses.</span></span>

<span data-ttu-id="427f9-1201">Устройство в сети может инициировать процесс обнаружения маршрутизатора, отправляя сообщение о запросе маршрутизатора (RS) по адресу многоадресной рассылки для всех маршрутизаторов (FF01::2).</span><span class="sxs-lookup"><span data-stu-id="427f9-1201">A device on the network may initiate the Router Discovery process by sending a router solicitation (RS) message to the all-router multicast address (FF01::2).</span></span> <span data-ttu-id="427f9-1202">Или оно может ожидать периодические объявления маршрутизатора на адресе многоадресной рассылки для всех узлов (FF::1).</span><span class="sxs-lookup"><span data-stu-id="427f9-1202">Or it can wait on the all-node multicast address (FF::1) for a periodic RA from the routers.</span></span>

<span data-ttu-id="427f9-1203">Сообщение RA содержит сведения о префиксах, чтобы настроить адрес IPv6 для этой сети.</span><span class="sxs-lookup"><span data-stu-id="427f9-1203">An RA message contains the prefix information for configuring an IPv6 address for that network.</span></span> <span data-ttu-id="427f9-1204">В NetX Duo запрос маршрутизатора включен по умолчанию и может быть отключен путем установки параметра конфигурации ***NX_DISABLE_ICMPV6_ROUTER_SOLICITATION** _ в _*_nx_user.h_\*\*.</span><span class="sxs-lookup"><span data-stu-id="427f9-1204">In NetX Duo, router solicitation is by default enabled and can be disabled by setting the configuration option ***NX_DISABLE_ICMPV6_ROUTER_SOLICITATION** _ in _*_nx_user.h_\*\*.</span></span> <span data-ttu-id="427f9-1205">Дополнительные сведения о настройке параметров запроса маршрутизатора см. в разделе "Параметры конфигурации" главы "Установка и использование NetX Duo".</span><span class="sxs-lookup"><span data-stu-id="427f9-1205">See Configuration Options in the "Installation and Use of NetX Duo" chapter for more details on setting Router Solicitation parameters.</span></span> 

<span data-ttu-id="427f9-1206">***Обнаружение префиксов***: устройство IPv6 использует обнаружение префиксов, чтобы узнавать, какие целевые узлы доступны напрямую без использования маршрутизатора.</span><span class="sxs-lookup"><span data-stu-id="427f9-1206">***Prefix Discovery***: An IPv6 device uses prefix discovery to learn which target hosts are accessible directly without going through a router.</span></span> <span data-ttu-id="427f9-1207">Эта информация предоставляется устройству IPv6 через сообщения RA от маршрутизатора.</span><span class="sxs-lookup"><span data-stu-id="427f9-1207">This information is made available to the IPv6 device from RA messages from the router.</span></span> <span data-ttu-id="427f9-1208">На устройстве IPv6 сведения о префиксах хранятся в таблице префиксов.</span><span class="sxs-lookup"><span data-stu-id="427f9-1208">The IPv6 device stores the prefix information in a prefix table.</span></span> <span data-ttu-id="427f9-1209">Обнаружение префикса — это сопоставление префикса из таблицы префиксов устройств IPv6 с целевым адресом.</span><span class="sxs-lookup"><span data-stu-id="427f9-1209">Prefix discovery is matching a prefix from the IPv6 device prefix table to a target address.</span></span> <span data-ttu-id="427f9-1210">Префикс соответствует целевому адресу, если все биты в префиксе совпадают с наиболее значащими битами целевого адреса.</span><span class="sxs-lookup"><span data-stu-id="427f9-1210">A prefix matches a target address if all the bits in the prefix match the most significant bits of the target address.</span></span> <span data-ttu-id="427f9-1211">Если более одного префикса соответствует адресу, то выбирается самый длинный.</span><span class="sxs-lookup"><span data-stu-id="427f9-1211">If more than one prefix covers an address, the longest prefix is selected.</span></span>

### <a name="icmpv6-error-messages"></a><span data-ttu-id="427f9-1212">Сообщения об ошибках ICMPv6</span><span class="sxs-lookup"><span data-stu-id="427f9-1212">ICMPv6 Error Messages</span></span>    
<span data-ttu-id="427f9-1213">В NetX Duo поддерживаются следующие сообщения об ошибках ICMPv6:</span><span class="sxs-lookup"><span data-stu-id="427f9-1213">The following ICMPv6 error messages are supported in NetX Duo:</span></span>  

- <span data-ttu-id="427f9-1214">Объект назначения недоступен</span><span class="sxs-lookup"><span data-stu-id="427f9-1214">Destination Unreachable</span></span>  
- <span data-ttu-id="427f9-1215">Пакет слишком велик</span><span class="sxs-lookup"><span data-stu-id="427f9-1215">Packet Too Big</span></span>  
- <span data-ttu-id="427f9-1216">Время превышено</span><span class="sxs-lookup"><span data-stu-id="427f9-1216">Time Exceed</span></span>  
- <span data-ttu-id="427f9-1217">Проблема с параметром</span><span class="sxs-lookup"><span data-stu-id="427f9-1217">Parameter Problem</span></span>  

## <a name="user-datagram-protocol-udp"></a><span data-ttu-id="427f9-1218">Протокол пользовательских датаграмм (UDP)</span><span class="sxs-lookup"><span data-stu-id="427f9-1218">User Datagram Protocol (UDP)</span></span>

<span data-ttu-id="427f9-1219">Протокол пользовательских датаграмм (UDP) обеспечивает простейшую форму передачи данных между участниками сети (RFC 768).</span><span class="sxs-lookup"><span data-stu-id="427f9-1219">The User Datagram Protocol (UDP) provides the simplest form of data transfer between network members (RFC 768).</span></span> <span data-ttu-id="427f9-1220">Пакеты данных UDP отправляются от одного участника сети к другому по принципу наименьших затрат, т. е. встроенный механизм подтверждения получателем пакета отсутствует.</span><span class="sxs-lookup"><span data-stu-id="427f9-1220">UDP data packets are sent from one network member to another in a best effort fashion; i.e., there is no built-in mechanism for acknowledgement by the packet recipient.</span></span> <span data-ttu-id="427f9-1221">Кроме того, в данном случае перед отправкой пакета UDP не требуется устанавливать подключение заранее.</span><span class="sxs-lookup"><span data-stu-id="427f9-1221">In addition, sending a UDP packet does not require any connection to be established in advance.</span></span> <span data-ttu-id="427f9-1222">По этой причине передача пакетов UDP очень эффективна.</span><span class="sxs-lookup"><span data-stu-id="427f9-1222">Because of this, UDP packet transmission is very efficient.</span></span>

<span data-ttu-id="427f9-1223">Для разработчиков, которые переходят свои приложения NetX на NetX Duo, в NetX Duo есть лишь несколько основных изменений функций UDP, по сравнению с NetX.</span><span class="sxs-lookup"><span data-stu-id="427f9-1223">For developers migrating their NetX applications to NetX Duo there are only a few basic changes in UDP functionality between NetX and NetX Duo.</span></span> <span data-ttu-id="427f9-1224">Это связано с тем, что IPv6 в первую очередь касается базового уровня IP.</span><span class="sxs-lookup"><span data-stu-id="427f9-1224">This is because IPv6 is primarily concerned with the underlying IP layer.</span></span> <span data-ttu-id="427f9-1225">Все службы UDP NetX Duo можно использовать для подключений IPv4 или IPv6.</span><span class="sxs-lookup"><span data-stu-id="427f9-1225">All NetX Duo UDP services can be used for either IPv4 or IPv6 connectivity.</span></span>

### <a name="udp-header"></a><span data-ttu-id="427f9-1226">Заголовок UDP</span><span class="sxs-lookup"><span data-stu-id="427f9-1226">UDP Header</span></span>       
<span data-ttu-id="427f9-1227">При передаче UDP помещает простой заголовок пакета перед данными приложения и удаляет аналогичный заголовок UDP из пакета при его получении, прежде чем передавать полученный UDP-пакет приложению.</span><span class="sxs-lookup"><span data-stu-id="427f9-1227">UDP places a simple packet header in front of the application's data on transmission, and removes a similar UDP header from the packet on reception before delivering a received UDP packet to the application.</span></span> <span data-ttu-id="427f9-1228">UDP использует протокол IP для отправки и получения пакетов, поэтому, когда пакет находится в сети, перед его заголовком UDP размещается заголовок IP.</span><span class="sxs-lookup"><span data-stu-id="427f9-1228">UDP utilizes the IP protocol for sending and receiving packets, which means there is an IP header in front of the UDP header when the packet is on the network.</span></span> <span data-ttu-id="427f9-1229">На рис. 12 показан формат заголовка UDP.</span><span class="sxs-lookup"><span data-stu-id="427f9-1229">Figure 12 shows the format of the UDP header.</span></span>

![Схема формата заголовка UDP.](./media/user-guide/image21.png)

### <a name="figure-12-udp-header"></a><span data-ttu-id="427f9-1231">РИС. 12.</span><span class="sxs-lookup"><span data-stu-id="427f9-1231">FIGURE 12.</span></span> <span data-ttu-id="427f9-1232">Заголовок UDP</span><span class="sxs-lookup"><span data-stu-id="427f9-1232">UDP Header</span></span>

> [!NOTE]
> <span data-ttu-id="427f9-1233">*Все заголовки в реализации UDP/IP должны быть представлены в формате с **обратным порядком байтов**. В этом формате наиболее значимый байт слова размещается по наименьшему байтовому адресу.*</span><span class="sxs-lookup"><span data-stu-id="427f9-1233">*All headers in the UDP/IP implementation are expected to be in **big endian** format. In this format, the most significant byte of the word resides at the lowest byte address.*</span></span>

<span data-ttu-id="427f9-1234">В следующей таблице описывается формат заголовка UDP.</span><span class="sxs-lookup"><span data-stu-id="427f9-1234">The following describes the UDP header format:</span></span>

|<span data-ttu-id="427f9-1235">Поле заголовка</span><span class="sxs-lookup"><span data-stu-id="427f9-1235">Header Field</span></span> |<span data-ttu-id="427f9-1236">Назначение</span><span class="sxs-lookup"><span data-stu-id="427f9-1236">Purpose</span></span> |
|---|---|
|<span data-ttu-id="427f9-1237">**16-разрядное поле номера исходного порта**</span><span class="sxs-lookup"><span data-stu-id="427f9-1237">**16-bit source port number**</span></span> |<span data-ttu-id="427f9-1238">Это поле содержит порт, из которого отправляется UDP-пакет.</span><span class="sxs-lookup"><span data-stu-id="427f9-1238">This field contains the port on which the UDP packet is being sent from.</span></span> <span data-ttu-id="427f9-1239">Допустимый диапазон UDP-портов — от 1 до 0xFFFF.</span><span class="sxs-lookup"><span data-stu-id="427f9-1239">Valid UDP ports range from 1 through 0xFFFF.</span></span> |
|<span data-ttu-id="427f9-1240">**16-разрядное поле номера порта назначения**</span><span class="sxs-lookup"><span data-stu-id="427f9-1240">**16-bit destination port number**</span></span> |<span data-ttu-id="427f9-1241">Это поле содержит порт UDP, на который отправляется UDP-пакет.</span><span class="sxs-lookup"><span data-stu-id="427f9-1241">This field contains the UDP port to which the packet is being sent to.</span></span> <span data-ttu-id="427f9-1242">Допустимый диапазон UDP-портов — от 1 до 0xFFFF.</span><span class="sxs-lookup"><span data-stu-id="427f9-1242">Valid UDP ports range from 1 through 0xFFFF.</span></span> |
|<span data-ttu-id="427f9-1243">**16-разрядное поле длины UDP-пакета**</span><span class="sxs-lookup"><span data-stu-id="427f9-1243">**16-bit UDP length**</span></span> |<span data-ttu-id="427f9-1244">Это поле содержит число байтов в UDP-пакете, включая размер заголовка UDP.</span><span class="sxs-lookup"><span data-stu-id="427f9-1244">This field contains the number of bytes in the UDP packet, including the size of the UDP header.</span></span> |
|<span data-ttu-id="427f9-1245">**16-разрядное поле контрольной суммы UDP**</span><span class="sxs-lookup"><span data-stu-id="427f9-1245">**16-bit UDP checksum**</span></span> |<span data-ttu-id="427f9-1246">Это поле содержит 16-разрядную контрольную сумму пакета, включая заголовок UDP, область данных пакета и псевдозаголовок IP.</span><span class="sxs-lookup"><span data-stu-id="427f9-1246">This field contains the 16-bit checksum for the packet, including the UDP header, the packet data area, and the pseudo IP header.</span></span> |

### <a name="udp-enable"></a><span data-ttu-id="427f9-1247">Включение UDP</span><span class="sxs-lookup"><span data-stu-id="427f9-1247">UDP Enable</span></span>   
<span data-ttu-id="427f9-1248">Перед передачей UDP-пакетов приложение должно сначала включить протокол UDP, вызвав службу ***nx_udp_enable***.</span><span class="sxs-lookup"><span data-stu-id="427f9-1248">Before UDP packet transmission is possible, the application must first enable UDP by calling the ***nx_udp_enable*** service.</span></span> <span data-ttu-id="427f9-1249">После включения приложение может отправлять и получать UDP-пакеты.</span><span class="sxs-lookup"><span data-stu-id="427f9-1249">After enabled, the application is free to send and receive UDP packets.</span></span>  

### <a name="udp-socket-create"></a><span data-ttu-id="427f9-1250">Создание сокета UDP</span><span class="sxs-lookup"><span data-stu-id="427f9-1250">UDP Socket Create</span></span>    
<span data-ttu-id="427f9-1251">Сокеты UDP создаются во время инициализации или выполнения потоками приложения.</span><span class="sxs-lookup"><span data-stu-id="427f9-1251">UDP sockets are created either during initialization or during runtime by application threads.</span></span> <span data-ttu-id="427f9-1252">Начальный тип службы, срок жизни и длина очереди получения определяются службой ***nx_udp_socket_create***.</span><span class="sxs-lookup"><span data-stu-id="427f9-1252">The initial type of service, time to live, and receive queue depth are defined by the ***nx_udp_socket_create*** service.</span></span> <span data-ttu-id="427f9-1253">Число сокетов UDP в приложении не ограничено.</span><span class="sxs-lookup"><span data-stu-id="427f9-1253">There are no limits on the number of UDP sockets in an application.</span></span>

### <a name="udp-checksum"></a><span data-ttu-id="427f9-1254">Контрольная сумма UDP</span><span class="sxs-lookup"><span data-stu-id="427f9-1254">UDP Checksum</span></span>   
<span data-ttu-id="427f9-1255">Для протокола IPv6 требуется вычисление контрольной суммы заголовка UDP для данных пакета, тогда как в протоколе IPv4 это необязательно.</span><span class="sxs-lookup"><span data-stu-id="427f9-1255">IPv6 protocol requires a UDP header checksum computation on packet data, whereas in the IPv4 protocol it is optional.</span></span>  

<span data-ttu-id="427f9-1256">Протокол UDP указывает свою дополняющую 16-разрядную контрольную сумму, охватывающую псевдозаголовок IP (состоящий из исходного IP-адреса, IP-адреса назначения и IP-слова, указывающего протокол и длину), заголовок UDP и данные пакета UDP.</span><span class="sxs-lookup"><span data-stu-id="427f9-1256">UDP specifies a one's complement 16-bit checksum that covers the IP pseudo header (consisting of the source IP address, destination IP address, and the protocol/length IP word), the UDP header, and the UDP packet data.</span></span> <span data-ttu-id="427f9-1257">Единственным различием между контрольными суммами заголовков UDP-пакетов IPv4 и IPv6 является то, что исходный и конечный IP-адреса являются 32-разрядными в IPv4, а в IPv6 они 128-разрядные.</span><span class="sxs-lookup"><span data-stu-id="427f9-1257">The only differences between IPv4 and IPv6 UDP packet header checksums is that the source and destination IP addresses are 32 bit in IPv4 while in IPv6 they are 128 bit.</span></span> <span data-ttu-id="427f9-1258">Если вычисленная контрольная сумма UDP равна 0, она сохраняется как значение, состоящее только из единиц (0xFFFF).</span><span class="sxs-lookup"><span data-stu-id="427f9-1258">If the calculated UDP checksum is 0, it is stored as all ones (0xFFFF).</span></span> <span data-ttu-id="427f9-1259">Если для отправляющего сокета отключена логика контрольной суммы UDP, в поле контрольной суммы UDP помещается нулевое значение, указывающее, что контрольная сумма не вычислена.</span><span class="sxs-lookup"><span data-stu-id="427f9-1259">If the sending socket has the UDP checksum logic disabled, a zero is placed in the UDP checksum field to indicate the checksum was not calculated.</span></span>

<span data-ttu-id="427f9-1260">Если контрольная сумма UDP не совпадает с вычисленной контрольной суммой получателя, пакет UDP просто отбрасывается.</span><span class="sxs-lookup"><span data-stu-id="427f9-1260">If the UDP checksum does not match the computed checksum by the receiver, the UDP packet is simply discarded.</span></span>

<span data-ttu-id="427f9-1261">В сети IPv4 контрольная сумма UDP необязательна.</span><span class="sxs-lookup"><span data-stu-id="427f9-1261">On the IPv4 network, UDP checksum is optional.</span></span> <span data-ttu-id="427f9-1262">NetX Duo позволяет приложению включать или отключать расчет контрольной суммы UDP для каждого сокета.</span><span class="sxs-lookup"><span data-stu-id="427f9-1262">NetX Duo allows an application to enable or disable UDP checksum calculation on a per-socket basis.</span></span> <span data-ttu-id="427f9-1263">По умолчанию логика контрольной суммы UDP-сокета включена.</span><span class="sxs-lookup"><span data-stu-id="427f9-1263">By default, the UDP socket checksum logic is enabled.</span></span> <span data-ttu-id="427f9-1264">Приложение может отключить логику контрольной суммы для определенного сокета UDP, вызвав службу \***nx_udp_socket_checksum_disable** _.</span><span class="sxs-lookup"><span data-stu-id="427f9-1264">The application can disable checksum logic for a particular UDP socket by calling the \***nx_udp_socket_checksum_disable** _ service.</span></span> <span data-ttu-id="427f9-1265">Однако в сети IPv6 контрольная сумма UDP является обязательной.</span><span class="sxs-lookup"><span data-stu-id="427f9-1265">On the IPv6 network, however, UDP checksum is mandatory.</span></span> <span data-ttu-id="427f9-1266">Таким образом, служба _ *_nx_udp_socket_checksum_disable_*\* не отключает логику контрольной суммы UDP при отправке пакета через сеть IPv6.</span><span class="sxs-lookup"><span data-stu-id="427f9-1266">Therefore, the service _ *_nx_udp_socket_checksum_disable_*\* would not disable UDP checksum logic when sending a packet through the IPv6 network.</span></span>

<span data-ttu-id="427f9-1267">Некоторые контроллеры Ethernet могут создавать контрольную сумму UDP на лету.</span><span class="sxs-lookup"><span data-stu-id="427f9-1267">Certain Ethernet controllers are able to generate the UDP checksum on the fly.</span></span> <span data-ttu-id="427f9-1268">Если система может использовать функцию вычисления контрольной суммы оборудования, библиотеку NetX Duo можно построить без логики контрольной суммы.</span><span class="sxs-lookup"><span data-stu-id="427f9-1268">If the system is able to use hardware checksum computation feature, the NetX Duo library can be built without the checksum logic.</span></span> <span data-ttu-id="427f9-1269">Чтобы отключить контрольную сумму программного обеспечения UDP, Библиотека NetX Duo должна быть создана со следующими определенными символами: ***NX_DISABLE_UDP_TX_CHECKSUM** _ и _*_NX_DISABLE_UDP_RX_CHECKSUM_\*_ (описывается в главе 2).</span><span class="sxs-lookup"><span data-stu-id="427f9-1269">To disable UDP software checksum, the NetX Duo library must be built with the following symbols defined: ***NX_DISABLE_UDP_TX_CHECKSUM** _ and _*_NX_DISABLE_UDP_RX_CHECKSUM_\*_ (described in Chapter two).</span></span> <span data-ttu-id="427f9-1270">Параметры конфигурации полностью удаляют логику контрольной суммы UDP с NetX Duo, при этом вызов службы _ *_nx_udp_socket_checksum_disable_*\* позволяет приложению отключить обработку контрольной суммы UDP по протоколу IPv4 для каждого сокета.</span><span class="sxs-lookup"><span data-stu-id="427f9-1270">The configuration options remove UDP checksum logic from NetX Duo entirely, while calling the _ *_nx_udp_socket_checksum_disable_*\* service allows the application to disable IPv4 UDP checksum processing on a per socket basis.</span></span>

### <a name="udp-ports-and-binding"></a><span data-ttu-id="427f9-1271">Порты и привязка UDP</span><span class="sxs-lookup"><span data-stu-id="427f9-1271">UDP Ports and Binding</span></span>      
<span data-ttu-id="427f9-1272">UDP-порт — это логическая конечная точка в протоколе UDP.</span><span class="sxs-lookup"><span data-stu-id="427f9-1272">A UDP port is a logical end point in the UDP protocol.</span></span> <span data-ttu-id="427f9-1273">В компоненте UDP NetX Duo имеется 65 535 допустимых портов в диапазоне от 1 до 0xFFFF.</span><span class="sxs-lookup"><span data-stu-id="427f9-1273">There are 65,535 valid ports in the UDP component of NetX Duo, ranging from 1 through 0xFFFF.</span></span> <span data-ttu-id="427f9-1274">Для отправки или получения данных UDP приложение должно сначала создать сокет UDP, а затем привязать его к нужному порту.</span><span class="sxs-lookup"><span data-stu-id="427f9-1274">To send or receive UDP data, the application must first create a UDP socket, then bind it to a desired port.</span></span> <span data-ttu-id="427f9-1275">После привязки сокета UDP к порту приложение может отправлять и получать данные на этом сокете.</span><span class="sxs-lookup"><span data-stu-id="427f9-1275">After binding a UDP socket to a port, the application may send and receive data on that socket.</span></span>

### <a name="udp-fast-pathtrade"></a><span data-ttu-id="427f9-1276">UDP Fast Path&trade;</span><span class="sxs-lookup"><span data-stu-id="427f9-1276">UDP Fast Path&trade;</span></span>   
<span data-ttu-id="427f9-1277">UDP Fast Path&trade; — это название пути с низкими издержками пакетов за счет реализации UDP NetX Duo.</span><span class="sxs-lookup"><span data-stu-id="427f9-1277">The UDP Fast Path&trade; is the name for a low packet overhead path through the NetX Duo UDP implementation.</span></span> <span data-ttu-id="427f9-1278">Для отправки UDP-пакета требуется вызов всего нескольких функций (***nx_udp_socket_send** _ и _*_nx_ip_packet_send_\*_) с дальнейшим вызовом сетевого драйвера.</span><span class="sxs-lookup"><span data-stu-id="427f9-1278">Sending a UDP packet requires just a few function calls: ***nx_udp_socket_send** _, _*_nx_ip_packet_send_\*_, and the eventual call to the network driver.</span></span> <span data-ttu-id="427f9-1279">_*_nx_udp_socket_send_*_ доступен в NetX Duo для существующих приложений NetX и применим только для пакетов IPv4.</span><span class="sxs-lookup"><span data-stu-id="427f9-1279">_*_nx_udp_socket_send_*_ is available in NetX Duo for existing NetX applications and is only applicable for IPv4 packets.</span></span> <span data-ttu-id="427f9-1280">Однако предпочтительным методом является использование службы _ \*_nxd_udp_socket_send_\*\*, описанной ниже.</span><span class="sxs-lookup"><span data-stu-id="427f9-1280">The preferred method, however, is to use _ *_nxd_udp_socket_send_*\* service discussed below.</span></span> <span data-ttu-id="427f9-1281">При получении UDP-пакета он помещается в соответствующую очередь получения в сокете UDP либо доставляется в приостановленный поток приложения в ходе одного вызова функции из обработки прерывания получения сетевого драйвера.</span><span class="sxs-lookup"><span data-stu-id="427f9-1281">On UDP packet reception, the UDP packet is either placed on the appropriate UDP socket receive queue or delivered to a suspended application thread in a single function call from the network driver's receive interrupt processing.</span></span> <span data-ttu-id="427f9-1282">Эта логика с высокой степенью оптимизации для отправки и получения пакетов UDP является основой технологии UDP Fast Path.</span><span class="sxs-lookup"><span data-stu-id="427f9-1282">This highly optimized logic for sending and receiving UDP packets is the essence of UDP Fast Path technology.</span></span>  

### <a name="udp-packet-send"></a><span data-ttu-id="427f9-1283">Отправка UDP-пакета</span><span class="sxs-lookup"><span data-stu-id="427f9-1283">UDP Packet Send</span></span>    
<span data-ttu-id="427f9-1284">Отправку данных UDP через сети IPv6 или IPv4 легко осуществить путем вызова функции \***nx_udp_socket_send** _.</span><span class="sxs-lookup"><span data-stu-id="427f9-1284">Sending UDP data over IPv6 or IPv4 networks is easily accomplished by calling the \***nxd_udp_socket_send** _ function.</span></span> <span data-ttu-id="427f9-1285">Вызывающий объект должен задать версию IP-адреса в поле _nx_ip_version\* параметра указателя NXD_ADDRESS.</span><span class="sxs-lookup"><span data-stu-id="427f9-1285">The caller must set the IP version in the _nx_ip_version\* field of the NXD_ADDRESS pointer parameter.</span></span> <span data-ttu-id="427f9-1286">NetX Duo определит оптимальный исходный адрес для передаваемых пакетов UDP на основе адреса назначения IPv4 или IPv6.</span><span class="sxs-lookup"><span data-stu-id="427f9-1286">NetX Duo will determine the best source address for transmitted UDP packets based on the destination IPv4/IPv6 address.</span></span> <span data-ttu-id="427f9-1287">Эта служба помещает заголовок UDP перед данными пакета и отправляет его в сеть с помощью внутренней подпрограммы отправки IP-пакетов.</span><span class="sxs-lookup"><span data-stu-id="427f9-1287">This service places a UDP header in front of the packet data and sends it out onto the network using an internal IP send routine.</span></span> <span data-ttu-id="427f9-1288">При отправке UDP-пакетов приостановка потока не применяется, так как все операции передачи UDP-пакетов обрабатываются незамедлительно.</span><span class="sxs-lookup"><span data-stu-id="427f9-1288">There is no thread suspension on sending UDP packets because all UDP packet transmissions are processed immediately.</span></span> 

<span data-ttu-id="427f9-1289">Для мест назначения многоадресной или широковещательной рассылки приложение должно указать исходный IP-адрес, который будет использоваться, если у устройства NetX Duo есть несколько IP-адресов на выбор.</span><span class="sxs-lookup"><span data-stu-id="427f9-1289">For multicast or broadcast destinations, the application should specify the source IP address to use if the NetX Duo device has multiple IP addresses to choose from.</span></span> <span data-ttu-id="427f9-1290">Это можно сделать с помощью служб ***nxd_udp_socket_source_send.***</span><span class="sxs-lookup"><span data-stu-id="427f9-1290">This can be done with the services ***nxd_udp_socket_source_send.***</span></span>

> [!IMPORTANT]    
> <span data-ttu-id="427f9-1291">*Если для передачи многоадресных или широковещательных пакетов используется **nx_udp_socket_send**, в качестве исходного адреса используется IP-адрес первого включенного интерфейса*.</span><span class="sxs-lookup"><span data-stu-id="427f9-1291">*If **nx_udp_socket_send** is used for transmitting multicast or broadcast packets, the IP address of the first enabled interface is used as source address*.</span></span>

> [!NOTE] 
> <span data-ttu-id="427f9-1292">*Если для этого сокета включена логика контрольной суммы UDP, операция вычисления контрольной суммы выполняется в контексте вызывающего потока, не блокируя доступ к структурам данных UDP или IP*.</span><span class="sxs-lookup"><span data-stu-id="427f9-1292">*If UDP checksum logic is enabled for this socket, the checksum operation is performed in the context of the calling thread, without blocking access to the UDP or IP data structures*.</span></span> 

> [!WARNING]    
> <span data-ttu-id="427f9-1293">*Полезные данные UDP, находящиеся в структуре NX_PACKET, должны располагаться на границе длинных слов. Приложению необходимо оставить достаточно места между открывающим указателем и указателем начала данных, чтобы NetX Duo могло разместить заголовки UDP, IP и физических носителей*.</span><span class="sxs-lookup"><span data-stu-id="427f9-1293">*The UDP payload data residing in the NX_PACKET structure should reside on a long-word boundary. The application needs to leave sufficient space between the prepend pointer and the data start pointer for NetX Duo to place the UDP, IP, and physical media headers*.</span></span>

### <a name="udp-packet-receive"></a><span data-ttu-id="427f9-1294">Получение UDP-пакетов</span><span class="sxs-lookup"><span data-stu-id="427f9-1294">UDP Packet Receive</span></span>    
<span data-ttu-id="427f9-1295">Потоки приложения могут получать UDP-пакеты от определенного сокета, вызвав ***nx_udp_socket_receive***.</span><span class="sxs-lookup"><span data-stu-id="427f9-1295">Application threads may receive UDP packets from a particular socket by calling ***nx_udp_socket_receive***.</span></span> <span data-ttu-id="427f9-1296">Функция получения сокета доставляет самый старый пакет в его очереди получения.</span><span class="sxs-lookup"><span data-stu-id="427f9-1296">The socket receive function delivers the oldest packet on the socket's receive queue.</span></span> <span data-ttu-id="427f9-1297">Если в очереди получения нет пакетов, вызывающий поток может быть приостановлен (с необязательным временем ожидания) до поступления пакета.</span><span class="sxs-lookup"><span data-stu-id="427f9-1297">If there are no packets on the receive queue, the calling thread can suspend (with an optional timeout) until a packet arrives.</span></span>

<span data-ttu-id="427f9-1298">Функция обработки получаемых UDP-пакетов (обычно вызывается из обработчика прерываний получения сетевого драйвера) отвечает за помещение пакета в очередь получения UDP-сокета или доставку его первому приостановленному потоку, ожидающему пакет.</span><span class="sxs-lookup"><span data-stu-id="427f9-1298">The UDP receive packet processing (usually called from the network driver's receive interrupt handler) is responsible for either placing the packet on the UDP socket's receive queue or delivering it to the first suspended thread waiting for a packet.</span></span> <span data-ttu-id="427f9-1299">Если пакет находится в очереди, то при обработке получения проверяется также связанная с сокетом максимальная длина очереди получения.</span><span class="sxs-lookup"><span data-stu-id="427f9-1299">If the packet is queued, the receive processing also checks the maximum receive queue depth associated with the socket.</span></span> <span data-ttu-id="427f9-1300">Если размер нового пакета, поступившего в очередь, превышает длину очереди, самый старый пакет в очереди отбрасывается.</span><span class="sxs-lookup"><span data-stu-id="427f9-1300">If this newly queued packet exceeds the queue depth, the oldest packet in the queue is discarded.</span></span>

### <a name="udp-receive-notify"></a><span data-ttu-id="427f9-1301">Уведомление о получении UDP-пакета</span><span class="sxs-lookup"><span data-stu-id="427f9-1301">UDP Receive Notify</span></span>   
<span data-ttu-id="427f9-1302">Если поток приложения должен обрабатывать полученные данные из нескольких сокетов, следует использовать функцию ***nx_udp_socket_receive_notify***.</span><span class="sxs-lookup"><span data-stu-id="427f9-1302">If the application thread needs to process received data from more than one socket, the ***nx_udp_socket_receive_notify*** function should be used.</span></span> <span data-ttu-id="427f9-1303">Эта функция регистрирует функцию обратного вызова получения пакетов для сокета.</span><span class="sxs-lookup"><span data-stu-id="427f9-1303">This function registers a receive packet callback function for the socket.</span></span> <span data-ttu-id="427f9-1304">При каждом получении пакета сокетом выполняется функция обратного вызова.</span><span class="sxs-lookup"><span data-stu-id="427f9-1304">Whenever a packet is received on the socket, the callback function is executed.</span></span>

<span data-ttu-id="427f9-1305">Содержимое функции обратного вызова зависит от конкретного приложения. Эта функция, скорее всего, будет содержать логику для информирования потока обработки о том, что пакет сейчас доступен в соответствующем сокете.</span><span class="sxs-lookup"><span data-stu-id="427f9-1305">The contents of the callback function is applicationspecific; however, it would most likely contain logic to inform the processing thread that a packet is now available on the corresponding socket.</span></span>

### <a name="peer-address-and-port"></a><span data-ttu-id="427f9-1306">Адрес и порт однорангового узла</span><span class="sxs-lookup"><span data-stu-id="427f9-1306">Peer Address and Port</span></span>   
<span data-ttu-id="427f9-1307">При получении UDP-пакета приложение может найти IP-адрес и номер порта отправителя с помощью службы ***nx_udp_packet_info_extract***.</span><span class="sxs-lookup"><span data-stu-id="427f9-1307">On receiving a UDP packet, application may find the sender's IP address and port number by using the service ***nx_udp_packet_info_extract***.</span></span> <span data-ttu-id="427f9-1308">При успешном возвращении результата эта служба предоставляет сведения об IP-адресе и номере порта отправителя, а также локальном интерфейсе, через который был получен пакет.</span><span class="sxs-lookup"><span data-stu-id="427f9-1308">On successful return, this service provides information on the sender's IP address, sender's port number, and the local interface through which the packet was received.</span></span>  

### <a name="thread-suspension"></a><span data-ttu-id="427f9-1309">Приостановка потока</span><span class="sxs-lookup"><span data-stu-id="427f9-1309">Thread Suspension</span></span>   
<span data-ttu-id="427f9-1310">Как упоминалось ранее, потоки приложений могут быть приостановлены при попытке получить UDP-пакет на определенном UDP-порте.</span><span class="sxs-lookup"><span data-stu-id="427f9-1310">As mentioned previously, application threads can suspend while attempting to receive a UDP packet on a particular UDP port.</span></span> <span data-ttu-id="427f9-1311">После получения пакета на этом порте он передается первому приостановленному потоку, и этот поток возобновляется.</span><span class="sxs-lookup"><span data-stu-id="427f9-1311">After a packet is received on that port, it is given to the first thread suspended and that thread is then resumed.</span></span> <span data-ttu-id="427f9-1312">Необязательное время ожидания при приостановке пакета приема UDP — это функция, доступная для большинства служб NetX Duo.</span><span class="sxs-lookup"><span data-stu-id="427f9-1312">An optional timeout is available when suspending on a UDP receive packet, a feature available for most NetX Duo services.</span></span>  

### <a name="udp-socket-statistics-and-errors"></a><span data-ttu-id="427f9-1313">Статистические показатели и ошибки UDP-сокета</span><span class="sxs-lookup"><span data-stu-id="427f9-1313">UDP Socket Statistics and Errors</span></span>     
<span data-ttu-id="427f9-1314">Если этот параметр включен, программное обеспечение сокета UDP NetX Duo отслеживает несколько статистических показателей и ошибок, которые могут быть полезны для приложения.</span><span class="sxs-lookup"><span data-stu-id="427f9-1314">If enabled, the NetX Duo UDP socket software keeps track of several statistics and errors that may be useful to the application.</span></span> <span data-ttu-id="427f9-1315">Для каждого IP/UDP-экземпляра поддерживаются следующие статистические показатели и отчеты об ошибках:</span><span class="sxs-lookup"><span data-stu-id="427f9-1315">The following statistics and error reports are maintained for each IP/UDP instance:</span></span>

- <span data-ttu-id="427f9-1316">общее число отправленных UDP-пакетов;</span><span class="sxs-lookup"><span data-stu-id="427f9-1316">Total UDP Packets Sent</span></span>  
- <span data-ttu-id="427f9-1317">общее число отправленных байтов UDP;</span><span class="sxs-lookup"><span data-stu-id="427f9-1317">Total UDP Bytes Sent</span></span>  
- <span data-ttu-id="427f9-1318">общее число полученных UDP-пакетов;</span><span class="sxs-lookup"><span data-stu-id="427f9-1318">Total UDP Packets Received</span></span>   
- <span data-ttu-id="427f9-1319">общее число полученных байтов UDP;</span><span class="sxs-lookup"><span data-stu-id="427f9-1319">Total UDP Bytes Received</span></span>  
- <span data-ttu-id="427f9-1320">общее число недопустимых UDP-пакетов;</span><span class="sxs-lookup"><span data-stu-id="427f9-1320">Total UDP Invalid Packets</span></span>  
- <span data-ttu-id="427f9-1321">общее число отброшенных пакетов, получаемых по протоколу UDP;</span><span class="sxs-lookup"><span data-stu-id="427f9-1321">Total UDP Receive Packets Dropped</span></span>  
- <span data-ttu-id="427f9-1322">общее число ошибок контрольной суммы при получении по протоколу UDP;</span><span class="sxs-lookup"><span data-stu-id="427f9-1322">Total UDP Receive Checksum Errors</span></span>  
- <span data-ttu-id="427f9-1323">число отправленных пакетов UDP-сокета;</span><span class="sxs-lookup"><span data-stu-id="427f9-1323">UDP Socket Packets Sent</span></span>  
- <span data-ttu-id="427f9-1324">число отправленных байтов UDP-сокета;</span><span class="sxs-lookup"><span data-stu-id="427f9-1324">UDP Socket Bytes Sent</span></span>  
- <span data-ttu-id="427f9-1325">число полученных пакетов UDP-сокета;</span><span class="sxs-lookup"><span data-stu-id="427f9-1325">UDP Socket Packets Received</span></span>   
- <span data-ttu-id="427f9-1326">число полученных байтов UDP-сокета;</span><span class="sxs-lookup"><span data-stu-id="427f9-1326">UDP Socket Bytes Received</span></span>  
- <span data-ttu-id="427f9-1327">число поставленных в очередь пакетов UDP-сокета;</span><span class="sxs-lookup"><span data-stu-id="427f9-1327">UDP Socket Packets Queued</span></span>  
- <span data-ttu-id="427f9-1328">число отброшенных пакетов, получаемых от UDP-сокета;</span><span class="sxs-lookup"><span data-stu-id="427f9-1328">UDP Socket Receive Packets Dropped</span></span>  
- <span data-ttu-id="427f9-1329">число ошибок контрольной суммы UDP-сокета.</span><span class="sxs-lookup"><span data-stu-id="427f9-1329">UDP Socket Checksum Errors</span></span>  

<span data-ttu-id="427f9-1330">Все эти статистические показатели и отчеты об ошибках предоставляются приложению службой ***nx_udp_info_get** _ (для статистики UDP, собранной по всем UDP-сокетам) и службой _ *_nx_udp_socket_info_get_** (для статистики UDP, собранной для заданного UDP-сокета).</span><span class="sxs-lookup"><span data-stu-id="427f9-1330">All these statistics and error reports are available to the application with the ***nx_udp_info_get** _ service for UDP statistics amassed over all UDP sockets, and the _ *_nx_udp_socket_info_get_** service for UDP statistics on the specified UDP socket.</span></span>

### <a name="udp-socket-control-block-nx_udp_socket"></a><span data-ttu-id="427f9-1331">NX_UDP_SOCKET: блок управления сокетом UDP</span><span class="sxs-lookup"><span data-stu-id="427f9-1331">UDP Socket Control Block NX_UDP_SOCKET</span></span>
<span data-ttu-id="427f9-1332">Характеристики каждого UDP-сокета находятся в связанном блоке управления NX_UDP_SOCKET.</span><span class="sxs-lookup"><span data-stu-id="427f9-1332">The characteristics of each UDP socket are found in the associated NX_UDP_SOCKET control block.</span></span> <span data-ttu-id="427f9-1333">Он содержит такие полезные сведения, как ссылка на структуру данных IP, сетевой интерфейс для путей отправки и получения, привязанный порт и очередь получения пакетов.</span><span class="sxs-lookup"><span data-stu-id="427f9-1333">It contains useful information such as the link to the IP data structure, the network interface for the sending and receiving paths, the bound port, and the receive packet queue.</span></span> <span data-ttu-id="427f9-1334">Эта структура определена в файле ***nx_api.h***.</span><span class="sxs-lookup"><span data-stu-id="427f9-1334">This structure is defined in the ***nx_api.h*** file.</span></span>

## <a name="transmission-control-protocol-tcp"></a><span data-ttu-id="427f9-1335">Протокол TCP</span><span class="sxs-lookup"><span data-stu-id="427f9-1335">Transmission Control Protocol (TCP)</span></span>

<span data-ttu-id="427f9-1336">Управляющий протокол передачи (TCP) обеспечивает надежную потоковую передачу данных между двумя элементами сети (RFC 793).</span><span class="sxs-lookup"><span data-stu-id="427f9-1336">The Transmission Control Protocol (TCP) provides reliable stream data transfer between two network members (RFC 793).</span></span> <span data-ttu-id="427f9-1337">Все данные, отправленные одним элементом сети, проверяются и подтверждаются получающим элементом.</span><span class="sxs-lookup"><span data-stu-id="427f9-1337">All data sent from one network member are verified and acknowledged by the receiving member.</span></span> <span data-ttu-id="427f9-1338">Кроме того, перед любой передачей данных эти два элемента должны установить соединение.</span><span class="sxs-lookup"><span data-stu-id="427f9-1338">In addition, the two members must have established a connection prior to any data transfer.</span></span> <span data-ttu-id="427f9-1339">Все это обеспечивает надежную передачу данных, однако требует значительно больших временных затрат, чем описанная ранее передача данных UDP.</span><span class="sxs-lookup"><span data-stu-id="427f9-1339">All this results in reliable data transfer; however, it does require substantially more overhead than the previously described UDP data transfer.</span></span>

<span data-ttu-id="427f9-1340">За исключением случаев, когда указано иное, в службах API протокола TCP NetX и NetX Duo нет никаких различий, так как IPv6 в первую очередь касается базового уровня IP.</span><span class="sxs-lookup"><span data-stu-id="427f9-1340">Except where noted, there are no changes in TCP protocol API services between NetX and NetX Duo because IPv6 is primarily concerned with the underlying IP layer.</span></span> <span data-ttu-id="427f9-1341">Все службы TCP NetX Duo можно использовать для подключений IPv4 или IPv6.</span><span class="sxs-lookup"><span data-stu-id="427f9-1341">All NetX Duo TCP services can be used for either IPv4 or IPv6 connections.</span></span>

### <a name="tcp-header"></a><span data-ttu-id="427f9-1342">Заголовок TCP</span><span class="sxs-lookup"><span data-stu-id="427f9-1342">TCP Header</span></span>   
<span data-ttu-id="427f9-1343">При передаче заголовок TCP помещается перед данными, полученными от пользователя.</span><span class="sxs-lookup"><span data-stu-id="427f9-1343">On transmission, TCP header is placed in front of the data from the user.</span></span> <span data-ttu-id="427f9-1344">При получении заголовок TCP удаляется из входящего пакета, а для приложения остаются только пользовательские данные.</span><span class="sxs-lookup"><span data-stu-id="427f9-1344">On reception, TCP header is removed from the incoming packet, leaving only the user data available to the application.</span></span> <span data-ttu-id="427f9-1345">TCP использует протокол IP для отправки и получения пакетов, поэтому, когда пакет находится в сети, перед его заголовком TCP размещается заголовок IP.</span><span class="sxs-lookup"><span data-stu-id="427f9-1345">TCP utilizes the IP protocol to send and receive packets, which means there is an IP header in front of the TCP header when the packet is on the network.</span></span> <span data-ttu-id="427f9-1346">На рис. 13 показан формат заголовка TCP.</span><span class="sxs-lookup"><span data-stu-id="427f9-1346">Figure 13 shows the format of the TCP header.</span></span>

![Схема формата заголовка TCP.](./media/user-guide/image22.png)

### <a name="figure-13-tcp-header"></a><span data-ttu-id="427f9-1348">РИС. 13.</span><span class="sxs-lookup"><span data-stu-id="427f9-1348">FIGURE 13.</span></span> <span data-ttu-id="427f9-1349">Заголовок TCP</span><span class="sxs-lookup"><span data-stu-id="427f9-1349">TCP Header</span></span>

<span data-ttu-id="427f9-1350">В следующей таблице описывается формат заголовка TCP.</span><span class="sxs-lookup"><span data-stu-id="427f9-1350">The following describes the TCP header format:</span></span>

|<span data-ttu-id="427f9-1351">Поле&nbsp;заголовка</span><span class="sxs-lookup"><span data-stu-id="427f9-1351">Header&nbsp;Field</span></span> |<span data-ttu-id="427f9-1352">Назначение</span><span class="sxs-lookup"><span data-stu-id="427f9-1352">Purpose</span></span> |
|------|------|
| <span data-ttu-id="427f9-1353">**16-разрядное поле номера исходного порта**</span><span class="sxs-lookup"><span data-stu-id="427f9-1353">**16-bit source port number**</span></span> | <span data-ttu-id="427f9-1354">Это поле содержит порт, на который отправляется TCP-пакет.</span><span class="sxs-lookup"><span data-stu-id="427f9-1354">This field contains the port the TCP packet is being sent out on.</span></span> <span data-ttu-id="427f9-1355">Допустимый диапазон TCP-портов — от 1 до 0xFFFF.</span><span class="sxs-lookup"><span data-stu-id="427f9-1355">Valid TCP ports range from 1 through 0xFFFF.</span></span> |
| <span data-ttu-id="427f9-1356">**16-разрядный порт назначения**</span><span class="sxs-lookup"><span data-stu-id="427f9-1356">**16-bit destination port**</span></span> | <span data-ttu-id="427f9-1357">Это поле содержит TCP-порт, на который отправляется пакет.</span><span class="sxs-lookup"><span data-stu-id="427f9-1357">This field contains the TCP port the packet is being sent to.</span></span> <span data-ttu-id="427f9-1358">Допустимый диапазон TCP-портов — от 1 до 0xFFFF.</span><span class="sxs-lookup"><span data-stu-id="427f9-1358">Valid TCP ports range from 1 through 0xFFFF.</span></span> |
| <span data-ttu-id="427f9-1359">**32-разрядное поле порядкового номера**</span><span class="sxs-lookup"><span data-stu-id="427f9-1359">**32-bit sequence number**</span></span> | <span data-ttu-id="427f9-1360">Это поле содержит порядковый номер для данных, отправляемых с данного конца соединения.</span><span class="sxs-lookup"><span data-stu-id="427f9-1360">This field contains the sequence number for data sent from this end of the connection.</span></span> <span data-ttu-id="427f9-1361">Во время начальной последовательности соединения между двумя узлами TCP устанавливается исходная последовательность.</span><span class="sxs-lookup"><span data-stu-id="427f9-1361">The original sequence is established during the initial connection sequence between two TCP nodes.</span></span> <span data-ttu-id="427f9-1362">С этого момента каждая передача данных приводит к увеличению порядкового номера на количество отправленных байтов.</span><span class="sxs-lookup"><span data-stu-id="427f9-1362">Every data transfer from that point results in an increment of the sequence number by the amount bytes sent.</span></span> |
| <span data-ttu-id="427f9-1363">**32-разрядное поле номера подтверждения**</span><span class="sxs-lookup"><span data-stu-id="427f9-1363">**32-bit acknowledgement number**</span></span> | <span data-ttu-id="427f9-1364">Это поле содержит порядковый номер, соответствующий последнему байту, полученному данной стороной соединения.</span><span class="sxs-lookup"><span data-stu-id="427f9-1364">This field contains the sequence number corresponding to the last byte received by this side of the connection.</span></span> <span data-ttu-id="427f9-1365">Используется для определения того, были ли отправленные ранее данные успешно получены на другом конце соединения.</span><span class="sxs-lookup"><span data-stu-id="427f9-1365">This is used to determine whether or not data previously sent has successfully been received by the other end of the connection.</span></span> |
| <span data-ttu-id="427f9-1366">**4-разрядная длина заголовка**</span><span class="sxs-lookup"><span data-stu-id="427f9-1366">**4-bit header length**</span></span> | <span data-ttu-id="427f9-1367">Это поле содержит число 32-разрядных слов в заголовке TCP.</span><span class="sxs-lookup"><span data-stu-id="427f9-1367">This field contains the number of 32-bit words in the TCP header.</span></span> <span data-ttu-id="427f9-1368">Если в заголовке TCP отсутствуют параметры, значение этого поля равно 5.</span><span class="sxs-lookup"><span data-stu-id="427f9-1368">If no options are present in the TCP header, this field is 5.</span></span> |
| <span data-ttu-id="427f9-1369">**6-разрядное поле битов кода**</span><span class="sxs-lookup"><span data-stu-id="427f9-1369">**6-bit code bits**</span></span> |<span data-ttu-id="427f9-1370">Это поле содержит шесть разных битов кода, используемых для обозначения различных управляющих сведений, связанных с соединением.</span><span class="sxs-lookup"><span data-stu-id="427f9-1370">This field contains the six different code bits used to indicate various control information associated with the connection.</span></span> <span data-ttu-id="427f9-1371">Биты элемента управления определяются следующим образом: <br \> - URG (21): присутствуют срочные данные<br \> - ACK (20): Номер подтверждения действителен<br \> - PSH (19): Немедленно обработать эти данные<br \> - RST (18): Сброс подключения<br \> - SYN (17): Синхронизация порядковых номеров (используется для установления соединения)<br \> - FIN (16): отправитель завершил передачу (используется для закрытия соединения).</span><span class="sxs-lookup"><span data-stu-id="427f9-1371">The control bits are defined as follows:<br \> - URG (21): Urgent data presen<br \> - ACK (20): Acknowledgement number is valid<br \> - PSH (19): Handle this data immediately<br \> - RST (18): Reset the connection<br \> - SYN (17): Synchronize sequence numbers (used to establish connection)<br \> - FIN (16): Sender is finished with transmit (used to close connection)</span></span> |
|<span data-ttu-id="427f9-1372">**16-разрядное поле окна**</span><span class="sxs-lookup"><span data-stu-id="427f9-1372">**16-bit window**</span></span> |<span data-ttu-id="427f9-1373">Это поле используется для управления потоком.</span><span class="sxs-lookup"><span data-stu-id="427f9-1373">This field is used for flow control.</span></span> <span data-ttu-id="427f9-1374">Оно содержит количество байтов, которое сокет может получить в данный момент.</span><span class="sxs-lookup"><span data-stu-id="427f9-1374">It contains the amount of bytes the socket can currently receive.</span></span> <span data-ttu-id="427f9-1375">По сути, оно используется для управления потоком.</span><span class="sxs-lookup"><span data-stu-id="427f9-1375">This basically is used for flow control.</span></span> <span data-ttu-id="427f9-1376">Ответственность за то, чтобы отправляемые данные помещались в объявленное окно получателя, несет отправитель.</span><span class="sxs-lookup"><span data-stu-id="427f9-1376">The sender is responsible for making sure the data to send will fit into the receiver's advertised window.</span></span> |
|<span data-ttu-id="427f9-1377">**16-разрядное поле контрольной суммы TCP**</span><span class="sxs-lookup"><span data-stu-id="427f9-1377">**16-bit TCP checksum**</span></span> |<span data-ttu-id="427f9-1378">Это поле содержит 16-разрядную контрольную сумму пакета, включая заголовок TCP, область данных пакета и псевдозаголовок IP.</span><span class="sxs-lookup"><span data-stu-id="427f9-1378">This field contains the 16-bit checksum for the packet including the TCP header, the packet data area, and the pseudo IP header.</span></span> |
|<span data-ttu-id="427f9-1379">**16-разрядное поле указателя срочности**</span><span class="sxs-lookup"><span data-stu-id="427f9-1379">**16-bit urgent pointer**</span></span> |<span data-ttu-id="427f9-1380">Это поле содержит положительное смещение последнего байта срочных данных.</span><span class="sxs-lookup"><span data-stu-id="427f9-1380">This field contains the positive offset of the last byte of the urgent data.</span></span> <span data-ttu-id="427f9-1381">Оно допустимо только в случае, если в заголовке задан бит кода URG.</span><span class="sxs-lookup"><span data-stu-id="427f9-1381">This field is only valid if the URG code bit is set in the header.</span></span> |

> [!NOTE]  
> <span data-ttu-id="427f9-1382">*Все заголовки в реализации TCP/IP должны быть представлены в формате с **обратным порядком байтов**. В этом формате наиболее значимый байт слова размещается по наименьшему байтовому адресу*.</span><span class="sxs-lookup"><span data-stu-id="427f9-1382">*All headers in the TCP/IP implementation are expected to be in **big endian** format. In this format, the most significant byte of the word resides at the lowest byte address*.</span></span>

### <a name="tcp-enable"></a><span data-ttu-id="427f9-1383">Включение TCP</span><span class="sxs-lookup"><span data-stu-id="427f9-1383">TCP Enable</span></span>       
<span data-ttu-id="427f9-1384">Перед установкой TCP-соединения и передачей TCP-пакетов приложение должно сначала включить протокол TCP, вызвав службу ***nx_tcp_enable***.</span><span class="sxs-lookup"><span data-stu-id="427f9-1384">Before TCP connections and packet transmissions are possible, the application must first enable TCP by calling the ***nx_tcp_enable*** service.</span></span> <span data-ttu-id="427f9-1385">После включения приложение может получить доступ ко всем службам TCP.</span><span class="sxs-lookup"><span data-stu-id="427f9-1385">After enabled, the application is free to access all TCP services.</span></span>  

### <a name="tcp-socket-create"></a><span data-ttu-id="427f9-1386">Создание сокета TCP</span><span class="sxs-lookup"><span data-stu-id="427f9-1386">TCP Socket Create</span></span>    
<span data-ttu-id="427f9-1387">Сокеты TCP создаются во время инициализации или выполнения потоками приложения.</span><span class="sxs-lookup"><span data-stu-id="427f9-1387">TCP sockets are created either during initialization or during runtime by application threads.</span></span> <span data-ttu-id="427f9-1388">Начальный тип службы, срок жизни и размер окна определяются службой ***nx_tcp_socket_create***.</span><span class="sxs-lookup"><span data-stu-id="427f9-1388">The initial type of service, time to live, and window size are defined by the ***nx_tcp_socket_create*** service.</span></span> <span data-ttu-id="427f9-1389">Число сокетов TCP в приложении не ограничено.</span><span class="sxs-lookup"><span data-stu-id="427f9-1389">There are no limits on the number of TCP sockets in an application.</span></span>  

### <a name="tcp-checksum"></a><span data-ttu-id="427f9-1390">Контрольная сумма TCP</span><span class="sxs-lookup"><span data-stu-id="427f9-1390">TCP Checksum</span></span>     
<span data-ttu-id="427f9-1391">Протокол TCP указывает свою дополняющую 16-разрядную контрольную сумму, охватывающую псевдозаголовок IP (состоящий из исходного IP-адреса, IP-адреса назначения и IP-слова, указывающего протокол и длину), заголовок TCP и данные пакета TCP.</span><span class="sxs-lookup"><span data-stu-id="427f9-1391">TCP specifies a one's complement 16-bit checksum that covers the IP pseudo header, (consisting of the source IP address, destination IP address, and the protocol/length IP word), the TCP header, and the TCP packet data.</span></span> <span data-ttu-id="427f9-1392">Единственным различием между контрольными суммами заголовков TCP-пакетов IPv4 и IPv6 является то, что исходный и конечный IP-адреса являются 32-разрядными в IPv4, а в IPv6 они 128-разрядные.</span><span class="sxs-lookup"><span data-stu-id="427f9-1392">The only difference between IPv4 and IPv6 TCP packet header checksums is that the source and destination IP addresses are 32 bit in IPv4 and 128 bit in IPv6.</span></span> 

<span data-ttu-id="427f9-1393">Некоторые сетевые контроллеры могут выполнять вычисление и проверку контрольной суммы TCP в оборудовании.</span><span class="sxs-lookup"><span data-stu-id="427f9-1393">Certain network controllers are able to perform TCP checksum computation and validation in hardware.</span></span> <span data-ttu-id="427f9-1394">В таких системах приложения могут в максимальной мере использовать аппаратную логику вычисления контрольной суммы, чтобы сократить количество служебных данных во время выполнения.</span><span class="sxs-lookup"><span data-stu-id="427f9-1394">For such systems, applications may want to use hardware checksum logic as much as possible to reduce runtime overhead.</span></span> <span data-ttu-id="427f9-1395">Приложения могут полностью отключить логику вычисления контрольной суммы TCP из библиотеки NetX Duo во время сборки, определив ***NX_DISABLE_TCP_TX_CHECKSUM** _ и _*_NX_DISABLE_TCP_RX_CHECKSUM_\*\*.</span><span class="sxs-lookup"><span data-stu-id="427f9-1395">Applications may disable TCP checksum computation logic from the NetX Duo library altogether at build time by defining ***NX_DISABLE_TCP_TX_CHECKSUM** _ and _*_NX_DISABLE_TCP_RX_CHECKSUM_\*\*.</span></span> <span data-ttu-id="427f9-1396">В этом случае код для вычисления контрольной суммы TCP не компилируется.</span><span class="sxs-lookup"><span data-stu-id="427f9-1396">This way, the TCP checksum code is not compiled in.</span></span> <span data-ttu-id="427f9-1397">Однако следует соблюдать осторожность, если установлен необязательный пакет IPsec NetX Duo, а для подключения TCP может потребоваться пройти по безопасному каналу.</span><span class="sxs-lookup"><span data-stu-id="427f9-1397">However one should exercise caution if the optional NetX Duo IPsec package is installed, and the TCP connection may need to traverse through a secure channel.</span></span> <span data-ttu-id="427f9-1398">В этом случае данные в пакетах, принадлежащих TCP-соединению, уже зашифрованы, а большинство аппаратных модулей контрольной суммы TCP, имеющихся в сетевом драйвере, не могут формировать правильные значения контрольной суммы из зашифрованных полезных данных TCP.</span><span class="sxs-lookup"><span data-stu-id="427f9-1398">In this case, data in packets belonging to the TCP connection is already encrypted, and most hardware TCP checksum modules present in the network driver are unable to generate correct checksum value from the encrypted TCP payload.</span></span>

<span data-ttu-id="427f9-1399">Для решения этой проблемы приложение должно иметь доступ к логике контрольной суммы TCP в библиотеке и использовать функцию возможностей интерфейса.</span><span class="sxs-lookup"><span data-stu-id="427f9-1399">To address this issue, application shall keep the TCP checksum logic available in the library and use the interface capability feature.</span></span> <span data-ttu-id="427f9-1400">Если функция возможностей интерфейса включена, модуль TCP знает, как правильно обработать контрольную сумму TCP, если драйвер также может вычислить значение контрольной суммы:</span><span class="sxs-lookup"><span data-stu-id="427f9-1400">With interface capability feature enabled, the TCP module knows how to properly handle the TCP checksum if the driver is also able to compute the checksum value:</span></span>

1) <span data-ttu-id="427f9-1401">Если пакет TCP не подлежит процессу IPsec, оборудование сетевого интерфейса может вычислить контрольную сумму.</span><span class="sxs-lookup"><span data-stu-id="427f9-1401">If the TCP packet is not subject to IPsec process, the network interface hardware is able to compute the checksum.</span></span> <span data-ttu-id="427f9-1402">Поэтому модуль TCP не пытается вычислить контрольную сумму.</span><span class="sxs-lookup"><span data-stu-id="427f9-1402">Therefore the TCP module does not attempt to compute the checksum;</span></span>

2) <span data-ttu-id="427f9-1403">Если пакет IPsec установлен и пакет TCP подлежит процессу IPsec, то модуль TCP вычислит контрольную сумму в программном обеспечении перед отправкой пакета на уровень IPsec.</span><span class="sxs-lookup"><span data-stu-id="427f9-1403">If IPsec package is installed, and the TCP packet is subject to IPsec process, the TCP module computes checksum in software before sending the packet to IPsec layer.</span></span>

### <a name="tcp-port"></a><span data-ttu-id="427f9-1404">TCP-порт</span><span class="sxs-lookup"><span data-stu-id="427f9-1404">TCP Port</span></span>     
<span data-ttu-id="427f9-1405">TCP-порт — это логическая точка подключения в протоколе TCP.</span><span class="sxs-lookup"><span data-stu-id="427f9-1405">A TCP port is a logical connection point in the TCP protocol.</span></span> <span data-ttu-id="427f9-1406">В компоненте TCP NetX Duo имеется 65 535 допустимых портов в диапазоне от 1 до 0xFFFF.</span><span class="sxs-lookup"><span data-stu-id="427f9-1406">There are 65,535 valid ports in the TCP component of NetX Duo, ranging from 1 through 0xFFFF.</span></span> <span data-ttu-id="427f9-1407">В отличие от протокола UDP, в котором данные с одного порта могут отправляться на любой другой порт назначения, один TCP-порт подключается к другому конкретному TCP-порту, а передача данных может осуществляться, только если это подключение установлено. При этом передача возможна только между двумя портами, между которыми установлено соединение.</span><span class="sxs-lookup"><span data-stu-id="427f9-1407">Unlike UDP in which data from one port can be sent to any other destination port, a TCP port is connected to another specific TCP port, and only when this connection is established can any data transfer take place—and only between the two ports making up the connection.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="427f9-1408">*TCP-порты полностью отделены от UDP-портов. Например, UDP-порт с номером 1 не связан с TCP-портом с номером 1*.</span><span class="sxs-lookup"><span data-stu-id="427f9-1408">*TCP ports are completely separate from UDP ports; e.g., UDP port number 1 has no relation to TCP port number 1*.</span></span>

### <a name="client-server-model"></a><span data-ttu-id="427f9-1409">Модель "клиент — сервер"</span><span class="sxs-lookup"><span data-stu-id="427f9-1409">Client-Server Model</span></span>     
<span data-ttu-id="427f9-1410">Чтобы использовать протокол TCP для передачи данных, необходимо сначала установить соединение между двумя сокетами TCP.</span><span class="sxs-lookup"><span data-stu-id="427f9-1410">To use TCP for data transfer, a connection must first be established between the two TCP sockets.</span></span> <span data-ttu-id="427f9-1411">Установка соединения выполняется на стороне клиента и на стороне сервера.</span><span class="sxs-lookup"><span data-stu-id="427f9-1411">The establishment of the connection is done in a client-server fashion.</span></span> <span data-ttu-id="427f9-1412">Клиентская часть соединения — это сторона, которая инициирует соединение, а серверная часть просто ожидает запросы на подключение от клиента до завершения обработки.</span><span class="sxs-lookup"><span data-stu-id="427f9-1412">The client side of the connection is the side that initiates the connection, while the server side simply waits for client connection requests before any processing is done.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="427f9-1413">*Для устройств с поддержкой множественной адресации NetX Duo автоматически определяет исходный адрес, используемый для подключения, и адрес следующего прыжка на основе IP-адреса назначения соединения. Так как TCP ограничен отправкой пакетов на одноадресные (например, нешироковещательные) адреса назначения, NetX Duo не требует "подсказки" для выбора исходного адреса IPv6*.</span><span class="sxs-lookup"><span data-stu-id="427f9-1413">*For multihome devices, NetX Duo automatically determines the source address to use for the connection, and the next hop address based on the destination IP address of the connection. Because TCP is limited to sending packets to unicast (e.g.nonbroadcast) destination addresses, NetX Duo does not require a "hint" for choosing the source IPv6 address*.</span></span>

### <a name="tcp-socket-state-machine"></a><span data-ttu-id="427f9-1414">Конечный автомат сокета TCP</span><span class="sxs-lookup"><span data-stu-id="427f9-1414">TCP Socket State Machine</span></span>      
<span data-ttu-id="427f9-1415">Соединение между двумя сокетами TCP (один клиент и один сервер) реализовать сложно. Для управления такими соединениями используется конечный автомат.</span><span class="sxs-lookup"><span data-stu-id="427f9-1415">The connection between two TCP sockets (one client and one server) is complex and is managed in a state machine manner.</span></span> <span data-ttu-id="427f9-1416">Каждый сокет TCP запускается в состоянии CLOSED (ЗАКРЫТ).</span><span class="sxs-lookup"><span data-stu-id="427f9-1416">Each TCP socket starts in a CLOSED state.</span></span> <span data-ttu-id="427f9-1417">Через события подключения конечный автомат каждого сокета переводит его в состояние ESTABLISHED (УСТАНОВЛЕН), в котором выполняется основная часть передачи данных в TCP.</span><span class="sxs-lookup"><span data-stu-id="427f9-1417">Through connection events each socket's state machine migrates into the ESTABLISHED state, which is where the bulk of the data transfer in TCP takes place.</span></span> <span data-ttu-id="427f9-1418">Когда одной стороне соединения больше не требуется отправлять данные, она отключается.</span><span class="sxs-lookup"><span data-stu-id="427f9-1418">When one side of the connection no longer wishes to send data, it disconnects.</span></span> <span data-ttu-id="427f9-1419">После отключения другой стороны сокет TCP фактически возвращается в состояние CLOSED (ЗАКРЫТ).</span><span class="sxs-lookup"><span data-stu-id="427f9-1419">After the other side disconnects, eventually the TCP socket returns to the CLOSED state.</span></span> <span data-ttu-id="427f9-1420">Этот процесс повторяется всякий раз, когда клиент и сервер TCP устанавливают и закрывают соединение.</span><span class="sxs-lookup"><span data-stu-id="427f9-1420">This process repeats each time a TCP client and server establish and close a connection.</span></span> <span data-ttu-id="427f9-1421">На рис. 14 показаны различные состояния конечного автомата TCP.</span><span class="sxs-lookup"><span data-stu-id="427f9-1421">Figure 14 shows the various states of the TCP state machine.</span></span>

### <a name="tcp-client-connection"></a><span data-ttu-id="427f9-1422">Подключение клиента TCP</span><span class="sxs-lookup"><span data-stu-id="427f9-1422">TCP Client Connection</span></span>       
<span data-ttu-id="427f9-1423">Как упоминалось ранее, клиентская сторона TCP-соединения инициирует запрос на подключение к серверу TCP.</span><span class="sxs-lookup"><span data-stu-id="427f9-1423">As mentioned previously, the client side of the TCP connection initiates a connection request to a TCP server.</span></span> <span data-ttu-id="427f9-1424">Перед запросом на подключение необходимо включить протокол TCP на клиентском IP-экземпляре.</span><span class="sxs-lookup"><span data-stu-id="427f9-1424">Before a connection request can be made, TCP must be enabled on the client IP instance.</span></span> <span data-ttu-id="427f9-1425">Кроме того, необходимо создать клиентский сокет TCP с помощью службы \***nx_tcp_socket_create** _ и привязать его к порту посредством службы _ \*_nx_tcp_client_socket_bind_\*\*.</span><span class="sxs-lookup"><span data-stu-id="427f9-1425">In addition, the client TCP socket must next be created with the ***nx_tcp_socket_create** _ service and bound to a port via the _ *_nx_tcp_client_socket_bind_** service.</span></span>

<span data-ttu-id="427f9-1426">После привязки клиентского сокета для установления соединения с TCP-сервером используется служба ***nxd_tcp_client_socket_connect***.</span><span class="sxs-lookup"><span data-stu-id="427f9-1426">After the client socket is bound, the ***nxd_tcp_client_socket_connect*** service is used to establish a connection with a TCP server.</span></span> <span data-ttu-id="427f9-1427">Обратите внимание, что сокет должен находиться в состоянии CLOSED (ЗАКРЫТ) для инициации попытки подключения.</span><span class="sxs-lookup"><span data-stu-id="427f9-1427">Note the socket must be in a CLOSED state to initiate a connection attempt.</span></span> <span data-ttu-id="427f9-1428">Установка подключения начинается с выдачи пакета SYN NetX Duo, а затем ожидания передачи пакета подтверждения SYN с сервера, что означает принятие запроса на подключение.</span><span class="sxs-lookup"><span data-stu-id="427f9-1428">Establishing the connection starts with NetX Duo issuing a SYN packet and then waiting for a SYN ACK packet back from the server, which signifies acceptance of the connection request.</span></span> <span data-ttu-id="427f9-1429">После получения подтверждения SYN NetX Duo реагирует на пакет подтверждения и переводит клиентский сокет в состояние ESTABLISHED (УСТАНОВЛЕН).</span><span class="sxs-lookup"><span data-stu-id="427f9-1429">After the SYN ACK is received, NetX Duo responds with an ACK packet and promotes the client socket to the ESTABLISHED state.</span></span>

![Схема состояний конечного автомата TCP.](./media/user-guide/image24.png)   

<span data-ttu-id="427f9-1431">**РИС. 14. Состояния конечного автомата TCP**</span><span class="sxs-lookup"><span data-stu-id="427f9-1431">**FIGURE 14. States of the TCP State Machine**</span></span>


> [!WARNING]
> <span data-ttu-id="427f9-1432">*Приложения должны использовать **nxd_tcp_client_socket_connect** для TCP-подключений и по протоколам IPv4 и IPv6. Приложения все еще могут использовать **nx_tcp_client_socket_connect** для TCP-подключений IPv4, но разработчикам рекомендуется использовать **nxd_tcp_client_socket_connect**, так как **nx_tcp_client_socket_connect** рано или поздно станет устаревшим*.</span><span class="sxs-lookup"><span data-stu-id="427f9-1432">*Applications should use **nxd_tcp_client_socket_connect** for either IPv4 and IPv6 TCP connections. Applications can still use **nx_tcp_client_socket_connect** for IPv4 TCP connections, but developers are encouraged to use **nxd_tcp_client_socket_connect** since **nx_tcp_client_socket_connect** will eventually be deprecated*.</span></span>

<span data-ttu-id="427f9-1433">*Аналогичным образом, **nxd_tcp_socket_peer_info_get** работает с TCP-подключениями по протоколам IPv4 и IPv6. Однако **nx_tcp_socket_peer_info_get** по-прежнему доступен для устаревших приложений. Разработчикам рекомендуется использовать **nxd_tcp_socket_peer_info_get** в будущем*.</span><span class="sxs-lookup"><span data-stu-id="427f9-1433">*Similarly, **nxd_tcp_socket_peer_info_get** works with either IPv4 or IPv6 TCP connections. However, **nx_tcp_socket_peer_info_get** is still available for legacy applications. Developers are encouraged to use **nxd_tcp_socket_peer_info_get** going forward*.</span></span>

### <a name="tcp-client-disconnection"></a><span data-ttu-id="427f9-1434">Отключение клиента TCP</span><span class="sxs-lookup"><span data-stu-id="427f9-1434">TCP Client Disconnection</span></span>    
<span data-ttu-id="427f9-1435">Закрытие соединения выполняется путем вызова ***nx_tcp_socket_disconnect***.</span><span class="sxs-lookup"><span data-stu-id="427f9-1435">Closing the connection is accomplished by calling ***nx_tcp_socket_disconnect***.</span></span> <span data-ttu-id="427f9-1436">Если не задана приостановка, сокет клиента отправляет пакет RST на сокет сервера и переводит сокет в состояние CLOSED (ЗАКРЫТ).</span><span class="sxs-lookup"><span data-stu-id="427f9-1436">If no suspension is specified, the client socket sends a RST packet to the server socket and places the socket in the CLOSED state.</span></span> <span data-ttu-id="427f9-1437">В противном случае при запросе приостановки выполняется полный протокол отключения TCP, как показано ниже.</span><span class="sxs-lookup"><span data-stu-id="427f9-1437">Otherwise, if a suspension is requested, the full TCP disconnect protocol is performed, as follows:</span></span> 

- <span data-ttu-id="427f9-1438">Если сервер ранее инициировал запрос на отключение (клиентский сокет уже получил пакет FIN, ответил подтверждением и находится в состоянии CLOSE WAIT (ОЖИДАНИЕ ЗАКРЫТИЯ)), NetX Duo повышает состояние TCP-сокета клиента до состояния LAST ACK (ПОСЛЕДНЕЕ ПОДТВЕРЖДЕНИЕ) и отправляет пакет FIN.</span><span class="sxs-lookup"><span data-stu-id="427f9-1438">If the server previously initiated a disconnect request (the client socket has already received a FIN packet, responded with an ACK, and is in the CLOSE WAIT state), NetX Duo promotes the client TCP socket state to the LAST ACK state and sends a FIN packet.</span></span> <span data-ttu-id="427f9-1439">Затем он ожидает подтверждения от сервера перед завершением отключения и переходом в состояние CLOSED (ЗАКРЫТ).</span><span class="sxs-lookup"><span data-stu-id="427f9-1439">It then waits for an ACK from the server before completing the disconnect and entering the CLOSED state.</span></span>

- <span data-ttu-id="427f9-1440">Если, с другой стороны, клиент первым инициирует запрос на отключение (сервер не был отключен, а сокет по-прежнему находится в состоянии ESTABLISHED (УСТАНОВЛЕН)), NetX Duo отправляет пакет FIN для инициации отключения и ждет получения сообщения FIN и подтверждения от сервера до завершения отключения и помещения сокета в состояние CLOSED (ЗАКРЫТ).</span><span class="sxs-lookup"><span data-stu-id="427f9-1440">If on the other hand, the client is the first to initiate a disconnect request (the server has not disconnected and the socket is still in the ESTABLISHED state), NetX Duo sends a FIN packet to initiate the disconnect and waits to receive a FIN and an ACK from the server before completing the disconnect and placing the socket in a CLOSED state.</span></span>

<span data-ttu-id="427f9-1441">Если в очереди передачи сокета остались пакеты, NetX Duo приостанавливается на указанное время ожидания, чтобы обеспечить подтверждение этих пакетов.</span><span class="sxs-lookup"><span data-stu-id="427f9-1441">If there are still packets on the socket transmit queue, NetX Duo suspends for the specified timeout to allow the packets to be acknowledged.</span></span> <span data-ttu-id="427f9-1442">По истечении времени ожидания NetX Duo очищает очередь передачи сокета клиента.</span><span class="sxs-lookup"><span data-stu-id="427f9-1442">If the timeout expires, NetX Duo empties the transmit queue of the client socket.</span></span> 

<span data-ttu-id="427f9-1443">Чтобы отменить привязку порта к сокету клиента, приложение вызывает ***nx_tcp_client_socket_unbind***.</span><span class="sxs-lookup"><span data-stu-id="427f9-1443">To unbind the port from the client socket, the application calls ***nx_tcp_client_socket_unbind***.</span></span> <span data-ttu-id="427f9-1444">Сокет должен находиться в состоянии CLOSED (ЗАКРЫТ) или в процессе отсоединения (т. е. в состоянии TIMED WAIT (ОЖИДАНИЕ С ПРИВЯЗКОЙ КО ВРЕМЕНИ)) до освобождения порта. В противном случае возвращается ошибка.</span><span class="sxs-lookup"><span data-stu-id="427f9-1444">The socket must be in a CLOSED state or in the process of disconnecting (i.e., TIMED WAIT state) before the port is released; otherwise, an error is returned.</span></span>

<span data-ttu-id="427f9-1445">Наконец, если сокет клиента приложению больше не требуется, вызывается ***nx_tcp_socket_delete*** для удаления сокета.</span><span class="sxs-lookup"><span data-stu-id="427f9-1445">Finally, if the application no longer needs the client socket, it calls ***nx_tcp_socket_delete*** to delete the socket.</span></span>

### <a name="tcp-server-connection"></a><span data-ttu-id="427f9-1446">Подключение к серверу TCP</span><span class="sxs-lookup"><span data-stu-id="427f9-1446">TCP Server Connection</span></span>      
<span data-ttu-id="427f9-1447">Серверная сторона TCP-соединения является пассивной; т. е. сервер ожидает инициирования клиентом запроса на подключение.</span><span class="sxs-lookup"><span data-stu-id="427f9-1447">The server side of a TCP connection is passive; i.e., the server waits for a client to initiate connection request.</span></span> <span data-ttu-id="427f9-1448">Чтобы принять клиентское подключение, необходимо сначала включить TCP в экземпляре IP, вызвав службу \***nx_tcp_enable** _.</span><span class="sxs-lookup"><span data-stu-id="427f9-1448">To accept a client connection, TCP must first be enabled on the IP instance by calling the service \***nx_tcp_enable** _.</span></span> <span data-ttu-id="427f9-1449">Затем приложение должно создать сокет TCP с помощью службы _ \*_nx_tcp_socket_create_\*\*.</span><span class="sxs-lookup"><span data-stu-id="427f9-1449">Next, the application must create a TCP socket using the _ *_nx_tcp_socket_create_*\* service.</span></span>  

<span data-ttu-id="427f9-1450">Сокет сервера также должен быть настроен для ожидания передачи данных запросов на подключение.</span><span class="sxs-lookup"><span data-stu-id="427f9-1450">The server socket must also be set up for listening for connection requests.</span></span> <span data-ttu-id="427f9-1451">Для этого используется служба ***nx_tcp_server_socket_listen***.</span><span class="sxs-lookup"><span data-stu-id="427f9-1451">This is achieved by using the ***nx_tcp_server_socket_listen*** service.</span></span> <span data-ttu-id="427f9-1452">Эта служба переводит сокет сервера в состояние LISTEN (ОЖИДАНИЕ ПЕРЕДАЧИ ДАННЫХ) и привязывает указанный порт сервера к сокету.</span><span class="sxs-lookup"><span data-stu-id="427f9-1452">This service places the server socket in the LISTEN state and binds the specified server port to the socket.</span></span>

> [!NOTE] 
> <span data-ttu-id="427f9-1453">*Чтобы задать подпрограммы обратного вызова для прослушивания сокета, приложение указывает соответствующую функцию обратного вызова для аргумента tcp_listen_callback службы **nx_tcp_server_socket_listen**. Эта функция обратного вызова приложения затем выполняется NetX Duo всякий раз, когда на этом порте сервера запрашивается новое подключение. Обработка в обратном вызове находится под управлением приложения.*</span><span class="sxs-lookup"><span data-stu-id="427f9-1453">*To set a socket listen callback routine the application specifies the appropriate callback function for the tcp_listen_callback argument of the **nx_tcp_server_socket_listen** service. This application callback function is then executed by NetX Duo whenever a new connection is requested on this server port. The processing in the callback is under application control.*</span></span>

<span data-ttu-id="427f9-1454">Чтобы принимать клиентские запросы на подключение, приложение вызывает службу \***nx_tcp_server_socket_accept** _.</span><span class="sxs-lookup"><span data-stu-id="427f9-1454">To accept client connection requests, the application calls the \***nx_tcp_server_socket_accept** _ service.</span></span> <span data-ttu-id="427f9-1455">Для вызова службы принятия сокет сервера должен находиться в состоянии LISTEN (ОЖИДАНИЕ ПЕРЕДАЧИ ДАННЫХ) или состоянии SYN RECEIVED (ПОЛУЧЕН ЗАПРОС СИНХРОНИЗАЦИИ) (т. е. сервер находится в состоянии LISTEN (ОЖИДАНИЕ ПЕРЕДАЧИ ДАННЫХ) и получил пакет SYN от клиента, запросившего соединение).</span><span class="sxs-lookup"><span data-stu-id="427f9-1455">The server socket must either be in a LISTEN state or a SYN RECEIVED state (i.e., the server is in the LISTEN state and has received a SYN packet from a client requesting a connection) to call the accept service.</span></span> <span data-ttu-id="427f9-1456">Состояние успешного возврата из _ *_nx_tcp_server_socket_accept_*\* указывает, что подключение установлено, а сокет сервера находится в состоянии ESTABLISHED (УСТАНОВЛЕН).</span><span class="sxs-lookup"><span data-stu-id="427f9-1456">A successful return status from _ *_nx_tcp_server_socket_accept_*\* indicates the connection has been set up and the server socket is in the ESTABLISHED state.</span></span>

<span data-ttu-id="427f9-1457">Когда сокет сервера будет иметь допустимое подключение, дополнительные запросы на подключение клиентов будут помещаться в очередь, пока она не будет полностью занята. Длина очереди определяется параметром *listen_queue_size, передаваемым в службу*  \***nx_tcp_server_socket_listen** _.</span><span class="sxs-lookup"><span data-stu-id="427f9-1457">After the server socket has a valid connection, additional client connection requests are queued up to the depth specified by the *listen_queue_size, passed into the* \***nx_tcp_server_socket_listen** _ service.</span></span> <span data-ttu-id="427f9-1458">Для обработки последующих соединений на порте сервера приложение должно вызвать _ *_nx_tcp_server_socket_relisten_*\* с доступным сокетом (т е. сокетом в состоянии CLOSED (ЗАКРЫТ)).</span><span class="sxs-lookup"><span data-stu-id="427f9-1458">In order to process subsequent connections on a server port, the application must call _ *_nx_tcp_server_socket_relisten_*\* with an available socket (i.e., a socket in a CLOSED state).</span></span> <span data-ttu-id="427f9-1459">Обратите внимание, что при этом может использоваться тот же сокет сервера, если связанное с ним предыдущее соединение завершено, а сокет находится в состоянии CLOSED (ЗАКРЫТ).</span><span class="sxs-lookup"><span data-stu-id="427f9-1459">Note that the same server socket could be used if the previous connection associated with the socket is now finished and the socket is in the CLOSED state.</span></span>

### <a name="tcp-server-disconnection"></a><span data-ttu-id="427f9-1460">Отключение сервера TCP</span><span class="sxs-lookup"><span data-stu-id="427f9-1460">TCP Server Disconnection</span></span>     
<span data-ttu-id="427f9-1461">Закрытие соединения выполняется путем вызова ***nx_tcp_socket_disconnect***.</span><span class="sxs-lookup"><span data-stu-id="427f9-1461">Closing the connection is accomplished by calling ***nx_tcp_socket_disconnect***.</span></span> <span data-ttu-id="427f9-1462">Если не задана приостановка, сокет сервера отправляет пакет RST на сокет клиента и переводит сокет в состояние CLOSED (ЗАКРЫТ).</span><span class="sxs-lookup"><span data-stu-id="427f9-1462">If no suspension is specified, the server socket sends a RST packet to the client socket and places the socket in the CLOSED state.</span></span> <span data-ttu-id="427f9-1463">В противном случае при запросе приостановки выполняется полный протокол отключения TCP, как показано ниже.</span><span class="sxs-lookup"><span data-stu-id="427f9-1463">Otherwise, if a suspension is requested, the full TCP disconnect protocol is performed, as follows:</span></span>

- <span data-ttu-id="427f9-1464">Если клиент ранее инициировал запрос на отключение (серверный сокет уже получил пакет FIN, ответил подтверждением и находится в состоянии CLOSE WAIT (ОЖИДАНИЕ ЗАКРЫТИЯ)), NetX Duo повышает состояние TCP-сокета до состояния LAST ACK (ПОСЛЕДНЕЕ ПОДТВЕРЖДЕНИЕ) и отправляет пакет FIN.</span><span class="sxs-lookup"><span data-stu-id="427f9-1464">If the client previously initiated a disconnect request (the server socket has already received a FIN packet, responded with an ACK, and is in the CLOSE WAIT state), NetX Duo promotes the TCP socket state to the LAST ACK state and sends a FIN packet.</span></span> <span data-ttu-id="427f9-1465">Затем он ожидает подтверждения от сервера перед завершением отключения и входом в состояние CLOSED (ЗАКРЫТ).</span><span class="sxs-lookup"><span data-stu-id="427f9-1465">It then waits for an ACK from the client before  completing the disconnect and entering the CLOSED state.</span></span>

- <span data-ttu-id="427f9-1466">Если, с другой стороны, сервер первым инициирует запрос на отключение (клиент не был отключен, а сокет по-прежнему находится в состоянии ESTABLISHED (УСТАНОВЛЕН)), NetX Duo отправляет пакет FIN для инициации отключения и ждет получения сообщения FIN и подтверждения от клиента до завершения отключения и помещения сокета в состояние CLOSED (ЗАКРЫТ).</span><span class="sxs-lookup"><span data-stu-id="427f9-1466">If on the other hand, the server is the first to initiate a disconnect request (the client has not disconnected and the socket is still in the ESTABLISHED state), NetX Duo sends a FIN packet to initiate the disconnect and waits to receive a FIN and an ACK from the client before completing the disconnect and placing the socket in a CLOSED state.</span></span>

<span data-ttu-id="427f9-1467">Если в очереди передачи сокета остались пакеты, NetX Duo приостанавливается на указанное время ожидания, чтобы обеспечить подтверждение этих пакетов.</span><span class="sxs-lookup"><span data-stu-id="427f9-1467">If there are still packets on the socket transmit queue, NetX Duo suspends for the specified timeout to allow those packets to be acknowledged.</span></span> <span data-ttu-id="427f9-1468">По истечении времени ожидания NetX Duo освобождает очередь передачи сокета сервера.</span><span class="sxs-lookup"><span data-stu-id="427f9-1468">If the timeout expires, NetX Duo flushes the transmit queue of the server socket.</span></span>

<span data-ttu-id="427f9-1469">После завершения обработки отключения и перехода сокета сервера в состояние CLOSED (ЗАКРЫТ) приложение должно вызвать службу \***nx_tcp_server_socket_unaccept** _, чтобы завершить сопоставление этого сокета с портом сервера.</span><span class="sxs-lookup"><span data-stu-id="427f9-1469">After the disconnect processing is complete and the server socket is in the CLOSED state, the application must call the \***nx_tcp_server_socket_unaccept** _ service to end the association of this socket with the server port.</span></span> <span data-ttu-id="427f9-1470">Примечание. Эта служба должна вызываться приложением, даже если _*_nx_tcp_socket_disconnect_*_ или _*_nx_tcp_server_socket_accept_*_ возвращает состояние ошибки.</span><span class="sxs-lookup"><span data-stu-id="427f9-1470">Note this service must be called by the application even if _*_nx_tcp_socket_disconnect_*_ or _*_nx_tcp_server_socket_accept_*_ return an error status.</span></span> <span data-ttu-id="427f9-1471">После возврата _*_nx_tcp_server_socket_unaccept_*_ сокет можно использовать в качестве сокета клиента или сервера или даже удалить, если он больше не требуется.</span><span class="sxs-lookup"><span data-stu-id="427f9-1471">After the _*_nx_tcp_server_socket_unaccept_*_ returns, the socket can be used as a client or server socket, or even deleted if it is no longer needed.</span></span> <span data-ttu-id="427f9-1472">Если требуется принять другое клиентское соединение на том же порте сервера, для этого сокета должна быть вызвана служба _ \*_nx_tcp_server_socket_relisten_\*\*.</span><span class="sxs-lookup"><span data-stu-id="427f9-1472">If accepting another client connection on the same server port is desired, the _ *_nx_tcp_server_socket_relisten_*\* service should be called on this socket.</span></span>

<span data-ttu-id="427f9-1473">В следующем сегменте кода показана последовательность вызовов типичного сервера TCP.</span><span class="sxs-lookup"><span data-stu-id="427f9-1473">The following code segment illustrates the sequence of calls a typical TCP server uses:</span></span>

```c
/* Set up a previously created TCP socket to
   listen on port 12 */
nx_tcp_server_socket_listen()

/* Loop to make a (another) connection. */
while(1)
{
    /* Wait for a client socket connection request
       for 100 ticks. */
    nx_tcp_server_socket_accept();

    /* (Send and receive TCP messages with the TCP
       client) */

    /* Disconnect the server socket. */
    nx_tcp_socket_disconnect();

    /* Remove this server socket from listening on
       the port. */
    nx_tcp_server_socket_unaccept(&server_socket);
    /* Set up server socket to relisten on the
       same port for the next client. */
    nx_tcp_server_socket_relisten();
}
```

### <a name="mss-validation"></a><span data-ttu-id="427f9-1474">Проверка MSS</span><span class="sxs-lookup"><span data-stu-id="427f9-1474">MSS Validation</span></span>      
<span data-ttu-id="427f9-1475">Максимальный размер сегмента (MSS) — это максимальное количество байтов, которые может получить узел TCP без фрагментации с помощью базового уровня IP.</span><span class="sxs-lookup"><span data-stu-id="427f9-1475">The Maximum Segment Size (MSS) is the maximum amount of bytes a TCP host can receive without being fragmented by the underlying IP layer.</span></span> <span data-ttu-id="427f9-1476">На этапе установки TCP-соединения оба его конца обмениваются своим значением MSS для TCP, чтобы отправитель не отправлял сегмент данных TCP, превышающий размер MSS получателя.</span><span class="sxs-lookup"><span data-stu-id="427f9-1476">During TCP connection establishment phase, both ends exchanges its own TCP MSS value, so that the sender does not send a TCP data segment that is larger than the receiver's MSS.</span></span> <span data-ttu-id="427f9-1477">Модуль TCP NetX Duo при необходимости проверяет значение MSS, объявленное для однорангового узла, перед установкой соединения.</span><span class="sxs-lookup"><span data-stu-id="427f9-1477">NetX Duo TCP module will optionally validate its peer's advertised MSS value before establishing a connection.</span></span> <span data-ttu-id="427f9-1478">По умолчанию NetX Duo не разрешает такую проверку.</span><span class="sxs-lookup"><span data-stu-id="427f9-1478">By default NetX Duo does not enable such a check.</span></span> <span data-ttu-id="427f9-1479">Приложения, желающие выполнять проверку MSS, должны определить ***NX_ENABLE_TCP_MSS_CHECK** _ при создании библиотеки NetX Duo, а минимальное значение должно быть определено в _*_NX_TCP_MSS_MINIMUM_\*_.</span><span class="sxs-lookup"><span data-stu-id="427f9-1479">Applications wishing to perform MSS validation shall define ***NX_ENABLE_TCP_MSS_CHECK** _ when building the NetX Duo library, and the minimum value shall be defined in _*_NX_TCP_MSS_MINIMUM_\*_.</span></span> <span data-ttu-id="427f9-1480">Входящие TCP-соединения со значениями MSS ниже _ *_NX_TCP_MSS_MINIMUM_*\* отбрасываются.</span><span class="sxs-lookup"><span data-stu-id="427f9-1480">Incoming TCP connections with MSS values below _ *_NX_TCP_MSS_MINIMUM_*\* are dropped.</span></span>

### <a name="stop-listening-on-a-server-port"></a><span data-ttu-id="427f9-1481">Прекращение прослушивания порта сервера</span><span class="sxs-lookup"><span data-stu-id="427f9-1481">Stop Listening on a Server Port</span></span>    
<span data-ttu-id="427f9-1482">Если приложению больше не требуется ожидать передачи данных для запросов клиентского соединения на порте сервера, который был ранее указан при вызове службы \***nx_tcp_server_socket_listen** _, приложение просто вызывает службу _ \*_nx_tcp_server_socket_unlisten_\*\*.</span><span class="sxs-lookup"><span data-stu-id="427f9-1482">If the application no longer wishes to listen for client connection requests on a server port that was previously specified by a call to the ***nx_tcp_server_socket_listen** _ service, the application simply calls the _ *_nx_tcp_server_socket_unlisten_** service.</span></span> <span data-ttu-id="427f9-1483">Эта служба переводит любой сокет, ожидающий подключения, в состояние CLOSED (ЗАКРЫТ) и освобождает все пакеты запросов на подключение клиентов, помещенные в очередь.</span><span class="sxs-lookup"><span data-stu-id="427f9-1483">This service places any socket waiting for a connection back in the CLOSED state and releases any queued client connection request packets.</span></span> 

### <a name="tcp-window-size"></a><span data-ttu-id="427f9-1484">Размер окна TCP</span><span class="sxs-lookup"><span data-stu-id="427f9-1484">TCP Window Size</span></span>   
<span data-ttu-id="427f9-1485">Во время этапов настройки соединения и передачи данных каждый порт сообщает объем данных, которые он может обработать. Этот объем называется размером окна.</span><span class="sxs-lookup"><span data-stu-id="427f9-1485">During both the setup and data transfer phases of the connection, each port reports the amount of data it can handle, which is called its window size.</span></span> <span data-ttu-id="427f9-1486">При получении и обработке данных размер этого окна корректируется динамически.</span><span class="sxs-lookup"><span data-stu-id="427f9-1486">As data are received and processed, this window size is adjusted dynamically.</span></span> <span data-ttu-id="427f9-1487">В протоколе TCP отправитель может передавать только объем данных, помещающихся в окно получателя.</span><span class="sxs-lookup"><span data-stu-id="427f9-1487">In TCP, a sender can only send an amount of data that fits into the receiver's window.</span></span> <span data-ttu-id="427f9-1488">По сути, размер окна обеспечивает управление потоком для передачи данных в каждом направлении соединения.</span><span class="sxs-lookup"><span data-stu-id="427f9-1488">In essence, the window size provides flow control for data transfer in each direction of the connection.</span></span>   

### <a name="tcp-packet-send"></a><span data-ttu-id="427f9-1489">Отправка пакетов TCP</span><span class="sxs-lookup"><span data-stu-id="427f9-1489">TCP Packet Send</span></span>     
<span data-ttu-id="427f9-1490">Отправку данных TCP можно легко выполнить, вызвав функцию ***nx_tcp_socket_send***.</span><span class="sxs-lookup"><span data-stu-id="427f9-1490">Sending TCP data is easily accomplished by calling the ***nx_tcp_socket_send*** function.</span></span> <span data-ttu-id="427f9-1491">Если размер передаваемых данных превышает значение MSS для сокета или текущий размер окна приема однорангового узла (в зависимости от того, какое из этих значений меньше), внутренняя логика TCP отсекает при передаче данные, выходящие за пределы этого меньшего значения (MSS или окна однорангового узла).</span><span class="sxs-lookup"><span data-stu-id="427f9-1491">If the size of the data being transmitted is larger than the MSS value of the socket or the current peer receive window size, whichever is smaller, TCP internal logic carves off the data that fits into min (MSS, peer receive Window) for transmission.</span></span> <span data-ttu-id="427f9-1492">Затем эта служба создает заголовок TCP перед пакетом (в том числе вычисляет контрольную сумму).</span><span class="sxs-lookup"><span data-stu-id="427f9-1492">This service then builds a TCP header in front of the packet (including the checksum calculation).</span></span> <span data-ttu-id="427f9-1493">Если размер окна получателя не равен нулю, вызывающий объект будет передавать столько данных, сколько помещается в окно получателя.</span><span class="sxs-lookup"><span data-stu-id="427f9-1493">If the receiver's window size is not zero, the caller will send as much data as it can to fill up the receiver window size.</span></span> <span data-ttu-id="427f9-1494">Если размер окна получения равен нулю, вызывающий объект может приостановить передачу и дождаться, пока размер окна получателя станет достаточно большим для отправки этого пакета.</span><span class="sxs-lookup"><span data-stu-id="427f9-1494">If the receive window becomes zero, the caller may suspend and wait for the receiver's window size to increase enough for this packet to be sent.</span></span> <span data-ttu-id="427f9-1495">Если в какой-то момент времени несколько потоков попытаются отправить данные через один и тот же сокет, они могут быть приостановлены.</span><span class="sxs-lookup"><span data-stu-id="427f9-1495">At any given time, multiple threads may suspend while trying to send data through the same socket.</span></span> 

> [!WARNING]  
> <span data-ttu-id="427f9-1496">*Данные TCP, находящиеся в структуре NX_PACKET, должны располагаться на границе длинных слов. Кроме того, необходимо иметь достаточно места между открывающим указателем и указателем начала данных для размещения заголовков TCP, IP и физических носителей*.</span><span class="sxs-lookup"><span data-stu-id="427f9-1496">*The TCP data residing in the NX_PACKET structure should reside on a long-word boundary. In addition, there needs to be sufficient space between the prepend pointer and the data start pointer to place the TCP, IP, and physical media headers*.</span></span>

### <a name="tcp-packet-retransmit"></a><span data-ttu-id="427f9-1497">Повторная отправка TCP-пакетов</span><span class="sxs-lookup"><span data-stu-id="427f9-1497">TCP Packet Retransmit</span></span>      
<span data-ttu-id="427f9-1498">Ранее отправленные и переданные TCP-пакеты фактически хранятся внутри системы до тех пор, пока другая сторона соединения не возвратит пакет ACK.</span><span class="sxs-lookup"><span data-stu-id="427f9-1498">Previously transmitted TCP packets sent actually stored internally until an ACK is returned from the other side of the connection.</span></span> <span data-ttu-id="427f9-1499">Если передача данных не подтверждается в течение времени ожидания, хранимый пакет отправляется повторно и задается следующий период времени ожидания.</span><span class="sxs-lookup"><span data-stu-id="427f9-1499">If transmitted data is not acknowledged within the timeout period, the stored packet is re-sent and the next timeout period is set.</span></span> <span data-ttu-id="427f9-1500">При получении пакета ACK окончательно освобождаются все пакеты, для которых действителен номер подтверждения во внутренней очереди передачи.</span><span class="sxs-lookup"><span data-stu-id="427f9-1500">When an ACK is received, all packets covered by the acknowledgement number in the internal transmit queue are finally released.</span></span>  

> [!WARNING]   
> <span data-ttu-id="427f9-1501">*Приложение не должно повторно использовать пакет или изменять содержимое пакета после того, как nx_tcp_socket_send() вернется с NX_SUCCESS. Переданный пакет в конечном итоге освобождается внутренней обработкой NetX Duo после того, как данные подтверждаются на другом конце*.</span><span class="sxs-lookup"><span data-stu-id="427f9-1501">*Application shall not reuse the packet or alter the contents of the packet after nx_tcp_socket_send() returns with NX_SUCCESS. The transmitted packet is eventually released by NetX Duo internal processing after the data is acknowledged by the other end*.</span></span>

### <a name="tcp-keepalive"></a><span data-ttu-id="427f9-1502">Проверка активности TCP-соединения</span><span class="sxs-lookup"><span data-stu-id="427f9-1502">TCP Keepalive</span></span>     
<span data-ttu-id="427f9-1503">Функция проверки активности TCP-соединения позволяет сокету выявлять ситуации, когда его кэширующий узел отключается без правильного завершения (например, в случае аварийного завершения однорангового узла), а также предотвращать завершения подключения после длительных периодов бездействия определенными средствами мониторинга сетей.</span><span class="sxs-lookup"><span data-stu-id="427f9-1503">TCP Keepalive feature allows a socket to detect whether or not its peer disconnects without proper termination (for example, the peer crashed), or to prevent certain network monitoring facilities to terminate a connection for long periods of idle.</span></span> <span data-ttu-id="427f9-1504">Функция проверки активности TCP-соединения периодически отправляет TCP-кадр без данных, а текущий порядковый номер уменьшается на единицу.</span><span class="sxs-lookup"><span data-stu-id="427f9-1504">TCP Keepalive works by periodically sending a TCP frame with no data, and the sequence number set to one less than the current sequence number.</span></span> <span data-ttu-id="427f9-1505">При получении такого кадра проверки активности TCP-соединения получатель, если он по-прежнему активен, отвечает пакетом ACK для текущего порядкового номера.</span><span class="sxs-lookup"><span data-stu-id="427f9-1505">On receiving such TCP Keepalive frame, the recipient, if still alive, responses with an ACK for its current sequence number.</span></span> <span data-ttu-id="427f9-1506">На этом транзакция проверки активности завершается.</span><span class="sxs-lookup"><span data-stu-id="427f9-1506">This completes the keepalive transaction.</span></span>  

<span data-ttu-id="427f9-1507">По умолчанию функция проверки активности не включена.</span><span class="sxs-lookup"><span data-stu-id="427f9-1507">By default the keepalive feature is not enabled.</span></span> <span data-ttu-id="427f9-1508">Для использования этой функции библиотека NetX Duo должна быть создана с определенным \***NX_ENABLE_TCP_KEEPALIVE** _.</span><span class="sxs-lookup"><span data-stu-id="427f9-1508">To use this feature, NetX Duo library must be built with \***NX_ENABLE_TCP_KEEPALIVE** _ defined.</span></span> <span data-ttu-id="427f9-1509">Символ _ *_NX_TCP_KEEPALIVE_INITIAL_*\* указывает число секунд бездействия до инициирования кадра проверки активности.</span><span class="sxs-lookup"><span data-stu-id="427f9-1509">The symbol _ *_NX_TCP_KEEPALIVE_INITIAL_*\* specifies the number of seconds of inactivity before the keepalive frame is initiated.</span></span>  

### <a name="tcp-packet-receive"></a><span data-ttu-id="427f9-1510">Получение TCP-пакетов</span><span class="sxs-lookup"><span data-stu-id="427f9-1510">TCP Packet Receive</span></span>   
<span data-ttu-id="427f9-1511">Функция обработки получаемых TCP-пакетов (вызывается из вспомогательного потока IP) отвечает за обработку различных действий подключения и отключения, а также обработку подтверждения передачи.</span><span class="sxs-lookup"><span data-stu-id="427f9-1511">The TCP receive packet processing (called from the IP helper thread) is responsible for handling various connection and disconnection actions as well as transmit acknowledge processing.</span></span> <span data-ttu-id="427f9-1512">Кроме того, функция обработки получаемых TCP-пакетов отвечает за помещение пакетов с получаемыми данными в очередь получения соответствующего сокета TCP или доставку пакета первому приостановленному потоку, ожидающему пакет.</span><span class="sxs-lookup"><span data-stu-id="427f9-1512">In addition, the TCP receive packet processing is responsible for placing packets with receive data on the appropriate TCP socket's receive queue or delivering the packet to the first suspended thread waiting for a packet.</span></span>

### <a name="tcp-receive-notify"></a><span data-ttu-id="427f9-1513">Уведомление о получении TCP-пакета</span><span class="sxs-lookup"><span data-stu-id="427f9-1513">TCP Receive Notify</span></span>     
<span data-ttu-id="427f9-1514">Если поток приложения должен обрабатывать полученные данные из нескольких сокетов, следует использовать функцию ***nx_tcp_socket_receive_notify***.</span><span class="sxs-lookup"><span data-stu-id="427f9-1514">If the application thread needs to process received data from more than one socket, the ***nx_tcp_socket_receive_notify*** function should be used.</span></span> <span data-ttu-id="427f9-1515">Эта функция регистрирует функцию обратного вызова получения пакетов для сокета.</span><span class="sxs-lookup"><span data-stu-id="427f9-1515">This function registers a receive packet callback function for the socket.</span></span> <span data-ttu-id="427f9-1516">При каждом получении пакета сокетом выполняется функция обратного вызова.</span><span class="sxs-lookup"><span data-stu-id="427f9-1516">Whenever a packet is received on the socket, the callback function is executed.</span></span>  

<span data-ttu-id="427f9-1517">Содержимое функции обратного вызова зависит от конкретного приложения. Скорее всего, эта функция будет содержать логику для информирования потока обработки о том, что пакет доступен в соответствующем сокете.</span><span class="sxs-lookup"><span data-stu-id="427f9-1517">The contents of the callback function are applicationspecific; however, the function would most likely contain logic to inform the processing thread that a packet is available on the corresponding socket.</span></span> 

### <a name="thread-suspension"></a><span data-ttu-id="427f9-1518">Приостановка потока</span><span class="sxs-lookup"><span data-stu-id="427f9-1518">Thread Suspension</span></span>      
<span data-ttu-id="427f9-1519">Как упоминалось ранее, потоки приложений могут быть приостановлены при попытке получить данные на определенном TCP-порте.</span><span class="sxs-lookup"><span data-stu-id="427f9-1519">As mentioned previously, application threads can suspend while attempting to receive data from a particular TCP port.</span></span> <span data-ttu-id="427f9-1520">После получения пакета на этом порте он передается первому приостановленному потоку, и этот поток возобновляется.</span><span class="sxs-lookup"><span data-stu-id="427f9-1520">After a packet is received on that port, it is given to the first thread suspended and that thread is then resumed.</span></span> <span data-ttu-id="427f9-1521">Необязательное время ожидания при приостановке пакета приема TCP — это функция, доступная для большинства служб NetX Duo.</span><span class="sxs-lookup"><span data-stu-id="427f9-1521">An optional timeout is available when suspending on a TCP receive packet, a feature available for most NetX Duo services.</span></span>  

<span data-ttu-id="427f9-1522">Приостановка потока также доступна для подключения (как клиента, так и сервера), привязки клиента и служб отключения.</span><span class="sxs-lookup"><span data-stu-id="427f9-1522">Thread suspension is also available for connection (both client and server), client binding, and disconnection services.</span></span>  

### <a name="tcp-socket-statistics-and-errors"></a><span data-ttu-id="427f9-1523">Статистические показатели и ошибки сокета TCP</span><span class="sxs-lookup"><span data-stu-id="427f9-1523">TCP Socket Statistics and Errors</span></span>     
<span data-ttu-id="427f9-1524">Если этот параметр включен, программное обеспечение сокета TCP NetX Duo отслеживает несколько статистических показателей и ошибок, которые могут быть полезны для приложения.</span><span class="sxs-lookup"><span data-stu-id="427f9-1524">If enabled, the NetX Duo TCP socket software keeps track of several statistics and errors that may be useful to the application.</span></span> <span data-ttu-id="427f9-1525">Для каждого IP/TCP-экземпляра поддерживаются следующие статистические показатели и отчеты об ошибках:</span><span class="sxs-lookup"><span data-stu-id="427f9-1525">The following statistics and error reports are maintained for each IP/TCP instance:</span></span>   

- <span data-ttu-id="427f9-1526">общее число отправленных TCP-пакетов;</span><span class="sxs-lookup"><span data-stu-id="427f9-1526">Total TCP Packets Sent</span></span>  
- <span data-ttu-id="427f9-1527">общее число отправленных байтов TCP;</span><span class="sxs-lookup"><span data-stu-id="427f9-1527">Total TCP Bytes Sent</span></span>  
- <span data-ttu-id="427f9-1528">общее число полученных TCP-пакетов;</span><span class="sxs-lookup"><span data-stu-id="427f9-1528">Total TCP Packets Received</span></span>   
- <span data-ttu-id="427f9-1529">общее число полученных байтов TCP;</span><span class="sxs-lookup"><span data-stu-id="427f9-1529">Total TCP Bytes Received</span></span>   
- <span data-ttu-id="427f9-1530">общее число недопустимых TCP-пакетов;</span><span class="sxs-lookup"><span data-stu-id="427f9-1530">Total TCP Invalid Packets</span></span>   
- <span data-ttu-id="427f9-1531">общее число отброшенных пакетов, получаемых по протоколу TCP;</span><span class="sxs-lookup"><span data-stu-id="427f9-1531">Total TCP Receive Packets Dropped</span></span>    
- <span data-ttu-id="427f9-1532">общее число ошибок контрольной суммы при получении по протоколу TCP;</span><span class="sxs-lookup"><span data-stu-id="427f9-1532">Total TCP Receive Checksum Errors</span></span>   
- <span data-ttu-id="427f9-1533">общее число TCP-соединений;</span><span class="sxs-lookup"><span data-stu-id="427f9-1533">Total TCP Connections</span></span>   
- <span data-ttu-id="427f9-1534">общее число отключений TCP-соединений;</span><span class="sxs-lookup"><span data-stu-id="427f9-1534">Total TCP Disconnections</span></span>   
- <span data-ttu-id="427f9-1535">общее число сброшенных TCP-соединений;</span><span class="sxs-lookup"><span data-stu-id="427f9-1535">Total TCP Connections Dropped</span></span>    
- <span data-ttu-id="427f9-1536">общее число повторно отправленных TCP-пакетов;</span><span class="sxs-lookup"><span data-stu-id="427f9-1536">Total TCP Packet Retransmits</span></span>   
- <span data-ttu-id="427f9-1537">число отправленных пакетов сокета TCP;</span><span class="sxs-lookup"><span data-stu-id="427f9-1537">TCP Socket Packets Sent</span></span>   
- <span data-ttu-id="427f9-1538">число отправленных байтов сокета TCP;</span><span class="sxs-lookup"><span data-stu-id="427f9-1538">TCP Socket Bytes Sent</span></span>   
- <span data-ttu-id="427f9-1539">число полученных пакетов сокета TCP;</span><span class="sxs-lookup"><span data-stu-id="427f9-1539">TCP Socket Packets Received</span></span>   
- <span data-ttu-id="427f9-1540">число полученных байтов сокета TCP;</span><span class="sxs-lookup"><span data-stu-id="427f9-1540">TCP Socket Bytes Received</span></span>   
- <span data-ttu-id="427f9-1541">общее число повторно отправленных пакетов сокета TCP;</span><span class="sxs-lookup"><span data-stu-id="427f9-1541">TCP Socket Packet Retransmits</span></span>    
- <span data-ttu-id="427f9-1542">число поставленных в очередь пакетов сокета TCP;</span><span class="sxs-lookup"><span data-stu-id="427f9-1542">TCP Socket Packets Queued</span></span>    
- <span data-ttu-id="427f9-1543">число ошибок контрольной суммы сокета TCP;</span><span class="sxs-lookup"><span data-stu-id="427f9-1543">TCP Socket Checksum Errors</span></span>    
- <span data-ttu-id="427f9-1544">состояние сокета TCP;</span><span class="sxs-lookup"><span data-stu-id="427f9-1544">TCP Socket State</span></span>    
- <span data-ttu-id="427f9-1545">длина очереди передачи сокета TCP;</span><span class="sxs-lookup"><span data-stu-id="427f9-1545">TCP Socket Transmit Queue Depth</span></span>    
- <span data-ttu-id="427f9-1546">размер окна передачи сокета TCP;</span><span class="sxs-lookup"><span data-stu-id="427f9-1546">TCP Socket Transmit Window Size</span></span>    
- <span data-ttu-id="427f9-1547">размер окна получения сокета TCP.</span><span class="sxs-lookup"><span data-stu-id="427f9-1547">TCP Socket Receive Window Size</span></span>    

<span data-ttu-id="427f9-1548">Все эти статистические показатели и отчеты об ошибках предоставляются приложению службой ***nx_tcp_info_get** _ (для общей статистики TCP) и службой _ *_nx_tcp_socket_info_get_** (для статистики TCP каждого отдельного сокета).</span><span class="sxs-lookup"><span data-stu-id="427f9-1548">All these statistics and error reports are available to the application with the ***nx_tcp_info_get** _ service for total TCP statistics and the _ *_nx_tcp_socket_info_get_** service for TCP statistics per socket.</span></span>

### <a name="tcp-socket-control-block-nx_tcp_socket"></a><span data-ttu-id="427f9-1549">Блок управления сокетом TCP NX_TCP_SOCKET</span><span class="sxs-lookup"><span data-stu-id="427f9-1549">TCP Socket Control Block NX_TCP_SOCKET</span></span>      
<span data-ttu-id="427f9-1550">Характеристики каждого из сокетов TCP находятся в связанном блоке управления *NX_TCP_SOCKET*, который содержит полезную информацию, такую как ссылка на структуру данных IP, интерфейс сетевого подключения, связанный порт и очередь получения пакетов.</span><span class="sxs-lookup"><span data-stu-id="427f9-1550">The characteristics of each TCP socket are found in the associated *NX_TCP_SOCKET* control block, which contains useful information such as the link to the IP data structure, the network connection interface, the bound port, and the receive packet queue.</span></span> <span data-ttu-id="427f9-1551">Эта структура определена в файле ***nx_api.h***.</span><span class="sxs-lookup"><span data-stu-id="427f9-1551">This structure is defined in the ***nx_api.h*** file.</span></span>