---
title: Глава 3. Функциональное описание ОСРВ Azure NetX Secure
description: Эта глава содержит функциональное описание NetX Secure TLS.
author: philmea
ms.author: philmea
ms.date: 06/04/2020
ms.topic: article
ms.service: rtos
ms.openlocfilehash: c28ad0255f99986a4ddfe5faefad81e70840e5e0
ms.sourcegitcommit: e3d42e1f2920ec9cb002634b542bc20754f9544e
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/22/2021
ms.locfileid: "104814511"
---
# <a name="chapter-3---functional-description-of-azure-rtos-netx-secure"></a>Глава 3. Функциональное описание ОСРВ Azure NetX Secure

## <a name="execution-overview"></a>Общие сведения о выполнении

Эта глава содержит функциональное описание ОСРВ Azure NetX Secure TLS. В приложении NetX Secure TLS используются два основных типа выполнения программы: инициализация и вызовы интерфейса приложения. 

*NetX Secure предполагает наличие ThreadX и NetX или NetX Duo. Из ThreadX требуется выполнение потоков, приостановка, периодические таймеры и механизмы взаимного исключения. Из NetX или NetX Duo требуются механизмы сетевого взаимодействия и драйверы TCP/IP.*

## <a name="transport-layer-security-tls-and-secure-sockets-layer-ssl"></a>Протоколы TLS и SSL

Компонент защищенного сетевого протокола NetX Secure является реализацией протокола TLS, как описано в документах RFC 2246 (версия 1.0), 4346 (версия 1.1), 5246 (версия 1.2) и 8446 (версия 1.3). Также включены процедуры поддержки базовых сертификатов X.509 (RFC 5280).

NetX Secure TLS поддерживает протокол TLS версий 1.2 и 1.3. Предоставляются реализации и для устаревших протоколов TLS 1.0 и TLS 1.1, но их следует инициализировать явным образом и не рекомендуется использовать в новых продуктах.

*SSL* — это первоначальное название протокола TLS, использовавшееся до того, как он стал стандартом в RFC 2246, и название "SSL" часто используется в качестве универсального названия протоколов TLS. Последней версией SSL была версия 3.0, а протокол TLS 1.0 иногда называют протоколом SSL версии 3.1. Все версии официального протокола SSL считаются устаревшими и небезопасными, и в настоящее время NetX Secure не предоставляет реализацию SSL.

TLS задает протокол для создания *ключей сеанса*, которые создаются во время *подтверждения* TLS между клиентом и сервером TLS. Эти ключи используются для шифрования данных, отправляемых приложением во время *сеанса* TLS.

Данные TLS делятся на *записи*, которые концептуально аналогичны пакету TCP. Каждая запись TLS содержит заголовок, а зашифрованные записи TLS также содержат примечание (хэш контрольной суммы). Записи подтверждения TLS имеют дополнительный заголовок, инкапсулированный в запись TLS большего размера. Запись TLS инкапсулирована сетевым протоколом транспортного уровня аналогично тому, как пакет TCP инкапсулирован IP-пакетом.

### <a name="tls-13"></a>Протокол TLS 1.3

В августе 2018 года спецификация TLS 1.3 была завершена. Новая версия протокола претерпела довольно значительные изменения, которые затронули некоторые фундаментальные аспекты базовой безопасности и производительности TLS. Однако эти изменения в основном невидимы для обычного пользователя TLS, так как они относятся в первую очередь к конечному автомату подтверждения TLS и созданию ключей сеанса. Кроме того, был добавлен ряд дополнительных функций и расширений. Ниже приведена сводка внесенных изменений и их влияние на функциональные возможности TLS.

- Конечный автомат подтверждения был оптимизирован за счет удаления всего обмена сообщениями от сервера.
- Создание ключей было изменено для использования стандартизованной процедуры HKDF (функция формирования ключа на основе HMAC), и ключи сеанса привязываются ко всем сообщениям подтверждения (а не к некоторым выбранным параметрам).
- Все комплекты шифров TLS 1.2 и более ранних версий являются нерекомендуемыми и несовместимы с протоколом TLS 1.3. Аналогичным образом, все комплекты шифров TLS 1.3 не могут использоваться в предыдущих версиях протокола.
- Все комплекты шифров TLS 1.3 обеспечивают полную безопасность пересылки (PFS) с использованием временных ключей<sup>6</sup>. 
- Протокол TLS 1.3 удаляет "код проверки подлинности сообщения" (MAC) из каждой записи и использует шифры AEAD<sup>7</sup>.
- Были добавлены некоторые дополнительные функции, включая 0-RTT (нулевое время кругового пути), что позволяет отправлять данные приложений во время подтверждения. Функция 0-RTT является абсолютно необязательной и сейчас не поддерживается в TLS для ОСРВ Azure.

Протокол TLS 1.3 не оказывает существенного влияния на приложения пользователя. API остается одинаковым в разных версиях, а комплекты шифров помечаются так, чтобы можно было использовать одну таблицу комплектов шифров.

Для использования протокола TLS 1.3 макрос NX_SECURE_TLS_ENABLE_TLS_1_3 должен быть глобально определен. Протокол TLS 1.3 по умолчанию отключен в TLS для ОСРВ Azure.

6. "Временные" ключи — это пары асимметричных ключей, которые создаются во время подтверждения TLS и используются для обмена секретами только для этого сеанса. Пара ключей удаляется после использования. Это не позволит злоумышленнику получить доступ к зашифрованным данным в записанном сеансе TLS, даже если закрытый ключ сертификата будет скомпрометирован в будущем, что и обеспечивает полную безопасность пересылки.

7. Шифрование с проверкой подлинности с помощью связанных данных — это режим для таких шифров, как AES, который сочетает в одной операции шифрование и проверку целостности, устраняя необходимость в отдельном хэше данных для проверки целостности.

### <a name="tls-record-header"></a>Заголовок записи TLS

Любая допустимая запись TLS должна содержать заголовок TLS, как показано в разделе "Ошибка. Источник ссылки не найден".

![Схема заголовка записи TLS.](media/image2.png)

Рисунок 1. Заголовок записи TLS

Ниже приведены определения полей заголовка записи TLS.

| Поле заголовка TLS | Назначение     |
| ---------------- | ------------- |
| **8 разрядов: тип сообщения** | Это поле содержит тип отправляемой записи TLS. Допустимые типы:<br />- ChangeCipherSpec<sup>8</sup>: 0x14;<br />- оповещение: 0x15;<br />- подтверждение: 0x16;<br />- данные приложения: 0x17. |
| **16 разрядов: версия протокола** | Это поле содержит версию протокола TLS. Допустимы следующие значения:<br />- SSL 3.0: 0x0300;<br />- TLS 1.0: 0x0301;<br />- TLS 1.1: 0x0302;<br />- TLS 1.2: 0x0303;<br />- **TLS 1.3 <sup>9</sup>** : **0x0303**. |
| **16 разрядов: длина** | Это поле содержит длину данных, инкапсулированных в запись TLS. |

8. В протоколе TLS 1.3 сообщение ChangeCipherSpec больше не используется, хотя оно по-прежнему может быть отправлено для обеспечения совместимости, и в этом случае сообщение игнорируется.

9. Следуя этой схеме, формально протокол TLS 1.3 должен был бы использовать значение 0x0304. Но этот протокол был изменен так, чтобы в расширении использовалась фактическая версия протокола, поэтому все записи TLS 1.3 содержат 0x0303 в поле версии протокола для обеспечения обратной совместимости.

### <a name="tls-handshake-record-header"></a>Заголовок записи подтверждения TLS

Любая допустимая запись подтверждения TLS должна содержать заголовок подтверждения TLS, как показано на рисунке 2.

![Схема заголовка записи подтверждения TLS.](media/image3.png)

Рисунок 2. Заголовок записи подтверждения TLS

Ниже приведены определения полей заголовка записи подтверждения TLS.

| Поле заголовка TLS | Назначение |
| ---------------- |----------------------- |
| **8 разрядов: тип сообщения** | Это поле содержит тип отправляемой записи TLS. Допустимые типы:<br />- ChangeCipherSpec<sup>10</sup>: 0x14;<br />- Alert: 0x15;<br />- Handshake: 0x16;<br />- данные приложения: 0x17. |
| **16 разрядов: версия протокола** | Это поле содержит версию протокола TLS. Допустимы следующие значения:<br />- SSL 3.0: 0x0300;<br />- TLS 1.0: 0x0301;<br />- TLS 1.1: 0x0302;<br />- TLS 1.2: 0x0303;<br />- **TLS 1.3 <sup>11</sup>** : **0x0303**. |
| **16 разрядов: длина**    | Это поле содержит длину данных, инкапсулированных в запись TLS. |
| **8 разрядов: тип подтверждения** | Это поле содержит тип сообщения подтверждения. Допустимы следующие значения (* сообщения, **выделенные жирным шрифтом**, добавлены в протокол TLS 1.3):<br />- HelloRequest: 0x00;<br />- ClientHello: 0x01;<br />- ServerHello: 0x02;<br />- **HelloVerifyRequest**: **0x03**;<br />- **NewSessionTicket**: **0x04**;<br />- **EndOfEarlyData**: **0x05**;<br />- **EncryptedExtensions**: **0x08**;<br />- Certificate: 0x0B;<br />- ServerKeyExchange: 0x0C;<br />- CertificateRequest: 0x0D;<br />- ServerHelloDone: 0x0E;<br />- CertificateVerify: 0x0F;<br />- ClientKeyExchange: 0x10;<br />- Finished: 0x14;<br />- **KeyUpdate**: **0x18**;<br />- **MessageHash**: **0xFE**. |
| **24 разряда: длина**    | Это поле содержит длину данных сообщения подтверждения. |

10. В протоколе TLS 1.3 сообщение ChangeCipherSpec больше не используется, хотя оно по-прежнему может быть отправлено для обеспечения совместимости, и в этом случае сообщение игнорируется.

11. Следуя этой схеме, формально протокол TLS 1.3 должен был бы использовать значение 0x0304. Но этот протокол был изменен так, чтобы в расширении использовалась фактическая версия протокола, поэтому все записи TLS 1.3 содержат 0x0303 в поле версии протокола для обеспечения обратной совместимости.

### <a name="the-tls-handshake-and-tls-session"></a>Подтверждение TLS и сеанс TLS

Типичное подтверждение TLS (версий 1.0–1.2) показано на рисунке 3. Подтверждение TLS начинается, когда клиент TLS отправляет сообщение *ClientHello* на сервер TLS, указывая необходимость начать сеанс TLS. Это сообщение содержит сведения о шифровании, которое клиент предпочитает использовать для сеанса, а также данные, используемые для создания ключей сеанса позже при подтверждении. Пока не созданы ключи сеанса, все сообщения в подтверждении TLS не шифруются. В протоколе TLS 1.3 подтверждение несколько изменено. Дополнительные сведения об этом представлены в следующем разделе.

Сервер TLS отвечает на ClientHello с сообщением ServerHello, указывающим на выбор варианта шифрования, предоставленного клиентом. За сообщением ServerHello следует сообщение Certificate, в котором сервер предоставляет цифровой сертификат для проверки подлинности клиента. Наконец, сервер отправляет сообщение ServerHelloDone, указывающее, что отправлены все сообщения. Сервер может дополнительно отправлять и другие сообщения после сообщения ServerHello, а в некоторых случаях он может не отправлять сообщение Certificate, поэтому потребуется сообщение ServerHelloDone.

После того как клиент получит все сообщения сервера, у него будет достаточно сведений для создания ключей сеанса. Для этого протокол TLS создает общий фрагмент случайных данных, называемый *предварительной главной копией секрета*, который имеет фиксированный размер и используется в качестве начального значения для создания всех необходимых ключей после включения шифрования. Предварительная главная копия секрета шифруется с помощью алгоритма с открытым ключом (например, RSA), указанного в сообщениях Hello (дополнительные сведения об алгоритмах с открытым ключом см. ниже), и открытого ключа, предоставленного сервером в его сертификате. Необязательная функция TLS, называемая общими ключами (PSK), включает в себя комплекты шифров, которые не используют сертификат, а вместо этого используют значение секрета, которое передается между узлами (как правило, путем физического перемещения или другого безопасного метода). Предварительная главная копия секрета создается с помощью общего секрета, а не передается в зашифрованном сообщении. Ознакомьтесь с разделом, посвященным общим ключам, ниже.

Зашифрованная предварительная главная копия секрета передается на сервер в сообщении ClientKeyExchange. При получении сообщения ClientKeyExchange сервер расшифровывает предварительную главную копию секрета с помощью своего закрытого ключа и продолжает создавать ключи сеанса одновременно с клиентом TLS.

После создания ключей сеанса все последующие сообщения могут быть зашифрованы с помощью алгоритма с закрытым ключом (например, AES), выбранного в сообщениях Hello. Одно завершающее незашифрованное сообщение, именуемое ChangeCipherSpec, отправляет как клиент, так и сервер, чтобы указать, что все последующие сообщения будут зашифрованы.

Первое зашифрованное сообщение, отправленное и клиентом, и сервером, также является завершающим сообщением подтверждения TLS, именуемым Finished. Это сообщение содержит хэш всех полученных и отправленных сообщений подтверждения. Этот хэш используется, чтобы проверить, что ни одно из сообщений в подтверждении не было изменено или повреждено (что может указывать на нарушение безопасности).

После получения сообщений Finished и проверки хэшей подтверждения начинается сеанс TLS. Приложение начинает отправку и получение данных. Все данные, отправляемые любой из сторон во время сеанса TLS, сначала хэшируются с помощью хэш-алгоритма, выбранного в сообщениях Hello (для обеспечения целостности сообщений), и шифруются с помощью выбранного алгоритма с закрытым ключом и созданных ключей сеанса.

Наконец, сеанс TLS может быть успешно завершен только в том случае, если это действие выбрал клиент или сервер. Усеченный сеанс считается нарушением безопасности, так как злоумышленник может попытаться предотвратить получение всех данных. Поэтому, когда одна из сторон желает завершить сеанс, передается специальное уведомление, которое называется оповещением CloseNotify. Как клиент, так и сервер должны отправить и обработать оповещение CloseNotify, чтобы успешно завершить сеанс.

![Схема типичного подтверждения TLS.](media/image4.png)

Рисунок 3. Типичное подтверждение TLS

### <a name="tls-13-handshake"></a>Подтверждение TLS 1.3

Протокол TLS 1.3 достаточно радикально изменен по сравнению с протоколом TLS. Большинство изменений было внесено в процесс подтверждения, чтобы повысить безопасность и производительность. Типичное подтверждение TLS 1.3 показано на рисунке 4. Основное различие можно увидеть в количестве обменов данными между сервером и клиентом.

В протоколе TLS 1.2 и более ранних версиях сервер отправлял две серии сообщений<sup>12</sup> — сначала сообщение ServerHello, а затем сообщение ChangeCipherSpec, после чего отправлял зашифрованное сообщение Finished, завершающее подтверждение. В протоколе TLS 1.3 сервер отправляет все в первой серии — сообщение ServerHello, расширения, сертификат и сообщение Finished. Сообщение ChangeCipherSpec было удалено, и сервер создает ключи сеанса и начинает шифровать сообщения подтверждения сразу после сообщения ServerHello.

Новая схема означает, что большая часть подтверждения TLS защищена шифрованием. Это ограничивает объем данных в виде открытого текста, к которым злоумышленник может получить доступ. Кроме того, удаление второй серии сообщений сервера (это были просто сообщение ChangeCipherSpec и следующее за ним сообщение Finished) означает, что клиенту TLS больше не требуется ожидать передачи данных приложения. Как только клиент отправит собственное сообщение Finished, начнется сеанс.

12. Серия — это просто набор сообщений TLS, отправляемых одновременно.

![Схема подтверждения TLS 1.3.](media/image5.png)

Рисунок 4. Подтверждение TLS 1.3

> [!NOTE]
> *В протоколе TLS 1.3 также введено понятие "ранние данные" и 0-RTT (нулевое время кругового пути). Это означает, что некоторые данные приложения могут быть отправлены в первой серии сообщений. Эта необязательная функция была добавлена в первую очередь для того, чтобы оптимизировать время отклика веб-браузера (например, чтобы предварительно отправить заголовки HTTP для начала визуализации страницы). Начиная с ОСРВ Azure 6.0 эта функция не поддерживается.*

### <a name="initialization"></a>Инициализация

Прежде чем использовать NetX Secure TLS, необходимо инициализировать стек NetX TCP/IP или NetX Duo TCP/IP. Сведения о том, как правильно инициализировать стек TCP/IP, см. в руководстве пользователя NetX или NetX Duo.

После инициализации стека TCP/IP NetX можно включить протокол TLS. На внутреннем уровне передача всего сетевого трафика и обработка TLS выполняется стеком NetX или NetX Duo без необходимости вмешательства пользователя. Однако протокол TLS накладывает определенные требования, которые должны выполняться отдельно от базового сетевого стека. Эти параметры назначаются блоку управления TLS ***NX_SECURE_TLS_SESSION** _ с помощью службы _ *_nx_secure_tls_session_create_**.

Протокол TLS имеет два режима: сервер и клиент, один из которых может быть включен в приложении (но только один режим на сокет NetX). Каждый из режимов имеет собственные требования. Они описаны ниже.

В любом режиме для NetX Secure TLS требуется, чтобы сокет TCP (***NX_TCP_SOCKET** _) был создан и настроен для связи по протоколу TCP с удаленным узлом. Сокет TCP назначается экземпляру сеанса TLS с помощью службы _ *_nx_secure_tls_session_start_**, как описано ниже.

### <a name="initialization--tls-server"></a>Инициализация — сервер TLS

Помимо сокета TCP для режима сервера NetX Secure TLS требуется *цифровой сертификат*— документ, используемый для идентификации сервера TLS для подключающегося клиента TLS, а также сертификаты, соответствующие *закрытому ключу* (обычно для алгоритма шифрования RSA). Стандарт X.509 Международного союза электросвязи определяет формат сертификата, используемого протоколом TLS, и существует множество служебных программ для создания цифровых сертификатов X.509.

Для NetX Secure TLS сертификат X.509 должен быть зашифрован в двоичном формате Distinguished Encoding Rules (DER) ASN.1. DER — это стандартный сетевой двоичный формат TLS для сертификатов.

Закрытый ключ, связанный с предоставленным сертификатом, должен быть зашифрован в формате DER с открытым ключом (PKCS) № 1. Закрытый ключ используется только на устройстве и никогда не передается по сети. Обеспечьте безопасность закрытых ключей, так как они обеспечивают защиту при обмене данными по протоколу TLS.

Чтобы инициализировать сертификат сервера TLS, приложение должно предоставить указатель на буфер, содержащий сертификат X.509, зашифрованный в формате DER, и (необязательно) данные закрытого ключа RSA, зашифрованные в формате DER с открытым ключом (PKCS) № 1, с помощью службы ***nx_secure_x509_certificate_intialize** _, которая заполняет структуру _ *NX_SECURE_X509_CERT** соответствующими данными сертификата для протокола TLS.

После инициализации сертификата сервера его необходимо добавить в блок управления TLS с помощью службы ***nx_secure_tls_local_certificate_add***.

После добавления сертификата сервера в блок управления TLS можно использовать сокет, чтобы установить безопасное подключение к серверу TLS.

### <a name="initialization--tls-client"></a>Инициализация — клиент TLS

Для режима клиента NetX Secure TLS требуется *хранилище доверенных сертификатов*, которое представляет собой коллекцию цифровых сертификатов в кодировке X.509 из доверенных центров сертификации (ЦС). Предполагается, что эти сертификаты являются доверенными для протокола TLS. Они служат базой для проверки подлинности сертификатов, предоставляемых сущностями сервера TLS клиенту NetX Secure TLS.

Сертификат доверенного ЦС может быть либо *самозаверяющим*, либо подписанным другим центром сертификации. В последнем случае сертификат называется сертификатом *промежуточного ЦС* (ICA). В типичном приложении TLS сервер предоставляет сертификаты ICA вместе с сертификатом сервера, но единственным требованием для успешной проверки подлинности является то, что цепочка издателей (сертификатов, используемых для подписи других сертификатов) должна отслеживаться от сертификата сервера до сертификата доверенного ЦС в хранилище доверенных сертификатов. Эта цепочка называется  *цепочкой доверия* или *цепочкой сертификатов*.

Чтобы инициализировать сертификат доверенного ЦС или сертификат ICA, приложение должно предоставить указатель на буфер, содержащий сертификат X.509, зашифрованный в формате DER, с помощью службы ***nx_secure_x509_certificate_intialize** _, которая заполняет структуру _ *NX_SECURE_X509_CERT** соответствующими данными сертификата для протокола TLS.

После этого все доверенные сертификаты, которые были инициализированы, добавляются в блок управления TLS с помощью службы ***nx_secure_tls_trusted_certificate_add***. Сбой при добавлении сертификата приведет к сбою сеанса клиента TLS, так как протокол TLS не сможет проверить подлинность удаленных узлов сервера TLS.

Клиенту TLS также требуется выделить место для хранения входящего сертификата сервера (при условии, что не используется режим общего ключа). Начиная с NetX Secure TLS 5.12 больше не требуется, чтобы приложение выделяло место для хранения удаленного сертификата. Однако устаревший параметр для выделения места для сертификата сервера по-прежнему доступен, а сертификаты, выделенные пользователем, будут использоваться до оптимизации внутреннего буфера сертификатов <sup>13</sup> (дополнительные сведения см. в описании службы ***nx_secure_tls_remote_certificate_allocate***).

После создания хранилища доверенных сертификатов и выделения пространства для сертификата сервера можно использовать сокет для установления безопасного подключения к клиенту TLS.

13. Для оптимизации используется "буфер пакетов", предоставляемый приложением пользователя сеансу TLS с помощью службы *nx_secure_tls_session_packet_buffer_set*. Он позволяет выделить структуры анализа X.509 вместо использования предоставленных пользователем структур, используемых в более ранних версиях NetX Secure TLS. Существует небольшая вероятность, что размер цепочки сертификатов превысит размер буфера пакетов. В этом случае можно увеличить размер буфера пакетов или использовать службу *nx_secure_tls _remote_certificate_allocate*, чтобы выделить больше пространства для цепочки сертификатов.

### <a name="application-interface-calls"></a>Вызовы интерфейса приложения

Приложения NetX Secure TLS обычно будут выполнять вызовы функций из потоков приложения, работающих в ОСРВ ThreadX. В некоторых случаях инициализация, особенно для базовых протоколов сетевого взаимодействия (например, TCP и IP), может быть вызвана из ***tx_application_define*** . Дополнительные сведения об инициализации сетевого взаимодействия см. в руководстве пользователя NetX или NetX Duo.

Протокол TLS активно использует процедуры шифрования, которые являются ресурсоемкими операциями. Как правило, эти операции будут выполняться в контексте вызывающего потока.

### <a name="tls-session-start"></a>Начало сеанса TLS

Для работы протокола TLS требуется базовый сетевой протокол транспортного уровня. Обычно используется протокол TCP. Чтобы установить сеанс NetX Secure TLS, необходимо установить TCP-подключение с помощью API NetX TCP или NetX Duo TCP. Необходимо создать сокет **NX_TCP_SOCKET** и установить подключение с помощью служб **_nx_tcp_server_socket_listen_ *_ и _* _nx_tcp_server_socket_accept_ *_ (для сервера TLS) или службы _* _nx_tcp_client_socket_connect_** (для клиента TLS).

После установления TCP-подключения сокет TCP передается в службу ***nx_secure_tls_session_start***.

### <a name="tls-packet-allocation"></a>Выделение пакетов TLS

NetX Secure TLS использует ту же структуру пакетов, что и NetX TCP или NetX Duo TCP (***NX_PACKET** _), за исключением того, что вместо службы _*_nx_packet_allocate_*_ необходимо вызвать службу _ *_nx_secure_tls_packet_allocate_**, чтобы правильно выделить пространство для заголовка TLS.

### <a name="tls-session-send"></a>Отправка данных в сеансе TLS

После начала сеанса TLS приложение может отправить данные с помощью службы ***nx_secure_tls_session_send** _. Служба отправки работает аналогично службе _*_nx_tcp_socket_send_*_. Она принимает структуру данных _*_NX_PACKET_*_, содержащую отправляемые данные. Только эти данные будут зашифрованы стеком NX Secure TLS перед отправкой, а пакет должен быть выделен с помощью _*_nx_secure_tls_packet_allocate_**.

### <a name="tls-session-receive"></a>Получение данных в сеансе TLS

После начала сеанса TLS приложение может начать получение данных с помощью службы ***nx_secure_tls_session_send** _. Как и в случае отправки данных в сеансе TLS, эта служба работает аналогично службе _*_nx_tcp_socket_receive_**, за исключением того, что входящие данные расшифровываются и проверяются стеком TLS перед возвращением в структуру пакета.

### <a name="tls-session-close"></a>Закрытие сеанса TLS

По завершении сеанса TLS и клиент TLS, и сервер TLS должны отправить оповещение CloseNotify другой стороне, чтобы окончательно завершить сеанс. Обе стороны должны получить и обработать это оповещение, чтобы успешно завершить сеанс.

Если удаленный узел отправляет оповещение CloseNotify, все вызовы службы ***nx_secure_tls_session_receive** _ обрабатывают его, отправляют соответствующее оповещение обратно на удаленный узел и возвращают значение _*_NX_SECURE_TLS_SESSION_CLOSED_**. После закрытия сеанса дальнейшие попытки отправить или получить данные в этом сеансе TLS завершатся ошибкой.

Если приложению нужно закрыть сеанс TLS, необходимо вызвать службу ***nx_secure_tls_session_end** _. Эта служба отправит оповещение CloseNotify и обработает ответное оповещение CloseNotify. Если ответ не получен, будет возвращено значение ошибки _ *_NX_SECURE_TLS_SESSION_CLOSE_FAIL_**, указывающее на то, что сеанс TLS не был корректно завершен, возможно из-за нарушения безопасности.

### <a name="tls-alerts"></a>Оповещения TLS

Протокол TLS предназначен для обеспечения максимальной безопасности, поэтому любое аномальное поведение в протоколе считается потенциальным нарушением безопасности. По этой причине все ошибки, возникающие при обработке, шифровании или расшифровке сообщений, считаются неустранимыми ошибками, которые немедленно завершают подтверждение или сеанс.

Хотя обработка ошибок в локальном приложении относительно проста, удаленный узел должен быть уведомлен о том, что произошла ошибка, чтобы правильно обработать ситуацию и предотвратить возможные дальнейшие нарушения безопасности. По этой причине при любой ошибке протокол TLS отправляет сообщение *Alert* на удаленный узел.

Сообщения Alert обрабатываются так же, как и любые другие сообщения TLS, и шифруются во время сеанса, чтобы предотвратить сбор информации злоумышленником из указанного типа оповещения. Во время подтверждения отправляются ограниченные оповещения, чтобы уменьшить объем сведений, которые могут быть получены потенциальным злоумышленником.

Оповещение CloseNotify, используемое для закрытия сеанса TLS, является единственным оповещением не об неустранимом сбое. Хотя оно считается оповещением и отправляется в виде сообщения Alert, отличие CloseNotify от других оповещений состоит в том, что оно не указывает на ошибку.

Значение и "уровень" ("предупреждение" и "неустранимая ошибка"; большинство оповещений TLS имеют уровень "неустранимая ошибка") оповещения определяются в документах RFC по протоколу TLS и указывают тип возникшей ошибки. Большинство оповещений TLS, отличных от CloseNotify, могут рассматриваться как потенциальные проблемы безопасности, что приведет к прерыванию сеанса или подтверждения TLS. Если какой-либо вызов API TLS возвращает **NX_SECURE_TLS_ALERT_RECEIVED** (0x114), то можно использовать службу API **_nx_secure_tls_session_alert_value_get_** (введенную в NetX Secure TLS версии 5.12), чтобы получить значение и уровень оповещения TLS для приложения. Это позволит приложению принимать решения о том, как реагировать на проблемы безопасности. В большинстве случаев любое оповещение, полученное от удаленного узла, отличное от CloseNotify, должно считаться неустранимой ошибкой, хотя есть некоторые исключения (дополнительные сведения см. в документах RFC по протоколу TLS).

### <a name="tls-session-renegotiation"></a>Повторное согласование сеанса TLS

Протокол TLS поддерживает понятие "повторное согласование", которое представляет собой просто согласование параметров сеанса TLS в контексте существующего сеанса TLS. На практике это означает, что новые сообщения подтверждения шифруются и проходят проверку подлинности с помощью существующего сеанса. Повторное согласование используется, когда узлу TLS требуется создать новые параметры сеанса (например, создать новые ключи сеанса TLS) без завершения существующего сеанса. Например, повторное согласование может быть желательным, если политики безопасности для приложения предписывают, что ключи сеанса должны использоваться только в течение ограниченного времени, а сеанс TLS остается активным дольше.

Одна из проблем с повторным согласованием сеанса заключается в том, что протокол TLS уязвим для определенной атаки "злоумышленник в середине", когда злоумышленник может вынудить сервер инициировать повторное согласование с новыми параметрами, позволяя злоумышленнику перехватить сеанс TLS. Чтобы устранить эту ошибку, было введено расширение для указания безопасного повторного согласования (см. раздел **Ошибка. Источник ссылки не найден** .

NetX Secure TLS полностью поддерживает повторное согласование сеанса и расширение для указания безопасного повторного согласования.

При получении данных с удаленного узла повторные согласования (и расширение) обрабатываются автоматически, без взаимодействия с приложением. Если требуется уведомление о повторном согласовании сеансов, можно передать обратный вызов повторного согласования с помощью службы *nx_secure_tls_session_renegotiate_callback_set*. Обратный вызов будет осуществляться всякий раз, когда удаленный узел будет запрашивать повторное согласование, что позволит приложению принять необходимые меры.

Чтобы инициировать повторное согласование из активного сеанса TLS, просто запустите службу *nx_secure_tls_session_renegotiate* в соответствующем сеансе TLS.

### <a name="tls-session-resumption"></a>Возобновление сеанса TLS

Возобновление сеанса TLS не следует путать с повторным согласованием сеанса, несмотря на некоторое сходство. *Повторное согласование* сеанса включает в себя запуск нового подтверждения в существующем сеансе TLS, тогда как *возобновление* сеанса является необязательной функцией, включающей в себя перезапуск сеанса TLS без полного подтверждения TLS. Для этого реализация TLS может кэшировать параметры сеанса и ключи, связав их с *идентификатором сеанса*, уникальным идентификатором, полученным при первоначальном подтверждении. Предоставляя идентификатор сеанса серверу TLS, клиент указывает, что предыдущий сеанс TLS между узлами существовал и был завершен какое-то время назад и что клиент по-прежнему владеет состоянием для повторного создания сеанса с сокращенным подтверждением. Так как ключи сеанса теоретически по-прежнему являются секретными и известны только двум взаимодействующим узлам, сервер может запустить новый сеанс TLS и пропустить большую часть обычного подтверждения.

Возобновление сеанса может быть удобно для того, чтобы избежать потенциально ресурсоемких операций с открытым ключом, которые выполняются для отправки главной копии секрета после создания ключей и проверки подписей сертификатов. Однако для этого также требуется, чтобы параметры сеанса, ключи и состояние шифрования были сохранены в памяти для всех возможных сеансов (по крайней мере в течение настраиваемого периода времени).

Текущая версия NetX Secure TLS не поддерживает возобновление сеанса — идентификатор сеанса просто игнорируется серверами TLS, а клиенты TLS всегда предоставляют идентификатор сеанса NULL, который предлагает серверу выполнить полное подтверждение. Отсутствие возобновления сеанса не должно вызывать проблем со взаимодействием, так как это абсолютно необязательная функция, и все реализации TLS должны по умолчанию использовать полное подтверждение, если идентификатор сеанса имеет значение NULL или не распознан.

### <a name="protocol-layering"></a>Уровень протокола

Протокол TLS соответствует сетевому стеку между транспортным уровнем (например, TCP) и прикладным уровнем. Протокол TLS иногда относят к протоколам транспортного уровня (отсюда и его название — TLS, *Transport Layer* Security (безопасность транспортного уровня)), но так как он действует как приложение по отношению к базовым сетевым протоколам (например, TCP), иногда его относят к прикладному уровню.

Для протокола TLS требуется протокол транспортного уровня, поддерживающий доставку по порядку и без потерь, например протокол TCP. В соответствии с этим требованием протокол TLS не может выполняться на основе протокола UDP, так как UDP не гарантирует доставку датаграмм. Для приложений, которым требуется безопасность TLS по протоколу передачи датаграмм, например UDP, используется отдельный протокол *DTLS*, который является модифицированной версией протокола TLS. NetX Secure поддерживает протокол DTLS, но описание DTLS приведено в отдельном документе.

![Схема уровней протоколов TCP/IP и TLS.](media/image6.png)

Рисунок 5. Уровни протоколов TCP/IP и TLS

## <a name="network-communications-security"></a>Безопасность сетевого взаимодействия

Обеспечение безопасности взаимодействия через общедоступные сети и Интернет является важнейшей темой, которой посвящено огромное количество книг, статей и решений. Эта тема является немыслимо сложной, но ее можно упростить до следующей идеи: нужно отправлять информацию по сети так, чтобы только указанный адресат мог получить доступ к этой информации или изменить ее. Эта идея порождает три важных понятия: секретность, целостность и проверка подлинности. Протокол TLS предоставляет решения для всех этих трех понятий.

### <a name="secrecy"></a>Секретность

При отправке данных по сети часто важно, чтобы они не были получены вредоносной сущностью. Если данные отправляются через подключение по протоколу TCP/IP, любой пользователь, имеющий доступ к сети, сможет считать эти данные с помощью легко доступных сетевых средств. Чтобы предотвратить несанкционированное получение этих данных, их необходимо зашифровать таким образом, чтобы их мог прочитать только указанный адресат — это и есть *секретность*. Алгоритмы шифрования, такие как RSA и AES, в протоколе TLS обеспечивают секретность.

### <a name="integrity"></a>Целостность

Иногда одной секретности недостаточно, чтобы защитить данные, передаваемые по сети. В некоторых случаях вредоносная сущность может изменять содержимое пакета TCP, даже не зная, что он содержит. Зашифрованные данные могут быть изменены, что приведет к ошибке расшифровки или изменению параметров сообщения, что может быть как раз тем результатом, которого добивался злоумышленник. При передаче в сети мы не можем предотвратить изменение данных злоумышленником, но мы можем предоставить механизм, позволяющий определить, были ли данные изменены. Если данные были изменены во время передачи, об этом станет известно, и они могут быть отклонены. Это и есть понятие *целостности*. В протоколе TLS целостность обеспечивает класс криптографических процедур, называемых *хэш-функциями*. Примерами хэш-функций являются MD5 и SHA-1.

### <a name="authentication"></a>Проверка подлинности

Третьим важным понятием в безопасности сетевого взаимодействия является идея о том, что данные должны быть переданы только указанному адресату. Злоумышленник может попытаться предоставить допустимую сущность для получения данных, предназначенных для другого узла. Даже если данные отправляются с помощью механизмов обеспечения секретности и целостности, злоумышленник все равно может добиться желаемого (скомпрометировать безопасное взаимодействие) благодаря этому обману. Чтобы избежать этого, перед отправкой конфиденциальных данных требуется использовать механизм для подтверждения подлинности удаленного узла. Процесс подтверждения подлинности удаленного узла — это и есть *проверка подлинности*. В протоколе TLS проверка подлинности обеспечивается с помощью цифровых сертификатов, хэш-функций и механизма, называемого *цифровыми подписями*, который использует свойство шифрования с открытым ключом (описывается ниже). Ограниченная, но полезная разновидность проверки подлинности также может быть реализована с помощью *общего ключа* (PSK).

## <a name="tls-encryption"></a>Шифрование TLS

Протокол TLS — это платформа для обеспечения безопасного сетевого взаимодействия через Интернет с использованием шифрования. Шифрование обычно определяется как процесс кодирования данных таким образом, чтобы было чрезвычайно сложно получить исходные данные (или сведения об этих данных) без *ключа*. В компьютерных системах шифрование основано на сложной математике (например, на конечных полях) и может быть разделено на два типа: *с закрытым ключом* (*симметричное шифрование*) и *с открытым ключом* (*асимметричное шифрование*). Примеры шифрования с закрытым ключом: AES (Advanced Encryption Standard) и RC4 (Rivest Cipher 4). Примеры шифрования с открытым ключом: RSA (Rivest, Shamir, Adleson) и шифры Диффи-Хелмана.

Протокол TLS использует процедуры шифрования как с закрытым, так и с открытым ключом,чтобы обеспечить баланс производительности, безопасности и гибкости.

### <a name="private-key-encryption"></a>Шифрование с закрытым ключом

Шифрование с закрытым ключом используется уже тысячи лет. Простые шифры подстановки (в которых буква или слово заменяется другой несвязанной буквой или словом) являются наиболее ранними известными примерами шифрования, но с приходом эпохи информации шифрование с закрытым ключом было значительно улучшено.

В шифре с закрытым ключом используется "ключ", который представляет собой просто значение (в общем случае это может быть слово, фраза или число), которое используется для кодирования некоторых данных, чтобы только сущность, имеющая доступ к этому ключу, могла декодировать данные в осмысленную информацию. Ключ используется как для шифрования, так и для расшифровки данных, поэтому этот процесс также называется *симметричным шифрованием*.

Как правило, шифры с закрытым ключом быстро и просто реализовать, даже если в них используются чрезвычайно сложные математические расчеты. По этой причине в протоколе TLS для множества безопасных подключений используются шифры с закрытым ключом.

Однако у шифрования с закрытым ключом возникает недостаток, когда речь заходит о взаимодействии через общие компьютерные сети: ключ нужно передавать между компьютерами, пытающимися обмениваться данными. В общем случае нецелесообразно и часто невозможно безопасно передать закрытый ключ между двумя компьютерами в Интернете, так как предполагается, что сетевой трафик может быть получен любым количеством сущностей на разных прыжках, проходимых данными при передаче через Интернет. Если ключ получен вредоносной сущностью, все данные, зашифрованные с помощью этого ключа, являются скомпрометированными. Так как большинство компьютеров в Интернете имеют только сетевое подключение без дополнительного безопасного канала для обмена данными, отправка ключей по сети равноценна отправке данных без шифрования — они не обеспечивают безопасность.

По этой причине шифрования с закрытым ключом недостаточно для реализации протокола безопасности сетевого взаимодействия общего назначения. И нам может помочь шифрование с открытым ключом.

NetX Secure TLS поддерживает шифрование с закрытым ключом AES.

### <a name="public-key-encryption"></a>Шифрование с открытым ключом

В отличие от шифрования с закрытым ключом, шифрование с открытым ключом — это довольно новая концепция, разработанная в 1970-х годах. С помощью понятия "функции с секретными параметрами" из математики было обнаружено, что существовал способ передать ключ по сети, не нарушая безопасность зашифрованных данных.

Принцип шифрования с открытым ключом состоит в том, что ключ (согласно описанному выше шифрованию с закрытым ключом) разбивается на две части — *закрытый ключ* и *открытый ключ*, что и дало название этому виду шифрования. Принцип состоит в том, что один из этих ключей (как правило, открытый ключ) используется для шифрования, а другой используется для расшифровки. Эта асимметрия ключей породила еще одно название шифрования с открытым ключом: *асимметричное шифрование*.

Математические вычисления при шифровании с открытым ключом довольно сложны, но идея заключается в том, что открытый ключ можно использовать *только* для шифрования, а получение этого ключа не позволяет получить зашифрованные данные. Закрытый ключ, в свою очередь, является единственным средством для расшифровки данных, зашифрованных с помощью открытого ключа. Таким образом, если закрытый ключ не скомпрометирован, любая сущность, желающая безопасно взаимодействовать с владельцем этого закрытого ключа, должна просто зашифровать свои данные с помощью соответствующего открытого ключа, зная, что только владелец закрытого ключа сможет получить защищенные данные.

NetX Secure TLS поддерживает шифрование с открытым ключом RSA.

> [!IMPORTANT] 
> *Алгоритмы RSA являются очень ресурсоемкими операциями, если используется программная реализация RSA. При увеличении размера ключей требуемая вычислительная мощность возрастает в квадратном соотношении. Это значит, что при увеличении размера ключа в 2 раза расшифровка замедлится в 4 раза.*

### <a name="public-key-authentication"></a>Проверка подлинности с открытым ключом

Интересный побочный результат принципа шифрования с открытым ключом заключается в том, что его можно использовать как для шифрования, так и для проверки подлинности, выполняя обратную операцию: шифрование с помощью *закрытого* ключа и расшифровку с помощью *открытого* ключа. Фактический механизм этого процесса зависит от используемого алгоритма с открытым ключом, но принцип одинаков.

Для проверки подлинности с помощью открытого ключа владелец закрытого ключа шифрует некоторый фрагмент данных (обычно это криптографический хэш данных, подлинность которых следует проверить) с помощью этого закрытого ключа. Затем кто-то, желающий убедиться, что данные получены от владельца закрытого ключа, использует связанный открытый ключ для их расшифровки. Если расшифровка прошла успешно и предполагается, что пользователь уверен в действительности этого открытого ключа, он может быть уверен, что данные поступили от владельца закрытого ключа.

В протоколе TLS проверка подлинности с открытым ключом используется для проверки действительности цифрового сертификата, предоставленного сервером TLS (и, при необходимости, клиентом TLS), с помощью открытых ключей из хранилища доверенных сертификатов. Сертификат проверяется по открытому ключу в хранилище, а данные в сертификате используются для проверки подлинности сервера.

NetX Secure TLS поддерживает проверку подлинности RSA.

### <a name="cryptographic-hashing"></a>Криптографическое хэширование

Шифрование — не единственная криптографическая операция, используемая в протоколе TLS. Чтобы обеспечить целостность сообщений во время сеанса TLS, необходимо вычислять контрольную сумму. Это позволит убедиться, что содержимое сообщения не было изменено. Однако простого вычисления контрольной суммы (как в протоколе TCP) недостаточно, чтобы обеспечить приемлемый уровень целостности, так как осведомленный злоумышленник может легко ее саботировать. Механизм, используемый протоколом TLS для обеспечения целостности сообщений, называется *криптографическим хэшем*.

Шифрование — это кодирование 1:1, то есть из зашифрованных данных могут быть получены все исходные данные. Однако хэш позволяет сопоставить произвольный объем данных со значением фиксированного размера, как и контрольная сумма. В отличие от простой контрольной суммы, хэш специально разработан для уменьшения числа *конфликтов*, в результате которых разные входные данные могут формировать одинаковые выходные данные. Если в простой контрольной сумме один бит будет обращен из 1 в 0, а другой — из 0 в 1, то эта контрольная сумма не изменится. При использовании криптографического хэша выходные данные будут значительно отличаться, что затруднит для злоумышленника изменение хэшированных данных и получение такого же результата операции хэширования с измененными данными (то есть фальшивую проверку целостности этих данных).

В протоколе TLS используется несколько различных алгоритмов хэширования для обеспечения целостности сообщений — как сообщений приложений, так и управляющих сообщений TLS. К ним относятся алгоритмы MD5, SHA-1 и SHA-256.

NetX Secure TLS поддерживает алгоритмы хэширования MD5, SHA-1 и SHA-256.

## <a name="tls-extensions"></a>Расширения TLS

Протокол TLS предоставляет ряд расширений, которые обеспечивают дополнительные функциональные возможности для определенных приложений. Эти расширения обычно передаются как часть сообщений ClientHello или ServerHello, указывая удаленному узлу намерение использовать расширение или предоставляя дополнительные сведения для установления безопасного сеанса TLS.

В общем случае в начале подтверждения расширения предоставляют дополнительные параметры для протокола TLS, которые помогают выполнять последующие операции. Для некоторых расширений требуется ввод данных или принятие решения приложением, в то время как другие обрабатываются автоматически.

В следующей таблице описаны расширения TLS, которые в настоящее время поддерживаются в NetX Secure TLS.

| **Extension Name**              | **Описание**              |
| ------------------------------- |----------------------------- |
| Указание безопасного повторного согласования | Это расширение устраняет уязвимость к атаке "злоумышленник в середине", которая может возникнуть во время подтверждения повторного согласования.|
| Указание имени сервера          | Это расширение позволяет клиенту TLS предоставить конкретное DNS-имя серверу TLS, давая серверу возможность выбрать правильные учетные данные (предполагается, что сервер имеет несколько удостоверяющих сертификатов и сетевых точек входа). |
| Алгоритмы сигнатуры            | Это расширение позволяет клиенту TLS предоставить список допустимых алгоритмов сигнатуры и хэширования для сервера TLS. |

Общие сведения о поддерживаемых расширениях TLS

### <a name="secure-renegotiation-indication"></a>Указание безопасного повторного согласования

Протокол TLS поддерживает выполнение подтверждения в существующем сеансе TLS, используя при этом установленный сеанс для шифрования сообщений подтверждения. Этот процесс позволяет повторно установить ключи сеанса шифрования без завершения сеанса TLS (см. раздел "Повторное согласование сеанса TLS").

К сожалению, после того как в течение некоторого времени в протоколе TLS использовалось повторное согласование, была обнаружена уязвимость к атаке "злоумышленник в середине", использующей функцию повторного согласования. Чтобы устранить эту уязвимость, было введено расширение для указания безопасного повторного согласования. По сути, расширение для безопасного повторного согласования использует хэш сообщения Finished из установленного подключения, чтобы убедиться в том, что в подтверждении повторного согласования участвуют исходные узлы. Фактически, хэш используется в качестве маркера проверки, исходя из предположения, что злоумышленник не сможет подделать хэш (что потребует доступа к ключам сеанса).

NetX Secure TLS автоматически обрабатывает повторное согласование и по умолчанию использует расширение для безопасного повторного согласования. Взаимодействие с приложением не требуется.

### <a name="server-name-indication"></a>Указание имени сервера

Во время подтверждения TLS клиент TLS должен предоставить удаленному серверу удостоверяющий сертификат, чтобы проверить подлинность этого сервера. Однако могут возникнуть ситуации, когда сервер предоставит несколько различных служб с разными "виртуальными" серверами, у каждого из которых есть уникальное удостоверение. В случае одного сервера с несколькими удостоверениями клиент TLS может предоставить определенное DNS-имя, которое будет использоваться сервером для выбора правильных учетных данных. Механизм для предоставления этого имени — это расширение для указания имени сервера (SNI).

От приложения, использующего расширение SNI, требуется определенное взаимодействие. Приложение должно предоставить клиентам TLS DNS-имя, отправляемое на удаленный сервер. Для серверов TLS приложение должно прочитать DNS-имя из расширения и выбрать соответствующий сертификат, чтобы отправить его клиенту.

Следующие разделы содержат более подробные сведения об использовании расширения SNI в NetX Secure TLS.

### <a name="sni-extension--tls-client"></a>Расширение SNI — клиент TLS

Клиент NetX Secure TLS, желающий использовать расширение SNI, должен предоставить DNS-имя для протокола TLS, которое будет предоставлено при подтверждении. Это имя должно быть инициализировано и указано перед началом сеанса TLS, так как расширение передается в сообщении ClientHello, запускающем процесс подтверждения.

В следующем фрагменте кода показано, как используется это расширение. Сначала инициализируется объект NX_SECURE_X509_DNS_NAME с требуемым именем сервера. Затем перед началом сеанса TLS это имя передается в протокол TLS с помощью API расширения SNI. После задания имени дальнейшие действия не требуются. Ознакомьтесь со справочником по API в главе 4,  
  
"Описание служб ОСРВ Azure NetX Secure DTLS", чтобы получить дополнительные сведения об отдельных функциях.

```C
/* The dns_name variable will contain our desired server name. */
UINT status;
NX_SECURE_X509_DNS_NAME dns_name;

/* Initialize the server DNS name. */
status = nx_secure_x509_dns_name_initialize(&dns_name, "www.example.com", 
                                            strlen("www.example.com"));


/* Initialize SNI extension in previously-initialized TLS Session. */
status = nx_secure_tls_session_sni_extension_set(&client_tls_session, &dns_name);

/* Now start the TLS session, starting with establishing the TCP connection – if 
   TLS is started before initializing the SNI extension, the extension will not be 
   sent in the ClientHello message! */
status = nx_tcp_client_socket_connect(&client_socket, IP_ADDRESS(1, 2, 3, 4), 443, 
                                      5 * NX_IP_PERIODIC_RATE);

status = nx_secure_tls_session_start(&client_tls_session, &client_socket, 
                                     NX_WAIT_FOREVER);
```
### <a name="sni-extension--tls-server"></a>Расширение SNI — сервер TLS

На стороне сервера TLS расширение SNI может быть обработано приложением для выбора правильных учетных данных (например, сертификата), которые будут предоставлены удаленному клиенту во время подтверждения. Для этого приложение должно предоставить обратный вызов сеанса, который выполняется после получения сообщения ClientHello.

Пример кода для API nx_secure_tls_session_server_callback_set (см. стр. 122) иллюстрирует анализ входящего расширения SNI с помощью обратного вызова сервера. По сути, сервер TLS получает сообщение ClientHello и выполняет обратный вызов. Затем приложение использует API *nx_secure_tls_session_sni_extension_parse* для анализа данных расширения, предоставленных для обратного вызова, чтобы найти расширение SNI и вернуть указанное DNS-имя. Обратите внимание на то, что расширение поддерживает только одно DNS-имя. После получения имени приложение использует его, чтобы найти и отправить соответствующий удостоверяющий сертификат сервера (и цепочку издателей, если применимо).

### <a name="signature-algorithms-extension"></a>Расширение алгоритмов сигнатуры

Это расширение относится только к протоколу TLS 1.2 и позволяет клиенту TLS предоставить список допустимых пар сигнатур и хэш-алгоритмов для создания и проверки цифровых подписей. Этот список создается автоматически NetX Secure TLS для клиентов TLS с помощью таблицы шифров, предоставленной для *nx_secure_tls_session_create*. Взаимодействие с приложением не требуется.

## <a name="authentication-methods"></a>Способы проверки подлинности

Протокол TLS предоставляет платформу для установления безопасного подключения между двумя устройствами по незащищенной сети, но часть проблемы заключается в том, чтобы определить подлинность устройства на другом конце этого подключения. Без механизма проверки подлинности удостоверений удаленных узлов злоумышленник легко сможет предоставить фальшивое доверенное устройство.

Изначально может показаться, что использование IP-адресов, аппаратных MAC-адресов или DNS обеспечивает относительно высокий уровень надежности для идентификации узлов в сети, но, учитывая характер технологии TCP/IP и простоту подмены адресов и повреждения записей DNS (например, с помощью подделки записей кэша DNS), для протокола TLS требуется дополнительный уровень защиты от поддельных удостоверений.

Существует ряд механизмов, которые могут обеспечить этот дополнительный уровень проверки подлинности для TLS, но наиболее распространенным является *цифровой сертификат*. К другим механизмам относятся схемы на основе общих ключей (PSK) и паролей.

### <a name="digital-cerificates"></a>Цифровые сертификаты

Цифровые сертификаты — наиболее распространенный способ проверки подлинности удаленного узла в протоколе TLS. По сути, цифровой сертификат — это документ с особым форматированием, который предоставляет идентификационные данные устройства в компьютерной сети.

В протоколе TLS обычно используется формат X.509 — стандарт, разработанный Международным союзом электросвязи, хотя могут использоваться и другие форматы сертификатов, если узлы TLS могут согласовать используемый формат. Стандарт X.509 определяет точный формат сертификатов и различные кодировки, которые можно использовать для создания цифрового документа. Большинство сертификатов X.509, используемых с протоколом TLS, кодируется с использованием разновидности ASN.1 — еще одного стандарта связи. В ASN.1 доступны различные цифровые кодировки, но чаще всего для кодирования сертификатов TLS применяется стандарт DER (Distinguished Encoding Rules). DER — это упрощенное подмножество стандарта BER (Basic Encoding Rules) ASN.1, которое предназначено обеспечить однозначность и упростить анализ. В сети сертификаты TLS обычно кодируются в двоичном формате DER, и именно в этом формате NetX Secure ожидает сертификаты X.509.

Хотя двоичные сертификаты в формате DER используются в фактическом протоколе TLS, они могут создаваться и храниться в разных кодировках с такими расширениями файла, как PEM, CRT и P12. Различные варианты используются приложениями разных производителей, но в целом их можно преобразовать в формат DER с помощью широко доступных средств.

Наиболее распространенной альтернативной кодировкой сертификатов является PEM. Формат PEM (Privacy-Enhanced Mail) представляет собой версию кодировки DER в формате Base64, которая часто используется, так как это кодирование позволяет получить печатный текст, который можно легко отправить с помощью электронной почты или веб-протоколов.

Создание сертификата для вашего приложения NetX Secure обычно выходит за рамки данного руководства, но программа командной строки OpenSSL ([www.openssl.org](http://www.openssl.org)) широко доступна и может выполнять взаимное преобразование большинства форматов.

В зависимости от приложения вы можете создавать собственные сертификаты, получать сертификаты от изготовителя или правительственной организации или приобретать сертификаты у коммерческого центра сертификации.

Чтобы использовать цифровой сертификат в приложении NetX Secure, необходимо сначала преобразовать этот сертификат в двоичный формат DER и, при необходимости, преобразовать в двоичный формат соответствующий закрытый ключ (например, "закрытый показатель" для RSA), обычно это ключ RSA или ключ ECC в кодировке DER и формате PKCS № 1. После завершения преобразования необходимо загрузить сертификат и закрытый ключ на устройство. Возможные варианты включают в себя использование файловой системы флэш-памяти или создание массива C на основе данных (с помощью такого инструмента, как xxd в Linux), а также компиляцию сертификата и ключа в приложении в качестве постоянных данных.

После загрузки сертификата на устройство можно использовать API TLS, чтобы связать этот сертификат с сеансом TLS.

Дополнительные сведения и примеры использования сертификатов X.509 с NetX Secure TLS приведены в разделе "Импорт сертификатов X.509 в NetX Secure".

Ознакомьтесь с дополнительными сведениями о приведенных ниже службах TLS в справочнике по API:

- nx_secure_x509_certificate_initialize
- nx_secure_tls_local_certificate_add
- nx_secure_tls_local_certificate_remove
- nx_secure_tls_remote_certificate_allocate
- nx_secure_tls_trusted_certificate_add
- nx_secure_trusted_certificate_remove

### <a name="tls-client-certificate-specifics"></a>Особенности сертификата клиента TLS

Для реализаций клиента TLS обычно не требуется загрузка локального сертификата<sup>14</sup> на устройство. Исключением является применение проверки подлинности на основе сертификата клиента, но она гораздо менее распространена.

Клиенту TLS требуется загрузка по крайней мере одного "доверенного" сертификата<sup>15</sup> (при необходимости может быть загружено больше) и выделение пространства для "удаленного" сертификата<sup>16</sup>.

Дополнительные сведения о добавлении доверенных сертификатов и выделении пространства для удаленных сертификатов см. в справочнике по API TLS для служб nx_secure_tls_remote_certificate_allocate и nx_secure_tls_trusted_certificate_add.

14. "Локальный" сертификат — это сертификат, идентифицирующий локальное устройство, то есть предоставляющий идентификационные данные устройства, на которое загружено приложение TLS.

15. "Доверенный" сертификат — это сертификат, который предоставляет основу для доверия и проверки подлинности удаленного устройства напрямую либо посредством инфраструктуры открытых ключей (PKI). Корень цепочки доверия обычно называется "центром сертификации" или сертификатом ЦС.

16. "Удаленный" сертификат означает сертификат, отправленный удаленным узлом во время подтверждения TLS. Он предоставляет удостоверение этого удаленного узла и проходит проверку подлинности, при которой это удостоверение сравнивается с доверенным сертификатом на локальном устройстве.

### <a name="tls-server-certificate-specifics"></a>Особенности сертификата сервера TLS

Для реализации сервера TLS обычно не требуется загрузка доверенных сертификатов на устройство или выделение удаленных сертификатов. Исключением является применение проверки подлинности на основе сертификата клиента, но она менее распространена.

Сервер TLS требует загрузки локального сертификата, чтобы сервер мог предоставить его удаленному клиенту во время подтверждения TLS, чтобы клиент мог проверить подлинность сервера.

Дополнительные сведения о загрузке локальных сертификатов для серверных приложений NetX TLS см. в справочнике по API для следующих служб: 
- nx_secure_tls_local_certificate_add, 
- nx_secure_tls_local_certificate_remove.

### <a name="pre-shared-keys-psk"></a>Общие ключи (PSK)

Альтернативным механизмом идентификации для проверки подлинности в протоколе TLS является понятие общих ключей (PSK). Использование комплекта шифров PSK устраняет необходимость выполнять операции шифрования с открытым ключом, требующие интенсивного использования процессора, что является явным преимуществом для встроенных устройств с ограниченными ресурсами. PSK заменяет сертификат в подтверждении TLS и используется вместо зашифрованной предварительной главной копии секрета для создания ключа сеанса TLS.

Комплекты шифров PSK ограничены в том смысле, что общий секрет должен находиться на обоих устройствах, прежде чем можно будет установить сеанс TLS. Это означает, что этот секрет должен быть загружен на устройства каким-либо альтернативным безопасным способом, а не через подключение по протоколу TLS для PSK. PSK можно обновить через подключение TLS для PSK, но устройство должно быть запущено с PSK, загруженным с помощью какого-либо другого механизма. Например, ключи PSK можно загрузить на устройства датчика и его шлюза на фабрике перед отправкой или использовать стандартное подключение TLS (с сертификатом) для загрузки PSK.

Существуют два варианта комплектов шифров PSK, они описаны в документе RFC 4279. В первом применяются ключи RSA или Диффи-Хелмана, которые используются точно так же, как и открытые ключи, передаваемые в сертификате при стандартном подтверждении TLS. Во втором варианте, который чаще используется в среде с ограниченными ресурсами, применяется PSK, который используется для непосредственного создания ключей сеанса (например, для использования AES), что позволяет избежать выполнения ресурсоемких операций RSA или Диффи-Хелмана.

NetX Secure поддерживает второй вариант комплектов шифров PSK, что позволяет избавить приложения от всего кода шифрования с открытым ключом и проблем с использованием памяти. Сам по себе PSK не является ключом AES, а, скорее, является паролем, с помощью которого создаются фактические ключи. Существует несколько ограничений для значения PSK, хотя более длинные значения обеспечивают большую безопасность (то же относится и к паролям).

Чтобы использовать PSK в приложении NetX Secure, необходимо сначала определить глобальный макрос **NX_SECURE_ENABLE_PSK_CIPHERSUITES**. Обычно это делается с помощью параметров компилятора, но определение можно также поместить в файл заголовка nx_secure_tls.h. После определения макроса поддержка комплекта шифров PSK будет скомпилирована в приложение NetX Secure TLS.

После включения поддержки PSK можно будет использовать API TLS, чтобы настроить ключи PSK для приложения. Для каждого PSK потребуется значение PSK (фактический секретный "ключ", который должен храниться в безопасном месте), значение "удостоверения", используемое для идентификации конкретного PSK, и "указание удостоверения", которое используется сервером TLS для выбора определенного значения PSK.

PSK может быть любым двоичным значением, так как он никогда не передается через сетевое подключение. Значение PSK может содержать до 64 байт.

Удостоверение и указание должны представлять собой печатные строки символов в формате UTF-8. Значения удостоверения и указания могут содержать до 128 байт.

Удостоверение и PSK образуют уникальную пару, которая загружается на все устройства в сети, которые должны взаимодействовать друг с другом.

"Указание" в основном используется, чтобы определить конкретные профили приложений для группирования ключей PSK по функциям или службам. Эти значения должны быть согласованы заранее, и они зависят от приложения. Например, серверное приложение командной строки OpenSSL (использующее PSK) применяет строку по умолчанию "Client_identity", которая должна быть предоставлена клиентом TLS для продолжения подтверждения TLS.

Дополнительные сведения о ключах PSK см. в справочнике по API NetX Secure для служб nx_secure_tls_client_psk_set и nx_secure_tls_psk_add.

## <a name="importing-x509-certificates-into-netx-secure"></a>Импорт сертификатов X.509 в NetX Secure

Цифровые сертификаты необходимы для большинства подключений TLS в Интернете. Сертификаты обеспечивают метод проверки подлинности неизвестных ранее узлов через Интернет за счет использования доверенных посредников, которые обычно называются *центрами сертификации* (ЦА). Чтобы подключить устройство NetX Secure к коммерческой облачной службе (например, Amazon Web Services), необходимо будет импортировать сертификаты в свое приложение, загрузив их на устройство.

Наряду с сертификатами иногда может понадобиться *закрытый ключ*, связанный с вашим сертификатом. В некоторых приложениях (например, в клиенте TLS, если не используется проверка подлинности на основе сертификата клиента) будет достаточно только сертификата, но если сертификат используется для идентификации устройства, вам потребуется закрытый ключ. Закрытые ключи обычно создаются при создании сертификата и хранятся в отдельном файле, который часто шифруется и защищается паролем.

### <a name="certificate-types"></a>Типы сертификатов

Цифровые сертификаты обычно используются для идентификации сущностей в сети, но в зависимости от применения они могут иметь немного разные свойства.

### <a name="local-certificates"></a>Локальные сертификаты

В этой документации мы будем называть "локальными" сертификаты, которые обеспечивают идентификацию локального устройства (другое возможное название — сертификаты устройств). Эти сертификаты предоставляются удаленному узлу, когда он пытается проверить подлинность локального устройства.

### <a name="remote-certificates"></a>Удаленные сертификаты

В этой документации "удаленными" называются сертификаты, предоставляемые удаленным узлом в процессе подтверждения TLS, если это возможно. Для этих сертификатов должно быть выделено пространство, иначе NetX Secure не сможет их проанализировать и выполнить подтверждение TLS.

### <a name="signing-certificates"></a>Сертификаты для подписи

"Сертификат для подписи" используется для цифрового подписывания других сертификатов или данных в целях проверки подлинности. Эти сертификаты могут быть промежуточными или корневыми сертификатами в инфраструктуре открытых ключей (PKI), они обычно не используются для идентификации отдельных устройств или узлов.

### <a name="root-ca-certificates"></a>Сертификаты корневого ЦС

Сертификаты корневого ЦС — это сертификаты для подписи, которые обеспечивают основу PKI и являются самозаверяющими, а не подписанными другим сертификатом для подписи. Для проверки удаленных серверов клиенту TLS обычно требуется по крайней мере один сертификат корневого ЦС.

### <a name="certificate-formats"></a>Форматы сертификатов

Цифровые сертификаты — это просто файлы, содержащие структурированные данные, закодированные с помощью синтаксиса ASN.1. Однако существуют различные форматы, в которых могут храниться сертификаты, и важно применить соответствующий формат, прежде чем загружать сертификат в приложение NetX Secure.

Наиболее распространенными форматами сертификатов являются DER и PEM. DER (*Distinguished Encoding Rules*, формат ASN.1) — это двоичный формат, используемый протоколом TLS при первоначальном подтверждении. PEM (*Privacy Enhanced Mail*) — это версия формата DER в кодировке Base64, которая подходит для отправки электронной почты или передачи данных по протоколу HTTP в Интернете. Разные поставщики используют разные расширения файлов для сертификатов, например PEM или CRT для сертификатов PEM и DER для сертификатов DER. Если у вас есть сертификат и вам не ясно, в каком он формате, откройте этот файл в текстовом редакторе и определите его тип: DER-файлы кодируются в двоичном формате, а PEM-файлы — это обычный текст ASCII, начинающийся с заголовка "-----BEGIN CERTIFICATE-----".

Для NetX Secure требуется, чтобы сертификат был в двоичном формате DER, поэтому перед импортом необходимо преобразовать сертификат в формат DER. Это можно сделать с помощью легкодоступных средств, таких как OpenSSL.

Если вам нужен закрытый ключ для приложения, файл ключа будет закодирован с помощью стандарта PEM или DER в определенном формате (PKCS № 1 для алгоритма RSA или RFC 5915 для алгоритма ECC). Прежде чем импортировать файл закрытого ключа, его необходимо преобразовать в формат DER.

Ниже в качестве примера приведены команды OpenSSL для преобразования сертификатов и файлов ключа RSA в формат DER, необходимый для NetX Secure (команды для ECC аналогичны, обратитесь к документации по OpenSSL).

```C
openssl x509 -inform PEM -in <certificate> -outform DER -out cert.der
openssl x509 -inform PEM -in <root CA cert> -outform DER -out CA_cert.der
openssl rsa -inform PEM -in <private key> -outform DER -out private.key
```
### <a name="private-keys-and-certificates"></a>Закрытые ключи и сертификаты

Если сертификат идентифицирует устройство, то вместе с ним необходимо загрузить связанный закрытый ключ. Закрытый ключ (который может применяться для одного из алгоритмов с открытым ключом, такого как RSA, алгоритм Диффи-Хелмана или алгоритм шифрования на основе эллиптических кривых) используется сервером TLS для расшифровки входящего материала ключа ("предварительная главная копия секрета"), полученного от клиента TLS. Таким образом сервер подтверждает свою подлинность для клиента. Если предоставлен удостоверяющий сертификат (сертификат со связанным закрытым ключом) и сервер запрашивает сертификат клиента, то закрытый ключ используется для проверки подлинности клиента. В случае, если используется RSA, клиент TLS шифрует маркер с помощью закрытого ключа, который затем расшифровывается сервером с помощью открытого ключа клиента, предоставленного в сертификате клиента (проверка подлинности для алгоритмов Диффи-Хелмана и ECC происходит аналогично, но с небольшими отличиями).

В NetX Secure служба *nx_secure_x509_certificate_initialize* используется для инициализации сертификата X.509 (дополнительные сведения см. в разделе "Загрузка сертификатов на устройство") и связывания закрытого ключа с данным сертификатом, если это необходимо.

Если предоставлен закрытый ключ, то сертификат помечается как удостоверяющий сертификат, используемый для идентификации устройства. Ключ передается как непрерывный большой двоичный объект и значение длины с соответствующим типом ключа. Тип ключа зависит от типа (например, RSA, ECC и т. д.) и формата ключа (например, PKCS № 1 для DER). Если ключ не предоставлен, можно передать значение NX_SECURE_X509_KEY_TYPE_NONE (значение 0x0), чтобы указать, что ключ не передается (длина 0 и указатель NX_NULL для параметра данных дадут тот же результат).

В следующей таблице приведены типы ключей, поддерживаемые NetX Secure, и связанные идентификаторы типа, которые передаются в *nx_secure_x509_certificate_initialize*. Дополнительные типы ключей будут приводиться по мере добавления алгоритмов шифрования в NetX Secure.

| Идентификатор                              | Алгоритм | Формат   | Кодирование | Значение |
| --------------------------------------- | --------- | -------- | -------- | ----- |
| NX_SECURE_X509_KEY_TYPE_NONE            | Нет      | Недоступно      | Недоступно      | 0x0   |
| NX_SECURE_X509_KEY_TYPE_RSA_PKCS1_DER   | RSA       | PKCS № 1   | DER      | 0x1   |
| NX_SECURE_X509_KEY_TYPE_EC_DER          | ECDSA     | RFC 5915 | DER      | 0x2   |

### <a name="user-defined-private-key-types"></a>Определяемые пользователем типы закрытых ключей

Значения идентификаторов типа ключей для службы *nx_secure_x509_certificate_initialize* управляют действиями, выполняемыми при предоставлении закрытого ключа. Для известных типов значения находятся в диапазоне 0x0000 0000–0x0000 FFFF (младшие 16 бит 32-разрядного целого числа без знака). Для платформ с пользовательскими типами ключей<sup>17</sup> (как и для некоторых аппаратных подсистем шифрования) в качестве типа ключа может быть передан определяемый пользователем тип ключа в диапазоне 0x0000 1000–0xFFFF FFFF (старшие 16 бит, отличные от нуля). Если заданы какие-либо старшие 16 бит типа ключа, то данные закрытого ключа передаются напрямую в соответствующую криптографическую процедуру (например, RSA), указанную в таблице комплекта шифров TLS. Определяемые пользователем типы ключей не анализируются и не обрабатываются каким-либо иным способом до передачи в криптографическую процедуру. Кроме того, определяемый пользователем тип ключа также будет передан в криптографическую процедуру, чтобы на этом уровне можно было выполнить любую необходимую обработку.

Обратите внимание на то, что определяемые пользователем типы ключей обычно используются для специальных аппаратных платформ, использующих пользовательские (возможно, зашифрованные) данные ключа. Как правило, это означает, что данные ключа создаются или кодируются с помощью механизма, относящегося к этому поставщику оборудования (или, в случае стандарта, к определенному стандарту, например PKCS № 11). Дополнительные сведения см. в документации по конкретной аппаратной платформе.

17. Для пользовательских типов ключей требуется соответствующая пользовательская криптографическая процедура, обрабатывающая пользовательский формат ключа. Криптографическая процедура должна включать в себя алгоритм сопоставления (например, RSA) и передаваться в протокол TLS в таблице комплекта шифров. 

### <a name="loading-certificates-onto-your-device"></a>Загрузка сертификатов на устройство

Любого метода загрузки файла на устройство будет достаточно для импорта сертификатов.

Самым простым способом загрузки сертификата является преобразование двоичных данных в кодировке DER в массив C и его компиляция в приложение в виде константы. Это можно легко сделать с помощью такого инструмента, как xxd в Linux (с параметром "-i").

Кроме того, вы можете загрузить сертификат в файловую систему флэш-памяти или хранилище другого типа, если это позволяет передать указатель на данные сертификата в API NetX Secure.

### <a name="certificate-files-needed-for-netx-secure"></a>Файлы сертификатов, необходимые для NetX Secure

Файлы сертификатов, которые потребуется импортировать, зависят от приложения. В общем случае серверам TLS требуется сертификат для идентификации устройства, а клиентам TLS требуется один или несколько *доверенных сертификатов* для проверки подлинности удаленных серверов. В следующей таблице показаны сертификаты, необходимые для разных способов применения протокола TLS.

| **Функциональные возможности протокола TLS**                     | **Минимально необходимые сертификаты и ключи**              |
| ------------------------------------------------- | --------------------------------------------------- |
| Клиент TLS                                        | Корневой сертификат ЦС                                 |
| Сервер TLS                                        | Локальный сертификат, закрытый ключ для этого сертификата |
| Сервер TLS с проверкой подлинности на основе сертификата клиента | Локальный сертификат, закрытый ключ, корневой ЦС             |
| Клиент TLS с проверкой подлинности на основе сертификата клиента | Локальный сертификат, закрытый ключ, корневой ЦС             |
| Клиент или сервер TLS только с общими ключами    | Нет (вместо сертификатов используется PSK)             |

Ниже приведены соответствующие службы для загрузки сертификатов.

| **Имя API**                                   | **Назначение**                                            |
| ---------------------------------------------- |------------------------------------------------------- |
| nx_secure_x509_certificate_initialize      | Должна вызываться для всех сертификатов, чтобы заполнить структуру NX_SECURE_X509_CERT данными сертификата и закрытым ключом. |
| nx_secure_tls_local_certificate_add       | Добавляет локальный сертификат в сеанс TLS для идентификации устройства.                                                                |
| nx_secure_tls_local_certificate_remove    | Удаляет локальный сертификат из сеанса TLS.                                                                                   |
| nx_secure_tls_remote_certificate_allocate | Выделяет пространство для удаленного сертификата (вызывается с неинициализированной структурой NX_SECURE_X509_CERT).                                   |
| nx_secure_tls_trusted_certificate_add     | Добавляет сертификат в сеанс TLS в качестве доверенного сертификата для проверки подлинности удаленных узлов.                                     |
| nx_secure_tls_trusted_certificate_remove  | Удаляет доверенный сертификат из сеанса TLS.                                                                                 |

### <a name="working-with-aws-iot-certificates"></a>Работа с сертификатами AWS IoT

В меню боковой панели интерфейса Amazon Web Services IoT выберите "Security" (Безопасность) и щелкните "Certificates" (Сертификаты). Создайте сертификат и следуйте инструкциям по загрузке нового сертификата устройства.

После загрузки сертификатов их необходимо будет преобразовать в формат DER с помощью OpenSSL или аналогичной служебной программы.

Примечание. AWS также предоставит файл открытого ключа. Открытый ключ содержится в локальном сертификате устройства, поэтому его не нужно импортировать в приложение.

Например, ниже приведены команды для преобразования локального сертификата устройства и его закрытого ключа в формат DER для использования с NetX Secure.

```C
openssl x509 -inform PEM -in <certificate> -outform DER -out cert.der
openssl x509 -inform PEM -in <root CA cert> -outform DER -out CA_cert.der
openssl rsa -inform PEM -in <private key> -outform DER -out private.key
```
Преобразованные файлы можно импортировать в приложение, следуя приведенным выше инструкциям.

## <a name="x509-certificate-validation-in-netx-secure"></a>Проверка сертификата X.509 в NetX Secure 

При использовании протокола TLS с сертификатами X.509 для идентификации и проверки узлов важно понимать, как эти сертификаты проверяются на самом деле. Хотя спецификация TLS не предоставляет подробные инструкции по проверке сертификата, она ссылается на спецификацию X.509 (RFC 5280). Обычно предполагается, что протокол TLS будет выполнять по крайней мере простую проверку подлинности входящих сертификатов (сертификатов, предоставляемых удаленным узлом во время подтверждения TLS), и NetX Secure TLS функционирует точно так же.

### <a name="basic-x509-validation"></a>Простая проверка X.509

Для любого входящего сертификата NetX Secure TLS выполняет простую проверку пути X.509. Этот процесс включает в себя проверку цифровой подписи каждого сертификата по сертификату издателя, который может быть предоставлен удаленным узлом или расположен в хранилище доверенных сертификатов (дополнительные сведения об импорте доверенных сертификатов см. в разделе "Импорт сертификатов X.509 в NetX Secure"). Процесс проверки по сертификатам издателя рекурсивно повторяется, пока не будет достигнут доверенный сертификат или не завершится вся цепочка (на самозаверяющем сертификате или отсутствующем сертификате издателя). При достижении доверенного сертификата проверяемый сертификат считается надежным, в противном случае он отклоняется. Кроме того, на каждом этапе процесса проверки дата окончания срока действия каждого сертификата проверяется по времени, предоставленному функцией меток времени приложения (дополнительные сведения см. в описании службы nx_secure_tls_session_time_function_set).

Спецификация X.509 также предоставляет алгоритм для поддержки "политик", являющихся идентификаторами в расширении X.509, которые можно проверить во время проверки пути. Сейчас NetX Secure обрабатывает сертификаты X.509 так, как если бы был определен параметр anyPolicy, то есть принимаются все политики, а дополнительная проверка политик не выполняется. Реализация X.509 в NetX Secure может быть дополнена этой функцией в будущем выпуске. Сейчас расширение политик можно получить из сертификата с помощью API *nx_secure_x509_extension_find*.

После завершения проверки основного пути протокол TLS выполняет обратный вызов проверки сертификата, указанный приложением, с помощью API *nx_secure_tls_session_certificate_callback_set*. Если обратный вызов не указан, то сертификат считается доверенным после успешной проверки пути. Если указан обратный вызов, то он будет выполнять все дополнительные проверки сертификата, необходимые приложению. Возвращаемое из обратного вызова значение используется, чтобы определить, следует ли продолжить подтверждение TLS или его нужно прервать из-за ошибки проверки.

Обратный вызов выполняется с указателем на соответствующий сеанс TLS и указателем NX_SECURE_X509_CERT на проверяемый сертификат. Между установлением сеанса TLS и подтверждением подлинности сертификата приложение имеет все необходимые данные из протокола TLS для выполнения дополнительных проверок.

Чтобы обеспечить дополнительную проверку, NetX Secure предоставляет процедуры X.509 для некоторых распространенных операций проверки, включая проверку DNS и проверку списка отзыва сертификатов. Все эти процедуры подходят для обратного вызова проверки сертификата, но также могут использоваться для автономной проверки сертификатов X.509.

В следующей таблице перечислены доступные вспомогательные функции для обработки сертификатов X.509. Более подробные описания операций можно найти в следующих разделах и справочнике по API в главе 4.  
  
Описание служб NetX Secure содержит дополнительные сведения о конкретных процедурах.

| **Имя API**                             | **Описание**                               |
| ---------------------------------------- | -------------------------------------- |
| nx_secure_x509_common_name_dns_check               | Проверка общего имени субъекта X.509 и SubjectAltName на соответствие ожидаемому DNS-имени. |
| nx_secure_x509_crl_revocation_check                 | Проверка сертификата на наличие в списке отзыва сертификатов X.509 (CRL).       |
| nx_secure_x509_extended_key_usage_extension_parse | Анализ и поиск конкретного значения OID расширенного использования ключа в сертификате.                   |
| nx_secure_x509_key_usage_extension_parse           | Анализ и возвращение битового поля использования ключа в сертификате.                            |
| nx_secure_x509_extension_find                        | Поиск и возвращение необработанных данных ASN.1 в кодировке DER для определенного расширения.            |

Вспомогательные функции X.509 для использования в обратном вызове проверки сертификата

### <a name="x509-extensions"></a>Расширения X.509

В спецификации X.509 описывается ряд расширений, позволяющие предоставить дополнительные сведения, которые можно использовать при проверке сертификатов. В большинстве случаев эти расширения являются необязательными и не требуются для безопасной проверки цифрового сертификата с помощью доверенного корневого сертификата. Однако NetX Secure поддерживает несколько базовых расширений. В будущих выпусках может быть добавлена поддержка дополнительных расширений.

Поддерживаемые в настоящее время расширения перечислены в таблице ниже.

| Имя расширения           | Описание                                                                   | Соответствующий API                                             |
| ------------------------ | ----------------------------------------------------------------------------- | -------------------------------------------------------- |
| Использование ключа                | Предоставляет приемлемые варианты использования открытого ключа сертификата в битовом поле.         | nx_secure_x509_key_usage_extension_parse           |
| Расширенное использование ключа       | Предоставляет приемлемые варианты использования открытого ключа сертификата посредством значений OID. | nx_secure_x509_extended_key_usage_extension_parse |
| Альтернативное имя субъекта | Предоставляет альтернативные DNS-имена, которые также представляются сертификатом.   | nx_secure_x509_common_name_dns_check               |

### <a name="unsupported-x509-extensions"></a>Неподдерживаемые расширения X.509

Реализация X.509 для NetX Secure также предоставляет службу для извлечения неподдерживаемых расширений: *nx_secure_x509_extension_find*. Этот API предназначен для опытных пользователей, так как он требует знания формата ASN.1 в кодировке DER для анализа возвращаемых данных. Он использовался внутри протокола для извлечения поддерживаемых расширений, но предоставляется для удобства в разработке пользовательской поддержки расширений X.509.

Чтобы использовать nx_secure_x509_extension_find, передается структура NX_SECURE_X509_EXTENSION вместе с сертификатом и идентификатором расширения, который представляет собой целочисленное представление строки OID переменной длины для известного типа расширения. Полный список поддерживаемых идентификаторов OID для расширений X.509 приведен в справочнике по API для службы nx_secure_x509_extension_find на странице 178.

Ниже приведено определение структуры NX_SECURE_X509_EXTENSION.

```C
typedef struct NX_SECURE_X509_EXTENSION_STRUCT
{
    /* Identifier (maps to OID) for this extension. */
    USHORT nx_secure_x509_extension_id;

    /* Critical flag - boolean value. */
    USHORT nx_secure_x509_extension_critical;

    /* Pointer to DER-encoded extension data. */
    const UCHAR *nx_secure_x509_extension_data;
    ULONG        nx_secure_x509_extension_data_length;
} NX_SECURE_X509_EXTENSION;
```
При успешном возвращении службы структура заполняется соответствующими данными из сертификата. Поле nx_secure_x509_extension_id обычно используется для внутренних операций, но будет заполнено соответствующим целочисленным представлением OID. Поле nx_secure_x509_extension_critical представляет значение флага критического расширения X.509 (логическое). Поля nx_secure_x509_extension_data и nx_secure_x509_extension_data_length содержат указатель на данные ASN.1 в кодировке DER для расширения и длину этих данных соответственно.

Фактический анализ данных расширения ASN.1 выходит за рамки данного документа, но если у вас есть доступ к исходному коду NetX Secure TLS, то вы сможете увидеть, как выполняется анализ везде, где вызывается nx_secure_x509_extension_find для поддерживаемых расширений.

### <a name="x509-dns-validation"></a>Проверка DNS для X.509

Обычная операция проверки сертификата в протоколе TLS включает в себя проверку имени домена верхнего уровня (TLD) удаленного узла по сертификату X.509, предоставленному этим узлом во время подтверждения TLS. Эта операция позволяет гарантировать, что сертификат действительно соответствует серверу узла, который его предоставил, если предположить, что поиск DNS является доверенным. В NetX Secure TLS эта функция обеспечивается службой **nx_secure_x509_common_name_dns_checkом**, которая принимает сертификат и строку, содержащую часть TLD URL-адреса, используемого для доступа к узлу. Значение TLD сравнивается с полем общего имени сертификата, и, если оно совпадает, возвращается значение NX_SUCCESS. Если общее имя не совпадает, процедура также проверит наличие *subjectAltName* расширения сертификата X.509. Если имеется значение subjectAltName, то все записи DNSName в расширении также проверяются по предоставленному значению TLD. Опять же, если найдено совпадение, возвращается значение NX_SUCCESS. Если совпадений не найдено, из обратного вызова проверки сертификата возвращается соответствующая ошибка.

### <a name="x509-key-usage-and-extended-key-usage-extensions"></a>Расширения для использование ключа и дополнительного использования ключа X.509

Расширения для использование ключа и дополнительного использования ключа X.509 предоставляют сведения о том, как открытый ключ сертификата может использоваться при проверке подлинности этого сертификата. Использование ключа указывает издатель сертификата, когда сертификат подписывается и выдается. Данные об использовании ключа может применять узел TLS, чтобы убедиться, что сертификат разрешено использовать при проверке подлинности удаленного узла TLS, а также для других операций.

Расширение для использования ключа состоит из простого битового поля, в котором каждый бит представляет конкретное использование ключа. Полный список этих значений приведен в справочнике по API для службы *nx_secure_x509_key_usage_extension_parse* на странице 183. Более полное описание битов использования ключа и их значение см. в разделе 4.2.1.3 документа RFC 5280.

Расширение для дополнительного использования ключа, как и расширение для использования ключа, предоставляет сведения о допустимом использовании ключа. Однако для поддержки произвольного использования в этом расширении используются значения OID, а не битовое поле. При анализе расширения для дополнительного использования ключа в NetX Secure X.509 приложение передает целое число, представляющее OID, после чего служба *nx_secure_x509_extended_key_usage_extension_parse* возвращает сведения о том, присутствует ли этот OID. Полный список поддерживаемых значений OID для дополнительного использования ключа приведен в справочнике по API для службы *nx_secure_x509_extended_key_usage_extension_parse* на странице 175. Более полное описание значений OID и их значение см. в разделе 4.2.1.12 документа RFC 5280.

### <a name="x509-crl-revocation-status-checking"></a>Проверка состояния отзыва с помощью списка отзыва сертификатов X.509

Стандарт X.509 предоставляет механизм, называемый *списком отзыва сертификатов* (CRL), который позволяет центру подписывания цифровых сертификатов отозвать действительность подписанных им сертификатов. Любое приложение, которому нужно проверить сертификаты из центра подписывания, может получить список отзыва сертификатов и сравнить все сертификаты, подписанные этим центром (издателем), со списком отзыва сертификатов, чтобы узнать, не отозвано ли их состояние по какой-либо причине (например, из-за скомпрометированного закрытого ключа). Таким образом приложение может избежать использования потенциально опасных сертификатов, которые проходят прочие проверки.

Чтобы получить список отзыва сертификатов, приложение может скачать его в кодировке DER со стандартного сервера или получить каким-либо иным способом. Фактическая настройка зависит от издателя, поэтому NetX Secure не предоставляет механизм получения списков отзыва сертификатов, однако предоставляется процедура для проверки сертификата на соответствие списку отзыва сертификатов, **nx_secure_x509_crl_revocation_check**.

Этот API принимает список отзыва сертификатов в кодировке DER, хранилище сертификатов для проверки (например, хранилище в сеансе TLS) и проверяемый сертификат. Сначала эта процедура проверяет наличие списка отзыва сертификатов в доверенном хранилище (части хранилища сертификатов, предоставленной приложением). Это важно для защиты от поддельных списков отзыва сертификатов, используемых для атак типа "отказ в обслуживании", и позволяет убедиться, что список отзыва сертификатов действительно получен от соответствующего издателя. После проверки списка отзыва сертификатов проверяется издатель. Если издатель списка отзыва сертификатов не соответствует издателю сертификата, то список отзыва сертификатов считается недействительным для этого сертификата и возвращается ошибка. Именно приложение должно решить, можно ли продолжить подтверждение TLS на этом этапе. Если издатели совпадают, то в списке отзыва сертификатов выполняется поиск серийного номера проверяемого сертификата. Если этот серийный номер есть в списке, возвращается ошибка, указывающая, что сертификат был отозван. Если совпадения не найдены, то возвращается значение NX_SUCCESS.

## <a name="client-certificate-authentication-in-netx-secure-tls"></a>Проверка подлинности на основе сертификата клиента в NetX Secure TLS

При использовании проверки подлинности на основе сертификата X.509 протокол TLS требует, чтобы экземпляр сервера TLS предоставил сертификат для идентификации, но по умолчанию экземпляру клиента TLS не требуется предоставлять сертификат для проверки подлинности. Вместо этого используется другая разновидность проверки подлинности (например, сочетание имени пользователя и пароля). Это соответствует наиболее распространенному использованию протокола TLS в Интернете для веб-сайтов. Например, веб-сайт розничной торговли должен доказать потенциальному клиенту, использующему веб-браузер, что сервером является действительным, но пользователь будет использовать имя для входа и пароль для доступа к определенной учетной записи.

Однако вариант использования по умолчанию не всегда желателен, поэтому протокол TLS дополнительно позволяет экземпляру сервера TLS запрашивать сертификат у удаленного клиента. Если эта функция включена, то во время подтверждения сервер TLS отправляет сообщение CertificateRequest клиенту TLS. Клиент должен отправить в ответ свой сертификат и сообщение CertificateVerify, которое содержит криптографический маркер, подтверждающий, что клиент владеет соответствующим закрытым ключом, связанным с этим сертификатом. Если проверка завершается сбоем или сертификат не связан с доверенным сертификатом на сервере, происходит сбой подтверждения TLS.

Существуют два отдельных варианта проверки подлинности на основе сертификата клиента в протоколе TLS, они рассматриваются в следующих разделах.

### <a name="client-certificate-authentication-for-tls-clients"></a>Проверка подлинности на основе сертификата клиента для клиентов TLS

Клиент TLS может попытаться подключиться к серверу, который запрашивает сертификат для проверки подлинности клиента. В этом случае клиент должен предоставить сертификат серверу и подтвердить, что он владеет соответствующим закрытым ключом, иначе сервер завершит подтверждение TLS.

В NetX Secure TLS нет специальной конфигурации для поддержки этой функции, но приложению потребуется указать локальный сертификат для экземпляра клиента TLS с помощью службы *nx_secure_tls_local_certificate_add*. Если приложение не предоставило сертификат, а удаленный сервер использует проверку подлинности на основе сертификата клиента и запрашивает сертификат, то подтверждение TLS завершится сбоем. Для выполнения подтверждения TLS сертификат, предоставленный сеансу TLS службой *nx_secure_tls_local_certificate_add*, должен быть распознан удаленным сервером.

### <a name="client-certificate-authentication-for-tls-servers"></a>Проверка подлинности на основе сертификата клиента для серверов TLS

В случае сервера TLS проверка подлинности на основе сертификата клиента выполняется немного сложнее, чем в случае клиента TLS, ввиду необязательного использования функции. В этом случае сервер TLS должен запросить сертификат у удаленного клиента TLS, обработать сообщение CertificateVerify, чтобы убедиться, что удаленный клиент владеет соответствующим закрытым ключом, а затем сервер должен убедиться, что сертификат, предоставленный клиентом, можно отследить до сертификата в хранилище локальных доверенных сертификатов.

В экземплярах сервера NetX Secure TLS проверка подлинности на основе сертификата клиента осуществляется с помощью служб <br>
*nx <span class="underline"> _</span>secure <span class="underline">_</span>tls <span class="underline"> _</span>session <span class="underline">_</span>client <span class="underline"> _</span>verify<span class="underline">_</span>enable* и<br>
*nx <span class="underline"> _</span>secure <span class="underline">_</span>tls <span class="underline"> _</span>session <span class="underline">_</span>client <span class="underline"> _</span>verify<span class="underline">_</span>disable*.

Чтобы включить проверку подлинности на основе сертификата клиента, приложение должно вызвать службу<br>
*nx <span class="underline"> _</span>secure <span class="underline">_</span>tls <span class="underline"> _</span>session <span class="underline">_</span>client <span class="underline"> _</span>verify <span class="underline">_</span>enable* с использованием экземпляра сеанса сервера TLS перед вызовом *nx_secure_tls_session_start*. Обратите внимание на то, что вызов этой службы для сеанса TLS, который используется для подключений клиента TLS, ни на что не повлияет.

Если включена проверка подлинности на основе сертификата клиента, сервер TLS запрашивает сертификат у удаленного клиента TLS во время подтверждения TLS. На сервере NetX Secure TLS сертификат клиента проверяется с помощью хранилища доверенных сертификатов, созданных с помощью *nx <span class="underline"> _</span>secure_tls <span class="underline">_</span>trusted <span class="underline"> _</span>certificate<span class="underline">_</span>add*, в соответствии с цепочкой издателей X.509. Удаленный клиент должен предоставить цепочку, которая связывает удостоверяющий сертификат с сертификатом в доверенном хранилище, иначе произойдет сбой подтверждения TLS. Кроме того, если происходит сбой обработки сообщения CertificateVerify, то подтверждение TLS также завершается ошибкой.

Методы сигнатур, используемые для метода CertificateVerify, являются фиксированными для протоколов TLS 1.0 и TLS 1.1 и задаются сервером TLS в протоколе TLS 1.2. Для протокола TLS 1.2 поддерживаются методы сигнатур, которые, как правило, соответствуют методам, передаваемым в таблице криптографических методов, но обычно это RSA с SHA-256 (ознакомьтесь с разделом "Шифрование в NetX Secure TLS", чтобы получить дополнительные сведения об инициализации TLS с помощью криптографических методов).

## <a name="cryptography-in-netx-secure-tls"></a>Шифрование в NetX Secure TLS

TLS определяет протокол, в котором может использоваться шифрование для защиты сетевого взаимодействия. Поэтому выбор фактического алгоритма шифрования, который может быть применен, не слишком ограничен для пользователей протокола TLS. Спецификация только требует реализовать один комплект шифров. В случае протокола TLS 1.2 это комплект шифров TLS_RSA_WITH_AES_128_CBC_SHA, предписывающий использование RSA для операций с открытым ключом, AES — в режиме CBC с 128-разрядными ключами для шифрования сеансов и SHA-1 — для хэшей для проверки подлинности сообщений.

Так как протокол NetX Secure совместим с протоколом TLS 1.2, он обеспечивает обязательный комплект шифров TLS_RSA_WITH_AES_128_CBC_SHA по умолчанию, но, учитывая количество возможных реализаций для каждого из криптографических методов ввиду возможностей оборудования и других соображений, NetX Secure предоставляет универсальный криптографический API, позволяющий пользователю указать, какие криптографические методы использовать в протоколе TLS.

Примечание. Механизм универсального криптографического API также позволяет пользователям реализовать собственные комплекты шифров, но это рекомендуется для опытных пользователей, уже работавших с комплектами шифров и расширениями TLS. Если вы заинтересованы в поддержке собственных комплектов шифров, обратитесь к своему представителю Express Logic.

### <a name="cryptographic-methods"></a>Криптографические методы

NetX Secure TLS реализует алгоритмы DES, 3DES, AES, MD5, HMAC-MD5, SHA-1, HMAC-SHA1, SHA-256, HMAC-SHA256, RSA и ECC (выбранные кривые) в программном обеспечении с помощью драйверов оборудования для определенных аппаратных платформ. Приложение может использовать криптографические процедуры, предоставляемые в NetX Secure, или пользовательские процедуры, предоставленные пользователем или сторонними производителями.

*NX_CRYPTO_METHOD* — это блок управления, предназначенный для описания конкретной реализации алгоритма шифрования для использования в NetX Secure TLS. С помощью *NX_CRYPTO_METHOD* приложение может легко интегрировать собственную реализацию шифрования в NetX Secure. Структура *NX_CRYPTO_METHOD* объявляется следующим образом.

```C
typedef struct NX_CRYPTO_METHOD_STRUCT
{
    /* Symbolic name of the algorithm. */
    USHORT nx_crypto_algorithm;

    /* Size of the key, in bits. */
    USHORT nx_crypto_key_size_in_bits;

    /* Size of the IV block, in bits, used for encryption. */
    USHORT nx_crypto_IV_size_in_bits;

    /* Size of the ICV block, in bits, used for authentication. */
    USHORT nx_crypto_ICV_size_in_bits;

    /* Size of the crypto block, in bytes. */
    ULONG nx_crypto_block_size_in_bytes;

    /* Size of the metadata area. */
    ULONG nx_crypto_metadata_size;

    /* nx_crypto_init function initializes the crypto method with the
        "secret key" or other state  information. The initialization 
        routine should return a handle to the caller.  This handle is 
        used in subsequent crypto operations to identify the session.  
        */

    UINT (*nx_crypto_init) (NX_CRYPTO_METHOD     *method,
                            UCHAR               *key, 
                            NX_CRYPTO_KEY_SIZE   key_size_in_bits,
                            VOID               **handler,
                            VOID                *crypto_metadata,
                            VOID                 crypto_metadata_size);

    /* NetX Secure calls the nx_crypto_cleanup routine when a TLS
       session is to be deleted (or updated).  Resources allocated 
       during the crypto operation should be released in this routine.  
       */
    UINT (*nx_crypto_cleanup) (VOID *handler);

    /* nx_crypto_operation is the actual crypto or hash operation. Note 
       that both input and output buffers are prepared by the caller. 
       For encryption or decryption operations, the crypto operation 
       routine uses the output buffer for encrypted or decrypted data. 
       For authentication operations, the authentication routine shall 
       use the output buffer for the digest. */
    UINT (*nx_crypto_operation)(UINT  op, 
                  VOID              *handler, 
                  NX_CRYPTO_METHOD  *method,
                  UCHAR             *key,
                  NX_CRYPTO_KEY_SIZE key_size_in_bits,
                  UCHAR             *input,
                  ULONG              input_length_in_byte,
                  UCHAR             *iv_ptr,
                  UCHAR             *output,
                  ULONG              output_length_in_byte,
                  VOID              *crypto_metadata,
                  VOID               crypto_metadata_size,
                  NX_PACKET*         packet_ptr,
                  VOID (*nx_crypto_hw_process_callback(NX_PACKET 
                                                       *packet_ptr, 
                                                        UINT status);
} NX_CRYPTO_METHOD;
```

Ниже приведено описание каждого элемента в структуре *NX_CRYPTO_METHOD*.

- nx_crypto_algorithm: это поле определяет алгоритм, описанный в *методе* переменной; некоторые допустимые значения для NetX Secure TLS приведены ниже (чтобы узнать какие-либо определенные значения, просмотрите файл nx_crypto_const.h).
    
  - NX_CRYPTO_NONE    
  - NX_CRYPTO_ENCRYPTION_NULL    
  - NX_CRYPTO_ENCRYPTION_AES_CBC    
  - NX_CRYPTO_AUTHENTICATION_NONE    
  - TLS_HASH_SHA_1    
  - TLS_HASH_SHA_256    
  - TLS_HASH_MD5    
  - TLS_CIPHER_RSA    
  - TLS_CIPHER_NULL

- nx_crypto_key_size_in_bits: это поле указывает размер секретного ключа, используемого методом.

- nx_crypto_IV_size_in_bits: это поле указывает размер вектора инициализации (IV). Обратите внимание на то, что в большинстве случаев блок IV используется только для алгоритмов шифрования и расшифровки. Алгоритмы проверки подлинности и проверки редко используют это поле.

- nx_crypto_ICV_size_in_bits: это поле определяет размер блока проверки целостности (ICV). Примечание. Этот блок предназначен для IPsec и не используется в протоколе TLS. Дополнительные сведения см. в описании NetX Duo IPsec.

- nx_crypto_block_size_in_bytes: это поле указывает размер в байтах блока алгоритма шифрования для шифров на основе блоков. В большинстве случаев оно используется процедурами шифрования, и редко — процедурами проверки подлинности.

- nx_crypto_metadata_area_size: это поле указывает размер области метаданных, требуемой для этого метода. Для каждой реализации может потребоваться определенный объем памяти для хранения сведений о состоянии или промежуточных данных (например, материала для преобразования ключей), либо для использования в качестве временной области. В этом поле указывается объем пространства, необходимый для реализации. Приложение предоставляет пространство памяти при создании сеанса TLS. Криптографическая функция отвечает за управление этой областью метаданных.

- nx_crypto_init: функция инициализации для алгоритма шифрования. Для реализации, которая не нуждается в процедуре инициализации, этому полю может быть присвоено значение NX_NULL. Обычно функция инициализации используется для инициализации внутренней структуры данных для алгоритма. NetX Secure TLS будет выполнять инициализацию криптографической процедуры, используя внутренний вызов этой функции.

Прототип функции инициализации:

```C
UINT crypto_init_function(NX_CRYPTO_METHOD *method, 
                          UCHAR *key, 
                          UINT  key_size_in_bits, 
                          VOID  **handle, 
                          VOID  *crypto_metadata_area, 
                          ULONG crypto_metadata_area_size);
```

  - method: указатель на блок управления криптографическим методом.

  - key: строка секретного ключа для обработки пакетов данных.

  - key_size_in_bits определяет размер секретного ключа в битах.

  - handle: определяемый реализацией элемент, задающий конкретный сеанс шифрования. Значение создается процедурой инициализации и передается обратно вызывающему объекту. Последующая операция шифрования или процедура очистки использует этот обработчик для идентификации сеанса.

  - crypto_metadata: указатель на область метаданных, которая требуется для реализации данного алгоритма. Для алгоритмов, которым не требуется область метаданных, это поле имеет значение NX_NULL, а процедура инициализации не должна обращаться к области метаданных.

  - crypto_metadata_size задает размер области метаданных. Для сопоставлений безопасности, созданных без области метаданных, это поле имеет значение 0, а процедура инициализации не должна обращаться к области метаданных.

  - Эта процедура должна возвращать значение *NX_SUCCESS*, если процесс инициализации прошел успешно. Вызывающий объект рассматривает любое другое возвращаемое значение как сбой.

- nx_crypto_cleanup: подпрограмма очистки, определенная для реализации алгоритма шифрования. Она вызывается при удалении или перезапуске сеанса TLS.

Прототип функции очистки:

```C
UINT crypto_cleanup_function(VOID *handle);
```
- Элемент handle передается в функцию очистки вызывающим объектом. Этот элемент инициализируется процедурой инициализации шифрования и используется для определения состояния алгоритма шифрования.

- Эта процедура должна вернуть значение *NX_SUCCESS*, если процесс инициализации прошел успешно. Вызывающий объект рассматривает любое другое возвращаемое значение как сбой.

- nx_crypto_operation: подпрограмма, выполняющая шифрование, расшифровку и запускающая службы проверки подлинности. Прототип функции операционной процедуры:

```C
UINT crypto_operation_function(UINT   op,
          VOID  *handle,  
          NX_CRYPTO_METHOD* method,
          UCHAR *key,
          UCHAR  key_size_in_bits,
          UCHAR* input,
          ULONG  input_length_in_byte,
          UCHAR* iv_ptr,
          UCHAR* output,
          ULONG  output_length_in_byte,
          VOID *crypto_metadata,
          ULONG crypto_metadata_size,
          NX_PACKET *packet_ptr,
          VOID (*nx_crypto_hw_process_callback)(NX_PACKET 
                          *packet_ptr, UINT status));
```

- Параметр op указывает тип операции, которая должна выполняться этой процедурой. Допустимые значения:
    
    - NX_CRYPTO_ENCRYPT
    - NX_CRYPTO_DECRYPT
    - NX_CRYPTO_AUTHENTICATE
    - NX_CRYPTO_VERIFY

- Элемент handle передается в операционную функцию вызывающим объектом. Он создается процедурой инициализации шифрования.
- method указывает на блок управления криптографическим методом.
- key указывает на секретный ключ, используемый для этой операции.
- key_size_in_bits определяет размер секретного ключа в битах.
- input: указатель на начало обрабатываемого сообщения.
- input_length_in_byte передается вызывающим объектом для указания размера обрабатываемого сообщения.
- iv_ptr настраивается вызывающим объектом и указывает на начало блока IV. Обратите внимание на то, что память для блока IV предоставляется вызывающим объектом. Для шифрования операционная функция должна записать в этот блок памяти сведения о векторе инициализации. Для расшифровки операционная функция должна получить сведения о векторе инициализации из этого блока памяти. Алгоритмы для операций проверки подлинности и проверки обычно не используют вектор инициализации.
- Параметр output настраивается вызывающим объектом и указывает на буфер вывода. Обратите внимание на то, что память для буфера вывода предоставляется вызывающим объектом. Для шифрования операционная функция должна записать в буфер вывода зашифрованный текст. Для расшифровки операция должна записать в буфер вывода расшифрованный текст (открытый текст). Для проверки подлинности в буфер вывода должно быть записано значение хэша. При проверке буфер вывода используется для хранения данных хэша.
- output_length_in_byte указывает размер буфера вывода.
- crypto_metadata указывает на область метаданных, используемую этой криптографической операцией. Эта область метаданных обычно инициализируется функцией crypto_init_function.
- crypto_metadata_size задает размер области метаданных.
- Эта процедура должна возвращать значение *NX_SUCCESS*, если выполнение операции прошло успешно. Вызывающий объект рассматривает любое другое возвращаемое значение как сбой.
- packet_ptr: пакет, содержащий обрабатываемые данные. Примечание. Этот параметр не используется протоколом TLS и должен быть иметь значение NX_NULL.
- nx_crypto_hw_process_callback: функция обратного вызова, предоставляемая методом шифрования. Этот параметр используется, если функция шифрования предоставляется оборудованием и требует процедуры обратного вызова.

NetX Secure TLS предоставляет следующие методы шифрования:

- *AES*  
- *RSA*  
- *NULL*

NetX Secure TLS предоставляет следующие способы проверки подлинности:

- *HMAC-MD5*  
- *HMAC-SHA1*  
- *HMAC-SHA256*

В следующих примерах показано, как настроить структуру *NX_CRYPTO_METHOD* для использования методов шифрования и проверки подлинности, предоставляемых NetX Duo IPsec.

***AES***

```C
/* AES-CBC 128. */
NX_CRYPTO_METHOD crypto_method_aes_cbc_128 = 
{
    /* AES crypto algorithm                             */
    NX_CRYPTO_ENCRYPTION_AES_CBC,                       

    /* Key size in bits. For AES-128 this value is 128  */
    NX_CRYPTO_AES_128_KEY_LEN_IN_BITS,              
   
    /* IV size in bits.  For AES-128 this value is 128  */
    NX_CRYPTO_AES_IV_LEN_IN_BITS,

    /* ICV size in bits, not used.                      */
    0,                                              

    /* Block size in bytes.  For AES this value is 16   */
    (NX_CRYPTO_AES_BLOCK_SIZE_IN_BITS >> 3),        

    /* Metadata size in bytes, for AES this value is 262*/
    sizeof(NX_CRYPTO_AES),              

    /* AES-CBC initialization routine.                  */
    _nx_secure_crypto_method_aes_init,               

    /* AES-CBC cleanup routine, not used.               */
    NX_NULL,                                        

    /* AES-CBC operation                                */
    _nx_secure_crypto_method_aes_operation           
};

/* RSA. */
NX_CRYPTO_METHOD crypto_method_rsa = 
{
    /* RSA crypto algorithm                             */
    TLS_CIPHER_RSA,                       

    /* Key size. RSA key sizes vary, so set to 0.         */
    0,              
   
    /* IV size in bits.  RSA does not use an IV.         */
    0,

    /* ICV size in bits, not used.                      */
    0,                                              

    /* Block size in bytes.  RSA does not have a block size. */
    0,        

    /* Metadata size in bytes, for RSA use the control block. */
    sizeof(NX_CRYPTO_RSA),              

    /* RSA initialization routine.                  */
    _nx_secure_crypto_method_rsa_init,               

    /* Cleanup routine, not used.                    */
    NX_NULL,                                        

    /* RSA operation                                */
    _nx_secure_crypto_method_rsa_operation           

};
```
***NULL***

```C
/* NULL encryption method. */
NX_CRYPTO_METHOD crypto_method_null = 
{
    NX_CRYPTO_ENCRYPTION_NULL,/* Name of the crypto algorithm  */
    0,                        /* Key size in bits, not used    */
    0,                        /* IV size in bits, not used     */
    0,                        /* ICV size in bits, not used    */
    4,                        /* Block size in bytes           */
    0,                        /* Metadata size in bytes        */
    NX_NULL,                  /* Initialization routine,unused */
    NX_NULL,                  /* Cleanup routine, not used     */
    _nx_secure_crypto_method_null_operation  /* NULL operation  
*/
}; 
```
***HMAC-SHA1***
```C
NX_CRYPTO_METHOD crypto_method_hmac_sha1 = 
{
    /* HMAC SHA1 algorithm                               */
    TLS_HASH_SHA1,            


    /* Key size in bits. For HMAC-SHA1 this value is 160 */ 
    NX_CRYPTO_HMAC_SHA1_KEY_LEN_IN_BITS,              

    /* IV size in bits, not used                         */
    0,                                            

    /* Transmitted ICV size in bits. Unused.             */
    0, 

    /* Block size in bytes, not used                     */
    0,                                            

    /* Metadata size in bytes                            */
    sizeof(NX_SHA1_HMAC),                                            

    /* Initialization routine, not used                  */
    NX_NULL,                                      

    /* Cleanup routine, not used                         */
    NX_NULL,                                          

    /* HMAC SHA1 operation                               */
    _nx_secure_crypto_method_hmac_sha1_operation   
};
```
***NONE***

Специальный метод **NX_CRYPTO_NONE** используется, чтобы сообщить модулю IPSec о том, что служба шифрования или проверки подлинности не требуется. Он настраивается, как показано ниже.

```C
/* NX_CRYPTO_NONE means encryption or authentication
   method is not needed.  */
NX_CRYPTO_METHOD crypto_method_none = 
{
    NX_CRYPTO_NONE,       /* Name of the crypto algorithm */
    0,                    /* Key size in bits, not used   */
    0,                    /* IV size in bits, not used    */
    0,                    /* ICV size in bits, not used   */
    0,                    /* Block size in bytes          */
    0,                    /* Metadata size in bytes       */
    NX_NULL,              /* Initialization routine, not used */
    NX_NULL,              /* Cleanup routine, not used    */
    NX_NULL               /* NULL operation               */
};                                               
```
### <a name="initializing-tls-with-cryptographic-methods"></a>Инициализация протокола TLS с помощью криптографических методов

После создания криптографических процедур, соответствующих сигнатурам криптографических методов, описанных в предыдущем разделе, необходимо передать их в протокол TLS при инициализации блока управления NX_SECURE_TLS_SESSION. Это выполняет служба TLS nx_secure_tls_session_create.

```C
UINT  nx_secure_tls_session_create(
              NX_SECURE_TLS_SESSION*     session_ptr,
              const NX_SECURE_TLS_CRYPTO*    tls_cipher_table,
              VOID*                encryption_metadata_area,
              ULONG                 encryption_metadata_size
);
```
- session_pointer: указатель на блок управления NX_SECURE_TLS_SESSION.
- tls_cipher_table: указатель на блок управления NX_SECURE_TLS_CRYPTO, описанный ниже.
- encryption_metadata_area указывает на пространство, используемое криптографическими процедурами в TLS.
- encryption_metadata_size задает размер области метаданных в байтах.

### <a name="elliptic-curve-cryptography-ecc-in-netx-secure-tls"></a>Шифрование на основе эллиптических кривых (ECC) в NetX Secure TLS

Шифрование на основе эллиптических кривых (ECC) предоставляет схему шифрования с открытым ключом, которую можно использовать вместо RSA. Алгоритм ECC обычно быстрее и использует меньшие ключи, чем RSA, поэтому он может быть удачным вариантом для встроенной реализации TLS. В версиях X-Ware, предшествовавших ОСРВ Azure 6.0, ECC предоставлялся как надстройка, требующая установки исходного кода ECC в проект. В ОСРВ Azure 6.0 компонент ECC интегрирован в основную базу кода, поэтому установка файлов ECC больше не требуется. Однако для ECC требуется инициализация, как и в предыдущих версиях.

### <a name="supported-ecc-curves"></a>Поддерживаемые кривые ECC

NetX Secure реализует части кривых в соответствии с <http://www.secg.org/sec2-v2.pdf>. Поддерживаются следующие кривые<sup>18</sup>:

  - secp256r1 
  - secp384r1 
  - secp521r1 

Если используются другие кривые ECC, то процедура *nx_secure_tls_session_start()* вернет ошибку NX_SECURE_TLS_NO_SUPPORTED_CIPHERS, указывающую, что используются неподдерживаемые кривые.

Обратите внимание на то, что цепочка сертификатов TLS может также быть зашифрована с помощью алгоритмов ECC. Хотя кривые, предоставляемые клиентом TLS, поддерживаются, возможна ситуация, когда кривая ECC, используемая в цепочке сертификатов, не поддерживается. В этом случае процедура *nx_secure_tls_session_start* вернет ошибку NX_SECURE_TLS_UNSUPPORTED_PUBLIC_CIPHER.

Пример таблицы комплектов шифров по умолчанию для ECC приведен в файле nx_crypto_generic_ciphersuites.c. Дополнительные сведения о таблицах комплектов шифров см. в разделе "Таблица криптографических шифров TLS".

18. Обратите внимание на то, что для устаревших приложений также предоставляются реализации кривых secp192r1 и secp224r1. Однако эти кривые уже считаются ненадежными и не должны использоваться для разработки новых приложений.

### <a name="crypto-methods-for-ecc"></a>Криптографические методы для ECC

Криптографические методы для групп алгоримтов на основе эллиптических кривых:

- NX_CRYPTO_METHOD crypto_method_ec_secp192<sup>15</sup>;  
- NX_CRYPTO_METHOD crypto_method_ec_secp224<sup>15</sup>;  
- NX_CRYPTO_METHOD crypto_method_ec_secp256;  
- NX_CRYPTO_METHOD crypto_method_ec_secp384;  
- NX_CRYPTO_METHOD crypto_method_ec_secp521;

Криптографические методы для кривых ECC определяются в файле nx_crypto_generic_ciphersuites.c.

Криптографический метод для ECDHE:

- NX_CRYPTO_METHOD crypto_method_ecdhe.

Криптографический метод для ECDSA:

- NX_CRYPTO_METHOD crypto_method_ecdsa.

Криптографические методы ECDSA и ECDHE определяются в файле nx_crypto_generic_ciphersuites.c.

Вместе с другими криптографическими методами, такими как RSA, SHA, AES, их можно использовать как стандартные блоки для таблицы подстановки комплектов шифров.

### <a name="enabling-ecc-support-for-tls"></a>Включение поддержки ECC для протокола TLS

ECC по умолчанию включен для протокола TLS. Чтобы отключить поддержку ECC, необходимо определить символ NX_SECURE_DISABLE_ECC_CIPHERSUITE.

Чтобы изменения вступили в силу, необходимо перестроить библиотеку NetX Secure и все приложения, использующие эту библиотеку.

В коде приложения после создания сеанса TLS должен вызываться API *nx_secure_tls_ecc_initialize()* . Этот API уведомляет сеанс TLS о типе кривых, используемых для операций обмена ключами TLS и проверки сертификатов. Если выбран алгоритм ECC, то на этапе подтверждения TLS клиент и сервер обмениваются параметрами, связанными с кривой ECC, чтобы определить, какую кривую использовать.

В следующем фрагменте кода показано, как использовать данный API. Обратите внимание на то, что аргументы (*nx_crypto_ecc_supported_groups, nx_crypto_ecc_supported_groups_size и nx_crypto_ecc_curves)* определены в файле *nx_crypto_generic_ciphersuites.c*. Поэтому эти символы можно использовать напрямую.

```C
status = nx_secure_tls_ecc_initialize(&tls_session,     
                    nx_crypto_ecc_supported_groups,      
                    nx_crypto_ecc_supported_groups_size,     
                    nx_crypto_ecc_curves);
```
Пример конфигурации в nx_crypto_generic_ciphersuites.c содержит таблицу подстановки комплектов шифров ECC, которая используется, если включен алгоритм ECC. Чтобы использовать ECC, просто передавайте nx_crypto_tls_ciphers_ecc как параметр таблицы комплектов шифров при создании сеансов TLS с помощью nx_secure_tls_session_create. В примере таблицы содержатся комплекты шифров ECC и другие комплекты шифров.

### <a name="tls-cryptographic-cipher-table"></a>Таблица криптографических шифров TLS

Структура NX_SECURE_TLS_CRYPTO определяется следующим образом.

```C
typedef struct NX_SECURE_METHODS_STRUCT
{
    /* Table that maps ciphersuites to crypto methods. */
    NX_SECURE_TLS_CIPHERSUITE_INFO* nx_secure_tls_ciphersuite_lookup_table;
    USHORT nx_secure_tls_ciphersuite_lookup_table_size;

    /* Table that maps X.509 cipher identifiers to crypto methods. */
    NX_SECURE_X509_CRYPTO *nx_secure_tls_x509_cipher_table;
    USHORT nx_secure_tls_x509_cipher_table_size;

    /* Specific routines needed for specific TLS versions. */
#if (NX_SECURE_TLS_TLS_1_0_ENABLED || NX_SECURE_TLS_TLS_1_1_ENABLED)
    NX_CRYPTO_METHOD *nx_secure_tls_handshake_hash_md5_method;
    NX_CRYPTO_METHOD *nx_secure_tls_handshake_hash_sha1_method;
    NX_CRYPTO_METHOD *nx_secure_tls_prf_1_method;
#endif

#if (NX_SECURE_TLS_TLS_1_2_ENABLED)
    NX_CRYPTO_METHOD *nx_secure_tls_handshake_hash_sha256_method;
    NX_CRYPTO_METHOD *nx_secure_tls_prf_sha256_method;
#endif

#if (NX_SECURE_TLS_TLS_1_3_ENABLED)
    const NX_CRYPTO_METHOD *nx_secure_tls_hkdf_method;
    const NX_CRYPTO_METHOD *nx_secure_tls_hmac_method;
    const NX_CRYPTO_METHOD *nx_secure_tls_ecdhe_method;
#endif

} NX_SECURE_TLS_CRYPTO;
```
Таблица создается путем заполнения записей для этой структуры в статической константе, расположенной в проекте NetX Secure TLS, который обычно размещается с помощью криптографических процедур и модулей.

Например, полностью программная ("универсальная") библиотека шифрования, предоставляемая с NetX Secure, содержит следующее определение таблицы (для поддержки комплектов шифров, не относящихся к ECC<sup>19</sup>).

```C
/* Define the cipher table object we can pass into TLS. */
const NX_SECURE_TLS_CRYPTO nx_crypto_tls_ciphers =
{
    /* TLS Ciphersuite lookup table and size. */
    _nx_crypto_ciphersuite_lookup_table,
    sizeof(_nx_crypto_ciphersuite_lookup_table) / 
    sizeof(NX_SECURE_TLS_CIPHERSUITE_INFO),

    /* X.509 certificate cipher table and size. */
    _nx_crypto_x509_cipher_lookup_table,
    sizeof(_nx_crypto_x509_cipher_lookup_table) / sizeof(NX_SECURE_X509_CRYPTO),

    /* TLS version-specific methods. */
#if (NX_SECURE_TLS_TLS_1_0_ENABLED || NX_SECURE_TLS_TLS_1_1_ENABLED)
    &crypto_method_md5,
    &crypto_method_sha1,
    &crypto_method_tls_prf_1,
#endif

#if (NX_SECURE_TLS_TLS_1_2_ENABLED)
    &crypto_method_sha256,
    &crypto_method_tls_prf_sha_256
#endif

#if (NX_SECURE_TLS_TLS_1_3_ENABLED)
    &crypto_method_hkdf,
    &crypto_method_hmac,
    &crypto_method_ecdhe,
#endif
};
```
В структуре первая запись является таблицей комплекта шифров TLS. Структура NX_SECURE_TLS_CIPHERSUITE_INFO сопоставляет криптографические процедуры (в виде указателей NX_CRYPTO_METHOD) с конкретными комплектами шифров, как определено в спецификациях TLS. Второе значение — это число записей в таблице, на которое указывает первое поле.

Следующее поле указывает на таблицу процедур, используемых протоколом X.509 при обработке цифровых сертификатов, а структура NX_SECURE_X509_CRYPTO по форме аналогична NX_SECURE_TLS_CIPHERSUITE_INFO. Следующее поле — число записей в таблице.

За таблицей подстановки указывается ряд процедур, необходимых для конкретных версий протокола TLS. Например, до выпуска протокола TLS версии 1.2 процедуры создания ключей и хэширования для подтверждения были запрограммированы для использования сочетания SHA-1 и MD5. Методы для этих процедур вызывались специально в структуре шифра, так как они не привязаны к определенным комплектам шифров. В протоколе TLS версии 1.2 процедуры создания ключей и хэширования выбираются комплектом шифров, но для комплектов шифров, которые не указывают применяемые процедуры, используется метод хэширования SHA-256, а структура шифра вызывает именно соответствующую процедуру.

В протоколе TLS 1.3 требуются дополнительные определенные шифры для различных операций.

19. Обратите внимание на то, что для поддержки TLS 1.3 требуется алгоритм ECC. Используйте nx_crypto_tls_ciphers_ecc, если включен протокол TLS 1.3.

### <a name="tls-ciphersuite-lookup-table"></a>Таблица подстановки комплектов шифров TLS

Чтобы заполнить таблицу шифров для протокола TLS, потребуется также создать таблицу подстановки комплектов шифров, которая сопоставляет криптографические процедуры с конкретными идентификаторами комплектов шифров. Эти идентификаторы представляют собой универсальные значения, зарегистрированные в IANA. Дополнительные сведения см. в документах RFC по протоколу TLS. Процедуры представляют 5 отдельных методов, используемых в каждом комплекте шифров (некоторые комплекты шифров могут не использовать все 5 методов): общедоступное шифрование, проверка подлинности с открытым ключом, шифрование сеансов, процедура хэширования сеансов и псевдослучайная функция TLS (PRF). В следующей таблице описаны все 5 методов.

| **Категория процедуры**      | **Описание**                                                                                       | **Примеры алгоритмов**                                            |
| ------------------------- | ----------------------------------------------------------------------------------------------------- | ----------------------------------------------------------------- |
| Общедоступное шифрование             | Используется для обмена ключами во время подтверждения TLS.                                                        | RSA, Диффи-Хелмана, ECC                                          |
| Проверка подлинности с открытым ключом | Используется для проверки подлинности или подписывания данных во время подтверждения TLS.                                            | RSA, DSS                                                          |
| Шифрование сеансов            | Алгоритм с симметричным ключом, используемый для шифрования данных приложения во время сеанса TLS.                       | AES, RC4                                                          |
| Хэширование сеансов              | Используется для обеспечения целостности сообщений во время сеанса TLS (гарантирует, что данные не изменяются). | SHA-1, SHA-256                                                    |
| Псевдослучайная функция (PRF) TLS                   | Используется для создания материала ключа, а также в хэше подтверждения при подтверждении TLS.                          | Метод PRF основан на процедурах хэширования: SHA-1 и MD5, SHA-256, SHA-512. |

Определение структуры NX_SECURE_TLS_CIPHERSUITE_INFO показано ниже.

```C
typedef struct NX_SECURE_TLS_CIPHERSUITE_INFO_struct
{
    /* The IANA value of the ciphersuite as defined by the TLS spec.*/
    USHORT nx_secure_tls_ciphersuite;

    /* The Public Key operation in this suite - RSA or DH. */
    NX_CRYPTO_METHOD *nx_secure_tls_public_cipher;

    /* The Public Authentication method used for signing data. */
    NX_CRYPTO_METHOD *nx_secure_tls_public_auth;

    /* The session cipher being used - AES, RC4, etc. */
    NX_CRYPTO_METHOD *nx_secure_tls_session_cipher;

    /* The size of the initialization vectors for the session cipher (bytes).*/
    USHORT nx_secure_tls_iv_size;

    /* The key size for the session cipher (bytes). */
    UCHAR nx_secure_tls_session_key_size;

    /* The hash being used - MD5, SHA-1, SHA-256, etc. */
    NX_CRYPTO_METHOD *nx_secure_tls_hash;

    /* The size of the hash being used. SHA-1 is 20 bytes, MD5 is 16 bytes.*/
    USHORT nx_secure_tls_hash_size;

    /* The TLS PRF being used – this is only for TLSv1.2. */
    NX_CRYPTO_METHOD *nx_secure_tls_prf;

} NX_SECURE_TLS_CIPHERSUITE_INFO;
```
Поле nx_secure_tls_ciphersuite содержит значение IANA комплекта шифров, а указатели NX_CRYPTO_METHOD представляют 5 методов, используемых этим комплектом шифров. Скалярные значения (nx_secure_tls_iv_size, nx_secure_tls_key_size и nx_secure_tls_hash_size) предоставляют сведения, которые могут быть недоступны в записях NX_CRYPTO_METHOD.

В качестве примера мы рассмотрим комплект шифров по умолчанию для протокола TLS, TLS_RSA_WITH_AES_128_CBC_SHA, который предписывает использование RSA, AES-CBC с 128-разрядными ключами и SHA-1 для хэширования сеансов. Для этого комплекта шифров не задан метод PRF TLS, поэтому в режиме TLS 1.2 будет использоваться метод PRF по умолчанию, SHA-256. Обратите внимание на то, что все комплекты шифров используют метод PRF на основе SHA-1 и MD5 в протоколах TLS версий 1.0 и 1.1, независимо от состояния PRF, указанного в таблице.

Запись в таблице NX_SECURE_TLS_CIPHERSUITE_INFO в универсальной криптографической библиотеке определяется следующим образом.

```C
{ 
  TLS_RSA_WITH_AES_128_CBC_SHA,     /* Ciphersuite identifier */
  &crypto_method_rsa,               /* Public-key cipher (NX_CRYPTO_METHOD)*/
  &crypto_method_rsa,               /* Authentication method(NX_CRYPTO_METHOD)*/
  &crypto_method_aes_cbc_128,       /* Session cipher method(NX_CRYPTO_METHOD)*/
  16,                               /* Session cipher IV size in bytes */
  16,                               /* Session cipher key size in bytes */
  &crypto_method_hmac_sha1,         /* Session hash routine(NX_CRYPTO_METHOD) */
  20,                               /* Session hash output size in bytes */
  &crypto_method_tls_prf_sha_256    /* TLSv1.2 PRF */
},
```

Обратите внимание на то, что для шифрования сеансов размер ключа определяется комплектом шифров, но для методов с открытым ключом размер ключа не известен до тех пор, пока не выполнено подтверждение TLS, так как открытые ключи содержатся в цифровых сертификатах, которыми обмениваются во время подтверждения.

### <a name="x509-cipher-lookup-table"></a>Таблица подстановки шифров X.509

Как и в таблице NX_SECURE_TLS_CIPHERSUITE_INFO, структура NX_SECURE_X509_CRYPTO сопоставляет криптографические процедуры с известными значениями. В случае протокола X.509 идентификаторами фактически являются значения OID, определяемые X.509 и зарегистрированные в текстах стандартов ISO и ITU. Значения OID — это многобайтовые значения переменной длины, предназначенные для уникальной идентификации различных данных в разных телекоммуникационных стандартах, включая криптографические процедуры, используемые в цифровых сертификатах. Так как значения OID имеют переменную длину, NetX Secure TLS сопоставляет официальные значения OID с константами фиксированной длины, которые используются внутри протокола (ознакомьтесь с файлом nx_secure_x509.h). Эти константы используются в структуре NX_SECURE_X509_CRYPTO, которая определяется следующим образом.

```C
/* Structure to hold X.509 cryptographic routine information. */
typedef struct NX_SECURE_X509_CRYPTO_struct
{
    /* Internal NetX Secure identifier for certificate "ciphersuite" which consists
       of a hash and a public key operation. These can be mapped to OIDs in X.509.
        */
    USHORT nx_secure_x509_crypto_identifier;

    /* Public-Key Cryptographic method used by certificates. */
    NX_CRYPTO_METHOD *nx_secure_x509_public_cipher_method;

    /* Hash method used by certificates. */
    NX_CRYPTO_METHOD *nx_secure_x509_hash_method;
} NX_SECURE_X509_CRYPTO;
```

Первое поле, *nx_secure_x509_crypto_identifier*, является внутренним представлением OID, используемым NetX Secure.

Второе и третье поля указывают на объекты NX_CRYPTO_METHOD, представляющие криптографические методы, идентифицируемые по значению OID, и операцию с открытым ключом, связанную с процедурой хэширования. Обратите внимание на то, что каждый цифровой сертификат может иметь несколько значений OID для криптографических процедур.

Таблица методов для протокола X.509 составлена таким же образом, как и таблица подстановки комплектов шифров. В качестве примера мы рассмотрим значение OID для RSA_SHA1. Фактическое значение OID для RSA_SHA1 выглядит следующим образом.

```C
{iso(1) member-body(2) us(840) rsadsi(113549) pkcs(1) pkcs-1(1) sha1-with-rsa-
signature(5)}
```
Это значение OID представлено в синтаксисе ASN.1 и имеет числовое значение 1.2.840.113549.1.1.5. Затем это значение кодируется в двоичный формат и преобразовывается в приведенные ниже байты.

```C
UCHAR RSA_SHA1_OID = { 0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, 0x01, 0x05 };
```
Сам процесс преобразования из ASN.1 в двоичный формат выходит за рамки данного документа. Чтобы получить дополнительные сведения, выполните поиск кодировок ASN.1 для значений OID. Двоичное представление значений OID, поддерживаемых NetX Secure, можно найти в файле *nx_secure_x509.c*.

После сопоставления фактического OID с распознанной внутри протокола константой можно создать запись для RSA_SHA1 в таблице NX_SECURE_X509_CRYPTO.

```C
{ 
    NX_SECURE_TLS_X509_TYPE_RSA_SHA_1,    /* Internal OID constant. */
    &crypto_method_rsa,                   /* RSA method (NX_CRYPTO_METHOD). */ 
    &crypto_method_sha1                   /* SHA-1 method (NX_CRYPTO_METHOD). */
}, 
```
### <a name="default-tls-routines"></a>Процедуры TLS по умолчанию

Как упоминалось выше, протоколу TLS требуется несколько процедур по умолчанию для создания ключей и проверки сообщений во время подтверждения. Основная процедура — это псевдослучайная функция TLS (PRF). Процедура PRF основана на процедурах хэширования и может использоваться для создания произвольного объема псевдослучайных данных<sup>20</sup>, применяемых для создания ключей или других целей.

Помимо процедуры PRF в каждой версии протокола TLS используются процедуры хэширования по умолчанию, которые также необходимо предоставить. Для протоколов TLS версий 1.0 и 1.1 этими процедурами хэширования являются MD5 и SHA-1. Для протокола TLS версии 1.2 требуется только алгоритм SHA-256.

В структуре NX_SECURE_TLS_CRYPTO есть указатели NX_CRYPTO_METHOD для MD5, SHA-1, SHA-256 — процедуры PRF для протокола TLS версии 1.0 или 1.1 и процедура PRF для протокола TLS 1.2 по умолчанию.

Для поддержки протокола TLS 1.3 добавляются поля для HKDF (создание ключей), HMAC (для определенных операций хэширования, используемых во время подтверждения) и ECDHE (требуется для обеспечения функциональных возможностей TLS 1.3).

В состав универсальной программной криптографической библиотеки входят программные версии PRF для TLS. Для протоколов TLS 1.0 и TLS 1.1 эта функция называется *nx_crypto_tls_prf_1*. Для протокола TLS 1.2 эта функция называется *nx_secure_tls_prf_sha256*. Суффикс "1" представляет устаревшую версию PRF для протокола TLS 1.0, а суффикс "SHA256" означает, что функция PRF по умолчанию для протокола TLS 1.2 основана на алгоритме SHA-256. Если требуется поддержка других процедур PRF, то суффикс для этих процедур будет отражать используемый метод хэширования. Так как процедуры PRF основаны на методах хэширования, базовые процедуры хэширования могут использовать независимое аппаратное ускорение на разных целевых платформах.

В дополнение к таблицам подстановки комплектов шифров TLS и X.509 можно добавить в структуру NX_SECURE_TLS_CRYPTO процедуры PRF и процедуры хэширования по умолчанию, чтобы использовать их для инициализации сеанса TLS.

20. "Псевдослучайный" означает, что процедура PRF является детерминированной, то есть она всегда будет выдавать одинаковые выходные данные для одних и тех же входных данных, а элемент случайности заключается в том, что эти данные невозможно спрогнозировать. Протокол TLS использует это свойство PRF для создания ключей сеанса на основе различных общедоступных данных и главной копии секрета, которые передаются во время подтверждения с использованием шифрования с открытым ключом, например RSA.

### <a name="cryptographic-metadata"></a>Криптографические метаданные

Прежде чем инициализировать сеанс TLS с помощью таблицы NX_SECURE_TLS_CRYPTO, необходимо выделить пространство буфера для метаданных криптографических процедур. Эти метаданные используются для хранения всех состояний, связанных с конкретной процедурой и представленных ее блоком управления. В поле *nx_crypto_metadata_area_size* каждой структуры NX_CRYPTO_METHOD должен быть задан размер структуры управления, связанной с этой процедурой, иначе при инициализации TLS не удастся правильно вычислить необходимое пространство, что может привести к проблемам переполнения буфера.

Перед созданием сеанса TLS необходимо выделить буфер метаданных. Этот буфер автоматически распределяется между nx_secure_tls_session_create и пространством, резервируемым для каждой из процедур, предоставленных в таблице криптографических методов. Учтите, что так как в сеансе TLS одновременно активен только один комплект шифров, то число поддерживаемых комплектов шифров не влияет на необходимое пространство метаданных. Это пространство резервируется для каждой из 5 процедур комплекта шифров на основе максимального размера блока управления для этой категории, указанного в таблице подстановки комплектов шифров.

Чтобы упростить вычисление размера буфера метаданных, служба *nx_secure_metadata_size_calculate* выполняет те же вычисления, что и nx_secure_tls_session_create, но просто возвращает общий размер буфера метаданных в байтах.

### <a name="initializing-the-tls-session"></a>Инициализация сеанса TLS

После создания объектов NX_CRYPTO_METHOD и NX_SECURE_TLS_CRYPTO и резервирования области метаданных можно инициализировать сеанс TLS, как показано ниже (значения взяты из приведенных выше примеров).

```C
/* Pointer to the platform-specific cipher table. */
extern nx_crypto_tls_ciphers;

/* Cryptographic routine metadata buffer. Size is determined by calling 
nx_secure_tls_metadata_size_calculate with the nx_crypto_tls_ciphers table referenced 
above. */
UCHAR crypto_metadata[4500];

/* Initialize our TLS session using our cipher table and metadata area. Note that we can 
use sizeof for the metadata array because the size parameter expects the size in bytes.*/

nx_secure_tls_session_create(
    &tls_session,            /* Pointer to TLS session.      */
    &nx_crypto_tls_ciphers,  /* Pointer to cipher table.     */
    crypto_metadata,         /* Cryptography metadata buffer.*/
    sizeof(crypto_metadata), /* Size of metadata buffer.     */
);
```
