---
title: Глава 3. Функциональное описание ОСРВ Azure NetX Secure
description: Эта глава содержит функциональное описание NetX Secure TLS.
author: philmea
ms.author: philmea
ms.date: 06/04/2020
ms.topic: article
ms.service: rtos
ms.openlocfilehash: c28ad0255f99986a4ddfe5faefad81e70840e5e0
ms.sourcegitcommit: e3d42e1f2920ec9cb002634b542bc20754f9544e
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/22/2021
ms.locfileid: "104814511"
---
# <a name="chapter-3---functional-description-of-azure-rtos-netx-secure"></a><span data-ttu-id="16c78-103">Глава 3. Функциональное описание ОСРВ Azure NetX Secure</span><span class="sxs-lookup"><span data-stu-id="16c78-103">Chapter 3 - Functional description of Azure RTOS NetX Secure</span></span>

## <a name="execution-overview"></a><span data-ttu-id="16c78-104">Общие сведения о выполнении</span><span class="sxs-lookup"><span data-stu-id="16c78-104">Execution Overview</span></span>

<span data-ttu-id="16c78-105">Эта глава содержит функциональное описание ОСРВ Azure NetX Secure TLS.</span><span class="sxs-lookup"><span data-stu-id="16c78-105">This chapter contains a functional description of Azure RTOS NetX Secure TLS.</span></span> <span data-ttu-id="16c78-106">В приложении NetX Secure TLS используются два основных типа выполнения программы: инициализация и вызовы интерфейса приложения.</span><span class="sxs-lookup"><span data-stu-id="16c78-106">There are two primary types of program execution in a NetX Secure TLS application: initialization and application interface calls.</span></span> 

<span data-ttu-id="16c78-107">*NetX Secure предполагает наличие ThreadX и NetX или NetX Duo. Из ThreadX требуется выполнение потоков, приостановка, периодические таймеры и механизмы взаимного исключения. Из NetX или NetX Duo требуются механизмы сетевого взаимодействия и драйверы TCP/IP.*</span><span class="sxs-lookup"><span data-stu-id="16c78-107">*NetX Secure assumes the existence of ThreadX and NetX/NetXDuo. From ThreadX, it requires thread execution, suspension, periodic timers, and mutual exclusion facilities. From NetX/NetXDuo it requires the TCP/IP networking facilities and drivers.*</span></span>

## <a name="transport-layer-security-tls-and-secure-sockets-layer-ssl"></a><span data-ttu-id="16c78-108">Протоколы TLS и SSL</span><span class="sxs-lookup"><span data-stu-id="16c78-108">Transport Layer Security (TLS) and Secure Sockets Layer (SSL)</span></span>

<span data-ttu-id="16c78-109">Компонент защищенного сетевого протокола NetX Secure является реализацией протокола TLS, как описано в документах RFC 2246 (версия 1.0), 4346 (версия 1.1), 5246 (версия 1.2) и 8446 (версия 1.3).</span><span class="sxs-lookup"><span data-stu-id="16c78-109">The secure network protocol component of NetX secure is an implementation of the Transport Layer Security (TLS) protocol as described in RFCs 2246 (version 1.0), 4346 (version 1.1), 5246 (version 1.2) and 8446 (version 1.3).</span></span> <span data-ttu-id="16c78-110">Также включены процедуры поддержки базовых сертификатов X.509 (RFC 5280).</span><span class="sxs-lookup"><span data-stu-id="16c78-110">Also included are support routines for basic X.509 (RFC 5280).</span></span>

<span data-ttu-id="16c78-111">NetX Secure TLS поддерживает протокол TLS версий 1.2 и 1.3.</span><span class="sxs-lookup"><span data-stu-id="16c78-111">NetX Secure TLS supports TLS versions 1.2 and 1.3.</span></span> <span data-ttu-id="16c78-112">Предоставляются реализации и для устаревших протоколов TLS 1.0 и TLS 1.1, но их следует инициализировать явным образом и не рекомендуется использовать в новых продуктах.</span><span class="sxs-lookup"><span data-stu-id="16c78-112">Implementations are provided for the now-deprecated TLS 1.0 and TLS 1.1, but they must be explicitly initialized and are not recommended for use in new products.</span></span>

<span data-ttu-id="16c78-113">*SSL* — это первоначальное название протокола TLS, использовавшееся до того, как он стал стандартом в RFC 2246, и название "SSL" часто используется в качестве универсального названия протоколов TLS.</span><span class="sxs-lookup"><span data-stu-id="16c78-113">*Secure Sockets Layer* (SSL) was the original name of TLS before it became a standard in RFC 2246 and "SSL" is often used as a generic name for the TLS protocols.</span></span> <span data-ttu-id="16c78-114">Последней версией SSL была версия 3.0, а протокол TLS 1.0 иногда называют протоколом SSL версии 3.1.</span><span class="sxs-lookup"><span data-stu-id="16c78-114">The last version of SSL was 3.0, and TLS 1.0 is sometimes referred to as SSL version 3.1.</span></span> <span data-ttu-id="16c78-115">Все версии официального протокола SSL считаются устаревшими и небезопасными, и в настоящее время NetX Secure не предоставляет реализацию SSL.</span><span class="sxs-lookup"><span data-stu-id="16c78-115">All versions of the official "SSL" protocol are considered obsolete and insecure and currently NetX Secure does not provide an SSL implementation.</span></span>

<span data-ttu-id="16c78-116">TLS задает протокол для создания *ключей сеанса*, которые создаются во время *подтверждения* TLS между клиентом и сервером TLS. Эти ключи используются для шифрования данных, отправляемых приложением во время *сеанса* TLS.</span><span class="sxs-lookup"><span data-stu-id="16c78-116">TLS specifies a protocol to generate *session keys* which are created during the TLS *handshake* between a TLS client and server and those keys are used to encrypt data sent by the application during the TLS *session.*</span></span>

<span data-ttu-id="16c78-117">Данные TLS делятся на *записи*, которые концептуально аналогичны пакету TCP.</span><span class="sxs-lookup"><span data-stu-id="16c78-117">TLS data is divided into *records* which are equivalent in concept to a TCP packet.</span></span> <span data-ttu-id="16c78-118">Каждая запись TLS содержит заголовок, а зашифрованные записи TLS также содержат примечание (хэш контрольной суммы).</span><span class="sxs-lookup"><span data-stu-id="16c78-118">Every TLS record has a header, and TLS encrypted records also have a footer (checksum hash).</span></span> <span data-ttu-id="16c78-119">Записи подтверждения TLS имеют дополнительный заголовок, инкапсулированный в запись TLS большего размера.</span><span class="sxs-lookup"><span data-stu-id="16c78-119">TLS handshake records have an additional header encapsulated within the larger TLS record.</span></span> <span data-ttu-id="16c78-120">Запись TLS инкапсулирована сетевым протоколом транспортного уровня аналогично тому, как пакет TCP инкапсулирован IP-пакетом.</span><span class="sxs-lookup"><span data-stu-id="16c78-120">The TLS record is encapsulated by the  transport layer network protocol in the same manner that a TCP packet is encapsulated by an IP packet.</span></span>

### <a name="tls-13"></a><span data-ttu-id="16c78-121">Протокол TLS 1.3</span><span class="sxs-lookup"><span data-stu-id="16c78-121">TLS 1.3</span></span>

<span data-ttu-id="16c78-122">В августе 2018 года спецификация TLS 1.3 была завершена.</span><span class="sxs-lookup"><span data-stu-id="16c78-122">In August 2018, the TLS 1.3 specification was finalized.</span></span> <span data-ttu-id="16c78-123">Новая версия протокола претерпела довольно значительные изменения, которые затронули некоторые фундаментальные аспекты базовой безопасности и производительности TLS.</span><span class="sxs-lookup"><span data-stu-id="16c78-123">The new version of the protocol is a fairly significant update that changes some fundamental aspects of the underlying security and performance of TLS.</span></span> <span data-ttu-id="16c78-124">Однако эти изменения в основном невидимы для обычного пользователя TLS, так как они относятся в первую очередь к конечному автомату подтверждения TLS и созданию ключей сеанса.</span><span class="sxs-lookup"><span data-stu-id="16c78-124">However, these changes are largely invisible to the typical TLS user since they apply primarily to the TLS handshake state machine and session key generation.</span></span> <span data-ttu-id="16c78-125">Кроме того, был добавлен ряд дополнительных функций и расширений.</span><span class="sxs-lookup"><span data-stu-id="16c78-125">A number of optional features and extensions were added as well.</span></span> <span data-ttu-id="16c78-126">Ниже приведена сводка внесенных изменений и их влияние на функциональные возможности TLS.</span><span class="sxs-lookup"><span data-stu-id="16c78-126">The following is a summary of the changes and how they impact TLS functionality.</span></span>

- <span data-ttu-id="16c78-127">Конечный автомат подтверждения был оптимизирован за счет удаления всего обмена сообщениями от сервера.</span><span class="sxs-lookup"><span data-stu-id="16c78-127">The handshake state machine was optimized by removing an entire exchange of messages by the server.</span></span>
- <span data-ttu-id="16c78-128">Создание ключей было изменено для использования стандартизованной процедуры HKDF (функция формирования ключа на основе HMAC), и ключи сеанса привязываются ко всем сообщениям подтверждения (а не к некоторым выбранным параметрам).</span><span class="sxs-lookup"><span data-stu-id="16c78-128">Key generation was updated to use a standardized routine called HKDF (HMAC-based Key Derivation Function) and ties the session keys to all of the handshake messages (instead of a few select parameters).</span></span>
- <span data-ttu-id="16c78-129">Все комплекты шифров TLS 1.2 и более ранних версий являются нерекомендуемыми и несовместимы с протоколом TLS 1.3.</span><span class="sxs-lookup"><span data-stu-id="16c78-129">All TLS 1.2 and earlier ciphersuites are deprecated and are incompatible with TLS 1.3.</span></span> <span data-ttu-id="16c78-130">Аналогичным образом, все комплекты шифров TLS 1.3 не могут использоваться в предыдущих версиях протокола.</span><span class="sxs-lookup"><span data-stu-id="16c78-130">Similarly, all TLS 1.3 ciphersuites are unusable with previous versions.</span></span>
- <span data-ttu-id="16c78-131">Все комплекты шифров TLS 1.3 обеспечивают полную безопасность пересылки (PFS) с использованием временных ключей<sup>6</sup>.</span><span class="sxs-lookup"><span data-stu-id="16c78-131">All TLS 1.3 ciphersuites provide Perfect Forward Secrecy (PFS) using ephemeral keys<sup>6</sup></span></span> 
- <span data-ttu-id="16c78-132">Протокол TLS 1.3 удаляет "код проверки подлинности сообщения" (MAC) из каждой записи и использует шифры AEAD<sup>7</sup>.</span><span class="sxs-lookup"><span data-stu-id="16c78-132">TLS 1.3 removes the "message authentication code" (MAC) in each record in favor of using AEAD<sup>7</sup> ciphers</span></span>
- <span data-ttu-id="16c78-133">Были добавлены некоторые дополнительные функции, включая 0-RTT (нулевое время кругового пути), что позволяет отправлять данные приложений во время подтверждения.</span><span class="sxs-lookup"><span data-stu-id="16c78-133">Some additional optional features were added, including 0-RTT (Zero Round Trip Time) which allows for application data to be sent during the handshake.</span></span> <span data-ttu-id="16c78-134">Функция 0-RTT является абсолютно необязательной и сейчас не поддерживается в TLS для ОСРВ Azure.</span><span class="sxs-lookup"><span data-stu-id="16c78-134">0-RTT is purely optional and is not currently supported in Azure RTOS TLS.</span></span>

<span data-ttu-id="16c78-135">Протокол TLS 1.3 не оказывает существенного влияния на приложения пользователя.</span><span class="sxs-lookup"><span data-stu-id="16c78-135">TLS 1.3 does not significantly affect user applications.</span></span> <span data-ttu-id="16c78-136">API остается одинаковым в разных версиях, а комплекты шифров помечаются так, чтобы можно было использовать одну таблицу комплектов шифров.</span><span class="sxs-lookup"><span data-stu-id="16c78-136">The API remains exactly the same between versions, and ciphersuites are marked so a single ciphersuite table may be used.</span></span>

<span data-ttu-id="16c78-137">Для использования протокола TLS 1.3 макрос NX_SECURE_TLS_ENABLE_TLS_1_3 должен быть глобально определен.</span><span class="sxs-lookup"><span data-stu-id="16c78-137">In order to use TLS 1.3, the macro NX_SECURE_TLS_ENABLE_TLS_1_3 must be globally defined.</span></span> <span data-ttu-id="16c78-138">Протокол TLS 1.3 по умолчанию отключен в TLS для ОСРВ Azure.</span><span class="sxs-lookup"><span data-stu-id="16c78-138">TLS 1.3 is disabled by default in Azure RTOS TLS.</span></span>

6. <span data-ttu-id="16c78-139">"Временные" ключи — это пары асимметричных ключей, которые создаются во время подтверждения TLS и используются для обмена секретами только для этого сеанса.</span><span class="sxs-lookup"><span data-stu-id="16c78-139">“Ephemeral” keys are asymmetric key pairs that are generated during the TLS handshake and used for the secrets exchange for only that session.</span></span> <span data-ttu-id="16c78-140">Пара ключей удаляется после использования. Это не позволит злоумышленнику получить доступ к зашифрованным данным в записанном сеансе TLS, даже если закрытый ключ сертификата будет скомпрометирован в будущем, что и обеспечивает полную безопасность пересылки.</span><span class="sxs-lookup"><span data-stu-id="16c78-140">They key pair is discarded after use – this prevents an attacker from being able to access encrypted data in a recorded TLS session even if a certificate private key is compromised at any time in the future – hence “Perfect Forward Secrecy”.</span></span>

7. <span data-ttu-id="16c78-141">Шифрование с проверкой подлинности с помощью связанных данных — это режим для таких шифров, как AES, который сочетает в одной операции шифрование и проверку целостности, устраняя необходимость в отдельном хэше данных для проверки целостности.</span><span class="sxs-lookup"><span data-stu-id="16c78-141">Authenticated Encryption with Associated Data – a mode for ciphers like AES that combines encryption and integrity checking in a single operation, eliminating the need for a separate hash of the data for integrity checking.</span></span>

### <a name="tls-record-header"></a><span data-ttu-id="16c78-142">Заголовок записи TLS</span><span class="sxs-lookup"><span data-stu-id="16c78-142">TLS Record header</span></span>

<span data-ttu-id="16c78-143">Любая допустимая запись TLS должна содержать заголовок TLS, как показано в разделе "Ошибка.</span><span class="sxs-lookup"><span data-stu-id="16c78-143">Any valid TLS record must have a TLS header, as shown in Error!</span></span> <span data-ttu-id="16c78-144">Источник ссылки не найден".</span><span class="sxs-lookup"><span data-stu-id="16c78-144">Reference source not found.</span></span>

![Схема заголовка записи TLS.](media/image2.png)

<span data-ttu-id="16c78-146">Рисунок 1. Заголовок записи TLS</span><span class="sxs-lookup"><span data-stu-id="16c78-146">Figure 1 - TLS record header</span></span>

<span data-ttu-id="16c78-147">Ниже приведены определения полей заголовка записи TLS.</span><span class="sxs-lookup"><span data-stu-id="16c78-147">The fields of the TLS record header are defined as follows:</span></span>

| <span data-ttu-id="16c78-148">Поле заголовка TLS</span><span class="sxs-lookup"><span data-stu-id="16c78-148">TLS Header Field</span></span> | <span data-ttu-id="16c78-149">Назначение</span><span class="sxs-lookup"><span data-stu-id="16c78-149">Purpose</span></span>     |
| ---------------- | ------------- |
| <span data-ttu-id="16c78-150">**8 разрядов: тип сообщения**</span><span class="sxs-lookup"><span data-stu-id="16c78-150">**8-bit Message Type**</span></span> | <span data-ttu-id="16c78-151">Это поле содержит тип отправляемой записи TLS.</span><span class="sxs-lookup"><span data-stu-id="16c78-151">This field contains the type of TLS record being sent.</span></span> <span data-ttu-id="16c78-152">Допустимые типы:</span><span class="sxs-lookup"><span data-stu-id="16c78-152">Valid types are as follows:</span></span><br /><span data-ttu-id="16c78-153">- ChangeCipherSpec<sup>8</sup>: 0x14;</span><span class="sxs-lookup"><span data-stu-id="16c78-153">- ChangeCipherSpec<sup>8</sup>: 0x14</span></span><br /><span data-ttu-id="16c78-154">- оповещение: 0x15;</span><span class="sxs-lookup"><span data-stu-id="16c78-154">- Alert: 0x15</span></span><br /><span data-ttu-id="16c78-155">- подтверждение: 0x16;</span><span class="sxs-lookup"><span data-stu-id="16c78-155">- Handshake: 0x16</span></span><br /><span data-ttu-id="16c78-156">- данные приложения: 0x17.</span><span class="sxs-lookup"><span data-stu-id="16c78-156">- Application Data: 0x17</span></span> |
| <span data-ttu-id="16c78-157">**16 разрядов: версия протокола**</span><span class="sxs-lookup"><span data-stu-id="16c78-157">**16-bit Protocol Version**</span></span> | <span data-ttu-id="16c78-158">Это поле содержит версию протокола TLS.</span><span class="sxs-lookup"><span data-stu-id="16c78-158">This field contains the TLS protocol version.</span></span> <span data-ttu-id="16c78-159">Допустимы следующие значения:</span><span class="sxs-lookup"><span data-stu-id="16c78-159">Valid values are as follows:</span></span><br /><span data-ttu-id="16c78-160">- SSL 3.0: 0x0300;</span><span class="sxs-lookup"><span data-stu-id="16c78-160">- SSL 3.0: 0x0300</span></span><br /><span data-ttu-id="16c78-161">- TLS 1.0: 0x0301;</span><span class="sxs-lookup"><span data-stu-id="16c78-161">- TLS 1.0: 0x0301</span></span><br /><span data-ttu-id="16c78-162">- TLS 1.1: 0x0302;</span><span class="sxs-lookup"><span data-stu-id="16c78-162">- TLS 1.1: 0x0302</span></span><br /><span data-ttu-id="16c78-163">- TLS 1.2: 0x0303;</span><span class="sxs-lookup"><span data-stu-id="16c78-163">- TLS 1.2: 0x0303</span></span><br /><span data-ttu-id="16c78-164">- **TLS 1.3 <sup>9</sup>** : **0x0303**.</span><span class="sxs-lookup"><span data-stu-id="16c78-164">- **TLS 1.3 <sup>9</sup>**: **0x0303**</span></span> |
| <span data-ttu-id="16c78-165">**16 разрядов: длина**</span><span class="sxs-lookup"><span data-stu-id="16c78-165">**16-bit Length**</span></span> | <span data-ttu-id="16c78-166">Это поле содержит длину данных, инкапсулированных в запись TLS.</span><span class="sxs-lookup"><span data-stu-id="16c78-166">This field contains the length of the data encapsulated in the TLS record.</span></span> |

8. <span data-ttu-id="16c78-167">В протоколе TLS 1.3 сообщение ChangeCipherSpec больше не используется, хотя оно по-прежнему может быть отправлено для обеспечения совместимости, и в этом случае сообщение игнорируется.</span><span class="sxs-lookup"><span data-stu-id="16c78-167">In TLS 1.3 the ChangeCipherSpec message is no longer used, though it still may be sent for compatibility reasons in which case the message is ignored.</span></span>

9. <span data-ttu-id="16c78-168">Следуя этой схеме, формально протокол TLS 1.3 должен был бы использовать значение 0x0304. Но этот протокол был изменен так, чтобы в расширении использовалась фактическая версия протокола, поэтому все записи TLS 1.3 содержат 0x0303 в поле версии протокола для обеспечения обратной совместимости.</span><span class="sxs-lookup"><span data-stu-id="16c78-168">TLS 1.3 would technically have a value of 0x0304 if this scheme was continued, but the protocol was changed to have the actual protocol version in an extension, so all TLS 1.3 records use 0x0303 in protocol version fields for backward-compatibility.</span></span>

### <a name="tls-handshake-record-header"></a><span data-ttu-id="16c78-169">Заголовок записи подтверждения TLS</span><span class="sxs-lookup"><span data-stu-id="16c78-169">TLS Handshake Record header</span></span>

<span data-ttu-id="16c78-170">Любая допустимая запись подтверждения TLS должна содержать заголовок подтверждения TLS, как показано на рисунке 2.</span><span class="sxs-lookup"><span data-stu-id="16c78-170">Any valid TLS handshake record must have a TLS Handshake header, as shown in Figure 2.</span></span>

![Схема заголовка записи подтверждения TLS.](media/image3.png)

<span data-ttu-id="16c78-172">Рисунок 2. Заголовок записи подтверждения TLS</span><span class="sxs-lookup"><span data-stu-id="16c78-172">Figure 2 - TLS Handshake record header</span></span>

<span data-ttu-id="16c78-173">Ниже приведены определения полей заголовка записи подтверждения TLS.</span><span class="sxs-lookup"><span data-stu-id="16c78-173">The fields of the TLS Handshake record header are defined as follows:</span></span>

| <span data-ttu-id="16c78-174">Поле заголовка TLS</span><span class="sxs-lookup"><span data-stu-id="16c78-174">TLS Header Field</span></span> | <span data-ttu-id="16c78-175">Назначение</span><span class="sxs-lookup"><span data-stu-id="16c78-175">Purpose</span></span> |
| ---------------- |----------------------- |
| <span data-ttu-id="16c78-176">**8 разрядов: тип сообщения**</span><span class="sxs-lookup"><span data-stu-id="16c78-176">**8-bit Message Type**</span></span> | <span data-ttu-id="16c78-177">Это поле содержит тип отправляемой записи TLS.</span><span class="sxs-lookup"><span data-stu-id="16c78-177">This field contains the type of TLS record being sent.</span></span> <span data-ttu-id="16c78-178">Допустимые типы:</span><span class="sxs-lookup"><span data-stu-id="16c78-178">Valid types are as follows:</span></span><br /><span data-ttu-id="16c78-179">- ChangeCipherSpec<sup>10</sup>: 0x14;</span><span class="sxs-lookup"><span data-stu-id="16c78-179">- ChangeCipherSpec<sup>10</sup>: 0x14</span></span><br /><span data-ttu-id="16c78-180">- Alert: 0x15;</span><span class="sxs-lookup"><span data-stu-id="16c78-180">- Alert: 0x15</span></span><br /><span data-ttu-id="16c78-181">- Handshake: 0x16;</span><span class="sxs-lookup"><span data-stu-id="16c78-181">- Handshake: 0x16</span></span><br /><span data-ttu-id="16c78-182">- данные приложения: 0x17.</span><span class="sxs-lookup"><span data-stu-id="16c78-182">- Application Data: 0x17</span></span> |
| <span data-ttu-id="16c78-183">**16 разрядов: версия протокола**</span><span class="sxs-lookup"><span data-stu-id="16c78-183">**16-bit Protocol Version**</span></span> | <span data-ttu-id="16c78-184">Это поле содержит версию протокола TLS.</span><span class="sxs-lookup"><span data-stu-id="16c78-184">This field contains the TLS protocol version.</span></span> <span data-ttu-id="16c78-185">Допустимы следующие значения:</span><span class="sxs-lookup"><span data-stu-id="16c78-185">Valid values are as follows:</span></span><br /><span data-ttu-id="16c78-186">- SSL 3.0: 0x0300;</span><span class="sxs-lookup"><span data-stu-id="16c78-186">- SSL 3.0: 0x0300</span></span><br /><span data-ttu-id="16c78-187">- TLS 1.0: 0x0301;</span><span class="sxs-lookup"><span data-stu-id="16c78-187">- TLS 1.0: 0x0301</span></span><br /><span data-ttu-id="16c78-188">- TLS 1.1: 0x0302;</span><span class="sxs-lookup"><span data-stu-id="16c78-188">- TLS 1.1: 0x0302</span></span><br /><span data-ttu-id="16c78-189">- TLS 1.2: 0x0303;</span><span class="sxs-lookup"><span data-stu-id="16c78-189">- TLS 1.2: 0x0303</span></span><br /><span data-ttu-id="16c78-190">- **TLS 1.3 <sup>11</sup>** : **0x0303**.</span><span class="sxs-lookup"><span data-stu-id="16c78-190">- **TLS 1.3 <sup>11</sup>**: **0x0303**</span></span> |
| <span data-ttu-id="16c78-191">**16 разрядов: длина**</span><span class="sxs-lookup"><span data-stu-id="16c78-191">**16-bit Length**</span></span>    | <span data-ttu-id="16c78-192">Это поле содержит длину данных, инкапсулированных в запись TLS.</span><span class="sxs-lookup"><span data-stu-id="16c78-192">This field contains the length of the data encapsulated in the TLS record.</span></span> |
| <span data-ttu-id="16c78-193">**8 разрядов: тип подтверждения**</span><span class="sxs-lookup"><span data-stu-id="16c78-193">**8-bit Handshake Type**</span></span> | <span data-ttu-id="16c78-194">Это поле содержит тип сообщения подтверждения.</span><span class="sxs-lookup"><span data-stu-id="16c78-194">This field contains the handshake message type.</span></span> <span data-ttu-id="16c78-195">Допустимы следующие значения (\* сообщения, **выделенные жирным шрифтом**, добавлены в протокол TLS 1.3):</span><span class="sxs-lookup"><span data-stu-id="16c78-195">Valid values are as follows (\*messages in **bold** were added in TLS 1.3):</span></span><br /><span data-ttu-id="16c78-196">- HelloRequest: 0x00;</span><span class="sxs-lookup"><span data-stu-id="16c78-196">- HelloRequest: 0x00</span></span><br /><span data-ttu-id="16c78-197">- ClientHello: 0x01;</span><span class="sxs-lookup"><span data-stu-id="16c78-197">- ClientHello: 0x01</span></span><br /><span data-ttu-id="16c78-198">- ServerHello: 0x02;</span><span class="sxs-lookup"><span data-stu-id="16c78-198">- ServerHello: 0x02</span></span><br /><span data-ttu-id="16c78-199">- **HelloVerifyRequest**: **0x03**;</span><span class="sxs-lookup"><span data-stu-id="16c78-199">- **HelloVerifyRequest**: **0x03**</span></span><br /><span data-ttu-id="16c78-200">- **NewSessionTicket**: **0x04**;</span><span class="sxs-lookup"><span data-stu-id="16c78-200">- **NewSessionTicket**: **0x04**</span></span><br /><span data-ttu-id="16c78-201">- **EndOfEarlyData**: **0x05**;</span><span class="sxs-lookup"><span data-stu-id="16c78-201">- **EndOfEarlyData**: **0x05**</span></span><br /><span data-ttu-id="16c78-202">- **EncryptedExtensions**: **0x08**;</span><span class="sxs-lookup"><span data-stu-id="16c78-202">- **EncryptedExtensions**: **0x08**</span></span><br /><span data-ttu-id="16c78-203">- Certificate: 0x0B;</span><span class="sxs-lookup"><span data-stu-id="16c78-203">- Certificate: 0x0B</span></span><br /><span data-ttu-id="16c78-204">- ServerKeyExchange: 0x0C;</span><span class="sxs-lookup"><span data-stu-id="16c78-204">- ServerKeyExchange: 0x0C</span></span><br /><span data-ttu-id="16c78-205">- CertificateRequest: 0x0D;</span><span class="sxs-lookup"><span data-stu-id="16c78-205">- CertificateRequest: 0x0D</span></span><br /><span data-ttu-id="16c78-206">- ServerHelloDone: 0x0E;</span><span class="sxs-lookup"><span data-stu-id="16c78-206">- ServerHelloDone: 0x0E</span></span><br /><span data-ttu-id="16c78-207">- CertificateVerify: 0x0F;</span><span class="sxs-lookup"><span data-stu-id="16c78-207">- CertificateVerify: 0x0F</span></span><br /><span data-ttu-id="16c78-208">- ClientKeyExchange: 0x10;</span><span class="sxs-lookup"><span data-stu-id="16c78-208">- ClientKeyExchange: 0x10</span></span><br /><span data-ttu-id="16c78-209">- Finished: 0x14;</span><span class="sxs-lookup"><span data-stu-id="16c78-209">- Finished: 0x14</span></span><br /><span data-ttu-id="16c78-210">- **KeyUpdate**: **0x18**;</span><span class="sxs-lookup"><span data-stu-id="16c78-210">- **KeyUpdate**: **0x18**</span></span><br /><span data-ttu-id="16c78-211">- **MessageHash**: **0xFE**.</span><span class="sxs-lookup"><span data-stu-id="16c78-211">- **MessageHash**: **0xFE**</span></span> |
| <span data-ttu-id="16c78-212">**24 разряда: длина**</span><span class="sxs-lookup"><span data-stu-id="16c78-212">**24-bit Length**</span></span>    | <span data-ttu-id="16c78-213">Это поле содержит длину данных сообщения подтверждения.</span><span class="sxs-lookup"><span data-stu-id="16c78-213">This field contains the length of the handshake message data.</span></span> |

10. <span data-ttu-id="16c78-214">В протоколе TLS 1.3 сообщение ChangeCipherSpec больше не используется, хотя оно по-прежнему может быть отправлено для обеспечения совместимости, и в этом случае сообщение игнорируется.</span><span class="sxs-lookup"><span data-stu-id="16c78-214">In TLS 1.3 the ChangeCipherSpec message is no longer used, though it still may be sent for compatibility reasons in which case the message is ignored.</span></span>

11. <span data-ttu-id="16c78-215">Следуя этой схеме, формально протокол TLS 1.3 должен был бы использовать значение 0x0304. Но этот протокол был изменен так, чтобы в расширении использовалась фактическая версия протокола, поэтому все записи TLS 1.3 содержат 0x0303 в поле версии протокола для обеспечения обратной совместимости.</span><span class="sxs-lookup"><span data-stu-id="16c78-215">TLS 1.3 would technically have a value of 0x0304 if this scheme was continued, but the protocol was changed to have the actual protocol version in an extension, so all TLS 1.3 records use 0x0303 in protocol version fields for backward-compatibility.</span></span>

### <a name="the-tls-handshake-and-tls-session"></a><span data-ttu-id="16c78-216">Подтверждение TLS и сеанс TLS</span><span class="sxs-lookup"><span data-stu-id="16c78-216">The TLS Handshake and TLS Session</span></span>

<span data-ttu-id="16c78-217">Типичное подтверждение TLS (версий 1.0–1.2) показано на рисунке 3.</span><span class="sxs-lookup"><span data-stu-id="16c78-217">A typical TLS handshake (versions 1.0-1.2) is shown in Figure 3.</span></span> <span data-ttu-id="16c78-218">Подтверждение TLS начинается, когда клиент TLS отправляет сообщение *ClientHello* на сервер TLS, указывая необходимость начать сеанс TLS.</span><span class="sxs-lookup"><span data-stu-id="16c78-218">A TLS handshake begins when the TLS Client sends a *ClientHello* message to a TLS server, indicating its desire to start a TLS session.</span></span> <span data-ttu-id="16c78-219">Это сообщение содержит сведения о шифровании, которое клиент предпочитает использовать для сеанса, а также данные, используемые для создания ключей сеанса позже при подтверждении.</span><span class="sxs-lookup"><span data-stu-id="16c78-219">The message contains information about the encryption the client would like to use for the session, along with information used to generate the session keys later in the handshake.</span></span> <span data-ttu-id="16c78-220">Пока не созданы ключи сеанса, все сообщения в подтверждении TLS не шифруются.</span><span class="sxs-lookup"><span data-stu-id="16c78-220">Until the session keys are generated, all messages in the TLS handshake are not encrypted.</span></span> <span data-ttu-id="16c78-221">В протоколе TLS 1.3 подтверждение несколько изменено. Дополнительные сведения об этом представлены в следующем разделе.</span><span class="sxs-lookup"><span data-stu-id="16c78-221">TLS 1.3 changes the handshake somewhat – details are presented in the next section.</span></span>

<span data-ttu-id="16c78-222">Сервер TLS отвечает на ClientHello с сообщением ServerHello, указывающим на выбор варианта шифрования, предоставленного клиентом.</span><span class="sxs-lookup"><span data-stu-id="16c78-222">The TLS Server responds to the ClientHello with a ServerHello message, indicating a selection from the encryption options provided by the client.</span></span> <span data-ttu-id="16c78-223">За сообщением ServerHello следует сообщение Certificate, в котором сервер предоставляет цифровой сертификат для проверки подлинности клиента.</span><span class="sxs-lookup"><span data-stu-id="16c78-223">The ServerHello is followed by a Certificate message, in which the server provides a digital certificate to authenticate its identity to the client.</span></span> <span data-ttu-id="16c78-224">Наконец, сервер отправляет сообщение ServerHelloDone, указывающее, что отправлены все сообщения.</span><span class="sxs-lookup"><span data-stu-id="16c78-224">Finally, the server sends a ServerHelloDone message to indicate it has no more messages to send.</span></span> <span data-ttu-id="16c78-225">Сервер может дополнительно отправлять и другие сообщения после сообщения ServerHello, а в некоторых случаях он может не отправлять сообщение Certificate, поэтому потребуется сообщение ServerHelloDone.</span><span class="sxs-lookup"><span data-stu-id="16c78-225">The server may optionally send other messages following the ServerHello and in some cases it may not send a Certificate message, hence the need for the ServerHelloDone message.</span></span>

<span data-ttu-id="16c78-226">После того как клиент получит все сообщения сервера, у него будет достаточно сведений для создания ключей сеанса.</span><span class="sxs-lookup"><span data-stu-id="16c78-226">Once the client has received all the server's messages, it has enough information to generate the session keys.</span></span> <span data-ttu-id="16c78-227">Для этого протокол TLS создает общий фрагмент случайных данных, называемый *предварительной главной копией секрета*, который имеет фиксированный размер и используется в качестве начального значения для создания всех необходимых ключей после включения шифрования.</span><span class="sxs-lookup"><span data-stu-id="16c78-227">TLS does this by creating a shared bit of random data called the *Pre-Master Secret*, which is a fixed-size and is used as a seed to generate all the keys needed once encryption is enabled.</span></span> <span data-ttu-id="16c78-228">Предварительная главная копия секрета шифруется с помощью алгоритма с открытым ключом (например, RSA), указанного в сообщениях Hello (дополнительные сведения об алгоритмах с открытым ключом см. ниже), и открытого ключа, предоставленного сервером в его сертификате.</span><span class="sxs-lookup"><span data-stu-id="16c78-228">The Pre-Master Secret is encrypted using the public key algorithm (e.g. RSA) specified in the Hello messages (see below for information on public key algorithms) and the public key provided by the server in its certificate.</span></span> <span data-ttu-id="16c78-229">Необязательная функция TLS, называемая общими ключами (PSK), включает в себя комплекты шифров, которые не используют сертификат, а вместо этого используют значение секрета, которое передается между узлами (как правило, путем физического перемещения или другого безопасного метода).</span><span class="sxs-lookup"><span data-stu-id="16c78-229">An optional TLS feature called Pre-Shared Keys (PSK) enables ciphersuites that do not use a certificate but instead use a secret value shared between the hosts (usually through physical transfer or other secured method).</span></span> <span data-ttu-id="16c78-230">Предварительная главная копия секрета создается с помощью общего секрета, а не передается в зашифрованном сообщении.</span><span class="sxs-lookup"><span data-stu-id="16c78-230">The shared secret is used to generate the Pre-Master Secret instead of using an encrypted message to send the Pre-Master Secret.</span></span> <span data-ttu-id="16c78-231">Ознакомьтесь с разделом, посвященным общим ключам, ниже.</span><span class="sxs-lookup"><span data-stu-id="16c78-231">See the section on Pre-Shared Keys below.</span></span>

<span data-ttu-id="16c78-232">Зашифрованная предварительная главная копия секрета передается на сервер в сообщении ClientKeyExchange.</span><span class="sxs-lookup"><span data-stu-id="16c78-232">The encrypted Pre-Master Secret is sent to the server in the ClientKeyExchange message.</span></span> <span data-ttu-id="16c78-233">При получении сообщения ClientKeyExchange сервер расшифровывает предварительную главную копию секрета с помощью своего закрытого ключа и продолжает создавать ключи сеанса одновременно с клиентом TLS.</span><span class="sxs-lookup"><span data-stu-id="16c78-233">The server, upon receiving the ClientKeyExchange message, decrypts the Pre-Master Secret using its private key and proceeds to generate the session keys in parallel with the TLS client.</span></span>

<span data-ttu-id="16c78-234">После создания ключей сеанса все последующие сообщения могут быть зашифрованы с помощью алгоритма с закрытым ключом (например, AES), выбранного в сообщениях Hello.</span><span class="sxs-lookup"><span data-stu-id="16c78-234">Once the session keys are generated, all further messages can be encrypted using the private-key algorithm (e.g. AES) selected in the Hello messages.</span></span> <span data-ttu-id="16c78-235">Одно завершающее незашифрованное сообщение, именуемое ChangeCipherSpec, отправляет как клиент, так и сервер, чтобы указать, что все последующие сообщения будут зашифрованы.</span><span class="sxs-lookup"><span data-stu-id="16c78-235">One final un-encrypted message called ChangeCipherSpec is sent by both the client and server to indicate that all further messages will be encrypted.</span></span>

<span data-ttu-id="16c78-236">Первое зашифрованное сообщение, отправленное и клиентом, и сервером, также является завершающим сообщением подтверждения TLS, именуемым Finished.</span><span class="sxs-lookup"><span data-stu-id="16c78-236">The first encrypted message sent by both the client and server is also the final TLS handshake message, called Finished.</span></span> <span data-ttu-id="16c78-237">Это сообщение содержит хэш всех полученных и отправленных сообщений подтверждения.</span><span class="sxs-lookup"><span data-stu-id="16c78-237">This message contains a hash of all the handshake messages received and sent.</span></span> <span data-ttu-id="16c78-238">Этот хэш используется, чтобы проверить, что ни одно из сообщений в подтверждении не было изменено или повреждено (что может указывать на нарушение безопасности).</span><span class="sxs-lookup"><span data-stu-id="16c78-238">This hash is used to verify that none of the messages in the handshake have been tampered with or corrupted (indicating a possible breach of security).</span></span>

<span data-ttu-id="16c78-239">После получения сообщений Finished и проверки хэшей подтверждения начинается сеанс TLS. Приложение начинает отправку и получение данных.</span><span class="sxs-lookup"><span data-stu-id="16c78-239">Once the Finished messages are received and the handshake hashes are verified, the TLS session begins, and the application begins sending and receiving data.</span></span> <span data-ttu-id="16c78-240">Все данные, отправляемые любой из сторон во время сеанса TLS, сначала хэшируются с помощью хэш-алгоритма, выбранного в сообщениях Hello (для обеспечения целостности сообщений), и шифруются с помощью выбранного алгоритма с закрытым ключом и созданных ключей сеанса.</span><span class="sxs-lookup"><span data-stu-id="16c78-240">All data sent by either side during the TLS session is first hashed using the hash algorithm chosen in the Hello messages (to provide message integrity) and encrypted using the chosen private-key algorithm with the generated session keys.</span></span>

<span data-ttu-id="16c78-241">Наконец, сеанс TLS может быть успешно завершен только в том случае, если это действие выбрал клиент или сервер.</span><span class="sxs-lookup"><span data-stu-id="16c78-241">Finally, a TLS session can only be successfully ended if either the Client or Server chooses to do so.</span></span> <span data-ttu-id="16c78-242">Усеченный сеанс считается нарушением безопасности, так как злоумышленник может попытаться предотвратить получение всех данных. Поэтому, когда одна из сторон желает завершить сеанс, передается специальное уведомление, которое называется оповещением CloseNotify.</span><span class="sxs-lookup"><span data-stu-id="16c78-242">A truncated session is considered a security breach (since an attacker may be attempting to prevent all the data being sent from being received) so a special notification is sent when either side wants to end the session, called a CloseNotify alert.</span></span> <span data-ttu-id="16c78-243">Как клиент, так и сервер должны отправить и обработать оповещение CloseNotify, чтобы успешно завершить сеанс.</span><span class="sxs-lookup"><span data-stu-id="16c78-243">Both the client and server must send and process a CloseNotify alert for a successful session shutdown.</span></span>

![Схема типичного подтверждения TLS.](media/image4.png)

<span data-ttu-id="16c78-245">Рисунок 3. Типичное подтверждение TLS</span><span class="sxs-lookup"><span data-stu-id="16c78-245">Figure 3- Typical TLS handshake</span></span>

### <a name="tls-13-handshake"></a><span data-ttu-id="16c78-246">Подтверждение TLS 1.3</span><span class="sxs-lookup"><span data-stu-id="16c78-246">TLS 1.3 Handshake</span></span>

<span data-ttu-id="16c78-247">Протокол TLS 1.3 достаточно радикально изменен по сравнению с протоколом TLS.</span><span class="sxs-lookup"><span data-stu-id="16c78-247">TLS 1.3 is a fairly major overhaul of the TLS protocol.</span></span> <span data-ttu-id="16c78-248">Большинство изменений было внесено в процесс подтверждения, чтобы повысить безопасность и производительность.</span><span class="sxs-lookup"><span data-stu-id="16c78-248">The vast majority of the changes were made to the handshake to increase security and performance.</span></span> <span data-ttu-id="16c78-249">Типичное подтверждение TLS 1.3 показано на рисунке 4.</span><span class="sxs-lookup"><span data-stu-id="16c78-249">A typical TLS 1.3 handshake is shown in Figure 4.</span></span> <span data-ttu-id="16c78-250">Основное различие можно увидеть в количестве обменов данными между сервером и клиентом.</span><span class="sxs-lookup"><span data-stu-id="16c78-250">The primary difference can be seen in the number of exchanges between the server and client.</span></span>

<span data-ttu-id="16c78-251">В протоколе TLS 1.2 и более ранних версиях сервер отправлял две серии сообщений<sup>12</sup> — сначала сообщение ServerHello, а затем сообщение ChangeCipherSpec, после чего отправлял зашифрованное сообщение Finished, завершающее подтверждение.</span><span class="sxs-lookup"><span data-stu-id="16c78-251">In TLS 1.2 and earlier, the server would send two flights<sup>12</sup> of messages – first the ServerHello and then a ChangeCipherSpec message before sending the encrypted Finished message that ends the handshake.</span></span> <span data-ttu-id="16c78-252">В протоколе TLS 1.3 сервер отправляет все в первой серии — сообщение ServerHello, расширения, сертификат и сообщение Finished.</span><span class="sxs-lookup"><span data-stu-id="16c78-252">In TLS 1.3, the server sends everything in the first flight – ServerHello, extensions, certificate, and Finished.</span></span> <span data-ttu-id="16c78-253">Сообщение ChangeCipherSpec было удалено, и сервер создает ключи сеанса и начинает шифровать сообщения подтверждения сразу после сообщения ServerHello.</span><span class="sxs-lookup"><span data-stu-id="16c78-253">The ChangeCipherSpec message was eliminated and the server generates its session keys and starts encrypting handshake messages immediately following the ServerHello.</span></span>

<span data-ttu-id="16c78-254">Новая схема означает, что большая часть подтверждения TLS защищена шифрованием. Это ограничивает объем данных в виде открытого текста, к которым злоумышленник может получить доступ.</span><span class="sxs-lookup"><span data-stu-id="16c78-254">The new arrangement means that more of the TLS handshake is protected by encryption, limiting the amount of plaintext data an attacker can access.</span></span> <span data-ttu-id="16c78-255">Кроме того, удаление второй серии сообщений сервера (это были просто сообщение ChangeCipherSpec и следующее за ним сообщение Finished) означает, что клиенту TLS больше не требуется ожидать передачи данных приложения. Как только клиент отправит собственное сообщение Finished, начнется сеанс.</span><span class="sxs-lookup"><span data-stu-id="16c78-255">Additionally, the removal of the second server flight (which was just a ChangeCipherSpec followed by a Finished) means that a TLS client no longer needs to wait to start transmitting application data – as soon as the client sends its own Finished message the session is started.</span></span>

12. <span data-ttu-id="16c78-256">Серия — это просто набор сообщений TLS, отправляемых одновременно.</span><span class="sxs-lookup"><span data-stu-id="16c78-256">A flight is simply a collection of TLS messages sent simultaneously in a group.</span></span>

![Схема подтверждения TLS 1.3.](media/image5.png)

<span data-ttu-id="16c78-258">Рисунок 4. Подтверждение TLS 1.3</span><span class="sxs-lookup"><span data-stu-id="16c78-258">Figure 4 - TLS 1.3 Handshake</span></span>

> [!NOTE]
> <span data-ttu-id="16c78-259">*В протоколе TLS 1.3 также введено понятие "ранние данные" и 0-RTT (нулевое время кругового пути). Это означает, что некоторые данные приложения могут быть отправлены в первой серии сообщений. Эта необязательная функция была добавлена в первую очередь для того, чтобы оптимизировать время отклика веб-браузера (например, чтобы предварительно отправить заголовки HTTP для начала визуализации страницы). Начиная с ОСРВ Azure 6.0 эта функция не поддерживается.*</span><span class="sxs-lookup"><span data-stu-id="16c78-259">*TLS 1.3 also introduced the notion of "Early data" and 0-RTT (Zero Round Trip Time), meaning that some application data can be sent in the first flight of messages. This optional feature was added primarily as an optimization for web browser responsiveness (e.g. to send early HTTP headers to start rendering a page). As of Azure RTOS 6.0 this feature is NOT supported.*</span></span>

### <a name="initialization"></a><span data-ttu-id="16c78-260">Инициализация</span><span class="sxs-lookup"><span data-stu-id="16c78-260">Initialization</span></span>

<span data-ttu-id="16c78-261">Прежде чем использовать NetX Secure TLS, необходимо инициализировать стек NetX TCP/IP или NetX Duo TCP/IP.</span><span class="sxs-lookup"><span data-stu-id="16c78-261">The NetX or NetXDuo TCP/IP stack must be initialized prior to using NetX Secure TLS.</span></span> <span data-ttu-id="16c78-262">Сведения о том, как правильно инициализировать стек TCP/IP, см. в руководстве пользователя NetX или NetX Duo.</span><span class="sxs-lookup"><span data-stu-id="16c78-262">Refer to the NetX or NetXDuo User Guide for information on how to properly initialize the TCP/IP stack.</span></span>

<span data-ttu-id="16c78-263">После инициализации стека TCP/IP NetX можно включить протокол TLS.</span><span class="sxs-lookup"><span data-stu-id="16c78-263">Once the NetX TCP/IP stack has been initialized, TLS can be enabled.</span></span> <span data-ttu-id="16c78-264">На внутреннем уровне передача всего сетевого трафика и обработка TLS выполняется стеком NetX или NetX Duo без необходимости вмешательства пользователя.</span><span class="sxs-lookup"><span data-stu-id="16c78-264">Internally, all TLS network traffic and processing is handled by the NetX/NetXDuo stack without requiring user intervention.</span></span> <span data-ttu-id="16c78-265">Однако протокол TLS накладывает определенные требования, которые должны выполняться отдельно от базового сетевого стека.</span><span class="sxs-lookup"><span data-stu-id="16c78-265">However, TLS has some specific requirements that must be handled separately from the underlying network stack.</span></span> <span data-ttu-id="16c78-266">Эти параметры назначаются блоку управления TLS \***NX_SECURE_TLS_SESSION** _ с помощью службы _ \*_nx_secure_tls_session_create_\*\*.</span><span class="sxs-lookup"><span data-stu-id="16c78-266">These parameters are assigned to the TLS control block called ***NX_SECURE_TLS_SESSION** _ using the _ *_nx_secure_tls_session_create_** service.</span></span>

<span data-ttu-id="16c78-267">Протокол TLS имеет два режима: сервер и клиент, один из которых может быть включен в приложении (но только один режим на сокет NetX). Каждый из режимов имеет собственные требования. Они описаны ниже.</span><span class="sxs-lookup"><span data-stu-id="16c78-267">TLS has two modes, Server and Client, either of which may be enabled in an application (but only one mode per NetX socket), and each have their own specific requirements, detailed below.</span></span>

<span data-ttu-id="16c78-268">В любом режиме для NetX Secure TLS требуется, чтобы сокет TCP (\***NX_TCP_SOCKET** _) был создан и настроен для связи по протоколу TCP с удаленным узлом.</span><span class="sxs-lookup"><span data-stu-id="16c78-268">In either mode, NetX Secure TLS requires a TCP socket (\***NX_TCP_SOCKET** _) to be created and set up for TCP communications with the remote host.</span></span> <span data-ttu-id="16c78-269">Сокет TCP назначается экземпляру сеанса TLS с помощью службы _ \*_nx_secure_tls_session_start_\*\*, как описано ниже.</span><span class="sxs-lookup"><span data-stu-id="16c78-269">The TCP socket is assigned to a TLS session instance with the _ *_nx_secure_tls_session_start_*\* service, detailed below.</span></span>

### <a name="initialization--tls-server"></a><span data-ttu-id="16c78-270">Инициализация — сервер TLS</span><span class="sxs-lookup"><span data-stu-id="16c78-270">Initialization – TLS Server</span></span>

<span data-ttu-id="16c78-271">Помимо сокета TCP для режима сервера NetX Secure TLS требуется *цифровой сертификат*— документ, используемый для идентификации сервера TLS для подключающегося клиента TLS, а также сертификаты, соответствующие *закрытому ключу* (обычно для алгоритма шифрования RSA).</span><span class="sxs-lookup"><span data-stu-id="16c78-271">In addition to a TCP socket, NetX Secure TLS Server mode requires a *Digital Certificate*, which is a document used to identify the TLS server to the connecting TLS client, and the certificates corresponding *Private Key*, usually for the RSA encryption algorithm.</span></span> <span data-ttu-id="16c78-272">Стандарт X.509 Международного союза электросвязи определяет формат сертификата, используемого протоколом TLS, и существует множество служебных программ для создания цифровых сертификатов X.509.</span><span class="sxs-lookup"><span data-stu-id="16c78-272">The International Telecommunications Union X.509 standard specifies the certificate format used by TLS and there are numerous utilities for creating X.509 digital certificates.</span></span>

<span data-ttu-id="16c78-273">Для NetX Secure TLS сертификат X.509 должен быть зашифрован в двоичном формате Distinguished Encoding Rules (DER) ASN.1.</span><span class="sxs-lookup"><span data-stu-id="16c78-273">For NetX Secure TLS, the X.509 certificate must be binary-encoded using the Distinguished Encoding Rules (DER) format of ASN.1.</span></span> <span data-ttu-id="16c78-274">DER — это стандартный сетевой двоичный формат TLS для сертификатов.</span><span class="sxs-lookup"><span data-stu-id="16c78-274">DER is the standard TLS over-the-wire binary format for certificates.</span></span>

<span data-ttu-id="16c78-275">Закрытый ключ, связанный с предоставленным сертификатом, должен быть зашифрован в формате DER с открытым ключом (PKCS) № 1.</span><span class="sxs-lookup"><span data-stu-id="16c78-275">The private key associated with the provided certificate must be in DER-Encoded PKCS#1 format.</span></span> <span data-ttu-id="16c78-276">Закрытый ключ используется только на устройстве и никогда не передается по сети.</span><span class="sxs-lookup"><span data-stu-id="16c78-276">The private key is only used on the device and will never be transmitted over the wire.</span></span> <span data-ttu-id="16c78-277">Обеспечьте безопасность закрытых ключей, так как они обеспечивают защиту при обмене данными по протоколу TLS.</span><span class="sxs-lookup"><span data-stu-id="16c78-277">Keep private keys safe as they provide the security for TLS communications!</span></span>

<span data-ttu-id="16c78-278">Чтобы инициализировать сертификат сервера TLS, приложение должно предоставить указатель на буфер, содержащий сертификат X.509, зашифрованный в формате DER, и (необязательно) данные закрытого ключа RSA, зашифрованные в формате DER с открытым ключом (PKCS) № 1, с помощью службы ***nx_secure_x509_certificate_intialize** _, которая заполняет структуру _ *NX_SECURE_X509_CERT** соответствующими данными сертификата для протокола TLS.</span><span class="sxs-lookup"><span data-stu-id="16c78-278">To initialize the TLS Server certificate, the application must provide a pointer to a buffer containing the DER-encoded X.509 certificate and optional DER-encoded PKCS#1 RSA private key data using the ***nx_secure_x509_certificate_intialize** _ service, which populates the _ *NX_SECURE_X509_CERT** structure with the appropriate certificate data for use by TLS.</span></span>

<span data-ttu-id="16c78-279">После инициализации сертификата сервера его необходимо добавить в блок управления TLS с помощью службы ***nx_secure_tls_local_certificate_add***.</span><span class="sxs-lookup"><span data-stu-id="16c78-279">Once the server certificate has been initialized, it must be added to the TLS control block using the ***nx_secure_tls_local_certificate_add*** service.</span></span>

<span data-ttu-id="16c78-280">После добавления сертификата сервера в блок управления TLS можно использовать сокет, чтобы установить безопасное подключение к серверу TLS.</span><span class="sxs-lookup"><span data-stu-id="16c78-280">Once the server's certificate has been added to the TLS control block, the socket may be used to establish a secure TLS Server connection.</span></span>

### <a name="initialization--tls-client"></a><span data-ttu-id="16c78-281">Инициализация — клиент TLS</span><span class="sxs-lookup"><span data-stu-id="16c78-281">Initialization – TLS Client</span></span>

<span data-ttu-id="16c78-282">Для режима клиента NetX Secure TLS требуется *хранилище доверенных сертификатов*, которое представляет собой коллекцию цифровых сертификатов в кодировке X.509 из доверенных центров сертификации (ЦС).</span><span class="sxs-lookup"><span data-stu-id="16c78-282">NetX Secure TLS Client mode requires a *Trusted Certificate Store*, which is a collection of X.509-encoded digital certificates from trusted Certificate Authorities (CA's).</span></span> <span data-ttu-id="16c78-283">Предполагается, что эти сертификаты являются доверенными для протокола TLS. Они служат базой для проверки подлинности сертификатов, предоставляемых сущностями сервера TLS клиенту NetX Secure TLS.</span><span class="sxs-lookup"><span data-stu-id="16c78-283">These certificates are assumed by the TLS protocol to be "trusted" and serve as the basis for authenticating certificates provided by TLS server entities to NetX Secure TLS Client.</span></span>

<span data-ttu-id="16c78-284">Сертификат доверенного ЦС может быть либо *самозаверяющим*, либо подписанным другим центром сертификации. В последнем случае сертификат называется сертификатом *промежуточного ЦС* (ICA).</span><span class="sxs-lookup"><span data-stu-id="16c78-284">A trusted CA certificate may either be *self-signed* or signed by another CA, in which case that certificate is called an *Intermediate CA* (ICA).</span></span> <span data-ttu-id="16c78-285">В типичном приложении TLS сервер предоставляет сертификаты ICA вместе с сертификатом сервера, но единственным требованием для успешной проверки подлинности является то, что цепочка издателей (сертификатов, используемых для подписи других сертификатов) должна отслеживаться от сертификата сервера до сертификата доверенного ЦС в хранилище доверенных сертификатов.</span><span class="sxs-lookup"><span data-stu-id="16c78-285">In a typical TLS application, the server provides the ICA certificates along with its server certificate, but the only requirement for successful authentication is that a chain of issuers (certificates used to sign other certificates) can be traced from the server certificate back to a trusted CA certificate in the Trusted Certificate Store.</span></span> <span data-ttu-id="16c78-286">Эта цепочка называется  *цепочкой доверия* или *цепочкой сертификатов*.</span><span class="sxs-lookup"><span data-stu-id="16c78-286">This chain is known as a  *chain of trust* or *certificate chain*.</span></span>

<span data-ttu-id="16c78-287">Чтобы инициализировать сертификат доверенного ЦС или сертификат ICA, приложение должно предоставить указатель на буфер, содержащий сертификат X.509, зашифрованный в формате DER, с помощью службы ***nx_secure_x509_certificate_intialize** _, которая заполняет структуру _ *NX_SECURE_X509_CERT** соответствующими данными сертификата для протокола TLS.</span><span class="sxs-lookup"><span data-stu-id="16c78-287">To initialize a trusted CA or ICA certificate, the application must provide a pointer to a buffer containing the DER-encoded X.509 certificate using the ***nx_secure_x509_certificate_intialize** _ service, which populates the _ *NX_SECURE_X509_CERT** structure with the appropriate certificate data for use by TLS.</span></span>

<span data-ttu-id="16c78-288">После этого все доверенные сертификаты, которые были инициализированы, добавляются в блок управления TLS с помощью службы ***nx_secure_tls_trusted_certificate_add***.</span><span class="sxs-lookup"><span data-stu-id="16c78-288">Trusted certificates that have been initialized are then added to the TLS control block using the ***nx_secure_tls_trusted_certificate_add*** service.</span></span> <span data-ttu-id="16c78-289">Сбой при добавлении сертификата приведет к сбою сеанса клиента TLS, так как протокол TLS не сможет проверить подлинность удаленных узлов сервера TLS.</span><span class="sxs-lookup"><span data-stu-id="16c78-289">Failure to add a certificate will cause the TLS Client session to fail as there will be no way for the TLS protocol to authenticate remote TLS server hosts.</span></span>

<span data-ttu-id="16c78-290">Клиенту TLS также требуется выделить место для хранения входящего сертификата сервера (при условии, что не используется режим общего ключа).</span><span class="sxs-lookup"><span data-stu-id="16c78-290">The TLS Client also needs space for the incoming server certificate to be allocated (assuming a Pre-Shared Key mode is not being used).</span></span> <span data-ttu-id="16c78-291">Начиная с NetX Secure TLS 5.12 больше не требуется, чтобы приложение выделяло место для хранения удаленного сертификата.</span><span class="sxs-lookup"><span data-stu-id="16c78-291">As of NetX Secure TLS 5.12, it is no longer necessary for the application to allocate space for remote certificate.</span></span> <span data-ttu-id="16c78-292">Однако устаревший параметр для выделения места для сертификата сервера по-прежнему доступен, а сертификаты, выделенные пользователем, будут использоваться до оптимизации внутреннего буфера сертификатов <sup>13</sup> (дополнительные сведения см. в описании службы ***nx_secure_tls_remote_certificate_allocate***).</span><span class="sxs-lookup"><span data-stu-id="16c78-292">However, the legacy option to allocate space for a server certificate is still available and user-allocated certificates will be used before the internal certificate buffer optimization <sup>13</sup> – see the ***nx_secure_tls_remote_certificate_allocate*** service for more information.</span></span>

<span data-ttu-id="16c78-293">После создания хранилища доверенных сертификатов и выделения пространства для сертификата сервера можно использовать сокет для установления безопасного подключения к клиенту TLS.</span><span class="sxs-lookup"><span data-stu-id="16c78-293">Once the Trusted Certificate Store has been created and space for the server certificate has been allocated, the socket may be used to establish a secure TLS Client connection.</span></span>

13. <span data-ttu-id="16c78-294">Для оптимизации используется "буфер пакетов", предоставляемый приложением пользователя сеансу TLS с помощью службы *nx_secure_tls_session_packet_buffer_set*. Он позволяет выделить структуры анализа X.509 вместо использования предоставленных пользователем структур, используемых в более ранних версиях NetX Secure TLS.</span><span class="sxs-lookup"><span data-stu-id="16c78-294">The optimization utilizes the “packet buffer” supplied by the user application to the tls session using *nx_secure_tls_session_packet_buffer_set* to allocate the X.509 parsing structures instead of using the user-supplied structures used in earlier versions of NetX Secure TLS.</span></span> <span data-ttu-id="16c78-295">Существует небольшая вероятность, что размер цепочки сертификатов превысит размер буфера пакетов. В этом случае можно увеличить размер буфера пакетов или использовать службу *nx_secure_tls _remote_certificate_allocate*, чтобы выделить больше пространства для цепочки сертификатов.</span><span class="sxs-lookup"><span data-stu-id="16c78-295">There is an unlikely possibility of encountering a certificate chain exceeding the size of the packet buffer in which case either the packet buffer size may be increased or *nx_secure_tls _remote_certificate_allocate* may be used to allocate more space for the certificate chain.</span></span>

### <a name="application-interface-calls"></a><span data-ttu-id="16c78-296">Вызовы интерфейса приложения</span><span class="sxs-lookup"><span data-stu-id="16c78-296">Application Interface Calls</span></span>

<span data-ttu-id="16c78-297">Приложения NetX Secure TLS обычно будут выполнять вызовы функций из потоков приложения, работающих в ОСРВ ThreadX.</span><span class="sxs-lookup"><span data-stu-id="16c78-297">NetX Secure TLS applications will typically make function calls from within application threads running under the ThreadX RTOS.</span></span> <span data-ttu-id="16c78-298">В некоторых случаях инициализация, особенно для базовых протоколов сетевого взаимодействия (например, TCP и IP), может быть вызвана из ***tx_application_define*** .</span><span class="sxs-lookup"><span data-stu-id="16c78-298">Some initialization, particularly for the underlying network communications protocols (e.g. TCP and IP) may be called from \***tx_application_define\*.**</span></span> <span data-ttu-id="16c78-299">Дополнительные сведения об инициализации сетевого взаимодействия см. в руководстве пользователя NetX или NetX Duo.</span><span class="sxs-lookup"><span data-stu-id="16c78-299">See the NetX/NetXDuo User Guide for more information on initializing network communications.</span></span>

<span data-ttu-id="16c78-300">Протокол TLS активно использует процедуры шифрования, которые являются ресурсоемкими операциями.</span><span class="sxs-lookup"><span data-stu-id="16c78-300">TLS makes heavy use of encryption routines which are processor-intensive operations.</span></span> <span data-ttu-id="16c78-301">Как правило, эти операции будут выполняться в контексте вызывающего потока.</span><span class="sxs-lookup"><span data-stu-id="16c78-301">Generally, these operations will be performed within the context of calling thread.</span></span>

### <a name="tls-session-start"></a><span data-ttu-id="16c78-302">Начало сеанса TLS</span><span class="sxs-lookup"><span data-stu-id="16c78-302">TLS Session Start</span></span>

<span data-ttu-id="16c78-303">Для работы протокола TLS требуется базовый сетевой протокол транспортного уровня.</span><span class="sxs-lookup"><span data-stu-id="16c78-303">TLS requires an underlying transport-layer network protocol in order to function.</span></span> <span data-ttu-id="16c78-304">Обычно используется протокол TCP.</span><span class="sxs-lookup"><span data-stu-id="16c78-304">The protocol typically used is TCP.</span></span> <span data-ttu-id="16c78-305">Чтобы установить сеанс NetX Secure TLS, необходимо установить TCP-подключение с помощью API NetX TCP или NetX Duo TCP.</span><span class="sxs-lookup"><span data-stu-id="16c78-305">In order to establish a NetX Secure TLS session, a TCP connection must be established using the NetX/NetXDuo TCP API.</span></span> <span data-ttu-id="16c78-306">Необходимо создать сокет **NX_TCP_SOCKET** и установить подключение с помощью служб **_nx_tcp_server_socket_listen_ *_ и _* _nx_tcp_server_socket_accept_ *_ (для сервера TLS) или службы _* _nx_tcp_client_socket_connect_** (для клиента TLS).</span><span class="sxs-lookup"><span data-stu-id="16c78-306">An **NX_TCP_SOCKET** must be created and a connection established using the **_nx_tcp_server_socket_listen_*_ and _*_nx_tcp_server_socket_accept_*_ services (for TLS Server) or the _*_nx_tcp_client_socket_connect_** service (for TLS Client).</span></span>

<span data-ttu-id="16c78-307">После установления TCP-подключения сокет TCP передается в службу ***nx_secure_tls_session_start***.</span><span class="sxs-lookup"><span data-stu-id="16c78-307">Once a TCP connection has been established, the TCP socket is then passed to the ***nx_secure_tls_session_start*** service.</span></span>

### <a name="tls-packet-allocation"></a><span data-ttu-id="16c78-308">Выделение пакетов TLS</span><span class="sxs-lookup"><span data-stu-id="16c78-308">TLS Packet Allocation</span></span>

<span data-ttu-id="16c78-309">NetX Secure TLS использует ту же структуру пакетов, что и NetX TCP или NetX Duo TCP (***NX_PACKET** _), за исключением того, что вместо службы _*_nx_packet_allocate_\*_ необходимо вызвать службу _ \*_nx_secure_tls_packet_allocate_\*\*, чтобы правильно выделить пространство для заголовка TLS.</span><span class="sxs-lookup"><span data-stu-id="16c78-309">NetX Secure TLS uses the same packet structure as NetX/NetXDuo TCP (***NX_PACKET** _) except that instead of calling the _*_nx_packet_allocate_*_ service, the _ *_nx_secure_tls_packet_allocate_** service must be called so that space for the TLS header may be allocated properly.</span></span>

### <a name="tls-session-send"></a><span data-ttu-id="16c78-310">Отправка данных в сеансе TLS</span><span class="sxs-lookup"><span data-stu-id="16c78-310">TLS Session Send</span></span>

<span data-ttu-id="16c78-311">После начала сеанса TLS приложение может отправить данные с помощью службы \***nx_secure_tls_session_send** _.</span><span class="sxs-lookup"><span data-stu-id="16c78-311">Once the TLS session has started, the application may send data using the \***nx_secure_tls_session_send** _ service.</span></span> <span data-ttu-id="16c78-312">Служба отправки работает аналогично службе _*_nx_tcp_socket_send_*_. Она принимает структуру данных _*_NX_PACKET_*_, содержащую отправляемые данные. Только эти данные будут зашифрованы стеком NX Secure TLS перед отправкой, а пакет должен быть выделен с помощью _\*_nx_secure_tls_packet_allocate_\*\*.</span><span class="sxs-lookup"><span data-stu-id="16c78-312">The send service is identical in use to the _*_nx_tcp_socket_send_*_ service, taking an _*_NX_PACKET_*_ data structure containing the data being sent, only that data will be encrypted by the NX Secure TLS stack before being sent, and the packet must be allocated using _\*_nx_secure_tls_packet_allocate_\*\*.</span></span>

### <a name="tls-session-receive"></a><span data-ttu-id="16c78-313">Получение данных в сеансе TLS</span><span class="sxs-lookup"><span data-stu-id="16c78-313">TLS Session Receive</span></span>

<span data-ttu-id="16c78-314">После начала сеанса TLS приложение может начать получение данных с помощью службы \***nx_secure_tls_session_send** _.</span><span class="sxs-lookup"><span data-stu-id="16c78-314">Once the TLS session has started, the application may begin receiving data using the \***nx_secure_tls_session_receive** _ service.</span></span> <span data-ttu-id="16c78-315">Как и в случае отправки данных в сеансе TLS, эта служба работает аналогично службе _\*_nx_tcp_socket_receive_\*\*, за исключением того, что входящие данные расшифровываются и проверяются стеком TLS перед возвращением в структуру пакета.</span><span class="sxs-lookup"><span data-stu-id="16c78-315">Like the TLS Session send, this service is identical in use to _\*_nx_tcp_socket_receive_\*\*, except that the incoming data is decrypted and verified by the TLS stack before being returned in the packet structure.</span></span>

### <a name="tls-session-close"></a><span data-ttu-id="16c78-316">Закрытие сеанса TLS</span><span class="sxs-lookup"><span data-stu-id="16c78-316">TLS Session Close</span></span>

<span data-ttu-id="16c78-317">По завершении сеанса TLS и клиент TLS, и сервер TLS должны отправить оповещение CloseNotify другой стороне, чтобы окончательно завершить сеанс.</span><span class="sxs-lookup"><span data-stu-id="16c78-317">Once a TLS session is complete, both the TLS client and server must send a CloseNotify alert to the other side to shut down the session.</span></span> <span data-ttu-id="16c78-318">Обе стороны должны получить и обработать это оповещение, чтобы успешно завершить сеанс.</span><span class="sxs-lookup"><span data-stu-id="16c78-318">Both sides must receive and process the alert to ensure a successful session shutdown.</span></span>

<span data-ttu-id="16c78-319">Если удаленный узел отправляет оповещение CloseNotify, все вызовы службы ***nx_secure_tls_session_receive** _ обрабатывают его, отправляют соответствующее оповещение обратно на удаленный узел и возвращают значение _*_NX_SECURE_TLS_SESSION_CLOSED_\*\*.</span><span class="sxs-lookup"><span data-stu-id="16c78-319">If the remote host sends a CloseNotify alert, any calls to the ***nx_secure_tls_session_receive** _ service will process the alert, send the corresponding alert back to the remote host, and return a value of _*_NX_SECURE_TLS_SESSION_CLOSED_\*\*.</span></span> <span data-ttu-id="16c78-320">После закрытия сеанса дальнейшие попытки отправить или получить данные в этом сеансе TLS завершатся ошибкой.</span><span class="sxs-lookup"><span data-stu-id="16c78-320">Once the session is closed, any further attempts to send or receive data with that TLS session will fail.</span></span>

<span data-ttu-id="16c78-321">Если приложению нужно закрыть сеанс TLS, необходимо вызвать службу \***nx_secure_tls_session_end** _.</span><span class="sxs-lookup"><span data-stu-id="16c78-321">If the application wishes to close the TLS session, the \***nx_secure_tls_session_end** _ service must be called.</span></span> <span data-ttu-id="16c78-322">Эта служба отправит оповещение CloseNotify и обработает ответное оповещение CloseNotify.</span><span class="sxs-lookup"><span data-stu-id="16c78-322">The service will send the CloseNotify alert and process the response CloseNotify.</span></span> <span data-ttu-id="16c78-323">Если ответ не получен, будет возвращено значение ошибки _ \*_NX_SECURE_TLS_SESSION_CLOSE_FAIL_\*\*, указывающее на то, что сеанс TLS не был корректно завершен, возможно из-за нарушения безопасности.</span><span class="sxs-lookup"><span data-stu-id="16c78-323">If the response is not received, an error value of _ *_NX_SECURE_TLS_SESSION_CLOSE_FAIL_*\* will be returned, indicating that the TLS session was not cleanly shutdown, a possible security breach.</span></span>

### <a name="tls-alerts"></a><span data-ttu-id="16c78-324">Оповещения TLS</span><span class="sxs-lookup"><span data-stu-id="16c78-324">TLS Alerts</span></span>

<span data-ttu-id="16c78-325">Протокол TLS предназначен для обеспечения максимальной безопасности, поэтому любое аномальное поведение в протоколе считается потенциальным нарушением безопасности.</span><span class="sxs-lookup"><span data-stu-id="16c78-325">TLS is designed to provide maximum security, so any errant behavior in the protocol is considered a potential security breach.</span></span> <span data-ttu-id="16c78-326">По этой причине все ошибки, возникающие при обработке, шифровании или расшифровке сообщений, считаются неустранимыми ошибками, которые немедленно завершают подтверждение или сеанс.</span><span class="sxs-lookup"><span data-stu-id="16c78-326">For this reason, any errors in message processing or encryption/decryption are considered fatal errors that terminate the handshake or session immediately.</span></span>

<span data-ttu-id="16c78-327">Хотя обработка ошибок в локальном приложении относительно проста, удаленный узел должен быть уведомлен о том, что произошла ошибка, чтобы правильно обработать ситуацию и предотвратить возможные дальнейшие нарушения безопасности.</span><span class="sxs-lookup"><span data-stu-id="16c78-327">While handling errors in a local application is relatively straightforward, the remote host needs to know that an error has occurred in order to properly handle the situation and prevent any further possible security breaches.</span></span> <span data-ttu-id="16c78-328">По этой причине при любой ошибке протокол TLS отправляет сообщение *Alert* на удаленный узел.</span><span class="sxs-lookup"><span data-stu-id="16c78-328">For this reason, TLS will send an *Alert* message to the remote host upon any error.</span></span>

<span data-ttu-id="16c78-329">Сообщения Alert обрабатываются так же, как и любые другие сообщения TLS, и шифруются во время сеанса, чтобы предотвратить сбор информации злоумышленником из указанного типа оповещения.</span><span class="sxs-lookup"><span data-stu-id="16c78-329">Alerts are treated in the same manner as any other TLS messages and are encrypted during the session to prevent an attacker from gathering information from the type of alert provided.</span></span> <span data-ttu-id="16c78-330">Во время подтверждения отправляются ограниченные оповещения, чтобы уменьшить объем сведений, которые могут быть получены потенциальным злоумышленником.</span><span class="sxs-lookup"><span data-stu-id="16c78-330">During the handshake, the alerts sent are limited in scope to limit the amount of information that could be obtained by a potential attacker.</span></span>

<span data-ttu-id="16c78-331">Оповещение CloseNotify, используемое для закрытия сеанса TLS, является единственным оповещением не об неустранимом сбое.</span><span class="sxs-lookup"><span data-stu-id="16c78-331">The CloseNotify alert, used to close the TLS session, is the only non-fatal alert.</span></span> <span data-ttu-id="16c78-332">Хотя оно считается оповещением и отправляется в виде сообщения Alert, отличие CloseNotify от других оповещений состоит в том, что оно не указывает на ошибку.</span><span class="sxs-lookup"><span data-stu-id="16c78-332">While it is considered an alert and sent as an alert message, a CloseNotify is unlike other alerts in that it does not indicate an error has occurred.</span></span>

<span data-ttu-id="16c78-333">Значение и "уровень" ("предупреждение" и "неустранимая ошибка"; большинство оповещений TLS имеют уровень "неустранимая ошибка") оповещения определяются в документах RFC по протоколу TLS и указывают тип возникшей ошибки.</span><span class="sxs-lookup"><span data-stu-id="16c78-333">The alert value and "level" (levels are "warning" and "fatal" – most TLS alerts are "fatal") are defined in the TLS RFCs and indicate the type of error that occurred.</span></span> <span data-ttu-id="16c78-334">Большинство оповещений TLS, отличных от CloseNotify, могут рассматриваться как потенциальные проблемы безопасности, что приведет к прерыванию сеанса или подтверждения TLS.</span><span class="sxs-lookup"><span data-stu-id="16c78-334">Most TLS Alerts other than CloseNotify can be considered an indication of a potential security issue and will result in the TLS session or handshake being aborted.</span></span> <span data-ttu-id="16c78-335">Если какой-либо вызов API TLS возвращает **NX_SECURE_TLS_ALERT_RECEIVED** (0x114), то можно использовать службу API **_nx_secure_tls_session_alert_value_get_** (введенную в NetX Secure TLS версии 5.12), чтобы получить значение и уровень оповещения TLS для приложения. Это позволит приложению принимать решения о том, как реагировать на проблемы безопасности.</span><span class="sxs-lookup"><span data-stu-id="16c78-335">If any TLS API call returns **NX_SECURE_TLS_ALERT_RECEIVED** (0x114), the API service **_nx_secure_tls_session_alert_value_get_** (new in NetX Secure TLS version 5.12) may be used to retrieve the TLS alert value and level for the application to use for any decisions regarding responses to security issues.</span></span> <span data-ttu-id="16c78-336">В большинстве случаев любое оповещение, полученное от удаленного узла, отличное от CloseNotify, должно считаться неустранимой ошибкой, хотя есть некоторые исключения (дополнительные сведения см. в документах RFC по протоколу TLS).</span><span class="sxs-lookup"><span data-stu-id="16c78-336">In most cases, any alert received from the remote host other than CloseNotify should be considered a fatal error, though there are some excptions – see the TLS RFCs for more information.</span></span>

### <a name="tls-session-renegotiation"></a><span data-ttu-id="16c78-337">Повторное согласование сеанса TLS</span><span class="sxs-lookup"><span data-stu-id="16c78-337">TLS Session Renegotiation</span></span>

<span data-ttu-id="16c78-338">Протокол TLS поддерживает понятие "повторное согласование", которое представляет собой просто согласование параметров сеанса TLS в контексте существующего сеанса TLS.</span><span class="sxs-lookup"><span data-stu-id="16c78-338">TLS supports the notion of "renegotiation" which is simply a renegotiation of the TLS session parameters within the context of an existing TLS session.</span></span> <span data-ttu-id="16c78-339">На практике это означает, что новые сообщения подтверждения шифруются и проходят проверку подлинности с помощью существующего сеанса.</span><span class="sxs-lookup"><span data-stu-id="16c78-339">What this means in practice is that the new handshake messages are encrypted and authenticated using the existing session.</span></span> <span data-ttu-id="16c78-340">Повторное согласование используется, когда узлу TLS требуется создать новые параметры сеанса (например, создать новые ключи сеанса TLS) без завершения существующего сеанса.</span><span class="sxs-lookup"><span data-stu-id="16c78-340">Renegotiation is used when a TLS host wants to generate new session parameters (e.g. generate new TLS session keys) without having to complete the existing session.</span></span> <span data-ttu-id="16c78-341">Например, повторное согласование может быть желательным, если политики безопасности для приложения предписывают, что ключи сеанса должны использоваться только в течение ограниченного времени, а сеанс TLS остается активным дольше.</span><span class="sxs-lookup"><span data-stu-id="16c78-341">For example, renegotiation may be desirable when security policies for an application dictate that session keys are only used for a limited time but a TLS session remains active beyond that time.</span></span>

<span data-ttu-id="16c78-342">Одна из проблем с повторным согласованием сеанса заключается в том, что протокол TLS уязвим для определенной атаки "злоумышленник в середине", когда злоумышленник может вынудить сервер инициировать повторное согласование с новыми параметрами, позволяя злоумышленнику перехватить сеанс TLS.</span><span class="sxs-lookup"><span data-stu-id="16c78-342">One issue with session renegotiation is that is makes TLS vulnerable to a specific Man-in-the-Middle attack where an attacker can convince a server to initiate a renegotiation with new parameters, thus allowing the attacker to hijack the TLS session.</span></span> <span data-ttu-id="16c78-343">Чтобы устранить эту ошибку, было введено расширение для указания безопасного повторного согласования (см. раздел **Ошибка. Источник ссылки не найден**</span><span class="sxs-lookup"><span data-stu-id="16c78-343">To mitigate this issue, the Secure Renegotiation Indication extension was introduced (see section **Error! Reference source not found.**</span></span> <span data-ttu-id="16c78-344">.</span><span class="sxs-lookup"><span data-stu-id="16c78-344">section).</span></span>

<span data-ttu-id="16c78-345">NetX Secure TLS полностью поддерживает повторное согласование сеанса и расширение для указания безопасного повторного согласования.</span><span class="sxs-lookup"><span data-stu-id="16c78-345">NetX Secure TLS completely supports session renegotiation and the Secure Renegotiation Indication extension.</span></span>

<span data-ttu-id="16c78-346">При получении данных с удаленного узла повторные согласования (и расширение) обрабатываются автоматически, без взаимодействия с приложением.</span><span class="sxs-lookup"><span data-stu-id="16c78-346">When receiving data from a remote host, renegotations (and the extension) are handled automatically without application interaction.</span></span> <span data-ttu-id="16c78-347">Если требуется уведомление о повторном согласовании сеансов, можно передать обратный вызов повторного согласования с помощью службы *nx_secure_tls_session_renegotiate_callback_set*.</span><span class="sxs-lookup"><span data-stu-id="16c78-347">If notification about session renegotiations is desired, a renegotiation callback may be supplied with the *nx_secure_tls_session_renegotiate_callback_set* service.</span></span> <span data-ttu-id="16c78-348">Обратный вызов будет осуществляться всякий раз, когда удаленный узел будет запрашивать повторное согласование, что позволит приложению принять необходимые меры.</span><span class="sxs-lookup"><span data-stu-id="16c78-348">The callback will be invoked whenever a renegotiation is requested by the remote host, allowing the application to take action if desired.</span></span>

<span data-ttu-id="16c78-349">Чтобы инициировать повторное согласование из активного сеанса TLS, просто запустите службу *nx_secure_tls_session_renegotiate* в соответствующем сеансе TLS.</span><span class="sxs-lookup"><span data-stu-id="16c78-349">To initiate a renegotiation from an active TLS session, simply invoke the *nx_secure_tls_session_renegotiate* service on the desired TLS session.</span></span>

### <a name="tls-session-resumption"></a><span data-ttu-id="16c78-350">Возобновление сеанса TLS</span><span class="sxs-lookup"><span data-stu-id="16c78-350">TLS Session Resumption</span></span>

<span data-ttu-id="16c78-351">Возобновление сеанса TLS не следует путать с повторным согласованием сеанса, несмотря на некоторое сходство.</span><span class="sxs-lookup"><span data-stu-id="16c78-351">TLS session resumption should not be confused with session renegotiation, despite some similarities.</span></span> <span data-ttu-id="16c78-352">*Повторное согласование* сеанса включает в себя запуск нового подтверждения в существующем сеансе TLS, тогда как *возобновление* сеанса является необязательной функцией, включающей в себя перезапуск сеанса TLS без полного подтверждения TLS.</span><span class="sxs-lookup"><span data-stu-id="16c78-352">Where session *renegotiation* involves starting a new handshake within an existing TLS session, session *resumption* is a purely optional feature that involves restarting a closed TLS session without performing a complete TLS handshake.</span></span> <span data-ttu-id="16c78-353">Для этого реализация TLS может кэшировать параметры сеанса и ключи, связав их с *идентификатором сеанса*, уникальным идентификатором, полученным при первоначальном подтверждении.</span><span class="sxs-lookup"><span data-stu-id="16c78-353">To achieve this, a TLS implementation may cache the session parameters and keys, associating them with a *session ID,* a unique identifier supplied in the original handshake.</span></span> <span data-ttu-id="16c78-354">Предоставляя идентификатор сеанса серверу TLS, клиент указывает, что предыдущий сеанс TLS между узлами существовал и был завершен какое-то время назад и что клиент по-прежнему владеет состоянием для повторного создания сеанса с сокращенным подтверждением.</span><span class="sxs-lookup"><span data-stu-id="16c78-354">By supplying a session ID to a TLS server, a client indicates that a previous TLS session between the hosts existed and completed some time in the past, and that the client still possesses the state to re-establish the session with a reduced handshake.</span></span> <span data-ttu-id="16c78-355">Так как ключи сеанса теоретически по-прежнему являются секретными и известны только двум взаимодействующим узлам, сервер может запустить новый сеанс TLS и пропустить большую часть обычного подтверждения.</span><span class="sxs-lookup"><span data-stu-id="16c78-355">Since the session keys are theoretically still secret and only known by the two communicating host, the server can start a new TLS session and bypass most of the normal handshake.</span></span>

<span data-ttu-id="16c78-356">Возобновление сеанса может быть удобно для того, чтобы избежать потенциально ресурсоемких операций с открытым ключом, которые выполняются для отправки главной копии секрета после создания ключей и проверки подписей сертификатов. Однако для этого также требуется, чтобы параметры сеанса, ключи и состояние шифрования были сохранены в памяти для всех возможных сеансов (по крайней мере в течение настраиваемого периода времени).</span><span class="sxs-lookup"><span data-stu-id="16c78-356">Session resumption can be useful to avoid the potentially expensive public-key operations used to share the key generation master secret and verify certificate signatures, but it also requires that the session parameters, keys, and crypotgraphic state be maintained in memory for all possible sessions (at least for a configurable time window).</span></span>

<span data-ttu-id="16c78-357">Текущая версия NetX Secure TLS не поддерживает возобновление сеанса — идентификатор сеанса просто игнорируется серверами TLS, а клиенты TLS всегда предоставляют идентификатор сеанса NULL, который предлагает серверу выполнить полное подтверждение.</span><span class="sxs-lookup"><span data-stu-id="16c78-357">The current version of NetX Secure TLS does not support session resumption – the session ID is simply ignored by TLS servers and TLS clients always supply a NULL session ID which prompts the server to perform a complete handshake.</span></span> <span data-ttu-id="16c78-358">Отсутствие возобновления сеанса не должно вызывать проблем со взаимодействием, так как это абсолютно необязательная функция, и все реализации TLS должны по умолчанию использовать полное подтверждение, если идентификатор сеанса имеет значение NULL или не распознан.</span><span class="sxs-lookup"><span data-stu-id="16c78-358">The lack of session resumption should cause no inter-operability issues as it is a completely optional feature and all TLS implementations must default to a complete handshake should the session ID be NULL or unrecognized.</span></span>

### <a name="protocol-layering"></a><span data-ttu-id="16c78-359">Уровень протокола</span><span class="sxs-lookup"><span data-stu-id="16c78-359">Protocol Layering</span></span>

<span data-ttu-id="16c78-360">Протокол TLS соответствует сетевому стеку между транспортным уровнем (например, TCP) и прикладным уровнем.</span><span class="sxs-lookup"><span data-stu-id="16c78-360">The TLS protocol fits into the networking stack between the transport layer (e.g. TCP) and the application layer.</span></span> <span data-ttu-id="16c78-361">Протокол TLS иногда относят к протоколам транспортного уровня (отсюда и его название — TLS, *Transport Layer* Security (безопасность транспортного уровня)), но так как он действует как приложение по отношению к базовым сетевым протоколам (например, TCP), иногда его относят к прикладному уровню.</span><span class="sxs-lookup"><span data-stu-id="16c78-361">TLS is sometimes considered a transport-layer protocol (hence *Transport Layer* Security) but because it acts as an application with regard to the underlying network protocols (such as TCP) it is sometimes grouped into the application layer.</span></span>

<span data-ttu-id="16c78-362">Для протокола TLS требуется протокол транспортного уровня, поддерживающий доставку по порядку и без потерь, например протокол TCP.</span><span class="sxs-lookup"><span data-stu-id="16c78-362">TLS requires a transport layer protocol that supports in-order and lossless delivery, such as TCP.</span></span> <span data-ttu-id="16c78-363">В соответствии с этим требованием протокол TLS не может выполняться на основе протокола UDP, так как UDP не гарантирует доставку датаграмм.</span><span class="sxs-lookup"><span data-stu-id="16c78-363">Due to this requirement, TLS cannot run on top of UDP since UDP does not guarantee delivery of datagrams.</span></span> <span data-ttu-id="16c78-364">Для приложений, которым требуется безопасность TLS по протоколу передачи датаграмм, например UDP, используется отдельный протокол *DTLS*, который является модифицированной версией протокола TLS.</span><span class="sxs-lookup"><span data-stu-id="16c78-364">A separate protocol called *DTLS,* which is a modified version of TLS, is used for applications that need the security of TLS over a datagram protocol like UDP.</span></span> <span data-ttu-id="16c78-365">NetX Secure поддерживает протокол DTLS, но описание DTLS приведено в отдельном документе.</span><span class="sxs-lookup"><span data-stu-id="16c78-365">NetX Secure supports DTLS, but documentation for DTLS is separate from this document.</span></span>

![Схема уровней протоколов TCP/IP и TLS.](media/image6.png)

<span data-ttu-id="16c78-367">Рисунок 5. Уровни протоколов TCP/IP и TLS</span><span class="sxs-lookup"><span data-stu-id="16c78-367">Figure 5- TCP/IP and TLS protocol layers</span></span>

## <a name="network-communications-security"></a><span data-ttu-id="16c78-368">Безопасность сетевого взаимодействия</span><span class="sxs-lookup"><span data-stu-id="16c78-368">Network Communications Security</span></span>

<span data-ttu-id="16c78-369">Обеспечение безопасности взаимодействия через общедоступные сети и Интернет является важнейшей темой, которой посвящено огромное количество книг, статей и решений.</span><span class="sxs-lookup"><span data-stu-id="16c78-369">Securing communications over public networks and the Internet is a critically important topic and the subject of vast numbers of books, articles, and solutions.</span></span> <span data-ttu-id="16c78-370">Эта тема является немыслимо сложной, но ее можно упростить до следующей идеи: нужно отправлять информацию по сети так, чтобы только указанный адресат мог получить доступ к этой информации или изменить ее.</span><span class="sxs-lookup"><span data-stu-id="16c78-370">The topic is mind-bogglingly complex, but can be reduced to a simple idea: sending information over a network so that only the intended target can access or change that information.</span></span> <span data-ttu-id="16c78-371">Эта идея порождает три важных понятия: секретность, целостность и проверка подлинности.</span><span class="sxs-lookup"><span data-stu-id="16c78-371">This breaks down into three important concepts: secrecy, integrity, and authentication.</span></span> <span data-ttu-id="16c78-372">Протокол TLS предоставляет решения для всех этих трех понятий.</span><span class="sxs-lookup"><span data-stu-id="16c78-372">The TLS protocol provides solutions for all three.</span></span>

### <a name="secrecy"></a><span data-ttu-id="16c78-373">Секретность</span><span class="sxs-lookup"><span data-stu-id="16c78-373">Secrecy</span></span>

<span data-ttu-id="16c78-374">При отправке данных по сети часто важно, чтобы они не были получены вредоносной сущностью.</span><span class="sxs-lookup"><span data-stu-id="16c78-374">When sending data over a network, it is often important that the data cannot be obtained by a malicious entity.</span></span> <span data-ttu-id="16c78-375">Если данные отправляются через подключение по протоколу TCP/IP, любой пользователь, имеющий доступ к сети, сможет считать эти данные с помощью легко доступных сетевых средств.</span><span class="sxs-lookup"><span data-stu-id="16c78-375">If data is sent over a TCP/IP connection, anyone with access to the network will be able to read that data using easily-available networking tools.</span></span> <span data-ttu-id="16c78-376">Чтобы предотвратить несанкционированное получение этих данных, их необходимо зашифровать таким образом, чтобы их мог прочитать только указанный адресат — это и есть *секретность*.</span><span class="sxs-lookup"><span data-stu-id="16c78-376">To prevent that data from being obtained, it must be encoded such that it cannot be read except by the intended target – this is *secrecy.*</span></span> <span data-ttu-id="16c78-377">Алгоритмы шифрования, такие как RSA и AES, в протоколе TLS обеспечивают секретность.</span><span class="sxs-lookup"><span data-stu-id="16c78-377">In TLS, encryption algorithms such as RSA and AES provide secrecy.</span></span>

### <a name="integrity"></a><span data-ttu-id="16c78-378">Целостность</span><span class="sxs-lookup"><span data-stu-id="16c78-378">Integrity</span></span>

<span data-ttu-id="16c78-379">Иногда одной секретности недостаточно, чтобы защитить данные, передаваемые по сети.</span><span class="sxs-lookup"><span data-stu-id="16c78-379">Sometimes, secrecy is not enough to protect data travelling over a network.</span></span> <span data-ttu-id="16c78-380">В некоторых случаях вредоносная сущность может изменять содержимое пакета TCP, даже не зная, что он содержит.</span><span class="sxs-lookup"><span data-stu-id="16c78-380">In some cases, it may be possible for a malicious entity to alter the contents of a TCP packet without needing to know what that packet contains.</span></span> <span data-ttu-id="16c78-381">Зашифрованные данные могут быть изменены, что приведет к ошибке расшифровки или изменению параметров сообщения, что может быть как раз тем результатом, которого добивался злоумышленник.</span><span class="sxs-lookup"><span data-stu-id="16c78-381">Encrypted data can be altered, rendering the decryption invalid or changing the parameters of the message leading to whatever result the attacker may be interested in achieving.</span></span> <span data-ttu-id="16c78-382">При передаче в сети мы не можем предотвратить изменение данных злоумышленником, но мы можем предоставить механизм, позволяющий определить, были ли данные изменены.</span><span class="sxs-lookup"><span data-stu-id="16c78-382">On the network, we cannot prevent an attacker from changing data in transit, but we can provide a mechanism to know whether or not the data has been changed.</span></span> <span data-ttu-id="16c78-383">Если данные были изменены во время передачи, об этом станет известно, и они могут быть отклонены.</span><span class="sxs-lookup"><span data-stu-id="16c78-383">When data is changed in transit, it will be known and the data can be rejected.</span></span> <span data-ttu-id="16c78-384">Это и есть понятие *целостности*.</span><span class="sxs-lookup"><span data-stu-id="16c78-384">This concept is *integrity*.</span></span> <span data-ttu-id="16c78-385">В протоколе TLS целостность обеспечивает класс криптографических процедур, называемых *хэш-функциями*.</span><span class="sxs-lookup"><span data-stu-id="16c78-385">In TLS, integrity is provided by a class of cryptographic routines known as *hash functions*.</span></span> <span data-ttu-id="16c78-386">Примерами хэш-функций являются MD5 и SHA-1.</span><span class="sxs-lookup"><span data-stu-id="16c78-386">Some examples of hash functions are MD5 and SHA-1.</span></span>

### <a name="authentication"></a><span data-ttu-id="16c78-387">Проверка подлинности</span><span class="sxs-lookup"><span data-stu-id="16c78-387">Authentication</span></span>

<span data-ttu-id="16c78-388">Третьим важным понятием в безопасности сетевого взаимодействия является идея о том, что данные должны быть переданы только указанному адресату.</span><span class="sxs-lookup"><span data-stu-id="16c78-388">The third important concept in network communications security is the idea that data should only be communicated to the intended target.</span></span> <span data-ttu-id="16c78-389">Злоумышленник может попытаться предоставить допустимую сущность для получения данных, предназначенных для другого узла.</span><span class="sxs-lookup"><span data-stu-id="16c78-389">An attacker may attempt to pose as a legitimate entity to receive data intended for another host.</span></span> <span data-ttu-id="16c78-390">Даже если данные отправляются с помощью механизмов обеспечения секретности и целостности, злоумышленник все равно может добиться желаемого (скомпрометировать безопасное взаимодействие) благодаря этому обману.</span><span class="sxs-lookup"><span data-stu-id="16c78-390">Even if the data is being sent with secrecy and integrity mechanisms in place, the attacker may still be able to achieve the desired result (a compromise of secure communications) through this deception.</span></span> <span data-ttu-id="16c78-391">Чтобы избежать этого, перед отправкой конфиденциальных данных требуется использовать механизм для подтверждения подлинности удаленного узла.</span><span class="sxs-lookup"><span data-stu-id="16c78-391">To prevent this, a mechanism is needed to prove the identity of a remote host before any sensitive data is sent.</span></span> <span data-ttu-id="16c78-392">Процесс подтверждения подлинности удаленного узла — это и есть *проверка подлинности*.</span><span class="sxs-lookup"><span data-stu-id="16c78-392">The process of proving the identity of a remote host is *authentication.*</span></span> <span data-ttu-id="16c78-393">В протоколе TLS проверка подлинности обеспечивается с помощью цифровых сертификатов, хэш-функций и механизма, называемого *цифровыми подписями*, который использует свойство шифрования с открытым ключом (описывается ниже).</span><span class="sxs-lookup"><span data-stu-id="16c78-393">In TLS, authentication is provided using digital certificates, hash functions, and a mechanism called *digital signatures* which utilizes a property of public-key encryption (described below).</span></span> <span data-ttu-id="16c78-394">Ограниченная, но полезная разновидность проверки подлинности также может быть реализована с помощью *общего ключа* (PSK).</span><span class="sxs-lookup"><span data-stu-id="16c78-394">A limited but useful form of authentication can also be provided with a *pre-shared key* (PSK).</span></span>

## <a name="tls-encryption"></a><span data-ttu-id="16c78-395">Шифрование TLS</span><span class="sxs-lookup"><span data-stu-id="16c78-395">TLS Encryption</span></span>

<span data-ttu-id="16c78-396">Протокол TLS — это платформа для обеспечения безопасного сетевого взаимодействия через Интернет с использованием шифрования.</span><span class="sxs-lookup"><span data-stu-id="16c78-396">The TLS protocol is a framework for providing secure network communications over the Internet utilizing encryption.</span></span> <span data-ttu-id="16c78-397">Шифрование обычно определяется как процесс кодирования данных таким образом, чтобы было чрезвычайно сложно получить исходные данные (или сведения об этих данных) без *ключа*.</span><span class="sxs-lookup"><span data-stu-id="16c78-397">Encryption is generally defined as the process of encoding data in such a way that obtaining the original data (or information about that data) is exceedingly difficult without a *key*.</span></span> <span data-ttu-id="16c78-398">В компьютерных системах шифрование основано на сложной математике (например, на конечных полях) и может быть разделено на два типа: *с закрытым ключом* (*симметричное шифрование*) и *с открытым ключом* (*асимметричное шифрование*).</span><span class="sxs-lookup"><span data-stu-id="16c78-398">In computer systems encryption is based on complex mathematics such as finite fields and can be classified into two types: *private key* (or *symmetric encryption*) and *public key* (or *asymmetric encryption*).</span></span> <span data-ttu-id="16c78-399">Примеры шифрования с закрытым ключом: AES (Advanced Encryption Standard) и RC4 (Rivest Cipher 4).</span><span class="sxs-lookup"><span data-stu-id="16c78-399">Examples of private key encryption are AES (Advanced Encryption Standard) and RC4 (Rivest Cipher 4).</span></span> <span data-ttu-id="16c78-400">Примеры шифрования с открытым ключом: RSA (Rivest, Shamir, Adleson) и шифры Диффи-Хелмана.</span><span class="sxs-lookup"><span data-stu-id="16c78-400">Examples of public-key encryption are the RSA (Rivest, Shamir, Adleson) and Diffie-Hellman ciphers.</span></span>

<span data-ttu-id="16c78-401">Протокол TLS использует процедуры шифрования как с закрытым, так и с открытым ключом,чтобы обеспечить баланс производительности, безопасности и гибкости.</span><span class="sxs-lookup"><span data-stu-id="16c78-401">The TLS protocol makes use of both private key and public key encryption routines to provide a balance of performance, security, and flexibility.</span></span>

### <a name="private-key-encryption"></a><span data-ttu-id="16c78-402">Шифрование с закрытым ключом</span><span class="sxs-lookup"><span data-stu-id="16c78-402">Private-Key Encryption</span></span>

<span data-ttu-id="16c78-403">Шифрование с закрытым ключом используется уже тысячи лет.</span><span class="sxs-lookup"><span data-stu-id="16c78-403">Private-key encryption has been in use for thousands of years.</span></span> <span data-ttu-id="16c78-404">Простые шифры подстановки (в которых буква или слово заменяется другой несвязанной буквой или словом) являются наиболее ранними известными примерами шифрования, но с приходом эпохи информации шифрование с закрытым ключом было значительно улучшено.</span><span class="sxs-lookup"><span data-stu-id="16c78-404">Basic substitution ciphers (where a letter or word is replaced by another unrelated letter or word) are the earliest known examples of encryption, but with the advent of the information age private key encryption has significantly improved.</span></span>

<span data-ttu-id="16c78-405">В шифре с закрытым ключом используется "ключ", который представляет собой просто значение (в общем случае это может быть слово, фраза или число), которое используется для кодирования некоторых данных, чтобы только сущность, имеющая доступ к этому ключу, могла декодировать данные в осмысленную информацию.</span><span class="sxs-lookup"><span data-stu-id="16c78-405">A private key cipher uses a "key" which is simply a value (which could be a word, phrase, or number in the general case) that is used to somehow encode some data so that only an entity that had access to that key could decode the data in a meaningful way.</span></span> <span data-ttu-id="16c78-406">Ключ используется как для шифрования, так и для расшифровки данных, поэтому этот процесс также называется *симметричным шифрованием*.</span><span class="sxs-lookup"><span data-stu-id="16c78-406">The key is used for both encryption and decryption of the data, hence the other name *symmetric encryption*.</span></span>

<span data-ttu-id="16c78-407">Как правило, шифры с закрытым ключом быстро и просто реализовать, даже если в них используются чрезвычайно сложные математические расчеты.</span><span class="sxs-lookup"><span data-stu-id="16c78-407">Private key ciphers are generally fast and fairly simple to implement, even if the mathematics involved are exceedingly complex.</span></span> <span data-ttu-id="16c78-408">По этой причине в протоколе TLS для множества безопасных подключений используются шифры с закрытым ключом.</span><span class="sxs-lookup"><span data-stu-id="16c78-408">For this reason, TLS uses private key ciphers for the bulk of secure communications.</span></span>

<span data-ttu-id="16c78-409">Однако у шифрования с закрытым ключом возникает недостаток, когда речь заходит о взаимодействии через общие компьютерные сети: ключ нужно передавать между компьютерами, пытающимися обмениваться данными.</span><span class="sxs-lookup"><span data-stu-id="16c78-409">However, private key encryption has a problem when we try to apply it to general computer network communications: the key must be shared between both machines trying to communicate.</span></span> <span data-ttu-id="16c78-410">В общем случае нецелесообразно и часто невозможно безопасно передать закрытый ключ между двумя компьютерами в Интернете, так как предполагается, что сетевой трафик может быть получен любым количеством сущностей на разных прыжках, проходимых данными при передаче через Интернет.</span><span class="sxs-lookup"><span data-stu-id="16c78-410">In the general case, it is impractical and often impossible to communicate a private key securely between two machines on the Internet, as it can be assumed that the network traffic can be obtained by any number of entities in the various hops that data takes when being routed through the Internet.</span></span> <span data-ttu-id="16c78-411">Если ключ получен вредоносной сущностью, все данные, зашифрованные с помощью этого ключа, являются скомпрометированными.</span><span class="sxs-lookup"><span data-stu-id="16c78-411">If the key is obtained by a malicious entity, all data encrypted using that key is compromised.</span></span> <span data-ttu-id="16c78-412">Так как большинство компьютеров в Интернете имеют только сетевое подключение без дополнительного безопасного канала для обмена данными, отправка ключей по сети равноценна отправке данных без шифрования — они не обеспечивают безопасность.</span><span class="sxs-lookup"><span data-stu-id="16c78-412">As most machines on the Internet have only a network connection and not another secure channel for communications, sending keys over the network is tantamount to sending the data unencrypted – it provides no security.</span></span>

<span data-ttu-id="16c78-413">По этой причине шифрования с закрытым ключом недостаточно для реализации протокола безопасности сетевого взаимодействия общего назначения.</span><span class="sxs-lookup"><span data-stu-id="16c78-413">For this reason, private key encryption is not sufficient to implement a general-purpose network communications security protocol.</span></span> <span data-ttu-id="16c78-414">И нам может помочь шифрование с открытым ключом.</span><span class="sxs-lookup"><span data-stu-id="16c78-414">This is where Public Key encryption can help.</span></span>

<span data-ttu-id="16c78-415">NetX Secure TLS поддерживает шифрование с закрытым ключом AES.</span><span class="sxs-lookup"><span data-stu-id="16c78-415">NetX Secure TLS supports AES private-key encryption.</span></span>

### <a name="public-key-encryption"></a><span data-ttu-id="16c78-416">Шифрование с открытым ключом</span><span class="sxs-lookup"><span data-stu-id="16c78-416">Public-Key Encryption</span></span>

<span data-ttu-id="16c78-417">В отличие от шифрования с закрытым ключом, шифрование с открытым ключом — это довольно новая концепция, разработанная в 1970-х годах.</span><span class="sxs-lookup"><span data-stu-id="16c78-417">Unlike private key encryption, public key encryption is a fairly new concept, having been developed in the 1970's.</span></span> <span data-ttu-id="16c78-418">С помощью понятия "функции с секретными параметрами" из математики было обнаружено, что существовал способ передать ключ по сети, не нарушая безопасность зашифрованных данных.</span><span class="sxs-lookup"><span data-stu-id="16c78-418">Using a concept known as "trap-door functions" in mathematics, it was discovered that there was a way to share a key over a network without compromising the security of then encrypted data.</span></span>

<span data-ttu-id="16c78-419">Принцип шифрования с открытым ключом состоит в том, что ключ (согласно описанному выше шифрованию с закрытым ключом) разбивается на две части — *закрытый ключ* и *открытый ключ*, что и дало название этому виду шифрования.</span><span class="sxs-lookup"><span data-stu-id="16c78-419">The way public key encryption works is that the key (in the private-key encryption sense described above) is split into two parts, a *private key* and a *public key*, from where public key encryption gets its name.</span></span> <span data-ttu-id="16c78-420">Принцип состоит в том, что один из этих ключей (как правило, открытый ключ) используется для шифрования, а другой используется для расшифровки.</span><span class="sxs-lookup"><span data-stu-id="16c78-420">The concept is that one of these keys (typically the public key) is used for encryption, while the other is used for decryption.</span></span> <span data-ttu-id="16c78-421">Эта асимметрия ключей породила еще одно название шифрования с открытым ключом: *асимметричное шифрование*.</span><span class="sxs-lookup"><span data-stu-id="16c78-421">This asymmetry of keys is the reason for the other name for public key encryption: *asymmetric encryption*.</span></span>

<span data-ttu-id="16c78-422">Математические вычисления при шифровании с открытым ключом довольно сложны, но идея заключается в том, что открытый ключ можно использовать *только* для шифрования, а получение этого ключа не позволяет получить зашифрованные данные.</span><span class="sxs-lookup"><span data-stu-id="16c78-422">The mathematics behind public key encryption are fairly complex, but the idea is that the public key can *only* be used for encryption, and obtaining that key does not allow encrypted data to be obtained.</span></span> <span data-ttu-id="16c78-423">Закрытый ключ, в свою очередь, является единственным средством для расшифровки данных, зашифрованных с помощью открытого ключа.</span><span class="sxs-lookup"><span data-stu-id="16c78-423">The private key, in turn, is the only way to decrypt data encrypted using the public key.</span></span> <span data-ttu-id="16c78-424">Таким образом, если закрытый ключ не скомпрометирован, любая сущность, желающая безопасно взаимодействовать с владельцем этого закрытого ключа, должна просто зашифровать свои данные с помощью соответствующего открытого ключа, зная, что только владелец закрытого ключа сможет получить защищенные данные.</span><span class="sxs-lookup"><span data-stu-id="16c78-424">Thus, by keeping the private key secret, anyone wishing to communicate securely with the owner of that private key need only encrypt their data with the corresponding public key with the knowledge that only someone in possession of that private key can obtain the secure data.</span></span>

<span data-ttu-id="16c78-425">NetX Secure TLS поддерживает шифрование с открытым ключом RSA.</span><span class="sxs-lookup"><span data-stu-id="16c78-425">NetX Secure TLS supports RSA public-key encryption.</span></span>

> [!IMPORTANT] 
> <span data-ttu-id="16c78-426">*Алгоритмы RSA являются очень ресурсоемкими операциями, если используется программная реализация RSA. При увеличении размера ключей требуемая вычислительная мощность возрастает в квадратном соотношении. Это значит, что при увеличении размера ключа в 2 раза расшифровка замедлится в 4 раза.*</span><span class="sxs-lookup"><span data-stu-id="16c78-426">*RSA is a very processor-intensive operation if the software RSA implementation is used. Larger key sizes increase the processing power required by a square factor – 4X slower for a 2X increase in key size.*</span></span>

### <a name="public-key-authentication"></a><span data-ttu-id="16c78-427">Проверка подлинности с открытым ключом</span><span class="sxs-lookup"><span data-stu-id="16c78-427">Public-Key Authentication</span></span>

<span data-ttu-id="16c78-428">Интересный побочный результат принципа шифрования с открытым ключом заключается в том, что его можно использовать как для шифрования, так и для проверки подлинности, выполняя обратную операцию: шифрование с помощью *закрытого* ключа и расшифровку с помощью *открытого* ключа.</span><span class="sxs-lookup"><span data-stu-id="16c78-428">An interesting side-effect of the public-key encryption concept is that it can be used to provide authentication as well as encryption by doing the operation in reverse: encrypting using the *private* key and decrypting using the *public* key.</span></span> <span data-ttu-id="16c78-429">Фактический механизм этого процесса зависит от используемого алгоритма с открытым ключом, но принцип одинаков.</span><span class="sxs-lookup"><span data-stu-id="16c78-429">The actual mechanism for doing this depends on the public key algorithm being used, but the concept is the same.</span></span>

<span data-ttu-id="16c78-430">Для проверки подлинности с помощью открытого ключа владелец закрытого ключа шифрует некоторый фрагмент данных (обычно это криптографический хэш данных, подлинность которых следует проверить) с помощью этого закрытого ключа.</span><span class="sxs-lookup"><span data-stu-id="16c78-430">To authenticate using public key authentication, the owner of a private key encrypts some piece of data (typically a cryptographic hash of the data to be authenticated) using that private key.</span></span> <span data-ttu-id="16c78-431">Затем кто-то, желающий убедиться, что данные получены от владельца закрытого ключа, использует связанный открытый ключ для их расшифровки. Если расшифровка прошла успешно и предполагается, что пользователь уверен в действительности этого открытого ключа, он может быть уверен, что данные поступили от владельца закрытого ключа.</span><span class="sxs-lookup"><span data-stu-id="16c78-431">Then, someone wishing to authenticate that the data came from the owner of the private key uses the associated public key to decrypt the data – if the decryption is successful, and assuming the user trusted the validity of that public key, then the user can be certain that the data came from the owner of the private key.</span></span>

<span data-ttu-id="16c78-432">В протоколе TLS проверка подлинности с открытым ключом используется для проверки действительности цифрового сертификата, предоставленного сервером TLS (и, при необходимости, клиентом TLS), с помощью открытых ключей из хранилища доверенных сертификатов.</span><span class="sxs-lookup"><span data-stu-id="16c78-432">In TLS, public key authentication is used to verify the validity of a digital certificate provided by a TLS server (and optionally the TLS client) using public keys from the trusted certificate store.</span></span> <span data-ttu-id="16c78-433">Сертификат проверяется по открытому ключу в хранилище, а данные в сертификате используются для проверки подлинности сервера.</span><span class="sxs-lookup"><span data-stu-id="16c78-433">The certificate is checked against a public key in the store and the data in the certificate is used to check the identity of the server.</span></span>

<span data-ttu-id="16c78-434">NetX Secure TLS поддерживает проверку подлинности RSA.</span><span class="sxs-lookup"><span data-stu-id="16c78-434">NetX Secure TLS supports RSA authentication.</span></span>

### <a name="cryptographic-hashing"></a><span data-ttu-id="16c78-435">Криптографическое хэширование</span><span class="sxs-lookup"><span data-stu-id="16c78-435">Cryptographic Hashing</span></span>

<span data-ttu-id="16c78-436">Шифрование — не единственная криптографическая операция, используемая в протоколе TLS.</span><span class="sxs-lookup"><span data-stu-id="16c78-436">Encryption is not the only cryptographic operation used in TLS.</span></span> <span data-ttu-id="16c78-437">Чтобы обеспечить целостность сообщений во время сеанса TLS, необходимо вычислять контрольную сумму. Это позволит убедиться, что содержимое сообщения не было изменено.</span><span class="sxs-lookup"><span data-stu-id="16c78-437">In order to provide message integrity during a TLS session, a checksum is needed to ensure that the message contents have not been tampered with.</span></span> <span data-ttu-id="16c78-438">Однако простого вычисления контрольной суммы (как в протоколе TCP) недостаточно, чтобы обеспечить приемлемый уровень целостности, так как осведомленный злоумышленник может легко ее саботировать.</span><span class="sxs-lookup"><span data-stu-id="16c78-438">However, a simple checksum (as is used in TCP) is insufficient to guarantee an acceptable level of integrity as it can be easily subverted by a knowledgeable attacker.</span></span> <span data-ttu-id="16c78-439">Механизм, используемый протоколом TLS для обеспечения целостности сообщений, называется *криптографическим хэшем*.</span><span class="sxs-lookup"><span data-stu-id="16c78-439">The mechanism used by TLS to provide message integrity is known as a *cryptographic hash*.</span></span>

<span data-ttu-id="16c78-440">Шифрование — это кодирование 1:1, то есть из зашифрованных данных могут быть получены все исходные данные.</span><span class="sxs-lookup"><span data-stu-id="16c78-440">Encryption is a 1:1 encoding – that is, the entirety of the original data can be obtained from the encrypted data.</span></span> <span data-ttu-id="16c78-441">Однако хэш позволяет сопоставить произвольный объем данных со значением фиксированного размера, как и контрольная сумма.</span><span class="sxs-lookup"><span data-stu-id="16c78-441">However, a hash maps an arbitrary amount of data into a fixed size value, just like a checksum.</span></span> <span data-ttu-id="16c78-442">В отличие от простой контрольной суммы, хэш специально разработан для уменьшения числа *конфликтов*, в результате которых разные входные данные могут формировать одинаковые выходные данные.</span><span class="sxs-lookup"><span data-stu-id="16c78-442">Unlike a simple checksum, a hash is specifically designed to reduce *collisions*, where different input data result in the same output.</span></span> <span data-ttu-id="16c78-443">Если в простой контрольной сумме один бит будет обращен из 1 в 0, а другой — из 0 в 1, то эта контрольная сумма не изменится.</span><span class="sxs-lookup"><span data-stu-id="16c78-443">In a simple checksum, if a bit is flipped from 1 to 0 and another bit from 0 to 1, the checksum is the same.</span></span> <span data-ttu-id="16c78-444">При использовании криптографического хэша выходные данные будут значительно отличаться, что затруднит для злоумышленника изменение хэшированных данных и получение такого же результата операции хэширования с измененными данными (то есть фальшивую проверку целостности этих данных).</span><span class="sxs-lookup"><span data-stu-id="16c78-444">With a cryptographic hash, the output would differ significantly, making it difficult for an attacker to change the hashed data and have the hash operation on the changed data still result in the same value (and thus falsely verifying the integrity of that data).</span></span>

<span data-ttu-id="16c78-445">В протоколе TLS используется несколько различных алгоритмов хэширования для обеспечения целостности сообщений — как сообщений приложений, так и управляющих сообщений TLS.</span><span class="sxs-lookup"><span data-stu-id="16c78-445">TLS uses a number of different hash algorithms to provide integrity for messages, both application messages and TLS control messages.</span></span> <span data-ttu-id="16c78-446">К ним относятся алгоритмы MD5, SHA-1 и SHA-256.</span><span class="sxs-lookup"><span data-stu-id="16c78-446">These include MD5, SHA-1 and SHA-256.</span></span>

<span data-ttu-id="16c78-447">NetX Secure TLS поддерживает алгоритмы хэширования MD5, SHA-1 и SHA-256.</span><span class="sxs-lookup"><span data-stu-id="16c78-447">NetX Secure TLS supports MD5, SHA-1, and SHA-256 hashing.</span></span>

## <a name="tls-extensions"></a><span data-ttu-id="16c78-448">Расширения TLS</span><span class="sxs-lookup"><span data-stu-id="16c78-448">TLS Extensions</span></span>

<span data-ttu-id="16c78-449">Протокол TLS предоставляет ряд расширений, которые обеспечивают дополнительные функциональные возможности для определенных приложений.</span><span class="sxs-lookup"><span data-stu-id="16c78-449">TLS provides a number of extensions that provide additional functionality for certain applications.</span></span> <span data-ttu-id="16c78-450">Эти расширения обычно передаются как часть сообщений ClientHello или ServerHello, указывая удаленному узлу намерение использовать расширение или предоставляя дополнительные сведения для установления безопасного сеанса TLS.</span><span class="sxs-lookup"><span data-stu-id="16c78-450">These extensions are typically sent as part of the ClientHello or ServerHello messages, indicating to a remote host the desire to use an extension or providing additional details for use in establishing the secure TLS session.</span></span>

<span data-ttu-id="16c78-451">В общем случае в начале подтверждения расширения предоставляют дополнительные параметры для протокола TLS, которые помогают выполнять последующие операции.</span><span class="sxs-lookup"><span data-stu-id="16c78-451">In general, extensions provide optional parameters to TLS at the beginning of the handshake that guide the proceeding operations.</span></span> <span data-ttu-id="16c78-452">Для некоторых расширений требуется ввод данных или принятие решения приложением, в то время как другие обрабатываются автоматически.</span><span class="sxs-lookup"><span data-stu-id="16c78-452">Some extensions require application input or decision making, while others are handled automatically.</span></span>

<span data-ttu-id="16c78-453">В следующей таблице описаны расширения TLS, которые в настоящее время поддерживаются в NetX Secure TLS.</span><span class="sxs-lookup"><span data-stu-id="16c78-453">The following table describes the TLS extensions currently supported by NetX Secure TLS:</span></span>

| <span data-ttu-id="16c78-454">**Extension Name**</span><span class="sxs-lookup"><span data-stu-id="16c78-454">**Extension Name**</span></span>              | <span data-ttu-id="16c78-455">**Описание**</span><span class="sxs-lookup"><span data-stu-id="16c78-455">**Description**</span></span>              |
| ------------------------------- |----------------------------- |
| <span data-ttu-id="16c78-456">Указание безопасного повторного согласования</span><span class="sxs-lookup"><span data-stu-id="16c78-456">Secure Renegotiation Indication</span></span> | <span data-ttu-id="16c78-457">Это расширение устраняет уязвимость к атаке "злоумышленник в середине", которая может возникнуть во время подтверждения повторного согласования.</span><span class="sxs-lookup"><span data-stu-id="16c78-457">This extension mitigates a Man-in-the-Middle attack vulnerability that could occur during a renegotiation handshake.</span></span>|
| <span data-ttu-id="16c78-458">Указание имени сервера</span><span class="sxs-lookup"><span data-stu-id="16c78-458">Server Name Indication</span></span>          | <span data-ttu-id="16c78-459">Это расширение позволяет клиенту TLS предоставить конкретное DNS-имя серверу TLS, давая серверу возможность выбрать правильные учетные данные (предполагается, что сервер имеет несколько удостоверяющих сертификатов и сетевых точек входа).</span><span class="sxs-lookup"><span data-stu-id="16c78-459">This extension allows a TLS Client to supply a specific DNS name to a TLS Server, allowing the server to select the correct credentials (assumes the server has multiple identity certificates and network entrypoints).</span></span> |
| <span data-ttu-id="16c78-460">Алгоритмы сигнатуры</span><span class="sxs-lookup"><span data-stu-id="16c78-460">Signature Algorithms</span></span>            | <span data-ttu-id="16c78-461">Это расширение позволяет клиенту TLS предоставить список допустимых алгоритмов сигнатуры и хэширования для сервера TLS.</span><span class="sxs-lookup"><span data-stu-id="16c78-461">This extension enables a TLS Client to provide a list of acceptable signature and hash algorithms to a TLS Server.</span></span> |

<span data-ttu-id="16c78-462">Общие сведения о поддерживаемых расширениях TLS</span><span class="sxs-lookup"><span data-stu-id="16c78-462">Overview of supported TLS Extensions</span></span>

### <a name="secure-renegotiation-indication"></a><span data-ttu-id="16c78-463">Указание безопасного повторного согласования</span><span class="sxs-lookup"><span data-stu-id="16c78-463">Secure Renegotiation Indication</span></span>

<span data-ttu-id="16c78-464">Протокол TLS поддерживает выполнение подтверждения в существующем сеансе TLS, используя при этом установленный сеанс для шифрования сообщений подтверждения.</span><span class="sxs-lookup"><span data-stu-id="16c78-464">TLS supports the notion of performing a handshake within an existing TLS session, thereby using the established session to encrypt the handshake messages.</span></span> <span data-ttu-id="16c78-465">Этот процесс позволяет повторно установить ключи сеанса шифрования без завершения сеанса TLS (см. раздел "Повторное согласование сеанса TLS").</span><span class="sxs-lookup"><span data-stu-id="16c78-465">This process allows the cryptographic session keys to be re-established without ending the TLS session (see section "TLS Session Renegotiation").</span></span>

<span data-ttu-id="16c78-466">К сожалению, после того как в течение некоторого времени в протоколе TLS использовалось повторное согласование, была обнаружена уязвимость к атаке "злоумышленник в середине", использующей функцию повторного согласования.</span><span class="sxs-lookup"><span data-stu-id="16c78-466">Unfortunately, after TLS had been using renegotiation for some time, it was discovered that there was a vulnerability to a Man-in-the-Middle attack that exploited the renegotiation feature.</span></span> <span data-ttu-id="16c78-467">Чтобы устранить эту уязвимость, было введено расширение для указания безопасного повторного согласования.</span><span class="sxs-lookup"><span data-stu-id="16c78-467">To close the vulnerability, the Secure Renegotiation Indication extension was introduced.</span></span> <span data-ttu-id="16c78-468">По сути, расширение для безопасного повторного согласования использует хэш сообщения Finished из установленного подключения, чтобы убедиться в том, что в подтверждении повторного согласования участвуют исходные узлы. Фактически, хэш используется в качестве маркера проверки, исходя из предположения, что злоумышленник не сможет подделать хэш (что потребует доступа к ключам сеанса).</span><span class="sxs-lookup"><span data-stu-id="16c78-468">Essentially, the Secure Renegotiation extension uses the Finished message hash from the established connection to verify that the original hosts are participating in the renegotiation handshake – essentially the hash is used as a verification token under the assumption that an attacker would not be able to forge the hash (which would require access to the session keys).</span></span>

<span data-ttu-id="16c78-469">NetX Secure TLS автоматически обрабатывает повторное согласование и по умолчанию использует расширение для безопасного повторного согласования.</span><span class="sxs-lookup"><span data-stu-id="16c78-469">NetX Secure TLS handles renegotiation automatically and uses the Secure Renegotiation Extension by default.</span></span> <span data-ttu-id="16c78-470">Взаимодействие с приложением не требуется.</span><span class="sxs-lookup"><span data-stu-id="16c78-470">No application interaction is required.</span></span>

### <a name="server-name-indication"></a><span data-ttu-id="16c78-471">Указание имени сервера</span><span class="sxs-lookup"><span data-stu-id="16c78-471">Server Name Indication</span></span>

<span data-ttu-id="16c78-472">Во время подтверждения TLS клиент TLS должен предоставить удаленному серверу удостоверяющий сертификат, чтобы проверить подлинность этого сервера.</span><span class="sxs-lookup"><span data-stu-id="16c78-472">During the TLS handshake, a TLS Client expects a remote server to provide an identity certificate so the client can authenticate the server.</span></span> <span data-ttu-id="16c78-473">Однако могут возникнуть ситуации, когда сервер предоставит несколько различных служб с разными "виртуальными" серверами, у каждого из которых есть уникальное удостоверение.</span><span class="sxs-lookup"><span data-stu-id="16c78-473">However, there may be some cases where a server will provide multiple different services with different "virtual" servers each having unique identities.</span></span> <span data-ttu-id="16c78-474">В случае одного сервера с несколькими удостоверениями клиент TLS может предоставить определенное DNS-имя, которое будет использоваться сервером для выбора правильных учетных данных. Механизм для предоставления этого имени — это расширение для указания имени сервера (SNI).</span><span class="sxs-lookup"><span data-stu-id="16c78-474">In the case of a single server with multiple identities, a TLS client can supply a specific DNS name that the server will use to select the proper credentials – the mechanism for supplying this name is the Server Name Indication (SNI) extension.</span></span>

<span data-ttu-id="16c78-475">От приложения, использующего расширение SNI, требуется определенное взаимодействие.</span><span class="sxs-lookup"><span data-stu-id="16c78-475">For an application using the SNI extension, some interaction is required.</span></span> <span data-ttu-id="16c78-476">Приложение должно предоставить клиентам TLS DNS-имя, отправляемое на удаленный сервер.</span><span class="sxs-lookup"><span data-stu-id="16c78-476">For TLS Clients, the application must supply a DNS name to be sent to the remote server.</span></span> <span data-ttu-id="16c78-477">Для серверов TLS приложение должно прочитать DNS-имя из расширения и выбрать соответствующий сертификат, чтобы отправить его клиенту.</span><span class="sxs-lookup"><span data-stu-id="16c78-477">For TLS Servers, the application must read the DNS name from the extension and select an appropriate certificate to send back to the client.</span></span>

<span data-ttu-id="16c78-478">Следующие разделы содержат более подробные сведения об использовании расширения SNI в NetX Secure TLS.</span><span class="sxs-lookup"><span data-stu-id="16c78-478">The following sections provide more detail on how to use the SNI extension in NetX Secure TLS.</span></span>

### <a name="sni-extension--tls-client"></a><span data-ttu-id="16c78-479">Расширение SNI — клиент TLS</span><span class="sxs-lookup"><span data-stu-id="16c78-479">SNI Extension – TLS Client</span></span>

<span data-ttu-id="16c78-480">Клиент NetX Secure TLS, желающий использовать расширение SNI, должен предоставить DNS-имя для протокола TLS, которое будет предоставлено при подтверждении.</span><span class="sxs-lookup"><span data-stu-id="16c78-480">A NetX Secure TLS Client wishing to use the SNI extension must provide a DNS name to TLS to be supplied during the handshake.</span></span> <span data-ttu-id="16c78-481">Это имя должно быть инициализировано и указано перед началом сеанса TLS, так как расширение передается в сообщении ClientHello, запускающем процесс подтверждения.</span><span class="sxs-lookup"><span data-stu-id="16c78-481">This name must be initialized and supplied prior to starting a TLS session since the extension is sent in the ClientHello message which starts the handshake process.</span></span>

<span data-ttu-id="16c78-482">В следующем фрагменте кода показано, как используется это расширение.</span><span class="sxs-lookup"><span data-stu-id="16c78-482">The following code snippet illustrates the use of the extension.</span></span> <span data-ttu-id="16c78-483">Сначала инициализируется объект NX_SECURE_X509_DNS_NAME с требуемым именем сервера.</span><span class="sxs-lookup"><span data-stu-id="16c78-483">First, a NX_SECURE_X509_DNS_NAME object is initialized with the desired server name.</span></span> <span data-ttu-id="16c78-484">Затем перед началом сеанса TLS это имя передается в протокол TLS с помощью API расширения SNI.</span><span class="sxs-lookup"><span data-stu-id="16c78-484">Then, prior to starting the TLS session, the name is provided to TLS using the SNI extension API.</span></span> <span data-ttu-id="16c78-485">После задания имени дальнейшие действия не требуются.</span><span class="sxs-lookup"><span data-stu-id="16c78-485">Once the name is set, no further action is required.</span></span> <span data-ttu-id="16c78-486">Ознакомьтесь со справочником по API в главе 4,</span><span class="sxs-lookup"><span data-stu-id="16c78-486">See the API reference in Chapter 4</span></span>  
  
<span data-ttu-id="16c78-487">"Описание служб ОСРВ Azure NetX Secure DTLS", чтобы получить дополнительные сведения об отдельных функциях.</span><span class="sxs-lookup"><span data-stu-id="16c78-487">Description of NetX Secure Services for more information on the individual functions.</span></span>

```C
/* The dns_name variable will contain our desired server name. */
UINT status;
NX_SECURE_X509_DNS_NAME dns_name;

/* Initialize the server DNS name. */
status = nx_secure_x509_dns_name_initialize(&dns_name, "www.example.com", 
                                            strlen("www.example.com"));


/* Initialize SNI extension in previously-initialized TLS Session. */
status = nx_secure_tls_session_sni_extension_set(&client_tls_session, &dns_name);

/* Now start the TLS session, starting with establishing the TCP connection – if 
   TLS is started before initializing the SNI extension, the extension will not be 
   sent in the ClientHello message! */
status = nx_tcp_client_socket_connect(&client_socket, IP_ADDRESS(1, 2, 3, 4), 443, 
                                      5 * NX_IP_PERIODIC_RATE);

status = nx_secure_tls_session_start(&client_tls_session, &client_socket, 
                                     NX_WAIT_FOREVER);
```
### <a name="sni-extension--tls-server"></a><span data-ttu-id="16c78-488">Расширение SNI — сервер TLS</span><span class="sxs-lookup"><span data-stu-id="16c78-488">SNI Extension – TLS Server</span></span>

<span data-ttu-id="16c78-489">На стороне сервера TLS расширение SNI может быть обработано приложением для выбора правильных учетных данных (например, сертификата), которые будут предоставлены удаленному клиенту во время подтверждения.</span><span class="sxs-lookup"><span data-stu-id="16c78-489">On the TLS Server side, the SNI extension may be processed by the application in order to select proper credentials (e.g. certificate) to provide to the remote client during the handshake.</span></span> <span data-ttu-id="16c78-490">Для этого приложение должно предоставить обратный вызов сеанса, который выполняется после получения сообщения ClientHello.</span><span class="sxs-lookup"><span data-stu-id="16c78-490">To do this, the application must supply a session callback which is invoked following the receipt of a ClientHello message.</span></span>

<span data-ttu-id="16c78-491">Пример кода для API nx_secure_tls_session_server_callback_set (см. стр. 122) иллюстрирует анализ входящего расширения SNI с помощью обратного вызова сервера.</span><span class="sxs-lookup"><span data-stu-id="16c78-491">The example code for the nx_secure_tls_session_server_callback_set API  (see page 122) illustrates the parsing of an incoming SNI extension using a server callback.</span></span> <span data-ttu-id="16c78-492">По сути, сервер TLS получает сообщение ClientHello и выполняет обратный вызов.</span><span class="sxs-lookup"><span data-stu-id="16c78-492">Essentially, the TLS Server receives a ClientHello and invokes the callback.</span></span> <span data-ttu-id="16c78-493">Затем приложение использует API *nx_secure_tls_session_sni_extension_parse* для анализа данных расширения, предоставленных для обратного вызова, чтобы найти расширение SNI и вернуть указанное DNS-имя. Обратите внимание на то, что расширение поддерживает только одно DNS-имя.</span><span class="sxs-lookup"><span data-stu-id="16c78-493">Then the application uses the *nx_secure_tls_session_sni_extension_parse* API to parse the extension data provided to the callback to find the SNI extension and return the supplied DNS name (note that the extension only supports a single DNS name).</span></span> <span data-ttu-id="16c78-494">После получения имени приложение использует его, чтобы найти и отправить соответствующий удостоверяющий сертификат сервера (и цепочку издателей, если применимо).</span><span class="sxs-lookup"><span data-stu-id="16c78-494">Once the name is obtained, the application uses it to find and send the appropriate server identity certificate (and issuer chain if applicable).</span></span>

### <a name="signature-algorithms-extension"></a><span data-ttu-id="16c78-495">Расширение алгоритмов сигнатуры</span><span class="sxs-lookup"><span data-stu-id="16c78-495">Signature Algorithms Extension</span></span>

<span data-ttu-id="16c78-496">Это расширение относится только к протоколу TLS 1.2 и позволяет клиенту TLS предоставить список допустимых пар сигнатур и хэш-алгоритмов для создания и проверки цифровых подписей.</span><span class="sxs-lookup"><span data-stu-id="16c78-496">This extension is specific to TLS 1.2 and allows a TLS Client to provide a list of acceptable signature and hash algorithm pairs that are acceptable for use in generating and verifying digital signatures.</span></span> <span data-ttu-id="16c78-497">Этот список создается автоматически NetX Secure TLS для клиентов TLS с помощью таблицы шифров, предоставленной для *nx_secure_tls_session_create*.</span><span class="sxs-lookup"><span data-stu-id="16c78-497">The list is generated automatically by NetX Secure TLS for TLS Clients using the cipher table supplied to *nx_secure_tls_session_create*.</span></span> <span data-ttu-id="16c78-498">Взаимодействие с приложением не требуется.</span><span class="sxs-lookup"><span data-stu-id="16c78-498">No application interaction is required.</span></span>

## <a name="authentication-methods"></a><span data-ttu-id="16c78-499">Способы проверки подлинности</span><span class="sxs-lookup"><span data-stu-id="16c78-499">Authentication Methods</span></span>

<span data-ttu-id="16c78-500">Протокол TLS предоставляет платформу для установления безопасного подключения между двумя устройствами по незащищенной сети, но часть проблемы заключается в том, чтобы определить подлинность устройства на другом конце этого подключения.</span><span class="sxs-lookup"><span data-stu-id="16c78-500">TLS provides the framework for establishing a secure connection between two devices over an insecure network, but part of the problem is knowing the identity of the device on the other end of that connection.</span></span> <span data-ttu-id="16c78-501">Без механизма проверки подлинности удостоверений удаленных узлов злоумышленник легко сможет предоставить фальшивое доверенное устройство.</span><span class="sxs-lookup"><span data-stu-id="16c78-501">Without a mechanism for authenticating the identity of remote hosts, it becomes a trivial operation for an attacker to pose as a trusted device.</span></span>

<span data-ttu-id="16c78-502">Изначально может показаться, что использование IP-адресов, аппаратных MAC-адресов или DNS обеспечивает относительно высокий уровень надежности для идентификации узлов в сети, но, учитывая характер технологии TCP/IP и простоту подмены адресов и повреждения записей DNS (например, с помощью подделки записей кэша DNS), для протокола TLS требуется дополнительный уровень защиты от поддельных удостоверений.</span><span class="sxs-lookup"><span data-stu-id="16c78-502">Initially, it may seem that using IP addresses, hardware MAC addresses, or DNS would provide a relatively high level of confidence for identifying hosts on a network, but given the nature of TCP/IP technology and the ease with which addresses can be spoofed and DNS entries corrupted (e.g. through DNS cache poisoning), it becomes clear that TLS needs an additional layer of protection against fraudulent identities.</span></span>

<span data-ttu-id="16c78-503">Существует ряд механизмов, которые могут обеспечить этот дополнительный уровень проверки подлинности для TLS, но наиболее распространенным является *цифровой сертификат*.</span><span class="sxs-lookup"><span data-stu-id="16c78-503">There are various mechanisms that can provide this extra layer of authentication for TLS, but the most common is the *digital certificate.*</span></span> <span data-ttu-id="16c78-504">К другим механизмам относятся схемы на основе общих ключей (PSK) и паролей.</span><span class="sxs-lookup"><span data-stu-id="16c78-504">Other mechanisms include Pre-Shared Keys (PSK) and password schemes.</span></span>

### <a name="digital-cerificates"></a><span data-ttu-id="16c78-505">Цифровые сертификаты</span><span class="sxs-lookup"><span data-stu-id="16c78-505">Digital Cerificates</span></span>

<span data-ttu-id="16c78-506">Цифровые сертификаты — наиболее распространенный способ проверки подлинности удаленного узла в протоколе TLS.</span><span class="sxs-lookup"><span data-stu-id="16c78-506">Digital certificates are the most common method for authenticating a remote host in TLS.</span></span> <span data-ttu-id="16c78-507">По сути, цифровой сертификат — это документ с особым форматированием, который предоставляет идентификационные данные устройства в компьютерной сети.</span><span class="sxs-lookup"><span data-stu-id="16c78-507">Essentially, a digital certificate is a document with specific formatting that provides identity information for a device on a computer network.</span></span>

<span data-ttu-id="16c78-508">В протоколе TLS обычно используется формат X.509 — стандарт, разработанный Международным союзом электросвязи, хотя могут использоваться и другие форматы сертификатов, если узлы TLS могут согласовать используемый формат.</span><span class="sxs-lookup"><span data-stu-id="16c78-508">TLS normally uses a format called X.509, a standard developed by the International Telecommunication Union, though other formats of certificates may be used if the TLS hosts can agree on the format being used.</span></span> <span data-ttu-id="16c78-509">Стандарт X.509 определяет точный формат сертификатов и различные кодировки, которые можно использовать для создания цифрового документа.</span><span class="sxs-lookup"><span data-stu-id="16c78-509">X.509 defines a specific format for certificates and various encodings that can be used to produce a digital document.</span></span> <span data-ttu-id="16c78-510">Большинство сертификатов X.509, используемых с протоколом TLS, кодируется с использованием разновидности ASN.1 — еще одного стандарта связи.</span><span class="sxs-lookup"><span data-stu-id="16c78-510">Most X.509 certificates used with TLS are encoded using a variant of ASN.1, another telecommunications standard.</span></span> <span data-ttu-id="16c78-511">В ASN.1 доступны различные цифровые кодировки, но чаще всего для кодирования сертификатов TLS применяется стандарт DER (Distinguished Encoding Rules).</span><span class="sxs-lookup"><span data-stu-id="16c78-511">Within ASN.1 there are various digital encodings, but the most common encoding for TLS certificates is the Distinguished Encoding Rules (DER) standard.</span></span> <span data-ttu-id="16c78-512">DER — это упрощенное подмножество стандарта BER (Basic Encoding Rules) ASN.1, которое предназначено обеспечить однозначность и упростить анализ.</span><span class="sxs-lookup"><span data-stu-id="16c78-512">DER is a simplified subset of the ASN.1 Basic Encoding Rules (BER) that is designed to be unambiguous, making parsing easier.</span></span> <span data-ttu-id="16c78-513">В сети сертификаты TLS обычно кодируются в двоичном формате DER, и именно в этом формате NetX Secure ожидает сертификаты X.509.</span><span class="sxs-lookup"><span data-stu-id="16c78-513">Over the wire, TLS certificates are usually encoded in binary DER, and this is the format that NetX Secure expects for X.509 certificates.</span></span>

<span data-ttu-id="16c78-514">Хотя двоичные сертификаты в формате DER используются в фактическом протоколе TLS, они могут создаваться и храниться в разных кодировках с такими расширениями файла, как PEM, CRT и P12.</span><span class="sxs-lookup"><span data-stu-id="16c78-514">Though DER-formatted binary certificates are used in the actual TLS protocol, they may be generated and stored in a number of different encodings, with file extensions such as .pem, .crt, and .p12.</span></span> <span data-ttu-id="16c78-515">Различные варианты используются приложениями разных производителей, но в целом их можно преобразовать в формат DER с помощью широко доступных средств.</span><span class="sxs-lookup"><span data-stu-id="16c78-515">The different variants are used by different applications from different manufacturers, but generally all can be converted into DER using widely available tools.</span></span>

<span data-ttu-id="16c78-516">Наиболее распространенной альтернативной кодировкой сертификатов является PEM.</span><span class="sxs-lookup"><span data-stu-id="16c78-516">The most common of the alternative certificate encodings is PEM.</span></span> <span data-ttu-id="16c78-517">Формат PEM (Privacy-Enhanced Mail) представляет собой версию кодировки DER в формате Base64, которая часто используется, так как это кодирование позволяет получить печатный текст, который можно легко отправить с помощью электронной почты или веб-протоколов.</span><span class="sxs-lookup"><span data-stu-id="16c78-517">The PEM format (from Privacy-Enhanced Mail) is a base-64 encoded version of the DER encoding that is often used because the encoding results in printable text that can be easily sent using email or web-based protocols.</span></span>

<span data-ttu-id="16c78-518">Создание сертификата для вашего приложения NetX Secure обычно выходит за рамки данного руководства, но программа командной строки OpenSSL ([www.openssl.org](http://www.openssl.org)) широко доступна и может выполнять взаимное преобразование большинства форматов.</span><span class="sxs-lookup"><span data-stu-id="16c78-518">Generating a certificate for your NetX Secure application is generally outside the scope of this manual, but the OpenSSL command-line tool ([www.openssl.org](http://www.openssl.org)) is widely available and can convert between most formats.</span></span>

<span data-ttu-id="16c78-519">В зависимости от приложения вы можете создавать собственные сертификаты, получать сертификаты от изготовителя или правительственной организации или приобретать сертификаты у коммерческого центра сертификации.</span><span class="sxs-lookup"><span data-stu-id="16c78-519">Depending on your application, you may generate your own certificates, be provided certificates by a  manufacturer or government organization, or purchase certificates from a commercial certificate authority.</span></span>

<span data-ttu-id="16c78-520">Чтобы использовать цифровой сертификат в приложении NetX Secure, необходимо сначала преобразовать этот сертификат в двоичный формат DER и, при необходимости, преобразовать в двоичный формат соответствующий закрытый ключ (например, "закрытый показатель" для RSA), обычно это ключ RSA или ключ ECC в кодировке DER и формате PKCS № 1.</span><span class="sxs-lookup"><span data-stu-id="16c78-520">To use a digital certificate in your NetX Secure application, you must first convert your certificate into a binary DER format and, optionally, convert the associated private key (the "private exponent" for RSA, for example) into a binary format, typically a PKCS#1-formatted, DER-encoded RSA key or a DER-encoded ECC key.</span></span> <span data-ttu-id="16c78-521">После завершения преобразования необходимо загрузить сертификат и закрытый ключ на устройство.</span><span class="sxs-lookup"><span data-stu-id="16c78-521">Once the conversion is complete, it is up to you to load the certificate and private key onto the device.</span></span> <span data-ttu-id="16c78-522">Возможные варианты включают в себя использование файловой системы флэш-памяти или создание массива C на основе данных (с помощью такого инструмента, как xxd в Linux), а также компиляцию сертификата и ключа в приложении в качестве постоянных данных.</span><span class="sxs-lookup"><span data-stu-id="16c78-522">Possible options include using a flash-based file system or generating a C array from the data (using a tool such as "xxd" from Linux) and compiling the certificate and key into your application as constant data.</span></span>

<span data-ttu-id="16c78-523">После загрузки сертификата на устройство можно использовать API TLS, чтобы связать этот сертификат с сеансом TLS.</span><span class="sxs-lookup"><span data-stu-id="16c78-523">Once your certificate is loaded onto the device, the TLS API can be used to associate your certificate with a TLS session.</span></span>

<span data-ttu-id="16c78-524">Дополнительные сведения и примеры использования сертификатов X.509 с NetX Secure TLS приведены в разделе "Импорт сертификатов X.509 в NetX Secure".</span><span class="sxs-lookup"><span data-stu-id="16c78-524">For details and examples on how to use X.509 certificates with NetX Secure TLS, see the section "Importing X.509 certificates into NetX Secure".</span></span>

<span data-ttu-id="16c78-525">Ознакомьтесь с дополнительными сведениями о приведенных ниже службах TLS в справочнике по API:</span><span class="sxs-lookup"><span data-stu-id="16c78-525">Refer to the following TLS services in the API reference for more information:</span></span>

- <span data-ttu-id="16c78-526">nx_secure_x509_certificate_initialize</span><span class="sxs-lookup"><span data-stu-id="16c78-526">nx_secure_x509_certificate_initialize</span></span>
- <span data-ttu-id="16c78-527">nx_secure_tls_local_certificate_add</span><span class="sxs-lookup"><span data-stu-id="16c78-527">nx_secure_tls_local_certificate_add</span></span>
- <span data-ttu-id="16c78-528">nx_secure_tls_local_certificate_remove</span><span class="sxs-lookup"><span data-stu-id="16c78-528">nx_secure_tls_local_certificate_remove</span></span>
- <span data-ttu-id="16c78-529">nx_secure_tls_remote_certificate_allocate</span><span class="sxs-lookup"><span data-stu-id="16c78-529">nx_secure_tls_remote_certificate_allocate</span></span>
- <span data-ttu-id="16c78-530">nx_secure_tls_trusted_certificate_add</span><span class="sxs-lookup"><span data-stu-id="16c78-530">nx_secure_tls_trusted_certificate_add</span></span>
- <span data-ttu-id="16c78-531">nx_secure_trusted_certificate_remove</span><span class="sxs-lookup"><span data-stu-id="16c78-531">nx_secure_trusted_certificate_remove</span></span>

### <a name="tls-client-certificate-specifics"></a><span data-ttu-id="16c78-532">Особенности сертификата клиента TLS</span><span class="sxs-lookup"><span data-stu-id="16c78-532">TLS Client Certificate Specifics</span></span>

<span data-ttu-id="16c78-533">Для реализаций клиента TLS обычно не требуется загрузка локального сертификата<sup>14</sup> на устройство.</span><span class="sxs-lookup"><span data-stu-id="16c78-533">TLS Client implementations generally do not require a "local" certificate<sup>14</sup> to be loaded onto the device.</span></span> <span data-ttu-id="16c78-534">Исключением является применение проверки подлинности на основе сертификата клиента, но она гораздо менее распространена.</span><span class="sxs-lookup"><span data-stu-id="16c78-534">The exception to this is when Client Certificate Authentication is enabled, but this is far less common.</span></span>

<span data-ttu-id="16c78-535">Клиенту TLS требуется загрузка по крайней мере одного "доверенного" сертификата<sup>15</sup> (при необходимости может быть загружено больше) и выделение пространства для "удаленного" сертификата<sup>16</sup>.</span><span class="sxs-lookup"><span data-stu-id="16c78-535">A TLS Client requires at least one "trusted" certificate<sup>15</sup> to be loaded (more may be loaded if required), and space for a "remote" certificate<sup>16</sup> to be allocated.</span></span>

<span data-ttu-id="16c78-536">Дополнительные сведения о добавлении доверенных сертификатов и выделении пространства для удаленных сертификатов см. в справочнике по API TLS для служб nx_secure_tls_remote_certificate_allocate и nx_secure_tls_trusted_certificate_add.</span><span class="sxs-lookup"><span data-stu-id="16c78-536">For more information on adding trusted certificates and allocating space for remote certificates, see the TLS API reference for the following services: nx_secure_tls_remote_certificate_allocate, nx_secure_tls_trusted_certificate_add.</span></span>

14. <span data-ttu-id="16c78-537">"Локальный" сертификат — это сертификат, идентифицирующий локальное устройство, то есть предоставляющий идентификационные данные устройства, на которое загружено приложение TLS.</span><span class="sxs-lookup"><span data-stu-id="16c78-537">A “local” certificate is a certificate that identifies the local device – that is, it provides identity information for the device upon which the TLS application is loaded.</span></span>

15. <span data-ttu-id="16c78-538">"Доверенный" сертификат — это сертификат, который предоставляет основу для доверия и проверки подлинности удаленного устройства напрямую либо посредством инфраструктуры открытых ключей (PKI).</span><span class="sxs-lookup"><span data-stu-id="16c78-538">A “trusted” certificate is a certificate that provides a basis for trust and authentication of the remote device, either directly or through a Public Key Infrastructure (PKI).</span></span> <span data-ttu-id="16c78-539">Корень цепочки доверия обычно называется "центром сертификации" или сертификатом ЦС.</span><span class="sxs-lookup"><span data-stu-id="16c78-539">The root of the chain of trust is usually called a “Certification Authority” or CA certificate.</span></span>

16. <span data-ttu-id="16c78-540">"Удаленный" сертификат означает сертификат, отправленный удаленным узлом во время подтверждения TLS.</span><span class="sxs-lookup"><span data-stu-id="16c78-540">A “remote” certificate refers to the certificate sent by the remote host during the TLS handshake.</span></span> <span data-ttu-id="16c78-541">Он предоставляет удостоверение этого удаленного узла и проходит проверку подлинности, при которой это удостоверение сравнивается с доверенным сертификатом на локальном устройстве.</span><span class="sxs-lookup"><span data-stu-id="16c78-541">It provides identity for that remote host and is authenticated by comparing it to a “trusted” certificate on the local device.</span></span>

### <a name="tls-server-certificate-specifics"></a><span data-ttu-id="16c78-542">Особенности сертификата сервера TLS</span><span class="sxs-lookup"><span data-stu-id="16c78-542">TLS Server Certificate Specifics</span></span>

<span data-ttu-id="16c78-543">Для реализации сервера TLS обычно не требуется загрузка доверенных сертификатов на устройство или выделение удаленных сертификатов.</span><span class="sxs-lookup"><span data-stu-id="16c78-543">TLS Server implementations generally do not require "trusted" certificates to be loaded onto the device or remote certificates to be allocated.</span></span> <span data-ttu-id="16c78-544">Исключением является применение проверки подлинности на основе сертификата клиента, но она менее распространена.</span><span class="sxs-lookup"><span data-stu-id="16c78-544">The exception to this being when Client Certificate Authentication is enabled (this is less common).</span></span>

<span data-ttu-id="16c78-545">Сервер TLS требует загрузки локального сертификата, чтобы сервер мог предоставить его удаленному клиенту во время подтверждения TLS, чтобы клиент мог проверить подлинность сервера.</span><span class="sxs-lookup"><span data-stu-id="16c78-545">A TLS Server requires a "local" certificate to be loaded so the server can provide it to the remote client during the TLS handshake to authenticate the server to the client.</span></span>

<span data-ttu-id="16c78-546">Дополнительные сведения о загрузке локальных сертификатов для серверных приложений NetX TLS см. в справочнике по API для следующих служб:</span><span class="sxs-lookup"><span data-stu-id="16c78-546">For more information about loading local certificates for use with NetX TLS server applications, see the API reference for the following services:</span></span> 
- <span data-ttu-id="16c78-547">nx_secure_tls_local_certificate_add,</span><span class="sxs-lookup"><span data-stu-id="16c78-547">nx_secure_tls_local_certificate_add,</span></span> 
- <span data-ttu-id="16c78-548">nx_secure_tls_local_certificate_remove.</span><span class="sxs-lookup"><span data-stu-id="16c78-548">nx_secure_tls_local_certificate_remove.</span></span>

### <a name="pre-shared-keys-psk"></a><span data-ttu-id="16c78-549">Общие ключи (PSK)</span><span class="sxs-lookup"><span data-stu-id="16c78-549">Pre-Shared Keys (PSK)</span></span>

<span data-ttu-id="16c78-550">Альтернативным механизмом идентификации для проверки подлинности в протоколе TLS является понятие общих ключей (PSK).</span><span class="sxs-lookup"><span data-stu-id="16c78-550">An alternative mechanism for providing identification authentication in TLS is the notion of Pre-Shared Keys (PSK).</span></span> <span data-ttu-id="16c78-551">Использование комплекта шифров PSK устраняет необходимость выполнять операции шифрования с открытым ключом, требующие интенсивного использования процессора, что является явным преимуществом для встроенных устройств с ограниченными ресурсами.</span><span class="sxs-lookup"><span data-stu-id="16c78-551">Using a PSK ciphersuite removes the need to do the processor-intensive public-key encryption operations, a boon for resource-constrained embedded devices.</span></span> <span data-ttu-id="16c78-552">PSK заменяет сертификат в подтверждении TLS и используется вместо зашифрованной предварительной главной копии секрета для создания ключа сеанса TLS.</span><span class="sxs-lookup"><span data-stu-id="16c78-552">The PSK replaces the certificate in the TLS handshake and is used in place of the encrypted Pre-Master Secret for TLS session key generation.</span></span>

<span data-ttu-id="16c78-553">Комплекты шифров PSK ограничены в том смысле, что общий секрет должен находиться на обоих устройствах, прежде чем можно будет установить сеанс TLS.</span><span class="sxs-lookup"><span data-stu-id="16c78-553">The PSK ciphersuites are limited in the sense that that a shared secret must be present on both devices before a TLS session can be established.</span></span> <span data-ttu-id="16c78-554">Это означает, что этот секрет должен быть загружен на устройства каким-либо альтернативным безопасным способом, а не через подключение по протоколу TLS для PSK. PSK можно обновить через подключение TLS для PSK, но устройство должно быть запущено с PSK, загруженным с помощью какого-либо другого механизма.</span><span class="sxs-lookup"><span data-stu-id="16c78-554">This means that the devices must have been loaded with that secret using some secure means other than a TLS PSK connection - PSKs may be updated over a TLS PSK connection, but the device must necessarily start with a PSK that is loaded through some other mechanism.</span></span> <span data-ttu-id="16c78-555">Например, ключи PSK можно загрузить на устройства датчика и его шлюза на фабрике перед отправкой или использовать стандартное подключение TLS (с сертификатом) для загрузки PSK.</span><span class="sxs-lookup"><span data-stu-id="16c78-555">For example, a sensor device and its gateway device could be loaded with PSKs in the factory before shipping, or a standard TLS connection (with a certificate) could be used to load the PSK.</span></span>

<span data-ttu-id="16c78-556">Существуют два варианта комплектов шифров PSK, они описаны в документе RFC 4279.</span><span class="sxs-lookup"><span data-stu-id="16c78-556">PSK ciphersuites come in a couple of forms, described in RFC 4279.</span></span> <span data-ttu-id="16c78-557">В первом применяются ключи RSA или Диффи-Хелмана, которые используются точно так же, как и открытые ключи, передаваемые в сертификате при стандартном подтверждении TLS.</span><span class="sxs-lookup"><span data-stu-id="16c78-557">The first uses RSA or Diffie-Hellman keys which are used in the same manner as the public keys transmitted in the certificate in standard TLS handshakes.</span></span> <span data-ttu-id="16c78-558">Во втором варианте, который чаще используется в среде с ограниченными ресурсами, применяется PSK, который используется для непосредственного создания ключей сеанса (например, для использования AES), что позволяет избежать выполнения ресурсоемких операций RSA или Диффи-Хелмана.</span><span class="sxs-lookup"><span data-stu-id="16c78-558">The second form, which is of more use in a resource-constrained environment, uses a PSK that is used to directly generate the session keys (for use by AES, for example), avoiding the use of the expensive RSA or Diffie-Hellman operations.</span></span>

<span data-ttu-id="16c78-559">NetX Secure поддерживает второй вариант комплектов шифров PSK, что позволяет избавить приложения от всего кода шифрования с открытым ключом и проблем с использованием памяти.</span><span class="sxs-lookup"><span data-stu-id="16c78-559">NetX Secure supports the second form of PSK ciphersuites, enabling applications to remove all public-key cryptography code and memory usage.</span></span> <span data-ttu-id="16c78-560">Сам по себе PSK не является ключом AES, а, скорее, является паролем, с помощью которого создаются фактические ключи.</span><span class="sxs-lookup"><span data-stu-id="16c78-560">The PSK itself is not an AES key, but can be considered as being more like a password from which the actual keys are generated.</span></span> <span data-ttu-id="16c78-561">Существует несколько ограничений для значения PSK, хотя более длинные значения обеспечивают большую безопасность (то же относится и к паролям).</span><span class="sxs-lookup"><span data-stu-id="16c78-561">There are few restrictions on what the PSK value can be, though longer values will provide more security (same as with passwords).</span></span>

<span data-ttu-id="16c78-562">Чтобы использовать PSK в приложении NetX Secure, необходимо сначала определить глобальный макрос **NX_SECURE_ENABLE_PSK_CIPHERSUITES**.</span><span class="sxs-lookup"><span data-stu-id="16c78-562">To use PSK with your NetX Secure application, you must first define the global macro **NX_SECURE_ENABLE_PSK_CIPHERSUITES**.</span></span> <span data-ttu-id="16c78-563">Обычно это делается с помощью параметров компилятора, но определение можно также поместить в файл заголовка nx_secure_tls.h.</span><span class="sxs-lookup"><span data-stu-id="16c78-563">This is usually done through your compiler settings, but the definition can also be placed in the nx_secure_tls.h header file.</span></span> <span data-ttu-id="16c78-564">После определения макроса поддержка комплекта шифров PSK будет скомпилирована в приложение NetX Secure TLS.</span><span class="sxs-lookup"><span data-stu-id="16c78-564">With the macro defined, PSK ciphersuite support will be compiled into your NetX Secure TLS application.</span></span>

<span data-ttu-id="16c78-565">После включения поддержки PSK можно будет использовать API TLS, чтобы настроить ключи PSK для приложения.</span><span class="sxs-lookup"><span data-stu-id="16c78-565">With PSK support enabled, you can then use the TLS API to set up PSKs for your application.</span></span> <span data-ttu-id="16c78-566">Для каждого PSK потребуется значение PSK (фактический секретный "ключ", который должен храниться в безопасном месте), значение "удостоверения", используемое для идентификации конкретного PSK, и "указание удостоверения", которое используется сервером TLS для выбора определенного значения PSK.</span><span class="sxs-lookup"><span data-stu-id="16c78-566">Each PSK will require a PSK value (the actual secret "key" – keep this value safe), an "identity" value used to identify the specific PSK, and an "identity hint" that is used by a TLS server to choose a particular PSK value.</span></span>

<span data-ttu-id="16c78-567">PSK может быть любым двоичным значением, так как он никогда не передается через сетевое подключение.</span><span class="sxs-lookup"><span data-stu-id="16c78-567">The PSK itself can be any binary value as it is never sent over a network connection.</span></span> <span data-ttu-id="16c78-568">Значение PSK может содержать до 64 байт.</span><span class="sxs-lookup"><span data-stu-id="16c78-568">The PSK can be any value up to 64 bytes in length.</span></span>

<span data-ttu-id="16c78-569">Удостоверение и указание должны представлять собой печатные строки символов в формате UTF-8.</span><span class="sxs-lookup"><span data-stu-id="16c78-569">The identity and hint must be printable character strings formatted using UTF-8.</span></span> <span data-ttu-id="16c78-570">Значения удостоверения и указания могут содержать до 128 байт.</span><span class="sxs-lookup"><span data-stu-id="16c78-570">The identity and hint values may be any length up to 128 bytes.</span></span>

<span data-ttu-id="16c78-571">Удостоверение и PSK образуют уникальную пару, которая загружается на все устройства в сети, которые должны взаимодействовать друг с другом.</span><span class="sxs-lookup"><span data-stu-id="16c78-571">The identity and PSK form a unique pair that is loaded onto every device in the network that need to communicate with one another.</span></span>

<span data-ttu-id="16c78-572">"Указание" в основном используется, чтобы определить конкретные профили приложений для группирования ключей PSK по функциям или службам.</span><span class="sxs-lookup"><span data-stu-id="16c78-572">The "hint" is primarily used for defining specific application profiles to group PSKs by function or service.</span></span> <span data-ttu-id="16c78-573">Эти значения должны быть согласованы заранее, и они зависят от приложения.</span><span class="sxs-lookup"><span data-stu-id="16c78-573">These values must be agreed upon in advance and are application dependent.</span></span> <span data-ttu-id="16c78-574">Например, серверное приложение командной строки OpenSSL (использующее PSK) применяет строку по умолчанию "Client_identity", которая должна быть предоставлена клиентом TLS для продолжения подтверждения TLS.</span><span class="sxs-lookup"><span data-stu-id="16c78-574">As an example, the OpenSSL command-line server application (with PSK enabled) uses the default string "Client_identity", which must be provided by a TLS client in order to continue with the TLS handshake.</span></span>

<span data-ttu-id="16c78-575">Дополнительные сведения о ключах PSK см. в справочнике по API NetX Secure для служб nx_secure_tls_client_psk_set и nx_secure_tls_psk_add.</span><span class="sxs-lookup"><span data-stu-id="16c78-575">For more information on PSKs, see the NetX Secure API reference for the following services: nx_secure_tls_client_psk_set, nx_secure_tls_psk_add.</span></span>

## <a name="importing-x509-certificates-into-netx-secure"></a><span data-ttu-id="16c78-576">Импорт сертификатов X.509 в NetX Secure</span><span class="sxs-lookup"><span data-stu-id="16c78-576">Importing X.509 certificates into NetX Secure</span></span>

<span data-ttu-id="16c78-577">Цифровые сертификаты необходимы для большинства подключений TLS в Интернете.</span><span class="sxs-lookup"><span data-stu-id="16c78-577">Digital certificates are required for most TLS connections on the Internet.</span></span> <span data-ttu-id="16c78-578">Сертификаты обеспечивают метод проверки подлинности неизвестных ранее узлов через Интернет за счет использования доверенных посредников, которые обычно называются *центрами сертификации* (ЦА).</span><span class="sxs-lookup"><span data-stu-id="16c78-578">Certificates provide a method for authenticating previously unknown hosts over the Internet through the use of trusted intermediaries, usually called *Certificate Authorities* or CAs.</span></span> <span data-ttu-id="16c78-579">Чтобы подключить устройство NetX Secure к коммерческой облачной службе (например, Amazon Web Services), необходимо будет импортировать сертификаты в свое приложение, загрузив их на устройство.</span><span class="sxs-lookup"><span data-stu-id="16c78-579">To connect your NetX Secure device with a commercial cloud service (such as Amazon Web Services), you will need to import certificates into your application by loading them onto your device.</span></span>

<span data-ttu-id="16c78-580">Наряду с сертификатами иногда может понадобиться *закрытый ключ*, связанный с вашим сертификатом.</span><span class="sxs-lookup"><span data-stu-id="16c78-580">Along with certificates, you will also sometimes need a *private key* that is associated with your certificate.</span></span> <span data-ttu-id="16c78-581">В некоторых приложениях (например, в клиенте TLS, если не используется проверка подлинности на основе сертификата клиента) будет достаточно только сертификата, но если сертификат используется для идентификации устройства, вам потребуется закрытый ключ.</span><span class="sxs-lookup"><span data-stu-id="16c78-581">In some applications (such as TLS Client when Client Certificate Authentication is not being used) the certificate alone will be sufficient, but if your certificate is being used to identify your device you will need a private key.</span></span> <span data-ttu-id="16c78-582">Закрытые ключи обычно создаются при создании сертификата и хранятся в отдельном файле, который часто шифруется и защищается паролем.</span><span class="sxs-lookup"><span data-stu-id="16c78-582">Private keys are typically generated when you create your certificate and are stored in a separate file, often encrypted with a password.</span></span>

### <a name="certificate-types"></a><span data-ttu-id="16c78-583">Типы сертификатов</span><span class="sxs-lookup"><span data-stu-id="16c78-583">Certificate Types</span></span>

<span data-ttu-id="16c78-584">Цифровые сертификаты обычно используются для идентификации сущностей в сети, но в зависимости от применения они могут иметь немного разные свойства.</span><span class="sxs-lookup"><span data-stu-id="16c78-584">Digital certificates are generally used to identify entities on a network, but depending on what their application they will have slightly different properties.</span></span>

### <a name="local-certificates"></a><span data-ttu-id="16c78-585">Локальные сертификаты</span><span class="sxs-lookup"><span data-stu-id="16c78-585">Local Certificates</span></span>

<span data-ttu-id="16c78-586">В этой документации мы будем называть "локальными" сертификаты, которые обеспечивают идентификацию локального устройства (другое возможное название — сертификаты устройств).</span><span class="sxs-lookup"><span data-stu-id="16c78-586">For the purposes of this documentation, we will refer to "local certificates" as those certificates which provide an identity for our local device (another possible name could be "device certificate").</span></span> <span data-ttu-id="16c78-587">Эти сертификаты предоставляются удаленному узлу, когда он пытается проверить подлинность локального устройства.</span><span class="sxs-lookup"><span data-stu-id="16c78-587">These certificates will be provided to a remote host when the remote host desires to authenticate the local device.</span></span>

### <a name="remote-certificates"></a><span data-ttu-id="16c78-588">Удаленные сертификаты</span><span class="sxs-lookup"><span data-stu-id="16c78-588">Remote Certificates</span></span>

<span data-ttu-id="16c78-589">В этой документации "удаленными" называются сертификаты, предоставляемые удаленным узлом в процессе подтверждения TLS, если это возможно.</span><span class="sxs-lookup"><span data-stu-id="16c78-589">In this documentation, "remote certificates" refers to those certificates provided by a remote host during the TLS handshake when applicable.</span></span> <span data-ttu-id="16c78-590">Для этих сертификатов должно быть выделено пространство, иначе NetX Secure не сможет их проанализировать и выполнить подтверждение TLS.</span><span class="sxs-lookup"><span data-stu-id="16c78-590">Space for these certificates must be allocated or NetX Secure will not be able to parse them and complete the TLS handshake.</span></span>

### <a name="signing-certificates"></a><span data-ttu-id="16c78-591">Сертификаты для подписи</span><span class="sxs-lookup"><span data-stu-id="16c78-591">Signing Certificates</span></span>

<span data-ttu-id="16c78-592">"Сертификат для подписи" используется для цифрового подписывания других сертификатов или данных в целях проверки подлинности.</span><span class="sxs-lookup"><span data-stu-id="16c78-592">A "signing certificate" is used to digitally sign other certificates or data for the purpose of authentication.</span></span> <span data-ttu-id="16c78-593">Эти сертификаты могут быть промежуточными или корневыми сертификатами в инфраструктуре открытых ключей (PKI), они обычно не используются для идентификации отдельных устройств или узлов.</span><span class="sxs-lookup"><span data-stu-id="16c78-593">These certificates may be either intermediate or root certificates within a Public Key Infrastructure (PKI) and are generally not used to identify individual devices or hosts.</span></span>

### <a name="root-ca-certificates"></a><span data-ttu-id="16c78-594">Сертификаты корневого ЦС</span><span class="sxs-lookup"><span data-stu-id="16c78-594">Root CA Certificates</span></span>

<span data-ttu-id="16c78-595">Сертификаты корневого ЦС — это сертификаты для подписи, которые обеспечивают основу PKI и являются самозаверяющими, а не подписанными другим сертификатом для подписи.</span><span class="sxs-lookup"><span data-stu-id="16c78-595">"Root CA certificates" are signing certificates that provide the basis of a PKI and are self-signed, rather than being signed by another signing certificate.</span></span> <span data-ttu-id="16c78-596">Для проверки удаленных серверов клиенту TLS обычно требуется по крайней мере один сертификат корневого ЦС.</span><span class="sxs-lookup"><span data-stu-id="16c78-596">At least one Root CA certificate is typically required for a TLS Client to verify remote servers.</span></span>

### <a name="certificate-formats"></a><span data-ttu-id="16c78-597">Форматы сертификатов</span><span class="sxs-lookup"><span data-stu-id="16c78-597">Certificate formats</span></span>

<span data-ttu-id="16c78-598">Цифровые сертификаты — это просто файлы, содержащие структурированные данные, закодированные с помощью синтаксиса ASN.1.</span><span class="sxs-lookup"><span data-stu-id="16c78-598">Digital certificates are simply files containing structured data encoded using the ASN.1 syntax.</span></span> <span data-ttu-id="16c78-599">Однако существуют различные форматы, в которых могут храниться сертификаты, и важно применить соответствующий формат, прежде чем загружать сертификат в приложение NetX Secure.</span><span class="sxs-lookup"><span data-stu-id="16c78-599">However, there are various formats in which certificates may be stored and it is important to have the right format before loading a certificate into a NetX Secure application.</span></span>

<span data-ttu-id="16c78-600">Наиболее распространенными форматами сертификатов являются DER и PEM.</span><span class="sxs-lookup"><span data-stu-id="16c78-600">The most common formats for certificates are DER and PEM.</span></span> <span data-ttu-id="16c78-601">DER (*Distinguished Encoding Rules*, формат ASN.1) — это двоичный формат, используемый протоколом TLS при первоначальном подтверждении.</span><span class="sxs-lookup"><span data-stu-id="16c78-601">DER (for *Distinguished Encoding Rules*, an ASN.1 format) is the binary format used by TLS when performing the initial handshake.</span></span> <span data-ttu-id="16c78-602">PEM (*Privacy Enhanced Mail*) — это версия формата DER в кодировке Base64, которая подходит для отправки электронной почты или передачи данных по протоколу HTTP в Интернете.</span><span class="sxs-lookup"><span data-stu-id="16c78-602">PEM (from *Privacy Enhanced Mail*) is a base-64 encoded version of the DER format which is suitable for emailing or sending over HTTP on the web.</span></span> <span data-ttu-id="16c78-603">Разные поставщики используют разные расширения файлов для сертификатов, например PEM или CRT для сертификатов PEM и DER для сертификатов DER.</span><span class="sxs-lookup"><span data-stu-id="16c78-603">Different vendors use different filename extensions for certificates, such as ".pem" or ".crt" for PEM certificates, and ".der" for DER certificates.</span></span> <span data-ttu-id="16c78-604">Если у вас есть сертификат и вам не ясно, в каком он формате, откройте этот файл в текстовом редакторе и определите его тип: DER-файлы кодируются в двоичном формате, а PEM-файлы — это обычный текст ASCII, начинающийся с заголовка "-----BEGIN CERTIFICATE-----".</span><span class="sxs-lookup"><span data-stu-id="16c78-604">If you have a certificate and it is not clear what format is used, opening the file in a text editor will allow you to determine the type since DER files are encoded  binary, and PEM files are regular ASCII text that start with the header "-----BEGIN CERTIFICATE-----".</span></span>

<span data-ttu-id="16c78-605">Для NetX Secure требуется, чтобы сертификат был в двоичном формате DER, поэтому перед импортом необходимо преобразовать сертификат в формат DER.</span><span class="sxs-lookup"><span data-stu-id="16c78-605">NetX Secure requires that your certificate be in binary DER format, so you will need to convert your certificate into DER format before importing.</span></span> <span data-ttu-id="16c78-606">Это можно сделать с помощью легкодоступных средств, таких как OpenSSL.</span><span class="sxs-lookup"><span data-stu-id="16c78-606">This can be done with readily available tools such as OpenSSL.</span></span>

<span data-ttu-id="16c78-607">Если вам нужен закрытый ключ для приложения, файл ключа будет закодирован с помощью стандарта PEM или DER в определенном формате (PKCS № 1 для алгоритма RSA или RFC 5915 для алгоритма ECC).</span><span class="sxs-lookup"><span data-stu-id="16c78-607">If you need a private key for your application, the key file will be encoded using PEM or DER in a specific format (PKCS#1 for RSA, RFC 5915 for ECC).</span></span> <span data-ttu-id="16c78-608">Прежде чем импортировать файл закрытого ключа, его необходимо преобразовать в формат DER.</span><span class="sxs-lookup"><span data-stu-id="16c78-608">The private key file will need to be converted into DER before being imported.</span></span>

<span data-ttu-id="16c78-609">Ниже в качестве примера приведены команды OpenSSL для преобразования сертификатов и файлов ключа RSA в формат DER, необходимый для NetX Secure (команды для ECC аналогичны, обратитесь к документации по OpenSSL).</span><span class="sxs-lookup"><span data-stu-id="16c78-609">The following OpenSSL commands are given as an example for converting certificates and RSA key files into the DER format required by NetX Secure (ECC is similar – refer to the OpenSSL documentation).</span></span>

```C
openssl x509 -inform PEM -in <certificate> -outform DER -out cert.der
openssl x509 -inform PEM -in <root CA cert> -outform DER -out CA_cert.der
openssl rsa -inform PEM -in <private key> -outform DER -out private.key
```
### <a name="private-keys-and-certificates"></a><span data-ttu-id="16c78-610">Закрытые ключи и сертификаты</span><span class="sxs-lookup"><span data-stu-id="16c78-610">Private Keys and Certificates</span></span>

<span data-ttu-id="16c78-611">Если сертификат идентифицирует устройство, то вместе с ним необходимо загрузить связанный закрытый ключ.</span><span class="sxs-lookup"><span data-stu-id="16c78-611">For certificates that identify a device, the associated private key must be loaded along with the certificate.</span></span> <span data-ttu-id="16c78-612">Закрытый ключ (который может применяться для одного из алгоритмов с открытым ключом, такого как RSA, алгоритм Диффи-Хелмана или алгоритм шифрования на основе эллиптических кривых) используется сервером TLS для расшифровки входящего материала ключа ("предварительная главная копия секрета"), полученного от клиента TLS. Таким образом сервер подтверждает свою подлинность для клиента.</span><span class="sxs-lookup"><span data-stu-id="16c78-612">The private key (which may be for one of the public-key algorithms such as RSA, Diffie-Hellman, or Elliptic-Curve Cryptography) is used by a TLS server to decrypt the incoming key material (the "pre-master secret") from a TLS client, thereby authenticating itself to the client.</span></span> <span data-ttu-id="16c78-613">Если предоставлен удостоверяющий сертификат (сертификат со связанным закрытым ключом) и сервер запрашивает сертификат клиента, то закрытый ключ используется для проверки подлинности клиента. В случае, если используется RSA, клиент TLS шифрует маркер с помощью закрытого ключа, который затем расшифровывается сервером с помощью открытого ключа клиента, предоставленного в сертификате клиента (проверка подлинности для алгоритмов Диффи-Хелмана и ECC происходит аналогично, но с небольшими отличиями).</span><span class="sxs-lookup"><span data-stu-id="16c78-613">For a TLS Client, if an identity certificate (a certificate with its associated private key) is provided and a server requests a client certificate, the private key is used to authenticate the client – in the case of RSA the client  encrypts a token using the private key which the server then decrypts using the client's public key, provided in the client certificate (Diffie-Hellman and ECC authentication happens in a similar fashion but the details are a bit different).</span></span>

<span data-ttu-id="16c78-614">В NetX Secure служба *nx_secure_x509_certificate_initialize* используется для инициализации сертификата X.509 (дополнительные сведения см. в разделе "Загрузка сертификатов на устройство") и связывания закрытого ключа с данным сертификатом, если это необходимо.</span><span class="sxs-lookup"><span data-stu-id="16c78-614">In NetX secure, the service *nx_secure_x509_certificate_initialize* is used to initialize an X.509 certificate (see section "Loading certificates onto your device" for more information) and optionally associate a private key with that certificate.</span></span>

<span data-ttu-id="16c78-615">Если предоставлен закрытый ключ, то сертификат помечается как удостоверяющий сертификат, используемый для идентификации устройства.</span><span class="sxs-lookup"><span data-stu-id="16c78-615">If a private key is supplied, the certificate is marked as being the "identity" certificate used to identify the device.</span></span> <span data-ttu-id="16c78-616">Ключ передается как непрерывный большой двоичный объект и значение длины с соответствующим типом ключа.</span><span class="sxs-lookup"><span data-stu-id="16c78-616">The key is passed as a contiguous binary blob and a length, with an associated key type.</span></span> <span data-ttu-id="16c78-617">Тип ключа зависит от типа (например, RSA, ECC и т. д.) и формата ключа (например, PKCS № 1 для DER).</span><span class="sxs-lookup"><span data-stu-id="16c78-617">The key type depends on the type of key (e.g. RSA, ECC, etc.) and the format (e.g. PKCS#1 DER).</span></span> <span data-ttu-id="16c78-618">Если ключ не предоставлен, можно передать значение NX_SECURE_X509_KEY_TYPE_NONE (значение 0x0), чтобы указать, что ключ не передается (длина 0 и указатель NX_NULL для параметра данных дадут тот же результат).</span><span class="sxs-lookup"><span data-stu-id="16c78-618">If no key is supplied, the value NX_SECURE_X509_KEY_TYPE_NONE (value 0x0) can be passed to indicate no key is being supplied (a length of 0 and a NX_NULL pointer for the data parameter will achieve the same effect).</span></span>

<span data-ttu-id="16c78-619">В следующей таблице приведены типы ключей, поддерживаемые NetX Secure, и связанные идентификаторы типа, которые передаются в *nx_secure_x509_certificate_initialize*.</span><span class="sxs-lookup"><span data-stu-id="16c78-619">The following table shows the key types known to NetX Secure and the associated type identifier to be passed into *nx_secure_x509_certificate_initialize*.</span></span> <span data-ttu-id="16c78-620">Дополнительные типы ключей будут приводиться по мере добавления алгоритмов шифрования в NetX Secure.</span><span class="sxs-lookup"><span data-stu-id="16c78-620">Additional key types will be added as more encryption algorithms are added to NetX Secure.</span></span>

| <span data-ttu-id="16c78-621">Идентификатор</span><span class="sxs-lookup"><span data-stu-id="16c78-621">Identifier</span></span>                              | <span data-ttu-id="16c78-622">Алгоритм</span><span class="sxs-lookup"><span data-stu-id="16c78-622">Algorithm</span></span> | <span data-ttu-id="16c78-623">Формат</span><span class="sxs-lookup"><span data-stu-id="16c78-623">Format</span></span>   | <span data-ttu-id="16c78-624">Кодирование</span><span class="sxs-lookup"><span data-stu-id="16c78-624">Encoding</span></span> | <span data-ttu-id="16c78-625">Значение</span><span class="sxs-lookup"><span data-stu-id="16c78-625">Value</span></span> |
| --------------------------------------- | --------- | -------- | -------- | ----- |
| <span data-ttu-id="16c78-626">NX_SECURE_X509_KEY_TYPE_NONE</span><span class="sxs-lookup"><span data-stu-id="16c78-626">NX_SECURE_X509_KEY_TYPE_NONE</span></span>            | <span data-ttu-id="16c78-627">Нет</span><span class="sxs-lookup"><span data-stu-id="16c78-627">None</span></span>      | <span data-ttu-id="16c78-628">Недоступно</span><span class="sxs-lookup"><span data-stu-id="16c78-628">N/A</span></span>      | <span data-ttu-id="16c78-629">Недоступно</span><span class="sxs-lookup"><span data-stu-id="16c78-629">N/A</span></span>      | <span data-ttu-id="16c78-630">0x0</span><span class="sxs-lookup"><span data-stu-id="16c78-630">0x0</span></span>   |
| <span data-ttu-id="16c78-631">NX_SECURE_X509_KEY_TYPE_RSA_PKCS1_DER</span><span class="sxs-lookup"><span data-stu-id="16c78-631">NX_SECURE_X509_KEY_TYPE_RSA_PKCS1_DER</span></span>   | <span data-ttu-id="16c78-632">RSA</span><span class="sxs-lookup"><span data-stu-id="16c78-632">RSA</span></span>       | <span data-ttu-id="16c78-633">PKCS № 1</span><span class="sxs-lookup"><span data-stu-id="16c78-633">PKCS#1</span></span>   | <span data-ttu-id="16c78-634">DER</span><span class="sxs-lookup"><span data-stu-id="16c78-634">DER</span></span>      | <span data-ttu-id="16c78-635">0x1</span><span class="sxs-lookup"><span data-stu-id="16c78-635">0x1</span></span>   |
| <span data-ttu-id="16c78-636">NX_SECURE_X509_KEY_TYPE_EC_DER</span><span class="sxs-lookup"><span data-stu-id="16c78-636">NX_SECURE_X509_KEY_TYPE_EC_DER</span></span>          | <span data-ttu-id="16c78-637">ECDSA</span><span class="sxs-lookup"><span data-stu-id="16c78-637">ECDSA</span></span>     | <span data-ttu-id="16c78-638">RFC 5915</span><span class="sxs-lookup"><span data-stu-id="16c78-638">RFC 5915</span></span> | <span data-ttu-id="16c78-639">DER</span><span class="sxs-lookup"><span data-stu-id="16c78-639">DER</span></span>      | <span data-ttu-id="16c78-640">0x2</span><span class="sxs-lookup"><span data-stu-id="16c78-640">0x2</span></span>   |

### <a name="user-defined-private-key-types"></a><span data-ttu-id="16c78-641">Определяемые пользователем типы закрытых ключей</span><span class="sxs-lookup"><span data-stu-id="16c78-641">User-defined private key types</span></span>

<span data-ttu-id="16c78-642">Значения идентификаторов типа ключей для службы *nx_secure_x509_certificate_initialize* управляют действиями, выполняемыми при предоставлении закрытого ключа.</span><span class="sxs-lookup"><span data-stu-id="16c78-642">The values of the key type identifiers for the *nx_secure_x509_certificate_initialize* service govern the actions taken when the private key is supplied.</span></span> <span data-ttu-id="16c78-643">Для известных типов значения находятся в диапазоне 0x0000 0000–0x0000 FFFF (младшие 16 бит 32-разрядного целого числа без знака).</span><span class="sxs-lookup"><span data-stu-id="16c78-643">For known types, the values are in the range 0x0000 0000 – 0x0000 FFFF (bottom 16 bits of a 32-bit unsigned integer).</span></span> <span data-ttu-id="16c78-644">Для платформ с пользовательскими типами ключей<sup>17</sup> (как и для некоторых аппаратных подсистем шифрования) в качестве типа ключа может быть передан определяемый пользователем тип ключа в диапазоне 0x0000 1000–0xFFFF FFFF (старшие 16 бит, отличные от нуля).</span><span class="sxs-lookup"><span data-stu-id="16c78-644">For platforms with custom key types<sup>17</sup> (as is the case for some hardware-based encryption engines), a user-defined key type in the range 0x0000 1000-0xFFFF FFFF (top 16 bits non-zero) may be passed as the key type.</span></span> <span data-ttu-id="16c78-645">Если заданы какие-либо старшие 16 бит типа ключа, то данные закрытого ключа передаются напрямую в соответствующую криптографическую процедуру (например, RSA), указанную в таблице комплекта шифров TLS.</span><span class="sxs-lookup"><span data-stu-id="16c78-645">If any of the top 16 bits of the key type are set, then the private key data is passed directly to the appropriate cryptographic routine (e.g. RSA) supplied in the TLS ciphersuite table.</span></span> <span data-ttu-id="16c78-646">Определяемые пользователем типы ключей не анализируются и не обрабатываются каким-либо иным способом до передачи в криптографическую процедуру.</span><span class="sxs-lookup"><span data-stu-id="16c78-646">User-defined key types are not parsed or otherwise processed before being passed to the cryptographic routine.</span></span> <span data-ttu-id="16c78-647">Кроме того, определяемый пользователем тип ключа также будет передан в криптографическую процедуру, чтобы на этом уровне можно было выполнить любую необходимую обработку.</span><span class="sxs-lookup"><span data-stu-id="16c78-647">In addition, the user-defined key type will also be passed to the cryptographic routine so that any appropriate processing can be handled at that level.</span></span>

<span data-ttu-id="16c78-648">Обратите внимание на то, что определяемые пользователем типы ключей обычно используются для специальных аппаратных платформ, использующих пользовательские (возможно, зашифрованные) данные ключа.</span><span class="sxs-lookup"><span data-stu-id="16c78-648">Note that user-defined key types are generally used for specific hardware platforms that utilize custom (possibly encrypted) key data.</span></span> <span data-ttu-id="16c78-649">Как правило, это означает, что данные ключа создаются или кодируются с помощью механизма, относящегося к этому поставщику оборудования (или, в случае стандарта, к определенному стандарту, например PKCS № 11).</span><span class="sxs-lookup"><span data-stu-id="16c78-649">Generally this implies that the key data is generated or encoded using a mechanism specific to that hardware vendor (or in the case of a standard like PKCS#11, a specific standard).</span></span> <span data-ttu-id="16c78-650">Дополнительные сведения см. в документации по конкретной аппаратной платформе.</span><span class="sxs-lookup"><span data-stu-id="16c78-650">Consult your hardware platform documentation for more information.</span></span>

17. <span data-ttu-id="16c78-651">Для пользовательских типов ключей требуется соответствующая пользовательская криптографическая процедура, обрабатывающая пользовательский формат ключа.</span><span class="sxs-lookup"><span data-stu-id="16c78-651">User-defined key types require a corresponding custom cryptographic routine to handle the custom key format.</span></span> <span data-ttu-id="16c78-652">Криптографическая процедура должна включать в себя алгоритм сопоставления (например, RSA) и передаваться в протокол TLS в таблице комплекта шифров.</span><span class="sxs-lookup"><span data-stu-id="16c78-652">The cryptographic routine must have a matching algorithm (e.g. RSA) and be passed into TLS in the ciphersuite table.</span></span> 

### <a name="loading-certificates-onto-your-device"></a><span data-ttu-id="16c78-653">Загрузка сертификатов на устройство</span><span class="sxs-lookup"><span data-stu-id="16c78-653">Loading certificates onto your device</span></span>

<span data-ttu-id="16c78-654">Любого метода загрузки файла на устройство будет достаточно для импорта сертификатов.</span><span class="sxs-lookup"><span data-stu-id="16c78-654">Any method for loading a file onto your device will be sufficient to import your certificates.</span></span>

<span data-ttu-id="16c78-655">Самым простым способом загрузки сертификата является преобразование двоичных данных в кодировке DER в массив C и его компиляция в приложение в виде константы.</span><span class="sxs-lookup"><span data-stu-id="16c78-655">The simplest method for loading a certificate is to convert the binary DER-encoded data into a C array and compile it into your application as a constant.</span></span> <span data-ttu-id="16c78-656">Это можно легко сделать с помощью такого инструмента, как xxd в Linux (с параметром "-i").</span><span class="sxs-lookup"><span data-stu-id="16c78-656">This can be easily done with tools such as "xxd" in Linux (with the "-i" option).</span></span>

<span data-ttu-id="16c78-657">Кроме того, вы можете загрузить сертификат в файловую систему флэш-памяти или хранилище другого типа, если это позволяет передать указатель на данные сертификата в API NetX Secure.</span><span class="sxs-lookup"><span data-stu-id="16c78-657">Alternatively, you can load your certificate into a flash filesystem or other storage options as long as you can pass a pointer to the certificate data into the NetX Secure API.</span></span>

### <a name="certificate-files-needed-for-netx-secure"></a><span data-ttu-id="16c78-658">Файлы сертификатов, необходимые для NetX Secure</span><span class="sxs-lookup"><span data-stu-id="16c78-658">Certificate files needed for NetX Secure</span></span>

<span data-ttu-id="16c78-659">Файлы сертификатов, которые потребуется импортировать, зависят от приложения.</span><span class="sxs-lookup"><span data-stu-id="16c78-659">The certificate files you will need to import depends on your application.</span></span> <span data-ttu-id="16c78-660">В общем случае серверам TLS требуется сертификат для идентификации устройства, а клиентам TLS требуется один или несколько *доверенных сертификатов* для проверки подлинности удаленных серверов.</span><span class="sxs-lookup"><span data-stu-id="16c78-660">In general, TLS Servers require a certificate to identify the device, and TLS Clients require one or more *Trusted Certificates* to authenticate remote servers.</span></span> <span data-ttu-id="16c78-661">В следующей таблице показаны сертификаты, необходимые для разных способов применения протокола TLS.</span><span class="sxs-lookup"><span data-stu-id="16c78-661">The following table illustrates certificates needed for some different TLS applications.</span></span>

| <span data-ttu-id="16c78-662">**Функциональные возможности протокола TLS**</span><span class="sxs-lookup"><span data-stu-id="16c78-662">**TLS functionality/options**</span></span>                     | <span data-ttu-id="16c78-663">**Минимально необходимые сертификаты и ключи**</span><span class="sxs-lookup"><span data-stu-id="16c78-663">**Certificates/keys needed (minimum)**</span></span>              |
| ------------------------------------------------- | --------------------------------------------------- |
| <span data-ttu-id="16c78-664">Клиент TLS</span><span class="sxs-lookup"><span data-stu-id="16c78-664">TLS Client</span></span>                                        | <span data-ttu-id="16c78-665">Корневой сертификат ЦС</span><span class="sxs-lookup"><span data-stu-id="16c78-665">Root CA certificate</span></span>                                 |
| <span data-ttu-id="16c78-666">Сервер TLS</span><span class="sxs-lookup"><span data-stu-id="16c78-666">TLS Server</span></span>                                        | <span data-ttu-id="16c78-667">Локальный сертификат, закрытый ключ для этого сертификата</span><span class="sxs-lookup"><span data-stu-id="16c78-667">Local certificate, private key for that certificate</span></span> |
| <span data-ttu-id="16c78-668">Сервер TLS с проверкой подлинности на основе сертификата клиента</span><span class="sxs-lookup"><span data-stu-id="16c78-668">TLS Server with Client Certificate Authentication</span></span> | <span data-ttu-id="16c78-669">Локальный сертификат, закрытый ключ, корневой ЦС</span><span class="sxs-lookup"><span data-stu-id="16c78-669">Local certificate, private key, Root CA</span></span>             |
| <span data-ttu-id="16c78-670">Клиент TLS с проверкой подлинности на основе сертификата клиента</span><span class="sxs-lookup"><span data-stu-id="16c78-670">TLS Client with Client Certificate Authentication</span></span> | <span data-ttu-id="16c78-671">Локальный сертификат, закрытый ключ, корневой ЦС</span><span class="sxs-lookup"><span data-stu-id="16c78-671">Local certificate, private key, Root CA</span></span>             |
| <span data-ttu-id="16c78-672">Клиент или сервер TLS только с общими ключами</span><span class="sxs-lookup"><span data-stu-id="16c78-672">TLS Client or Server with Pre-Shared Keys only</span></span>    | <span data-ttu-id="16c78-673">Нет (вместо сертификатов используется PSK)</span><span class="sxs-lookup"><span data-stu-id="16c78-673">None (PSK used instead of certificates)</span></span>             |

<span data-ttu-id="16c78-674">Ниже приведены соответствующие службы для загрузки сертификатов.</span><span class="sxs-lookup"><span data-stu-id="16c78-674">The relevant services for loading certificates are as follows:</span></span>

| <span data-ttu-id="16c78-675">**Имя API**</span><span class="sxs-lookup"><span data-stu-id="16c78-675">**API Name**</span></span>                                   | <span data-ttu-id="16c78-676">**Назначение**</span><span class="sxs-lookup"><span data-stu-id="16c78-676">**Purpose**</span></span>                                            |
| ---------------------------------------------- |------------------------------------------------------- |
| <span data-ttu-id="16c78-677">nx_secure_x509_certificate_initialize</span><span class="sxs-lookup"><span data-stu-id="16c78-677">nx_secure_x509_certificate_initialize</span></span>      | <span data-ttu-id="16c78-678">Должна вызываться для всех сертификатов, чтобы заполнить структуру NX_SECURE_X509_CERT данными сертификата и закрытым ключом.</span><span class="sxs-lookup"><span data-stu-id="16c78-678">Must be called for all certificates to populate the NX_SECURE_X509_CERT structure with your certificate data and private key.</span></span> |
| <span data-ttu-id="16c78-679">nx_secure_tls_local_certificate_add</span><span class="sxs-lookup"><span data-stu-id="16c78-679">nx_secure_tls_local_certificate_add</span></span>       | <span data-ttu-id="16c78-680">Добавляет локальный сертификат в сеанс TLS для идентификации устройства.</span><span class="sxs-lookup"><span data-stu-id="16c78-680">Add a local certificate to a TLS session to identify your device.</span></span>                                                                |
| <span data-ttu-id="16c78-681">nx_secure_tls_local_certificate_remove</span><span class="sxs-lookup"><span data-stu-id="16c78-681">nx_secure_tls_local_certificate_remove</span></span>    | <span data-ttu-id="16c78-682">Удаляет локальный сертификат из сеанса TLS.</span><span class="sxs-lookup"><span data-stu-id="16c78-682">Remove a local certificate from a TLS session.</span></span>                                                                                   |
| <span data-ttu-id="16c78-683">nx_secure_tls_remote_certificate_allocate</span><span class="sxs-lookup"><span data-stu-id="16c78-683">nx_secure_tls_remote_certificate_allocate</span></span> | <span data-ttu-id="16c78-684">Выделяет пространство для удаленного сертификата (вызывается с неинициализированной структурой NX_SECURE_X509_CERT).</span><span class="sxs-lookup"><span data-stu-id="16c78-684">Allocate space for a remote certificate (called with an uninitialized NX_SECURE_X509_CERT).</span></span>                                   |
| <span data-ttu-id="16c78-685">nx_secure_tls_trusted_certificate_add</span><span class="sxs-lookup"><span data-stu-id="16c78-685">nx_secure_tls_trusted_certificate_add</span></span>     | <span data-ttu-id="16c78-686">Добавляет сертификат в сеанс TLS в качестве доверенного сертификата для проверки подлинности удаленных узлов.</span><span class="sxs-lookup"><span data-stu-id="16c78-686">Add a certificate to a TLS Session as a Trusted Certificate for authenticating remote hosts.</span></span>                                     |
| <span data-ttu-id="16c78-687">nx_secure_tls_trusted_certificate_remove</span><span class="sxs-lookup"><span data-stu-id="16c78-687">nx_secure_tls_trusted_certificate_remove</span></span>  | <span data-ttu-id="16c78-688">Удаляет доверенный сертификат из сеанса TLS.</span><span class="sxs-lookup"><span data-stu-id="16c78-688">Remove a trusted certificate from a TLS Session.</span></span>                                                                                 |

### <a name="working-with-aws-iot-certificates"></a><span data-ttu-id="16c78-689">Работа с сертификатами AWS IoT</span><span class="sxs-lookup"><span data-stu-id="16c78-689">Working with AWS IoT Certificates</span></span>

<span data-ttu-id="16c78-690">В меню боковой панели интерфейса Amazon Web Services IoT выберите "Security" (Безопасность) и щелкните "Certificates" (Сертификаты).</span><span class="sxs-lookup"><span data-stu-id="16c78-690">In the Amazon Web Services IoT interface, select "Security" from the sidebar menu and select "Certificates".</span></span> <span data-ttu-id="16c78-691">Создайте сертификат и следуйте инструкциям по загрузке нового сертификата устройства.</span><span class="sxs-lookup"><span data-stu-id="16c78-691">Create a new certificate and follow the instructions to download your new device certificate.</span></span>

<span data-ttu-id="16c78-692">После загрузки сертификатов их необходимо будет преобразовать в формат DER с помощью OpenSSL или аналогичной служебной программы.</span><span class="sxs-lookup"><span data-stu-id="16c78-692">Once you have downloaded your certificates, you will need to convert them into DER format using OpenSSL or a similar utility.</span></span>

<span data-ttu-id="16c78-693">Примечание. AWS также предоставит файл открытого ключа.</span><span class="sxs-lookup"><span data-stu-id="16c78-693">NOTE: AWS will also provide a public key file.</span></span> <span data-ttu-id="16c78-694">Открытый ключ содержится в локальном сертификате устройства, поэтому его не нужно импортировать в приложение.</span><span class="sxs-lookup"><span data-stu-id="16c78-694">The public key is contained within the local device certificate so it does not need to be imported into your application.</span></span>

<span data-ttu-id="16c78-695">Например, ниже приведены команды для преобразования локального сертификата устройства и его закрытого ключа в формат DER для использования с NetX Secure.</span><span class="sxs-lookup"><span data-stu-id="16c78-695">As an example, here are the commands to convert the local device certificate and its private key into DER format for use with NetX Secure:</span></span>

```C
openssl x509 -inform PEM -in <certificate> -outform DER -out cert.der
openssl x509 -inform PEM -in <root CA cert> -outform DER -out CA_cert.der
openssl rsa -inform PEM -in <private key> -outform DER -out private.key
```
<span data-ttu-id="16c78-696">Преобразованные файлы можно импортировать в приложение, следуя приведенным выше инструкциям.</span><span class="sxs-lookup"><span data-stu-id="16c78-696">The converted files can be imported into your application following the above instructions.</span></span>

## <a name="x509-certificate-validation-in-netx-secure"></a><span data-ttu-id="16c78-697">Проверка сертификата X.509 в NetX Secure</span><span class="sxs-lookup"><span data-stu-id="16c78-697">X.509 Certificate Validation in NetX Secure</span></span> 

<span data-ttu-id="16c78-698">При использовании протокола TLS с сертификатами X.509 для идентификации и проверки узлов важно понимать, как эти сертификаты проверяются на самом деле.</span><span class="sxs-lookup"><span data-stu-id="16c78-698">When using TLS with X.509 certificates for host identification and verification, it is important to understand how those certificates are actually validated.</span></span> <span data-ttu-id="16c78-699">Хотя спецификация TLS не предоставляет подробные инструкции по проверке сертификата, она ссылается на спецификацию X.509 (RFC 5280).</span><span class="sxs-lookup"><span data-stu-id="16c78-699">While the TLS specification does not provide detailed instructions on how to validate a certificate, it does refer to the X.509 specification (RFC 5280).</span></span> <span data-ttu-id="16c78-700">Обычно предполагается, что протокол TLS будет выполнять по крайней мере простую проверку подлинности входящих сертификатов (сертификатов, предоставляемых удаленным узлом во время подтверждения TLS), и NetX Secure TLS функционирует точно так же.</span><span class="sxs-lookup"><span data-stu-id="16c78-700">In general, it is expected that TLS will perform at least basic validation on incoming certificates (those certificates supplied by the remote host during the TLS handshake), and NetX Secure TLS is no different.</span></span>

### <a name="basic-x509-validation"></a><span data-ttu-id="16c78-701">Простая проверка X.509</span><span class="sxs-lookup"><span data-stu-id="16c78-701">Basic X.509 Validation</span></span>

<span data-ttu-id="16c78-702">Для любого входящего сертификата NetX Secure TLS выполняет простую проверку пути X.509.</span><span class="sxs-lookup"><span data-stu-id="16c78-702">For any incoming certificate, NetX Secure TLS will perform basic X.509 path validation.</span></span> <span data-ttu-id="16c78-703">Этот процесс включает в себя проверку цифровой подписи каждого сертификата по сертификату издателя, который может быть предоставлен удаленным узлом или расположен в хранилище доверенных сертификатов (дополнительные сведения об импорте доверенных сертификатов см. в разделе "Импорт сертификатов X.509 в NetX Secure").</span><span class="sxs-lookup"><span data-stu-id="16c78-703">The process involves checking each certificate's digital signature against its issuer certificate, which may be provided by the remote host or be located in the trusted certificate store (see the section "Importing X.509 certificates into NetX Secure" for more information on importing trusted certificates).</span></span> <span data-ttu-id="16c78-704">Процесс проверки по сертификатам издателя рекурсивно повторяется, пока не будет достигнут доверенный сертификат или не завершится вся цепочка (на самозаверяющем сертификате или отсутствующем сертификате издателя).</span><span class="sxs-lookup"><span data-stu-id="16c78-704">The validation process is recursively repeated on the issuer certificates until a trusted certificate is reached or the chain ends (with a self-signed certificate or a missing issuer certificate).</span></span> <span data-ttu-id="16c78-705">При достижении доверенного сертификата проверяемый сертификат считается надежным, в противном случае он отклоняется.</span><span class="sxs-lookup"><span data-stu-id="16c78-705">If a trusted certificate is reached, the certificate is verified, otherwise it is rejected.</span></span> <span data-ttu-id="16c78-706">Кроме того, на каждом этапе процесса проверки дата окончания срока действия каждого сертификата проверяется по времени, предоставленному функцией меток времени приложения (дополнительные сведения см. в описании службы nx_secure_tls_session_time_function_set).</span><span class="sxs-lookup"><span data-stu-id="16c78-706">Additionally, at each stage in the verification process the expiration date of each certificate is checked against the time provided by the application timestamp function (see the service "nx_secure_tls_session_time_function_set" for more information).</span></span>

<span data-ttu-id="16c78-707">Спецификация X.509 также предоставляет алгоритм для поддержки "политик", являющихся идентификаторами в расширении X.509, которые можно проверить во время проверки пути.</span><span class="sxs-lookup"><span data-stu-id="16c78-707">The X.509 specification also provides an algorithm for supporting "policies", which are identifiers that are present in an X.509 extension that can be checked during path validation.</span></span> <span data-ttu-id="16c78-708">Сейчас NetX Secure обрабатывает сертификаты X.509 так, как если бы был определен параметр anyPolicy, то есть принимаются все политики, а дополнительная проверка политик не выполняется.</span><span class="sxs-lookup"><span data-stu-id="16c78-708">NetX Secure currently treats X.509 certificates as though the "anyPolicy" option is defined – that is, all policies are acceptable and the optional policy checking is not performed.</span></span> <span data-ttu-id="16c78-709">Реализация X.509 в NetX Secure может быть дополнена этой функцией в будущем выпуске.</span><span class="sxs-lookup"><span data-stu-id="16c78-709">The NetX Secure X.509 implementation may be augmented with this feature in a future release.</span></span> <span data-ttu-id="16c78-710">Сейчас расширение политик можно получить из сертификата с помощью API *nx_secure_x509_extension_find*.</span><span class="sxs-lookup"><span data-stu-id="16c78-710">For now, the policy extension may be obtained from a certificate using the *nx_secure_x509_extension_find* API.</span></span>

<span data-ttu-id="16c78-711">После завершения проверки основного пути протокол TLS выполняет обратный вызов проверки сертификата, указанный приложением, с помощью API *nx_secure_tls_session_certificate_callback_set*.</span><span class="sxs-lookup"><span data-stu-id="16c78-711">Once the basic path validation is complete, TLS will invoke the certificate verification callback supplied by the application using the *nx_secure_tls_session_certificate_callback_set* API.</span></span> <span data-ttu-id="16c78-712">Если обратный вызов не указан, то сертификат считается доверенным после успешной проверки пути.</span><span class="sxs-lookup"><span data-stu-id="16c78-712">If no callback is supplied, the certificate is considered to be trusted following successful path validation.</span></span> <span data-ttu-id="16c78-713">Если указан обратный вызов, то он будет выполнять все дополнительные проверки сертификата, необходимые приложению.</span><span class="sxs-lookup"><span data-stu-id="16c78-713">If a callback is supplied, the callback will perform any additional validation of the certificate required by the application.</span></span> <span data-ttu-id="16c78-714">Возвращаемое из обратного вызова значение используется, чтобы определить, следует ли продолжить подтверждение TLS или его нужно прервать из-за ошибки проверки.</span><span class="sxs-lookup"><span data-stu-id="16c78-714">The return value from the callback is used to determine whether to continue with the TLS handshake or to abort the handshake due to a validation failure.</span></span>

<span data-ttu-id="16c78-715">Обратный вызов выполняется с указателем на соответствующий сеанс TLS и указателем NX_SECURE_X509_CERT на проверяемый сертификат.</span><span class="sxs-lookup"><span data-stu-id="16c78-715">The callback is invoked with a pointer to the relevant TLS session and an NX_SECURE_X509_CERT pointer to the certificate to be validated.</span></span> <span data-ttu-id="16c78-716">Между установлением сеанса TLS и подтверждением подлинности сертификата приложение имеет все необходимые данные из протокола TLS для выполнения дополнительных проверок.</span><span class="sxs-lookup"><span data-stu-id="16c78-716">Between the TLS session and the certificate, the application has all of the data it needs from TLS to perform additional verification checks.</span></span>

<span data-ttu-id="16c78-717">Чтобы обеспечить дополнительную проверку, NetX Secure предоставляет процедуры X.509 для некоторых распространенных операций проверки, включая проверку DNS и проверку списка отзыва сертификатов.</span><span class="sxs-lookup"><span data-stu-id="16c78-717">To help with the additional validation, NetX Secure provides X.509 routines for some common validation operations, including DNS validation and Certificate Revocation List checking.</span></span> <span data-ttu-id="16c78-718">Все эти процедуры подходят для обратного вызова проверки сертификата, но также могут использоваться для автономной проверки сертификатов X.509.</span><span class="sxs-lookup"><span data-stu-id="16c78-718">All of these routines are suitable for use within the certificate verification callback but may also be used to perform off-line checking of X.509 certificates.</span></span>

<span data-ttu-id="16c78-719">В следующей таблице перечислены доступные вспомогательные функции для обработки сертификатов X.509.</span><span class="sxs-lookup"><span data-stu-id="16c78-719">The following table summarizes the available helper functions for X.509 certificate processing.</span></span> <span data-ttu-id="16c78-720">Более подробные описания операций можно найти в следующих разделах и справочнике по API в главе 4.</span><span class="sxs-lookup"><span data-stu-id="16c78-720">More detailed explanations for the operations can be found in the following sections and the API reference in Chapter 4</span></span>  
  
<span data-ttu-id="16c78-721">Описание служб NetX Secure содержит дополнительные сведения о конкретных процедурах.</span><span class="sxs-lookup"><span data-stu-id="16c78-721">Description of NetX Secure Services provides additional details on the specific routines.</span></span>

| <span data-ttu-id="16c78-722">**Имя API**</span><span class="sxs-lookup"><span data-stu-id="16c78-722">**API Name**</span></span>                             | <span data-ttu-id="16c78-723">**Описание**</span><span class="sxs-lookup"><span data-stu-id="16c78-723">**Description**</span></span>                               |
| ---------------------------------------- | -------------------------------------- |
| <span data-ttu-id="16c78-724">nx_secure_x509_common_name_dns_check</span><span class="sxs-lookup"><span data-stu-id="16c78-724">nx_secure_x509_common_name_dns_check</span></span>               | <span data-ttu-id="16c78-725">Проверка общего имени субъекта X.509 и SubjectAltName на соответствие ожидаемому DNS-имени.</span><span class="sxs-lookup"><span data-stu-id="16c78-725">Check the X.509 subject Common Name and SubjectAltName against an expected DNS name</span></span> |
| <span data-ttu-id="16c78-726">nx_secure_x509_crl_revocation_check</span><span class="sxs-lookup"><span data-stu-id="16c78-726">nx_secure_x509_crl_revocation_check</span></span>                 | <span data-ttu-id="16c78-727">Проверка сертификата на наличие в списке отзыва сертификатов X.509 (CRL).</span><span class="sxs-lookup"><span data-stu-id="16c78-727">Check for a revoked certificate in an X.509 Certificate Revocation List (CRL)</span></span>       |
| <span data-ttu-id="16c78-728">nx_secure_x509_extended_key_usage_extension_parse</span><span class="sxs-lookup"><span data-stu-id="16c78-728">nx_secure_x509_extended_key_usage_extension_parse</span></span> | <span data-ttu-id="16c78-729">Анализ и поиск конкретного значения OID расширенного использования ключа в сертификате.</span><span class="sxs-lookup"><span data-stu-id="16c78-729">Parse and find a specific extended key usage OID in a certificate</span></span>                   |
| <span data-ttu-id="16c78-730">nx_secure_x509_key_usage_extension_parse</span><span class="sxs-lookup"><span data-stu-id="16c78-730">nx_secure_x509_key_usage_extension_parse</span></span>           | <span data-ttu-id="16c78-731">Анализ и возвращение битового поля использования ключа в сертификате.</span><span class="sxs-lookup"><span data-stu-id="16c78-731">Parse and return the key usage bitfield in a certificate</span></span>                            |
| <span data-ttu-id="16c78-732">nx_secure_x509_extension_find</span><span class="sxs-lookup"><span data-stu-id="16c78-732">nx_secure_x509_extension_find</span></span>                        | <span data-ttu-id="16c78-733">Поиск и возвращение необработанных данных ASN.1 в кодировке DER для определенного расширения.</span><span class="sxs-lookup"><span data-stu-id="16c78-733">Find and return the raw DER-encoded ASN.1 data for a specific extension.</span></span>            |

<span data-ttu-id="16c78-734">Вспомогательные функции X.509 для использования в обратном вызове проверки сертификата</span><span class="sxs-lookup"><span data-stu-id="16c78-734">X.509 helper functions for use in the certificate verification callback</span></span>

### <a name="x509-extensions"></a><span data-ttu-id="16c78-735">Расширения X.509</span><span class="sxs-lookup"><span data-stu-id="16c78-735">X.509 Extensions</span></span>

<span data-ttu-id="16c78-736">В спецификации X.509 описывается ряд расширений, позволяющие предоставить дополнительные сведения, которые можно использовать при проверке сертификатов.</span><span class="sxs-lookup"><span data-stu-id="16c78-736">The X.509 specification describes a number of "extensions" that can be used to supply additional information that can be utilized in the verification of certificates.</span></span> <span data-ttu-id="16c78-737">В большинстве случаев эти расширения являются необязательными и не требуются для безопасной проверки цифрового сертификата с помощью доверенного корневого сертификата.</span><span class="sxs-lookup"><span data-stu-id="16c78-737">For the most part, these extensions are optional and are not required for secure validation of a digital certificate against a trusted root certificate.</span></span> <span data-ttu-id="16c78-738">Однако NetX Secure поддерживает несколько базовых расширений.</span><span class="sxs-lookup"><span data-stu-id="16c78-738">However, NetX Secure does support some basic extensions.</span></span> <span data-ttu-id="16c78-739">В будущих выпусках может быть добавлена поддержка дополнительных расширений.</span><span class="sxs-lookup"><span data-stu-id="16c78-739">Support for additional extensions may be added in future releases.</span></span>

<span data-ttu-id="16c78-740">Поддерживаемые в настоящее время расширения перечислены в таблице ниже.</span><span class="sxs-lookup"><span data-stu-id="16c78-740">The currently supported extensions are listed in the following table:</span></span>

| <span data-ttu-id="16c78-741">Имя расширения</span><span class="sxs-lookup"><span data-stu-id="16c78-741">Extension Name</span></span>           | <span data-ttu-id="16c78-742">Описание</span><span class="sxs-lookup"><span data-stu-id="16c78-742">Description</span></span>                                                                   | <span data-ttu-id="16c78-743">Соответствующий API</span><span class="sxs-lookup"><span data-stu-id="16c78-743">Relevant API</span></span>                                             |
| ------------------------ | ----------------------------------------------------------------------------- | -------------------------------------------------------- |
| <span data-ttu-id="16c78-744">Использование ключа</span><span class="sxs-lookup"><span data-stu-id="16c78-744">Key Usage</span></span>                | <span data-ttu-id="16c78-745">Предоставляет приемлемые варианты использования открытого ключа сертификата в битовом поле.</span><span class="sxs-lookup"><span data-stu-id="16c78-745">Provides acceptable uses for a certificate's public key in a bitfield</span></span>         | <span data-ttu-id="16c78-746">nx_secure_x509_key_usage_extension_parse</span><span class="sxs-lookup"><span data-stu-id="16c78-746">nx_secure_x509_key_usage_extension_parse</span></span>           |
| <span data-ttu-id="16c78-747">Расширенное использование ключа</span><span class="sxs-lookup"><span data-stu-id="16c78-747">Extended Key Usage</span></span>       | <span data-ttu-id="16c78-748">Предоставляет приемлемые варианты использования открытого ключа сертификата посредством значений OID.</span><span class="sxs-lookup"><span data-stu-id="16c78-748">Provides additional acceptable uses for a certificate's public key using OIDs</span></span> | <span data-ttu-id="16c78-749">nx_secure_x509_extended_key_usage_extension_parse</span><span class="sxs-lookup"><span data-stu-id="16c78-749">nx_secure_x509_extended_key_usage_extension_parse</span></span> |
| <span data-ttu-id="16c78-750">Альтернативное имя субъекта</span><span class="sxs-lookup"><span data-stu-id="16c78-750">Subject Alternative Name</span></span> | <span data-ttu-id="16c78-751">Предоставляет альтернативные DNS-имена, которые также представляются сертификатом.</span><span class="sxs-lookup"><span data-stu-id="16c78-751">Provides alternative DNS names that are also represented by the certificate</span></span>   | <span data-ttu-id="16c78-752">nx_secure_x509_common_name_dns_check</span><span class="sxs-lookup"><span data-stu-id="16c78-752">nx_secure_x509_common_name_dns_check</span></span>               |

### <a name="unsupported-x509-extensions"></a><span data-ttu-id="16c78-753">Неподдерживаемые расширения X.509</span><span class="sxs-lookup"><span data-stu-id="16c78-753">Unsupported X.509 Extensions</span></span>

<span data-ttu-id="16c78-754">Реализация X.509 для NetX Secure также предоставляет службу для извлечения неподдерживаемых расширений: *nx_secure_x509_extension_find*.</span><span class="sxs-lookup"><span data-stu-id="16c78-754">NetX Secure's X.509 implemenation does provide a service to extract unsupported extensions as well: *nx_secure_x509_extension_find*.</span></span> <span data-ttu-id="16c78-755">Этот API предназначен для опытных пользователей, так как он требует знания формата ASN.1 в кодировке DER для анализа возвращаемых данных.</span><span class="sxs-lookup"><span data-stu-id="16c78-755">This API is intended for advanced users as it requires knowledge of DER-encoded ASN.1 in order to parse the data returned.</span></span> <span data-ttu-id="16c78-756">Он использовался внутри протокола для извлечения поддерживаемых расширений, но предоставляется для удобства в разработке пользовательской поддержки расширений X.509.</span><span class="sxs-lookup"><span data-stu-id="16c78-756">It it used internally to extract supported extensions but is supplied for convenience in developing customized support for X.509 extensions.</span></span>

<span data-ttu-id="16c78-757">Чтобы использовать nx_secure_x509_extension_find, передается структура NX_SECURE_X509_EXTENSION вместе с сертификатом и идентификатором расширения, который представляет собой целочисленное представление строки OID переменной длины для известного типа расширения.</span><span class="sxs-lookup"><span data-stu-id="16c78-757">To use nx_secure_x509_extension_find, a NX_SECURE_X509_EXTENSION is passed in, along with the certificate and an extension ID, which is an integer representation of the variable-length OID string for a known extension type.</span></span> <span data-ttu-id="16c78-758">Полный список поддерживаемых идентификаторов OID для расширений X.509 приведен в справочнике по API для службы nx_secure_x509_extension_find на странице 178.</span><span class="sxs-lookup"><span data-stu-id="16c78-758">A complete list of supported OIDs for X.509 extensions is provided in the API reference for nx_secure_x509_extension_find on page 178.</span></span>

<span data-ttu-id="16c78-759">Ниже приведено определение структуры NX_SECURE_X509_EXTENSION.</span><span class="sxs-lookup"><span data-stu-id="16c78-759">The NX_SECURE_X509_EXTENSION structure is defined as follows:</span></span>

```C
typedef struct NX_SECURE_X509_EXTENSION_STRUCT
{
    /* Identifier (maps to OID) for this extension. */
    USHORT nx_secure_x509_extension_id;

    /* Critical flag - boolean value. */
    USHORT nx_secure_x509_extension_critical;

    /* Pointer to DER-encoded extension data. */
    const UCHAR *nx_secure_x509_extension_data;
    ULONG        nx_secure_x509_extension_data_length;
} NX_SECURE_X509_EXTENSION;
```
<span data-ttu-id="16c78-760">При успешном возвращении службы структура заполняется соответствующими данными из сертификата.</span><span class="sxs-lookup"><span data-stu-id="16c78-760">When the service returns successfully, the structure will be populated with the relevant data from the certificate.</span></span> <span data-ttu-id="16c78-761">Поле nx_secure_x509_extension_id обычно используется для внутренних операций, но будет заполнено соответствующим целочисленным представлением OID.</span><span class="sxs-lookup"><span data-stu-id="16c78-761">The nx_secure_x509_extension_id field is generally used for internal purposes but will be populated with the relevant OID integer representation.</span></span> <span data-ttu-id="16c78-762">Поле nx_secure_x509_extension_critical представляет значение флага критического расширения X.509 (логическое).</span><span class="sxs-lookup"><span data-stu-id="16c78-762">The nx_secure_x509_extension_critical field exposes the X.509 critical extension flag value (Boolean).</span></span> <span data-ttu-id="16c78-763">Поля nx_secure_x509_extension_data и nx_secure_x509_extension_data_length содержат указатель на данные ASN.1 в кодировке DER для расширения и длину этих данных соответственно.</span><span class="sxs-lookup"><span data-stu-id="16c78-763">The nx_secure_x509_extension_data and nx_secure_x509_extension_data_length fields contain a pointer to the DER-encoded ASN.1 data for the extension, and the length of that data, respectively.</span></span>

<span data-ttu-id="16c78-764">Фактический анализ данных расширения ASN.1 выходит за рамки данного документа, но если у вас есть доступ к исходному коду NetX Secure TLS, то вы сможете увидеть, как выполняется анализ везде, где вызывается nx_secure_x509_extension_find для поддерживаемых расширений.</span><span class="sxs-lookup"><span data-stu-id="16c78-764">Actual parsing of the extension ASN.1 data is beyond the scope of this document, but if you have access to the NetX Secure TLS source you can see how the parsing is done wherever nx_secure_x509_extension_find is called for supported extensions.</span></span>

### <a name="x509-dns-validation"></a><span data-ttu-id="16c78-765">Проверка DNS для X.509</span><span class="sxs-lookup"><span data-stu-id="16c78-765">X.509 DNS Validation</span></span>

<span data-ttu-id="16c78-766">Обычная операция проверки сертификата в протоколе TLS включает в себя проверку имени домена верхнего уровня (TLD) удаленного узла по сертификату X.509, предоставленному этим узлом во время подтверждения TLS.</span><span class="sxs-lookup"><span data-stu-id="16c78-766">A common certificate validation operation in TLS involves checking the Top-Level Domain (TLD) name of a remote host against the X.509 certificate provided by that host during the TLS handshake.</span></span> <span data-ttu-id="16c78-767">Эта операция позволяет гарантировать, что сертификат действительно соответствует серверу узла, который его предоставил, если предположить, что поиск DNS является доверенным.</span><span class="sxs-lookup"><span data-stu-id="16c78-767">This operation helps to ensure that the certificate does indeed match the host server that provided it, assuming the DNS lookup can be trusted.</span></span> <span data-ttu-id="16c78-768">В NetX Secure TLS эта функция обеспечивается службой **nx_secure_x509_common_name_dns_checkом**, которая принимает сертификат и строку, содержащую часть TLD URL-адреса, используемого для доступа к узлу.</span><span class="sxs-lookup"><span data-stu-id="16c78-768">In NetX Secure TLS, this functionality is provided by the service **nx_secure_x509_common_name_dns_check**, which takes the certificate and a string containing the TLD portion of the URL used to access the host.</span></span> <span data-ttu-id="16c78-769">Значение TLD сравнивается с полем общего имени сертификата, и, если оно совпадает, возвращается значение NX_SUCCESS.</span><span class="sxs-lookup"><span data-stu-id="16c78-769">The TLD is compared to the certificate's Common Name field and if it matches, NX_SUCCESS is returned.</span></span> <span data-ttu-id="16c78-770">Если общее имя не совпадает, процедура также проверит наличие *subjectAltName* расширения сертификата X.509.</span><span class="sxs-lookup"><span data-stu-id="16c78-770">If the Common Name does not match, the routine will also check for the existence of the X.509 certificate extension *subjectAltName*.</span></span> <span data-ttu-id="16c78-771">Если имеется значение subjectAltName, то все записи DNSName в расширении также проверяются по предоставленному значению TLD.</span><span class="sxs-lookup"><span data-stu-id="16c78-771">If a subjectAltName is present, any DNSName entries in the extension are also checked against the provided TLD.</span></span> <span data-ttu-id="16c78-772">Опять же, если найдено совпадение, возвращается значение NX_SUCCESS.</span><span class="sxs-lookup"><span data-stu-id="16c78-772">Again, if any match, NX_SUCCESS is returned.</span></span> <span data-ttu-id="16c78-773">Если совпадений не найдено, из обратного вызова проверки сертификата возвращается соответствующая ошибка.</span><span class="sxs-lookup"><span data-stu-id="16c78-773">If no match is found, an error suitable for returning from the certificate validation callback is returned.</span></span>

### <a name="x509-key-usage-and-extended-key-usage-extensions"></a><span data-ttu-id="16c78-774">Расширения для использование ключа и дополнительного использования ключа X.509</span><span class="sxs-lookup"><span data-stu-id="16c78-774">X.509 Key Usage and Extended Key Usage Extensions</span></span>

<span data-ttu-id="16c78-775">Расширения для использование ключа и дополнительного использования ключа X.509 предоставляют сведения о том, как открытый ключ сертификата может использоваться при проверке подлинности этого сертификата.</span><span class="sxs-lookup"><span data-stu-id="16c78-775">The X.509 Key Usage and Extended Key Usage extensions provide information on how a certificate's public key may be used when authenticating that certificate.</span></span> <span data-ttu-id="16c78-776">Использование ключа указывает издатель сертификата, когда сертификат подписывается и выдается.</span><span class="sxs-lookup"><span data-stu-id="16c78-776">The key usage is supplied by the certificate's issuer when the certificate is signed and issued.</span></span> <span data-ttu-id="16c78-777">Данные об использовании ключа может применять узел TLS, чтобы убедиться, что сертификат разрешено использовать при проверке подлинности удаленного узла TLS, а также для других операций.</span><span class="sxs-lookup"><span data-stu-id="16c78-777">The key usage may be used by a TLS host to check that the certificate is authorized to be used to authenticate a remote TLS host and perform other operations.</span></span>

<span data-ttu-id="16c78-778">Расширение для использования ключа состоит из простого битового поля, в котором каждый бит представляет конкретное использование ключа.</span><span class="sxs-lookup"><span data-stu-id="16c78-778">The Key Usage extension consists of a simple bitfield where each of the bits represents a specific key usage.</span></span> <span data-ttu-id="16c78-779">Полный список этих значений приведен в справочнике по API для службы *nx_secure_x509_key_usage_extension_parse* на странице 183.</span><span class="sxs-lookup"><span data-stu-id="16c78-779">A complete list of these values is provided in the API reference for *nx_secure_x509_key_usage_extension_parse* on page 183.</span></span> <span data-ttu-id="16c78-780">Более полное описание битов использования ключа и их значение см. в разделе 4.2.1.3 документа RFC 5280.</span><span class="sxs-lookup"><span data-stu-id="16c78-780">For a more complete description of the key usage bits and their meanings, refer to RFC 5280, section 4.2.1.3.</span></span>

<span data-ttu-id="16c78-781">Расширение для дополнительного использования ключа, как и расширение для использования ключа, предоставляет сведения о допустимом использовании ключа.</span><span class="sxs-lookup"><span data-stu-id="16c78-781">The Extended Key Usage extension, like the Key Usage extension, provides acceptable key use information.</span></span> <span data-ttu-id="16c78-782">Однако для поддержки произвольного использования в этом расширении используются значения OID, а не битовое поле.</span><span class="sxs-lookup"><span data-stu-id="16c78-782">However, in order to support arbitrary usages, the Extended Key Usage extension utilizes OIDs instead of a bitfield.</span></span> <span data-ttu-id="16c78-783">При анализе расширения для дополнительного использования ключа в NetX Secure X.509 приложение передает целое число, представляющее OID, после чего служба *nx_secure_x509_extended_key_usage_extension_parse* возвращает сведения о том, присутствует ли этот OID.</span><span class="sxs-lookup"><span data-stu-id="16c78-783">When parsing an Extended Key Usage extension in NetX Secure X.509, an integer representing the OID is supplied by the application – the *nx_secure_x509_extended_key_usage_extension_parse* service will then return whether that OID is present.</span></span> <span data-ttu-id="16c78-784">Полный список поддерживаемых значений OID для дополнительного использования ключа приведен в справочнике по API для службы *nx_secure_x509_extended_key_usage_extension_parse* на странице 175.</span><span class="sxs-lookup"><span data-stu-id="16c78-784">A complete list of supported OIDs for Extended Key usage is provided in the API reference for *nx_secure_x509_extended_key_usage_extension_parse* on page 175.</span></span> <span data-ttu-id="16c78-785">Более полное описание значений OID и их значение см. в разделе 4.2.1.12 документа RFC 5280.</span><span class="sxs-lookup"><span data-stu-id="16c78-785">For a more complete description of the OIDs and their meanings, refer to RFC 5280, section 4.2.1.12.</span></span>

### <a name="x509-crl-revocation-status-checking"></a><span data-ttu-id="16c78-786">Проверка состояния отзыва с помощью списка отзыва сертификатов X.509</span><span class="sxs-lookup"><span data-stu-id="16c78-786">X.509 CRL Revocation Status Checking</span></span>

<span data-ttu-id="16c78-787">Стандарт X.509 предоставляет механизм, называемый *списком отзыва сертификатов* (CRL), который позволяет центру подписывания цифровых сертификатов отозвать действительность подписанных им сертификатов.</span><span class="sxs-lookup"><span data-stu-id="16c78-787">X.509 provides a mechanism called the *Certificate Revocation List* (CRL) that allows a digital certificate signing authority to revoke the validity of certificates it has signed.</span></span> <span data-ttu-id="16c78-788">Любое приложение, которому нужно проверить сертификаты из центра подписывания, может получить список отзыва сертификатов и сравнить все сертификаты, подписанные этим центром (издателем), со списком отзыва сертификатов, чтобы узнать, не отозвано ли их состояние по какой-либо причине (например, из-за скомпрометированного закрытого ключа).</span><span class="sxs-lookup"><span data-stu-id="16c78-788">Any application that needs to verify certificates from a signing authority can obtain a CRL and compare any certificates signed by that authority (issuer) against the CRL to see if they have had their status revoked for some reason (such as compromised private key).</span></span> <span data-ttu-id="16c78-789">Таким образом приложение может избежать использования потенциально опасных сертификатов, которые проходят прочие проверки.</span><span class="sxs-lookup"><span data-stu-id="16c78-789">In this way, the application can avoid using potentially dangerous certificates that pass other certificate validation checks.</span></span>

<span data-ttu-id="16c78-790">Чтобы получить список отзыва сертификатов, приложение может скачать его в кодировке DER со стандартного сервера или получить каким-либо иным способом.</span><span class="sxs-lookup"><span data-stu-id="16c78-790">Obtaining a CRL is done by an application by downloading the DER-encoded list from a pre-defined server or through some other means.</span></span> <span data-ttu-id="16c78-791">Фактическая настройка зависит от издателя, поэтому NetX Secure не предоставляет механизм получения списков отзыва сертификатов, однако предоставляется процедура для проверки сертификата на соответствие списку отзыва сертификатов, **nx_secure_x509_crl_revocation_check**.</span><span class="sxs-lookup"><span data-stu-id="16c78-791">The actual setup varies from issuer to issuer so NetX Secure does not provide a mechanism for obtaining CRLs, but it does provide a routine to check a certificate against a CRL, **nx_secure_x509_crl_revocation_check**.</span></span>

<span data-ttu-id="16c78-792">Этот API принимает список отзыва сертификатов в кодировке DER, хранилище сертификатов для проверки (например, хранилище в сеансе TLS) и проверяемый сертификат.</span><span class="sxs-lookup"><span data-stu-id="16c78-792">The API takes a DER-encoded CRL, a certificate store (such as the one in a TLS session) to check against, and the certificate to be checked.</span></span> <span data-ttu-id="16c78-793">Сначала эта процедура проверяет наличие списка отзыва сертификатов в доверенном хранилище (части хранилища сертификатов, предоставленной приложением).</span><span class="sxs-lookup"><span data-stu-id="16c78-793">The routine first validates the CRL itself against the trusted store (part of the certificate store provided by the application).</span></span> <span data-ttu-id="16c78-794">Это важно для защиты от поддельных списков отзыва сертификатов, используемых для атак типа "отказ в обслуживании", и позволяет убедиться, что список отзыва сертификатов действительно получен от соответствующего издателя.</span><span class="sxs-lookup"><span data-stu-id="16c78-794">This is important to protect against fraudulent CRLs being used for Denial-of-Service attacks and establishes that the CRL is actually from the proper issuer.</span></span> <span data-ttu-id="16c78-795">После проверки списка отзыва сертификатов проверяется издатель. Если издатель списка отзыва сертификатов не соответствует издателю сертификата, то список отзыва сертификатов считается недействительным для этого сертификата и возвращается ошибка.</span><span class="sxs-lookup"><span data-stu-id="16c78-795">Following the CRL validation, the issuer is checked – if the issuer of the CRL does not match the issuer of the certificate, then the CRL is not valid for that certificate and an error is returned.</span></span> <span data-ttu-id="16c78-796">Именно приложение должно решить, можно ли продолжить подтверждение TLS на этом этапе.</span><span class="sxs-lookup"><span data-stu-id="16c78-796">It is up to the application to determine whether the TLS handshake can continue at this point.</span></span> <span data-ttu-id="16c78-797">Если издатели совпадают, то в списке отзыва сертификатов выполняется поиск серийного номера проверяемого сертификата.</span><span class="sxs-lookup"><span data-stu-id="16c78-797">If the issuers do match, then the CRL is searched for the serial number of the certificate being validated.</span></span> <span data-ttu-id="16c78-798">Если этот серийный номер есть в списке, возвращается ошибка, указывающая, что сертификат был отозван.</span><span class="sxs-lookup"><span data-stu-id="16c78-798">If the serial number is present in the list, an error indicating that the certificate has been revoked is returned.</span></span> <span data-ttu-id="16c78-799">Если совпадения не найдены, то возвращается значение NX_SUCCESS.</span><span class="sxs-lookup"><span data-stu-id="16c78-799">If no match is found, NX_SUCCESS is returned.</span></span>

## <a name="client-certificate-authentication-in-netx-secure-tls"></a><span data-ttu-id="16c78-800">Проверка подлинности на основе сертификата клиента в NetX Secure TLS</span><span class="sxs-lookup"><span data-stu-id="16c78-800">Client Certificate Authentication in NetX Secure TLS</span></span>

<span data-ttu-id="16c78-801">При использовании проверки подлинности на основе сертификата X.509 протокол TLS требует, чтобы экземпляр сервера TLS предоставил сертификат для идентификации, но по умолчанию экземпляру клиента TLS не требуется предоставлять сертификат для проверки подлинности. Вместо этого используется другая разновидность проверки подлинности (например, сочетание имени пользователя и пароля).</span><span class="sxs-lookup"><span data-stu-id="16c78-801">When using X.509 certificate authentication, the TLS protocol requires that the TLS Server instance provide a certificate for identification, but by default the TLS Client instance does not need to provide a certificate for authentication, using another form of authentication instead (e.g. a username/password combination).</span></span> <span data-ttu-id="16c78-802">Это соответствует наиболее распространенному использованию протокола TLS в Интернете для веб-сайтов.</span><span class="sxs-lookup"><span data-stu-id="16c78-802">This matches the most common use of TLS on the Internet for Web sites.</span></span> <span data-ttu-id="16c78-803">Например, веб-сайт розничной торговли должен доказать потенциальному клиенту, использующему веб-браузер, что сервером является действительным, но пользователь будет использовать имя для входа и пароль для доступа к определенной учетной записи.</span><span class="sxs-lookup"><span data-stu-id="16c78-803">For example, an online retail site must prove to a potential customer using a web browser that the server is legitimate, but the user will use a login/password to access a specific account.</span></span>

<span data-ttu-id="16c78-804">Однако вариант использования по умолчанию не всегда желателен, поэтому протокол TLS дополнительно позволяет экземпляру сервера TLS запрашивать сертификат у удаленного клиента.</span><span class="sxs-lookup"><span data-stu-id="16c78-804">However, the default case is not always desirable, so TLS optionally allows for the TLS Server instance to request a certificate from the remote Client.</span></span> <span data-ttu-id="16c78-805">Если эта функция включена, то во время подтверждения сервер TLS отправляет сообщение CertificateRequest клиенту TLS.</span><span class="sxs-lookup"><span data-stu-id="16c78-805">When this feature is enabled, the TLS Server will send a CertificateRequest message to the TLS Client during the handshake.</span></span> <span data-ttu-id="16c78-806">Клиент должен отправить в ответ свой сертификат и сообщение CertificateVerify, которое содержит криптографический маркер, подтверждающий, что клиент владеет соответствующим закрытым ключом, связанным с этим сертификатом.</span><span class="sxs-lookup"><span data-stu-id="16c78-806">The Client must respond with a certificate of its own and a CertificateVerify message which contains a cryptographic token proving that the Client owns the matching private key associated with that certificate.</span></span> <span data-ttu-id="16c78-807">Если проверка завершается сбоем или сертификат не связан с доверенным сертификатом на сервере, происходит сбой подтверждения TLS.</span><span class="sxs-lookup"><span data-stu-id="16c78-807">If the verification fails or the certificate is not connected to a trusted certificate on the Server, the TLS handshake fails.</span></span>

<span data-ttu-id="16c78-808">Существуют два отдельных варианта проверки подлинности на основе сертификата клиента в протоколе TLS, они рассматриваются в следующих разделах.</span><span class="sxs-lookup"><span data-stu-id="16c78-808">There are two separate cases for Client Certificate Authentication in TLS – the following sections cover both cases.</span></span>

### <a name="client-certificate-authentication-for-tls-clients"></a><span data-ttu-id="16c78-809">Проверка подлинности на основе сертификата клиента для клиентов TLS</span><span class="sxs-lookup"><span data-stu-id="16c78-809">Client Certificate Authentication for TLS Clients</span></span>

<span data-ttu-id="16c78-810">Клиент TLS может попытаться подключиться к серверу, который запрашивает сертификат для проверки подлинности клиента.</span><span class="sxs-lookup"><span data-stu-id="16c78-810">A TLS Client may attempt a connection to a server that requests a certificate for client authentication.</span></span> <span data-ttu-id="16c78-811">В этом случае клиент должен предоставить сертификат серверу и подтвердить, что он владеет соответствующим закрытым ключом, иначе сервер завершит подтверждение TLS.</span><span class="sxs-lookup"><span data-stu-id="16c78-811">In this case the Client must provide a certificate to the server and verify that it owns the matching private key or the Server will terminate the TLS handshake.</span></span>

<span data-ttu-id="16c78-812">В NetX Secure TLS нет специальной конфигурации для поддержки этой функции, но приложению потребуется указать локальный сертификат для экземпляра клиента TLS с помощью службы *nx_secure_tls_local_certificate_add*.</span><span class="sxs-lookup"><span data-stu-id="16c78-812">In NetX Secure TLS, there is no special configuration to support this feature but the application will have to provide a local identification certificate for the TLS Client instance using the *nx_secure_tls_local_certificate_add* service.</span></span> <span data-ttu-id="16c78-813">Если приложение не предоставило сертификат, а удаленный сервер использует проверку подлинности на основе сертификата клиента и запрашивает сертификат, то подтверждение TLS завершится сбоем.</span><span class="sxs-lookup"><span data-stu-id="16c78-813">If no certificate is provided by the application but the remote server is using Client Certificate Authentication and requests a certificate, the TLS handshake will fail.</span></span> <span data-ttu-id="16c78-814">Для выполнения подтверждения TLS сертификат, предоставленный сеансу TLS службой *nx_secure_tls_local_certificate_add*, должен быть распознан удаленным сервером.</span><span class="sxs-lookup"><span data-stu-id="16c78-814">The certificate provided to the TLS Session with *nx_secure_tls_local_certificate_add* must be recognized by the remote server in order to complete the TLS handshake.</span></span>

### <a name="client-certificate-authentication-for-tls-servers"></a><span data-ttu-id="16c78-815">Проверка подлинности на основе сертификата клиента для серверов TLS</span><span class="sxs-lookup"><span data-stu-id="16c78-815">Client Certificate Authentication for TLS Servers</span></span>

<span data-ttu-id="16c78-816">В случае сервера TLS проверка подлинности на основе сертификата клиента выполняется немного сложнее, чем в случае клиента TLS, ввиду необязательного использования функции.</span><span class="sxs-lookup"><span data-stu-id="16c78-816">The TLS Server case for Client Certificate Authentication is slightly more complex than the TLS Client case due to the feature being optional.</span></span> <span data-ttu-id="16c78-817">В этом случае сервер TLS должен запросить сертификат у удаленного клиента TLS, обработать сообщение CertificateVerify, чтобы убедиться, что удаленный клиент владеет соответствующим закрытым ключом, а затем сервер должен убедиться, что сертификат, предоставленный клиентом, можно отследить до сертификата в хранилище локальных доверенных сертификатов.</span><span class="sxs-lookup"><span data-stu-id="16c78-817">In this case, the TLS Server needs to specifically request a certificate from the remote TLS Client, then process the CertificateVerify message to verify that the remote Client owns the matching private key, and then the Server must check that the certificate provided by the Client can be traced to a certificate in the local trusted certificate store.</span></span>

<span data-ttu-id="16c78-818">В экземплярах сервера NetX Secure TLS проверка подлинности на основе сертификата клиента осуществляется с помощью служб</span><span class="sxs-lookup"><span data-stu-id="16c78-818">In NetX Secure TLS Server instances, Client Certificate Authentication is controlled by</span></span> <br>
<span data-ttu-id="16c78-819">*nx <span class="underline"> _</span>secure <span class="underline">_</span>tls <span class="underline"> _</span>session <span class="underline">_</span>client <span class="underline"> _</span>verify<span class="underline">_</span>enable* и</span><span class="sxs-lookup"><span data-stu-id="16c78-819">the *nx <span class="underline">_</span>secure <span class="underline">_</span>tls <span class="underline">_</span>session <span class="underline">_</span>client <span class="underline">_</span>verify<span class="underline">_</span>enable* and</span></span><br>
<span data-ttu-id="16c78-820">*nx <span class="underline"> _</span>secure <span class="underline">_</span>tls <span class="underline"> _</span>session <span class="underline">_</span>client <span class="underline"> _</span>verify<span class="underline">_</span>disable*.</span><span class="sxs-lookup"><span data-stu-id="16c78-820">*nx <span class="underline">_</span>secure <span class="underline">_</span>tls <span class="underline">_</span>session <span class="underline">_</span>client <span class="underline">_</span>verify<span class="underline">_</span>disable* services.</span></span>

<span data-ttu-id="16c78-821">Чтобы включить проверку подлинности на основе сертификата клиента, приложение должно вызвать службу</span><span class="sxs-lookup"><span data-stu-id="16c78-821">To enable Client Certificate Authentication, an application must call</span></span><br>
<span data-ttu-id="16c78-822">*nx <span class="underline"> _</span>secure <span class="underline">_</span>tls <span class="underline"> _</span>session <span class="underline">_</span>client <span class="underline"> _</span>verify <span class="underline">_</span>enable* с использованием экземпляра сеанса сервера TLS перед вызовом *nx_secure_tls_session_start*.</span><span class="sxs-lookup"><span data-stu-id="16c78-822">*nx <span class="underline">_</span>secure <span class="underline">_</span>tls <span class="underline">_</span>session <span class="underline">_</span>client <span class="underline">_</span>verify <span class="underline">_</span>enable* with the TLS Server session instance before calling *nx_secure_tls_session_start*.</span></span> <span data-ttu-id="16c78-823">Обратите внимание на то, что вызов этой службы для сеанса TLS, который используется для подключений клиента TLS, ни на что не повлияет.</span><span class="sxs-lookup"><span data-stu-id="16c78-823">Note that calling this service on a TLS Session that is used for TLS Client connections will have no effect.</span></span>

<span data-ttu-id="16c78-824">Если включена проверка подлинности на основе сертификата клиента, сервер TLS запрашивает сертификат у удаленного клиента TLS во время подтверждения TLS.</span><span class="sxs-lookup"><span data-stu-id="16c78-824">When Client Certificate Authentication is enabled, the TLS Server will request a certificate from the remote TLS Client during the TLS handshake.</span></span> <span data-ttu-id="16c78-825">На сервере NetX Secure TLS сертификат клиента проверяется с помощью хранилища доверенных сертификатов, созданных с помощью *nx <span class="underline"> _</span>secure_tls <span class="underline">_</span>trusted <span class="underline"> _</span>certificate<span class="underline">_</span>add*, в соответствии с цепочкой издателей X.509.</span><span class="sxs-lookup"><span data-stu-id="16c78-825">In NetX Secure TLS Server, the Client certificate is checked against the store of trusted certificates created with *nx <span class="underline">_</span>secure_tls <span class="underline">_</span>trusted <span class="underline">_</span>certificate<span class="underline">_</span>add* following the X.509 issuer chain.</span></span> <span data-ttu-id="16c78-826">Удаленный клиент должен предоставить цепочку, которая связывает удостоверяющий сертификат с сертификатом в доверенном хранилище, иначе произойдет сбой подтверждения TLS.</span><span class="sxs-lookup"><span data-stu-id="16c78-826">The remote Client must provide a chain that connects its identity certificate to a certificate in the trusted store or the TLS handshake will fail.</span></span> <span data-ttu-id="16c78-827">Кроме того, если происходит сбой обработки сообщения CertificateVerify, то подтверждение TLS также завершается ошибкой.</span><span class="sxs-lookup"><span data-stu-id="16c78-827">Additionally, if the CertificateVerify message processing fails, the TLS handshake will also fail.</span></span>

<span data-ttu-id="16c78-828">Методы сигнатур, используемые для метода CertificateVerify, являются фиксированными для протоколов TLS 1.0 и TLS 1.1 и задаются сервером TLS в протоколе TLS 1.2.</span><span class="sxs-lookup"><span data-stu-id="16c78-828">The signature methods used for the CertificateVerify method are fixed for TLS version 1.0 and TLS version 1.1, and are specified by the TLS Server in TLS version 1.2.</span></span> <span data-ttu-id="16c78-829">Для протокола TLS 1.2 поддерживаются методы сигнатур, которые, как правило, соответствуют методам, передаваемым в таблице криптографических методов, но обычно это RSA с SHA-256 (ознакомьтесь с разделом "Шифрование в NetX Secure TLS", чтобы получить дополнительные сведения об инициализации TLS с помощью криптографических методов).</span><span class="sxs-lookup"><span data-stu-id="16c78-829">For TLS 1.2, the signature methods supported generally follow the relevant methods supplied in the cryptographic method table, but typically RSA with SHA-256 (see the section "Cryptography in NetX Secure TLS" for more information on initializing TLS with cryptographic methods).</span></span>

## <a name="cryptography-in-netx-secure-tls"></a><span data-ttu-id="16c78-830">Шифрование в NetX Secure TLS</span><span class="sxs-lookup"><span data-stu-id="16c78-830">Cryptography in NetX Secure TLS</span></span>

<span data-ttu-id="16c78-831">TLS определяет протокол, в котором может использоваться шифрование для защиты сетевого взаимодействия.</span><span class="sxs-lookup"><span data-stu-id="16c78-831">TLS defines a protocol in which cryptography can be used to secure network communications.</span></span> <span data-ttu-id="16c78-832">Поэтому выбор фактического алгоритма шифрования, который может быть применен, не слишком ограничен для пользователей протокола TLS.</span><span class="sxs-lookup"><span data-stu-id="16c78-832">As such, it leaves the actual cryptography to be used fairly wide open for TLS users.</span></span> <span data-ttu-id="16c78-833">Спецификация только требует реализовать один комплект шифров. В случае протокола TLS 1.2 это комплект шифров TLS_RSA_WITH_AES_128_CBC_SHA, предписывающий использование RSA для операций с открытым ключом, AES — в режиме CBC с 128-разрядными ключами для шифрования сеансов и SHA-1 — для хэшей для проверки подлинности сообщений.</span><span class="sxs-lookup"><span data-stu-id="16c78-833">The specification only requires a single ciphersuite to be implemented – in the case of TLS 1.2, that ciphersuite is TLS_RSA_WITH_AES_128_CBC_SHA, indicating the use of RSA for public-key operations, AES in CBC mode with 128-bit keys for session encryption, and SHA-1 for message authentication hashes.</span></span>

<span data-ttu-id="16c78-834">Так как протокол NetX Secure совместим с протоколом TLS 1.2, он обеспечивает обязательный комплект шифров TLS_RSA_WITH_AES_128_CBC_SHA по умолчанию, но, учитывая количество возможных реализаций для каждого из криптографических методов ввиду возможностей оборудования и других соображений, NetX Secure предоставляет универсальный криптографический API, позволяющий пользователю указать, какие криптографические методы использовать в протоколе TLS.</span><span class="sxs-lookup"><span data-stu-id="16c78-834">Being TLS 1.2-compliant, NetX Secure enables the mandatory TLS_RSA_WITH_AES_128_CBC_SHA ciphersuite by default, but given the number of possible implementations for each of the cryptographic methods due to hardware capabilities and other considerations, NetX Secure provides a generic cryptographic API that allows a user to specify which cryptographic methods to use with TLS.</span></span>

<span data-ttu-id="16c78-835">Примечание. Механизм универсального криптографического API также позволяет пользователям реализовать собственные комплекты шифров, но это рекомендуется для опытных пользователей, уже работавших с комплектами шифров и расширениями TLS.</span><span class="sxs-lookup"><span data-stu-id="16c78-835">NOTE: The generic cryptographic API mechanism also allows users to implement their own ciphersuites, but this is recommended for advanced users who are familiar with the TLS ciphersuites and extensions.</span></span> <span data-ttu-id="16c78-836">Если вы заинтересованы в поддержке собственных комплектов шифров, обратитесь к своему представителю Express Logic.</span><span class="sxs-lookup"><span data-stu-id="16c78-836">Please contact your Express Logic representative if you are interested in supporting your own ciphersuites.</span></span>

### <a name="cryptographic-methods"></a><span data-ttu-id="16c78-837">Криптографические методы</span><span class="sxs-lookup"><span data-stu-id="16c78-837">Cryptographic Methods</span></span>

<span data-ttu-id="16c78-838">NetX Secure TLS реализует алгоритмы DES, 3DES, AES, MD5, HMAC-MD5, SHA-1, HMAC-SHA1, SHA-256, HMAC-SHA256, RSA и ECC (выбранные кривые) в программном обеспечении с помощью драйверов оборудования для определенных аппаратных платформ.</span><span class="sxs-lookup"><span data-stu-id="16c78-838">NetX Secure TLS implements DES, 3DES, AES, MD5, HMAC-MD5, SHA-1, HMAC-SHA1, SHA-256, HMAC-SHA256, RSA, and ECC (selected curves) in software with hardware drivers for certain hardware platforms.</span></span> <span data-ttu-id="16c78-839">Приложение может использовать криптографические процедуры, предоставляемые в NetX Secure, или пользовательские процедуры, предоставленные пользователем или сторонними производителями.</span><span class="sxs-lookup"><span data-stu-id="16c78-839">An application may use the cryptographic routines provided with NetX Secure, or use custom routines provided by the end user or third parties.</span></span>

<span data-ttu-id="16c78-840">*NX_CRYPTO_METHOD* — это блок управления, предназначенный для описания конкретной реализации алгоритма шифрования для использования в NetX Secure TLS.</span><span class="sxs-lookup"><span data-stu-id="16c78-840">The *NX_CRYPTO_METHOD* is a control block designed for an application to describe a particular implementation of a cryptographic algorithm to be used with NetX Secure TLS.</span></span> <span data-ttu-id="16c78-841">С помощью *NX_CRYPTO_METHOD* приложение может легко интегрировать собственную реализацию шифрования в NetX Secure.</span><span class="sxs-lookup"><span data-stu-id="16c78-841">With the *NX_CRYPTO_METHOD,* an application can easily integrate their own crypto implementation into NetX Secure.</span></span> <span data-ttu-id="16c78-842">Структура *NX_CRYPTO_METHOD* объявляется следующим образом.</span><span class="sxs-lookup"><span data-stu-id="16c78-842">The *NX_CRYPTO_METHOD* structure is declared as:</span></span>

```C
typedef struct NX_CRYPTO_METHOD_STRUCT
{
    /* Symbolic name of the algorithm. */
    USHORT nx_crypto_algorithm;

    /* Size of the key, in bits. */
    USHORT nx_crypto_key_size_in_bits;

    /* Size of the IV block, in bits, used for encryption. */
    USHORT nx_crypto_IV_size_in_bits;

    /* Size of the ICV block, in bits, used for authentication. */
    USHORT nx_crypto_ICV_size_in_bits;

    /* Size of the crypto block, in bytes. */
    ULONG nx_crypto_block_size_in_bytes;

    /* Size of the metadata area. */
    ULONG nx_crypto_metadata_size;

    /* nx_crypto_init function initializes the crypto method with the
        "secret key" or other state  information. The initialization 
        routine should return a handle to the caller.  This handle is 
        used in subsequent crypto operations to identify the session.  
        */

    UINT (*nx_crypto_init) (NX_CRYPTO_METHOD     *method,
                            UCHAR               *key, 
                            NX_CRYPTO_KEY_SIZE   key_size_in_bits,
                            VOID               **handler,
                            VOID                *crypto_metadata,
                            VOID                 crypto_metadata_size);

    /* NetX Secure calls the nx_crypto_cleanup routine when a TLS
       session is to be deleted (or updated).  Resources allocated 
       during the crypto operation should be released in this routine.  
       */
    UINT (*nx_crypto_cleanup) (VOID *handler);

    /* nx_crypto_operation is the actual crypto or hash operation. Note 
       that both input and output buffers are prepared by the caller. 
       For encryption or decryption operations, the crypto operation 
       routine uses the output buffer for encrypted or decrypted data. 
       For authentication operations, the authentication routine shall 
       use the output buffer for the digest. */
    UINT (*nx_crypto_operation)(UINT  op, 
                  VOID              *handler, 
                  NX_CRYPTO_METHOD  *method,
                  UCHAR             *key,
                  NX_CRYPTO_KEY_SIZE key_size_in_bits,
                  UCHAR             *input,
                  ULONG              input_length_in_byte,
                  UCHAR             *iv_ptr,
                  UCHAR             *output,
                  ULONG              output_length_in_byte,
                  VOID              *crypto_metadata,
                  VOID               crypto_metadata_size,
                  NX_PACKET*         packet_ptr,
                  VOID (*nx_crypto_hw_process_callback(NX_PACKET 
                                                       *packet_ptr, 
                                                        UINT status);
} NX_CRYPTO_METHOD;
```

<span data-ttu-id="16c78-843">Ниже приведено описание каждого элемента в структуре *NX_CRYPTO_METHOD*.</span><span class="sxs-lookup"><span data-stu-id="16c78-843">Below is the description of each element in the *NX_CRYPTO_METHOD* structure:</span></span>

- <span data-ttu-id="16c78-844">nx_crypto_algorithm: это поле определяет алгоритм, описанный в *методе* переменной; некоторые допустимые значения для NetX Secure TLS приведены ниже (чтобы узнать какие-либо определенные значения, просмотрите файл nx_crypto_const.h).</span><span class="sxs-lookup"><span data-stu-id="16c78-844">nx_crypto_algorithm: This field identifies the algorithm described in the variable *method* Some valid values for NetX Secure TLS are as follows (refer to nx_crypto_const.h for specific values):</span></span>
    
  - <span data-ttu-id="16c78-845">NX_CRYPTO_NONE</span><span class="sxs-lookup"><span data-stu-id="16c78-845">NX_CRYPTO_NONE</span></span>    
  - <span data-ttu-id="16c78-846">NX_CRYPTO_ENCRYPTION_NULL</span><span class="sxs-lookup"><span data-stu-id="16c78-846">NX_CRYPTO_ENCRYPTION_NULL</span></span>    
  - <span data-ttu-id="16c78-847">NX_CRYPTO_ENCRYPTION_AES_CBC</span><span class="sxs-lookup"><span data-stu-id="16c78-847">NX_CRYPTO_ENCRYPTION_AES_CBC</span></span>    
  - <span data-ttu-id="16c78-848">NX_CRYPTO_AUTHENTICATION_NONE</span><span class="sxs-lookup"><span data-stu-id="16c78-848">NX_CRYPTO_AUTHENTICATION_NONE</span></span>    
  - <span data-ttu-id="16c78-849">TLS_HASH_SHA_1</span><span class="sxs-lookup"><span data-stu-id="16c78-849">TLS_HASH_SHA_1</span></span>    
  - <span data-ttu-id="16c78-850">TLS_HASH_SHA_256</span><span class="sxs-lookup"><span data-stu-id="16c78-850">TLS_HASH_SHA_256</span></span>    
  - <span data-ttu-id="16c78-851">TLS_HASH_MD5</span><span class="sxs-lookup"><span data-stu-id="16c78-851">TLS_HASH_MD5</span></span>    
  - <span data-ttu-id="16c78-852">TLS_CIPHER_RSA</span><span class="sxs-lookup"><span data-stu-id="16c78-852">TLS_CIPHER_RSA</span></span>    
  - <span data-ttu-id="16c78-853">TLS_CIPHER_NULL</span><span class="sxs-lookup"><span data-stu-id="16c78-853">TLS_CIPHER_NULL</span></span>

- <span data-ttu-id="16c78-854">nx_crypto_key_size_in_bits: это поле указывает размер секретного ключа, используемого методом.</span><span class="sxs-lookup"><span data-stu-id="16c78-854">nx_crypto_key_size_in_bits: this field specifies the size of the secret key used by the method.</span></span>

- <span data-ttu-id="16c78-855">nx_crypto_IV_size_in_bits: это поле указывает размер вектора инициализации (IV).</span><span class="sxs-lookup"><span data-stu-id="16c78-855">nx_crypto_IV_size_in_bits: this field specifies the size of the Initialization Vector (IV).</span></span> <span data-ttu-id="16c78-856">Обратите внимание на то, что в большинстве случаев блок IV используется только для алгоритмов шифрования и расшифровки.</span><span class="sxs-lookup"><span data-stu-id="16c78-856">Note that in most cases the IV block is only used for encryption/decryption algorithms.</span></span> <span data-ttu-id="16c78-857">Алгоритмы проверки подлинности и проверки редко используют это поле.</span><span class="sxs-lookup"><span data-stu-id="16c78-857">Authentication and verification algorithms rarely use this field.</span></span>

- <span data-ttu-id="16c78-858">nx_crypto_ICV_size_in_bits: это поле определяет размер блока проверки целостности (ICV).</span><span class="sxs-lookup"><span data-stu-id="16c78-858">nx_crypto_ICV_size_in_bits: this field specifies the size of the Integrity Check Value (ICV) block.</span></span> <span data-ttu-id="16c78-859">Примечание. Этот блок предназначен для IPsec и не используется в протоколе TLS.</span><span class="sxs-lookup"><span data-stu-id="16c78-859">NOTE: This block is for IPsec usage and is unused in TLS.</span></span> <span data-ttu-id="16c78-860">Дополнительные сведения см. в описании NetX Duo IPsec.</span><span class="sxs-lookup"><span data-stu-id="16c78-860">See NetX Duo IPsec for more information.</span></span>

- <span data-ttu-id="16c78-861">nx_crypto_block_size_in_bytes: это поле указывает размер в байтах блока алгоритма шифрования для шифров на основе блоков.</span><span class="sxs-lookup"><span data-stu-id="16c78-861">nx_crypto_block_size_in_bytes: this field specifies the size of the cryptographic algorithm block for block-based ciphers, in bytes.</span></span> <span data-ttu-id="16c78-862">В большинстве случаев оно используется процедурами шифрования, и редко — процедурами проверки подлинности.</span><span class="sxs-lookup"><span data-stu-id="16c78-862">In most cases this is used by encryption routines and rarely by authentication routines.</span></span>

- <span data-ttu-id="16c78-863">nx_crypto_metadata_area_size: это поле указывает размер области метаданных, требуемой для этого метода.</span><span class="sxs-lookup"><span data-stu-id="16c78-863">nx_crypto_metadata_area_size: this field specifies the size of the metadata area this method requires.</span></span> <span data-ttu-id="16c78-864">Для каждой реализации может потребоваться определенный объем памяти для хранения сведений о состоянии или промежуточных данных (например, материала для преобразования ключей), либо для использования в качестве временной области.</span><span class="sxs-lookup"><span data-stu-id="16c78-864">Each implementation may require certain memory to store its state information, or to store intermediate data (such as key transformation material), or to use as a scratch area.</span></span> <span data-ttu-id="16c78-865">В этом поле указывается объем пространства, необходимый для реализации.</span><span class="sxs-lookup"><span data-stu-id="16c78-865">The amount of space required by an implementation is specified in this field.</span></span> <span data-ttu-id="16c78-866">Приложение предоставляет пространство памяти при создании сеанса TLS.</span><span class="sxs-lookup"><span data-stu-id="16c78-866">The application provides the memory space when creating a TLS session.</span></span> <span data-ttu-id="16c78-867">Криптографическая функция отвечает за управление этой областью метаданных.</span><span class="sxs-lookup"><span data-stu-id="16c78-867">The cryptographic function is responsible for managing this metadata area.</span></span>

- <span data-ttu-id="16c78-868">nx_crypto_init: функция инициализации для алгоритма шифрования.</span><span class="sxs-lookup"><span data-stu-id="16c78-868">nx_crypto_init: This is the initialization function for the cryptographic algorithm.</span></span> <span data-ttu-id="16c78-869">Для реализации, которая не нуждается в процедуре инициализации, этому полю может быть присвоено значение NX_NULL.</span><span class="sxs-lookup"><span data-stu-id="16c78-869">For an implementation that does not need an initialization routine, this field may be set to NX_NULL.</span></span> <span data-ttu-id="16c78-870">Обычно функция инициализации используется для инициализации внутренней структуры данных для алгоритма.</span><span class="sxs-lookup"><span data-stu-id="16c78-870">A typical use of an initialization function is to initialize the internal data structure for the algorithm.</span></span> <span data-ttu-id="16c78-871">NetX Secure TLS будет выполнять инициализацию криптографической процедуры, используя внутренний вызов этой функции.</span><span class="sxs-lookup"><span data-stu-id="16c78-871">NetX Secure TLS will handle initialization of the cryptographic routine by calling this function internally.</span></span>

<span data-ttu-id="16c78-872">Прототип функции инициализации:</span><span class="sxs-lookup"><span data-stu-id="16c78-872">The prototype for the initialization function is:</span></span>

```C
UINT crypto_init_function(NX_CRYPTO_METHOD *method, 
                          UCHAR *key, 
                          UINT  key_size_in_bits, 
                          VOID  **handle, 
                          VOID  *crypto_metadata_area, 
                          ULONG crypto_metadata_area_size);
```

  - <span data-ttu-id="16c78-873">method: указатель на блок управления криптографическим методом.</span><span class="sxs-lookup"><span data-stu-id="16c78-873">method is a pointer to the crypto method control block.</span></span>

  - <span data-ttu-id="16c78-874">key: строка секретного ключа для обработки пакетов данных.</span><span class="sxs-lookup"><span data-stu-id="16c78-874">key is the secret key string for processing the data packets.</span></span>

  - <span data-ttu-id="16c78-875">key_size_in_bits определяет размер секретного ключа в битах.</span><span class="sxs-lookup"><span data-stu-id="16c78-875">key_size_in_bits defines the size of the secret key, in bits.</span></span>

  - <span data-ttu-id="16c78-876">handle: определяемый реализацией элемент, задающий конкретный сеанс шифрования.</span><span class="sxs-lookup"><span data-stu-id="16c78-876">handle is an implementation-defined item that identifies a particular crypto session.</span></span> <span data-ttu-id="16c78-877">Значение создается процедурой инициализации и передается обратно вызывающему объекту.</span><span class="sxs-lookup"><span data-stu-id="16c78-877">The value is generated by the initialization routine, and is passed back to the caller.</span></span> <span data-ttu-id="16c78-878">Последующая операция шифрования или процедура очистки использует этот обработчик для идентификации сеанса.</span><span class="sxs-lookup"><span data-stu-id="16c78-878">The subsequent crypto operation or clean up routine use this handle to identify the session.</span></span>

  - <span data-ttu-id="16c78-879">crypto_metadata: указатель на область метаданных, которая требуется для реализации данного алгоритма.</span><span class="sxs-lookup"><span data-stu-id="16c78-879">crypto_metadata is a pointer to the metadata area required by the implementation of this algorithm.</span></span> <span data-ttu-id="16c78-880">Для алгоритмов, которым не требуется область метаданных, это поле имеет значение NX_NULL, а процедура инициализации не должна обращаться к области метаданных.</span><span class="sxs-lookup"><span data-stu-id="16c78-880">For algorithms that do not need a metadata area this field is set to NX_NULL and the initialization routine must not access the metadata area.</span></span>

  - <span data-ttu-id="16c78-881">crypto_metadata_size задает размер области метаданных.</span><span class="sxs-lookup"><span data-stu-id="16c78-881">crypto_metadata_size specifies the size of the metadata area.</span></span> <span data-ttu-id="16c78-882">Для сопоставлений безопасности, созданных без области метаданных, это поле имеет значение 0, а процедура инициализации не должна обращаться к области метаданных.</span><span class="sxs-lookup"><span data-stu-id="16c78-882">For SAs created without metadata area, this field is set to zero, and the initialization routine must not access the metadata area.</span></span>

  - <span data-ttu-id="16c78-883">Эта процедура должна возвращать значение *NX_SUCCESS*, если процесс инициализации прошел успешно.</span><span class="sxs-lookup"><span data-stu-id="16c78-883">This routine shall return *NX_SUCCESS* if the initialization process is successful.</span></span> <span data-ttu-id="16c78-884">Вызывающий объект рассматривает любое другое возвращаемое значение как сбой.</span><span class="sxs-lookup"><span data-stu-id="16c78-884">The caller treats any other return value as failure.</span></span>

- <span data-ttu-id="16c78-885">nx_crypto_cleanup: подпрограмма очистки, определенная для реализации алгоритма шифрования.</span><span class="sxs-lookup"><span data-stu-id="16c78-885">nx_crypto_cleanup: This is the cleanup routine defined for the implementation of a crypto algorithm.</span></span> <span data-ttu-id="16c78-886">Она вызывается при удалении или перезапуске сеанса TLS.</span><span class="sxs-lookup"><span data-stu-id="16c78-886">It is invoked when a TLS session is deleted or restarted.</span></span>

<span data-ttu-id="16c78-887">Прототип функции очистки:</span><span class="sxs-lookup"><span data-stu-id="16c78-887">The prototype for the cleanup function is:</span></span>

```C
UINT crypto_cleanup_function(VOID *handle);
```
- <span data-ttu-id="16c78-888">Элемент handle передается в функцию очистки вызывающим объектом.</span><span class="sxs-lookup"><span data-stu-id="16c78-888">handle is passed to the cleanup function by the caller.</span></span> <span data-ttu-id="16c78-889">Этот элемент инициализируется процедурой инициализации шифрования и используется для определения состояния алгоритма шифрования.</span><span class="sxs-lookup"><span data-stu-id="16c78-889">The handle is initialized by the crypto initialization routine and used to identify cryptographic algorithm state.</span></span>

- <span data-ttu-id="16c78-890">Эта процедура должна вернуть значение *NX_SUCCESS*, если процесс инициализации прошел успешно.</span><span class="sxs-lookup"><span data-stu-id="16c78-890">This routine shall return *NX_SUCCESS* if the cleanup process is successful.</span></span> <span data-ttu-id="16c78-891">Вызывающий объект рассматривает любое другое возвращаемое значение как сбой.</span><span class="sxs-lookup"><span data-stu-id="16c78-891">The caller treats any other return value as failure.</span></span>

- <span data-ttu-id="16c78-892">nx_crypto_operation: подпрограмма, выполняющая шифрование, расшифровку и запускающая службы проверки подлинности.</span><span class="sxs-lookup"><span data-stu-id="16c78-892">nx_crypto_operation: This is the routine that performs the actual encryption, decryption, and authentication services.</span></span> <span data-ttu-id="16c78-893">Прототип функции операционной процедуры:</span><span class="sxs-lookup"><span data-stu-id="16c78-893">The function prototype of the operation routine is:</span></span>

```C
UINT crypto_operation_function(UINT   op,
          VOID  *handle,  
          NX_CRYPTO_METHOD* method,
          UCHAR *key,
          UCHAR  key_size_in_bits,
          UCHAR* input,
          ULONG  input_length_in_byte,
          UCHAR* iv_ptr,
          UCHAR* output,
          ULONG  output_length_in_byte,
          VOID *crypto_metadata,
          ULONG crypto_metadata_size,
          NX_PACKET *packet_ptr,
          VOID (*nx_crypto_hw_process_callback)(NX_PACKET 
                          *packet_ptr, UINT status));
```

- <span data-ttu-id="16c78-894">Параметр op указывает тип операции, которая должна выполняться этой процедурой. Допустимые значения:</span><span class="sxs-lookup"><span data-stu-id="16c78-894">op indicates the type of operation this routine is expected to carry out. Valid values are:</span></span>
    
    - <span data-ttu-id="16c78-895">NX_CRYPTO_ENCRYPT</span><span class="sxs-lookup"><span data-stu-id="16c78-895">NX_CRYPTO_ENCRYPT</span></span>
    - <span data-ttu-id="16c78-896">NX_CRYPTO_DECRYPT</span><span class="sxs-lookup"><span data-stu-id="16c78-896">NX_CRYPTO_DECRYPT</span></span>
    - <span data-ttu-id="16c78-897">NX_CRYPTO_AUTHENTICATE</span><span class="sxs-lookup"><span data-stu-id="16c78-897">NX_CRYPTO_AUTHENTICATE</span></span>
    - <span data-ttu-id="16c78-898">NX_CRYPTO_VERIFY</span><span class="sxs-lookup"><span data-stu-id="16c78-898">NX_CRYPTO_VERIFY</span></span>

- <span data-ttu-id="16c78-899">Элемент handle передается в операционную функцию вызывающим объектом.</span><span class="sxs-lookup"><span data-stu-id="16c78-899">handle is passed to the operation function by the caller.</span></span> <span data-ttu-id="16c78-900">Он создается процедурой инициализации шифрования.</span><span class="sxs-lookup"><span data-stu-id="16c78-900">It is generated by the crypto initialization routine.</span></span>
- <span data-ttu-id="16c78-901">method указывает на блок управления криптографическим методом.</span><span class="sxs-lookup"><span data-stu-id="16c78-901">method points to the crypto method control block</span></span>
- <span data-ttu-id="16c78-902">key указывает на секретный ключ, используемый для этой операции.</span><span class="sxs-lookup"><span data-stu-id="16c78-902">key points to the secret key used for this operation</span></span>
- <span data-ttu-id="16c78-903">key_size_in_bits определяет размер секретного ключа в битах.</span><span class="sxs-lookup"><span data-stu-id="16c78-903">key_size_in_bits is the size of the secret key in bits</span></span>
- <span data-ttu-id="16c78-904">input: указатель на начало обрабатываемого сообщения.</span><span class="sxs-lookup"><span data-stu-id="16c78-904">input is a pointer to the beginning of the message to be operated on.</span></span>
- <span data-ttu-id="16c78-905">input_length_in_byte передается вызывающим объектом для указания размера обрабатываемого сообщения.</span><span class="sxs-lookup"><span data-stu-id="16c78-905">input_length_in_byte is passed by the caller to indicate the size of the message to be operated on.</span></span>
- <span data-ttu-id="16c78-906">iv_ptr настраивается вызывающим объектом и указывает на начало блока IV.</span><span class="sxs-lookup"><span data-stu-id="16c78-906">iv_ptr is setup by the caller to point to the beginning of an IV block.</span></span> <span data-ttu-id="16c78-907">Обратите внимание на то, что память для блока IV предоставляется вызывающим объектом.</span><span class="sxs-lookup"><span data-stu-id="16c78-907">Note that the memory for the IV block is provided by the caller.</span></span> <span data-ttu-id="16c78-908">Для шифрования операционная функция должна записать в этот блок памяти сведения о векторе инициализации. Для расшифровки операционная функция должна получить сведения о векторе инициализации из этого блока памяти.</span><span class="sxs-lookup"><span data-stu-id="16c78-908">For encryption, the operation function should write the IV information into this memory block; for decryption, the operation function should retrieve the IV information from this memory block.</span></span> <span data-ttu-id="16c78-909">Алгоритмы для операций проверки подлинности и проверки обычно не используют вектор инициализации.</span><span class="sxs-lookup"><span data-stu-id="16c78-909">Algorithms for authentication and verification operation typically do not use the initialization vector.</span></span>
- <span data-ttu-id="16c78-910">Параметр output настраивается вызывающим объектом и указывает на буфер вывода.</span><span class="sxs-lookup"><span data-stu-id="16c78-910">output is setup by the caller to point to an output buffer.</span></span> <span data-ttu-id="16c78-911">Обратите внимание на то, что память для буфера вывода предоставляется вызывающим объектом.</span><span class="sxs-lookup"><span data-stu-id="16c78-911">Note that the memory for the output buffer is provided by the caller.</span></span> <span data-ttu-id="16c78-912">Для шифрования операционная функция должна записать в буфер вывода зашифрованный текст. Для расшифровки операция должна записать в буфер вывода расшифрованный текст (открытый текст). Для проверки подлинности в буфер вывода должно быть записано значение хэша.</span><span class="sxs-lookup"><span data-stu-id="16c78-912">For encryption, the operation function should write the cipher text to the output buffer; for decryption, the operation should write the deciphered text (clear text) to the output buffer; for authentication, the hash value shall be written to the output buffer.</span></span> <span data-ttu-id="16c78-913">При проверке буфер вывода используется для хранения данных хэша.</span><span class="sxs-lookup"><span data-stu-id="16c78-913">For verification, the output buffer is used to store hash information.</span></span>
- <span data-ttu-id="16c78-914">output_length_in_byte указывает размер буфера вывода.</span><span class="sxs-lookup"><span data-stu-id="16c78-914">output_length_in_byte indicates the size of the output buffer</span></span>
- <span data-ttu-id="16c78-915">crypto_metadata указывает на область метаданных, используемую этой криптографической операцией.</span><span class="sxs-lookup"><span data-stu-id="16c78-915">crypto_metadata points to the metadata area to be used by this crypto operation.</span></span> <span data-ttu-id="16c78-916">Эта область метаданных обычно инициализируется функцией crypto_init_function.</span><span class="sxs-lookup"><span data-stu-id="16c78-916">The crypto metadata area is typically initialized by crypto_init_function.</span></span>
- <span data-ttu-id="16c78-917">crypto_metadata_size задает размер области метаданных.</span><span class="sxs-lookup"><span data-stu-id="16c78-917">crypto_metadata_size indicates the size of the metadata area.</span></span>
- <span data-ttu-id="16c78-918">Эта процедура должна возвращать значение *NX_SUCCESS*, если выполнение операции прошло успешно.</span><span class="sxs-lookup"><span data-stu-id="16c78-918">This routine shall return *NX_SUCCESS* if the operation process is successful.</span></span> <span data-ttu-id="16c78-919">Вызывающий объект рассматривает любое другое возвращаемое значение как сбой.</span><span class="sxs-lookup"><span data-stu-id="16c78-919">The caller treats any other return value as failure.</span></span>
- <span data-ttu-id="16c78-920">packet_ptr: пакет, содержащий обрабатываемые данные.</span><span class="sxs-lookup"><span data-stu-id="16c78-920">packet_ptr: The packet that contains the data being processed.</span></span> <span data-ttu-id="16c78-921">Примечание. Этот параметр не используется протоколом TLS и должен быть иметь значение NX_NULL.</span><span class="sxs-lookup"><span data-stu-id="16c78-921">NOTE: This parameter is unused by TLS and should be set to NX_NULL.</span></span>
- <span data-ttu-id="16c78-922">nx_crypto_hw_process_callback: функция обратного вызова, предоставляемая методом шифрования.</span><span class="sxs-lookup"><span data-stu-id="16c78-922">nx_crypto_hw_process_callback: A callback function provided by the encryption method.</span></span> <span data-ttu-id="16c78-923">Этот параметр используется, если функция шифрования предоставляется оборудованием и требует процедуры обратного вызова.</span><span class="sxs-lookup"><span data-stu-id="16c78-923">This is used if the crypto function is provided by hardware and requires a callback routine.</span></span>

<span data-ttu-id="16c78-924">NetX Secure TLS предоставляет следующие методы шифрования:</span><span class="sxs-lookup"><span data-stu-id="16c78-924">NetX Secure TLS provides the following encryption methods:</span></span>

- <span data-ttu-id="16c78-925">*AES*</span><span class="sxs-lookup"><span data-stu-id="16c78-925">*AES*</span></span>  
- <span data-ttu-id="16c78-926">*RSA*</span><span class="sxs-lookup"><span data-stu-id="16c78-926">*RSA*</span></span>  
- <span data-ttu-id="16c78-927">*NULL*</span><span class="sxs-lookup"><span data-stu-id="16c78-927">*NULL*</span></span>

<span data-ttu-id="16c78-928">NetX Secure TLS предоставляет следующие способы проверки подлинности:</span><span class="sxs-lookup"><span data-stu-id="16c78-928">NetX Secure TLS provides the following authentication methods:</span></span>

- <span data-ttu-id="16c78-929">*HMAC-MD5*</span><span class="sxs-lookup"><span data-stu-id="16c78-929">*HMAC-MD5*</span></span>  
- <span data-ttu-id="16c78-930">*HMAC-SHA1*</span><span class="sxs-lookup"><span data-stu-id="16c78-930">*HMAC-SHA1*</span></span>  
- <span data-ttu-id="16c78-931">*HMAC-SHA256*</span><span class="sxs-lookup"><span data-stu-id="16c78-931">*HMAC-SHA256*</span></span>

<span data-ttu-id="16c78-932">В следующих примерах показано, как настроить структуру *NX_CRYPTO_METHOD* для использования методов шифрования и проверки подлинности, предоставляемых NetX Duo IPsec.</span><span class="sxs-lookup"><span data-stu-id="16c78-932">The following examples illustrate how to configure the *NX_CRYPTO_METHOD* structure to use the encryption and authentication methods provided by NetX Duo IPsec.</span></span>

<span data-ttu-id="16c78-933">***AES***</span><span class="sxs-lookup"><span data-stu-id="16c78-933">***AES:***</span></span>

```C
/* AES-CBC 128. */
NX_CRYPTO_METHOD crypto_method_aes_cbc_128 = 
{
    /* AES crypto algorithm                             */
    NX_CRYPTO_ENCRYPTION_AES_CBC,                       

    /* Key size in bits. For AES-128 this value is 128  */
    NX_CRYPTO_AES_128_KEY_LEN_IN_BITS,              
   
    /* IV size in bits.  For AES-128 this value is 128  */
    NX_CRYPTO_AES_IV_LEN_IN_BITS,

    /* ICV size in bits, not used.                      */
    0,                                              

    /* Block size in bytes.  For AES this value is 16   */
    (NX_CRYPTO_AES_BLOCK_SIZE_IN_BITS >> 3),        

    /* Metadata size in bytes, for AES this value is 262*/
    sizeof(NX_CRYPTO_AES),              

    /* AES-CBC initialization routine.                  */
    _nx_secure_crypto_method_aes_init,               

    /* AES-CBC cleanup routine, not used.               */
    NX_NULL,                                        

    /* AES-CBC operation                                */
    _nx_secure_crypto_method_aes_operation           
};

/* RSA. */
NX_CRYPTO_METHOD crypto_method_rsa = 
{
    /* RSA crypto algorithm                             */
    TLS_CIPHER_RSA,                       

    /* Key size. RSA key sizes vary, so set to 0.         */
    0,              
   
    /* IV size in bits.  RSA does not use an IV.         */
    0,

    /* ICV size in bits, not used.                      */
    0,                                              

    /* Block size in bytes.  RSA does not have a block size. */
    0,        

    /* Metadata size in bytes, for RSA use the control block. */
    sizeof(NX_CRYPTO_RSA),              

    /* RSA initialization routine.                  */
    _nx_secure_crypto_method_rsa_init,               

    /* Cleanup routine, not used.                    */
    NX_NULL,                                        

    /* RSA operation                                */
    _nx_secure_crypto_method_rsa_operation           

};
```
<span data-ttu-id="16c78-934">***NULL***</span><span class="sxs-lookup"><span data-stu-id="16c78-934">***NULL***</span></span>

```C
/* NULL encryption method. */
NX_CRYPTO_METHOD crypto_method_null = 
{
    NX_CRYPTO_ENCRYPTION_NULL,/* Name of the crypto algorithm  */
    0,                        /* Key size in bits, not used    */
    0,                        /* IV size in bits, not used     */
    0,                        /* ICV size in bits, not used    */
    4,                        /* Block size in bytes           */
    0,                        /* Metadata size in bytes        */
    NX_NULL,                  /* Initialization routine,unused */
    NX_NULL,                  /* Cleanup routine, not used     */
    _nx_secure_crypto_method_null_operation  /* NULL operation  
*/
}; 
```
<span data-ttu-id="16c78-935">***HMAC-SHA1***</span><span class="sxs-lookup"><span data-stu-id="16c78-935">***HMAC-SHA1***</span></span>
```C
NX_CRYPTO_METHOD crypto_method_hmac_sha1 = 
{
    /* HMAC SHA1 algorithm                               */
    TLS_HASH_SHA1,            


    /* Key size in bits. For HMAC-SHA1 this value is 160 */ 
    NX_CRYPTO_HMAC_SHA1_KEY_LEN_IN_BITS,              

    /* IV size in bits, not used                         */
    0,                                            

    /* Transmitted ICV size in bits. Unused.             */
    0, 

    /* Block size in bytes, not used                     */
    0,                                            

    /* Metadata size in bytes                            */
    sizeof(NX_SHA1_HMAC),                                            

    /* Initialization routine, not used                  */
    NX_NULL,                                      

    /* Cleanup routine, not used                         */
    NX_NULL,                                          

    /* HMAC SHA1 operation                               */
    _nx_secure_crypto_method_hmac_sha1_operation   
};
```
<span data-ttu-id="16c78-936">***NONE***</span><span class="sxs-lookup"><span data-stu-id="16c78-936">***NONE***</span></span>

<span data-ttu-id="16c78-937">Специальный метод **NX_CRYPTO_NONE** используется, чтобы сообщить модулю IPSec о том, что служба шифрования или проверки подлинности не требуется.</span><span class="sxs-lookup"><span data-stu-id="16c78-937">A special method **NX_CRYPTO_NONE** is used to signal the IPsec module that the encryption or the authentication service is not required.</span></span> <span data-ttu-id="16c78-938">Он настраивается, как показано ниже.</span><span class="sxs-lookup"><span data-stu-id="16c78-938">It is configured as follows:</span></span>

```C
/* NX_CRYPTO_NONE means encryption or authentication
   method is not needed.  */
NX_CRYPTO_METHOD crypto_method_none = 
{
    NX_CRYPTO_NONE,       /* Name of the crypto algorithm */
    0,                    /* Key size in bits, not used   */
    0,                    /* IV size in bits, not used    */
    0,                    /* ICV size in bits, not used   */
    0,                    /* Block size in bytes          */
    0,                    /* Metadata size in bytes       */
    NX_NULL,              /* Initialization routine, not used */
    NX_NULL,              /* Cleanup routine, not used    */
    NX_NULL               /* NULL operation               */
};                                               
```
### <a name="initializing-tls-with-cryptographic-methods"></a><span data-ttu-id="16c78-939">Инициализация протокола TLS с помощью криптографических методов</span><span class="sxs-lookup"><span data-stu-id="16c78-939">Initializing TLS with Cryptographic Methods</span></span>

<span data-ttu-id="16c78-940">После создания криптографических процедур, соответствующих сигнатурам криптографических методов, описанных в предыдущем разделе, необходимо передать их в протокол TLS при инициализации блока управления NX_SECURE_TLS_SESSION.</span><span class="sxs-lookup"><span data-stu-id="16c78-940">Once you have created your cryptographic routines conforming to the cryptographic method signatures described in the previous section, you will need to pass them into TLS when you initialize an NX_SECURE_TLS_SESSION control block.</span></span> <span data-ttu-id="16c78-941">Это выполняет служба TLS nx_secure_tls_session_create.</span><span class="sxs-lookup"><span data-stu-id="16c78-941">This is done in the TLS service nx_secure_tls_session_create:</span></span>

```C
UINT  nx_secure_tls_session_create(
              NX_SECURE_TLS_SESSION*     session_ptr,
              const NX_SECURE_TLS_CRYPTO*    tls_cipher_table,
              VOID*                encryption_metadata_area,
              ULONG                 encryption_metadata_size
);
```
- <span data-ttu-id="16c78-942">session_pointer: указатель на блок управления NX_SECURE_TLS_SESSION.</span><span class="sxs-lookup"><span data-stu-id="16c78-942">session_pointer is a pointer to your NX_SECURE_TLS_SESSION control block.</span></span>
- <span data-ttu-id="16c78-943">tls_cipher_table: указатель на блок управления NX_SECURE_TLS_CRYPTO, описанный ниже.</span><span class="sxs-lookup"><span data-stu-id="16c78-943">tls_cipher_table is a pointer to an NX_SECURE_TLS_CRYPTO control block, described below.</span></span>
- <span data-ttu-id="16c78-944">encryption_metadata_area указывает на пространство, используемое криптографическими процедурами в TLS.</span><span class="sxs-lookup"><span data-stu-id="16c78-944">encryption_metadata_area points to space used by cryptographic routines in TLS.</span></span>
- <span data-ttu-id="16c78-945">encryption_metadata_size задает размер области метаданных в байтах.</span><span class="sxs-lookup"><span data-stu-id="16c78-945">encryption_metadata_size is the size of the metadata area in bytes.</span></span>

### <a name="elliptic-curve-cryptography-ecc-in-netx-secure-tls"></a><span data-ttu-id="16c78-946">Шифрование на основе эллиптических кривых (ECC) в NetX Secure TLS</span><span class="sxs-lookup"><span data-stu-id="16c78-946">Elliptic Curve Cryptography (ECC) in NetX Secure TLS</span></span>

<span data-ttu-id="16c78-947">Шифрование на основе эллиптических кривых (ECC) предоставляет схему шифрования с открытым ключом, которую можно использовать вместо RSA.</span><span class="sxs-lookup"><span data-stu-id="16c78-947">Elliptic Curve Cryptography (ECC) provides a public-key cryptography scheme that can be used instead of RSA.</span></span> <span data-ttu-id="16c78-948">Алгоритм ECC обычно быстрее и использует меньшие ключи, чем RSA, поэтому он может быть удачным вариантом для встроенной реализации TLS.</span><span class="sxs-lookup"><span data-stu-id="16c78-948">ECC is typically faster and uses smaller keys than RSA so it can be a valuable option for embedded TLS.</span></span> <span data-ttu-id="16c78-949">В версиях X-Ware, предшествовавших ОСРВ Azure 6.0, ECC предоставлялся как надстройка, требующая установки исходного кода ECC в проект.</span><span class="sxs-lookup"><span data-stu-id="16c78-949">In X-Ware versions prior to Azure RTOS 6.0, ECC was shipped as an add-on, requiring installation of the ECC source code into your project.</span></span> <span data-ttu-id="16c78-950">В ОСРВ Azure 6.0 компонент ECC интегрирован в основную базу кода, поэтому установка файлов ECC больше не требуется.</span><span class="sxs-lookup"><span data-stu-id="16c78-950">Azure RTOS 6.0 integrated ECC into the mainline codebase so installation of the ECC files is no longer necessary.</span></span> <span data-ttu-id="16c78-951">Однако для ECC требуется инициализация, как и в предыдущих версиях.</span><span class="sxs-lookup"><span data-stu-id="16c78-951">However, ECC still requires the same initialization as those previous versions.</span></span>

### <a name="supported-ecc-curves"></a><span data-ttu-id="16c78-952">Поддерживаемые кривые ECC</span><span class="sxs-lookup"><span data-stu-id="16c78-952">Supported ECC curves</span></span>

<span data-ttu-id="16c78-953">NetX Secure реализует части кривых в соответствии с <http://www.secg.org/sec2-v2.pdf>.</span><span class="sxs-lookup"><span data-stu-id="16c78-953">NetX Secure implements parts of the curves as per <http://www.secg.org/sec2-v2.pdf>.</span></span> <span data-ttu-id="16c78-954">Поддерживаются следующие кривые<sup>18</sup>:</span><span class="sxs-lookup"><span data-stu-id="16c78-954">Thefollowing curves are supported<sup>18</sup>:</span></span>

  - <span data-ttu-id="16c78-955">secp256r1</span><span class="sxs-lookup"><span data-stu-id="16c78-955">secp256r1</span></span> 
  - <span data-ttu-id="16c78-956">secp384r1</span><span class="sxs-lookup"><span data-stu-id="16c78-956">secp384r1</span></span> 
  - <span data-ttu-id="16c78-957">secp521r1</span><span class="sxs-lookup"><span data-stu-id="16c78-957">secp521r1</span></span> 

<span data-ttu-id="16c78-958">Если используются другие кривые ECC, то процедура *nx_secure_tls_session_start()* вернет ошибку NX_SECURE_TLS_NO_SUPPORTED_CIPHERS, указывающую, что используются неподдерживаемые кривые.</span><span class="sxs-lookup"><span data-stu-id="16c78-958">If other ECC curves are used, the *nx_secure_tls_session_start()* routine will return the error NX_SECURE_TLS_NO_SUPPORTED_CIPHERS indicating that unsupported curves were used.</span></span>

<span data-ttu-id="16c78-959">Обратите внимание на то, что цепочка сертификатов TLS может также быть зашифрована с помощью алгоритмов ECC.</span><span class="sxs-lookup"><span data-stu-id="16c78-959">Note that TLS certificate chain may be encrypted by ECC-algorithms as well.</span></span> <span data-ttu-id="16c78-960">Хотя кривые, предоставляемые клиентом TLS, поддерживаются, возможна ситуация, когда кривая ECC, используемая в цепочке сертификатов, не поддерживается.</span><span class="sxs-lookup"><span data-stu-id="16c78-960">Even though the curves provided by the TLS Client are supported, it is possible that the ECC curve used in the certificate chain is not supported.</span></span> <span data-ttu-id="16c78-961">В этом случае процедура *nx_secure_tls_session_start* вернет ошибку NX_SECURE_TLS_UNSUPPORTED_PUBLIC_CIPHER.</span><span class="sxs-lookup"><span data-stu-id="16c78-961">In this case, *nx_secure_tls_session_start* routine returns NX_SECURE_TLS_UNSUPPORTED_PUBLIC_CIPHER.</span></span>

<span data-ttu-id="16c78-962">Пример таблицы комплектов шифров по умолчанию для ECC приведен в файле nx_crypto_generic_ciphersuites.c.</span><span class="sxs-lookup"><span data-stu-id="16c78-962">A default ciphersuite table example for ECC is provided in nx_crypto_generic_ciphersuites.c.</span></span> <span data-ttu-id="16c78-963">Дополнительные сведения о таблицах комплектов шифров см. в разделе "Таблица криптографических шифров TLS".</span><span class="sxs-lookup"><span data-stu-id="16c78-963">See section "TLS Cryptographic Cipher Table" for more information on ciphersuite tables.</span></span>

18. <span data-ttu-id="16c78-964">Обратите внимание на то, что для устаревших приложений также предоставляются реализации кривых secp192r1 и secp224r1.</span><span class="sxs-lookup"><span data-stu-id="16c78-964">Note that implementations for the curves secp192r1 and secp224r1are also provided for legacy applications.</span></span> <span data-ttu-id="16c78-965">Однако эти кривые уже считаются ненадежными и не должны использоваться для разработки новых приложений.</span><span class="sxs-lookup"><span data-stu-id="16c78-965">However these curves are now considered weak and SHOULD NOT be used for new application development.</span></span>

### <a name="crypto-methods-for-ecc"></a><span data-ttu-id="16c78-966">Криптографические методы для ECC</span><span class="sxs-lookup"><span data-stu-id="16c78-966">Crypto Methods for ECC</span></span>

<span data-ttu-id="16c78-967">Криптографические методы для групп алгоримтов на основе эллиптических кривых:</span><span class="sxs-lookup"><span data-stu-id="16c78-967">Crypto methods for Elliptic Curve groups:</span></span>

- <span data-ttu-id="16c78-968">NX_CRYPTO_METHOD crypto_method_ec_secp192<sup>15</sup>;</span><span class="sxs-lookup"><span data-stu-id="16c78-968">NX_CRYPTO_METHOD crypto_method_ec_secp192<sup>15</sup>;</span></span>  
- <span data-ttu-id="16c78-969">NX_CRYPTO_METHOD crypto_method_ec_secp224<sup>15</sup>;</span><span class="sxs-lookup"><span data-stu-id="16c78-969">NX_CRYPTO_METHOD crypto_method_ec_secp224<sup>15</sup>;</span></span>  
- <span data-ttu-id="16c78-970">NX_CRYPTO_METHOD crypto_method_ec_secp256;</span><span class="sxs-lookup"><span data-stu-id="16c78-970">NX_CRYPTO_METHOD crypto_method_ec_secp256;</span></span>  
- <span data-ttu-id="16c78-971">NX_CRYPTO_METHOD crypto_method_ec_secp384;</span><span class="sxs-lookup"><span data-stu-id="16c78-971">NX_CRYPTO_METHOD crypto_method_ec_secp384;</span></span>  
- <span data-ttu-id="16c78-972">NX_CRYPTO_METHOD crypto_method_ec_secp521;</span><span class="sxs-lookup"><span data-stu-id="16c78-972">NX_CRYPTO_METHOD crypto_method_ec_secp521;</span></span>

<span data-ttu-id="16c78-973">Криптографические методы для кривых ECC определяются в файле nx_crypto_generic_ciphersuites.c.</span><span class="sxs-lookup"><span data-stu-id="16c78-973">The crypto methods for ECC curves are defined in nx_crypto_generic_ciphersuites.c.</span></span>

<span data-ttu-id="16c78-974">Криптографический метод для ECDHE:</span><span class="sxs-lookup"><span data-stu-id="16c78-974">Crypto method for ECDHE:</span></span>

- <span data-ttu-id="16c78-975">NX_CRYPTO_METHOD crypto_method_ecdhe.</span><span class="sxs-lookup"><span data-stu-id="16c78-975">NX_CRYPTO_METHOD crypto_method_ecdhe;</span></span>

<span data-ttu-id="16c78-976">Криптографический метод для ECDSA:</span><span class="sxs-lookup"><span data-stu-id="16c78-976">Crypto method for ECDSA:</span></span>

- <span data-ttu-id="16c78-977">NX_CRYPTO_METHOD crypto_method_ecdsa.</span><span class="sxs-lookup"><span data-stu-id="16c78-977">NX_CRYPTO_METHOD crypto_method_ecdsa;</span></span>

<span data-ttu-id="16c78-978">Криптографические методы ECDSA и ECDHE определяются в файле nx_crypto_generic_ciphersuites.c.</span><span class="sxs-lookup"><span data-stu-id="16c78-978">ECDSA and ECDHE crypto methods are defined in nx_crypto_generic_ciphersuites.c.</span></span>

<span data-ttu-id="16c78-979">Вместе с другими криптографическими методами, такими как RSA, SHA, AES, их можно использовать как стандартные блоки для таблицы подстановки комплектов шифров.</span><span class="sxs-lookup"><span data-stu-id="16c78-979">Combined with other crypto methods such as RSA, SHA, AES, they can be used as building blocks for the ciphersuite lookup table.</span></span>

### <a name="enabling-ecc-support-for-tls"></a><span data-ttu-id="16c78-980">Включение поддержки ECC для протокола TLS</span><span class="sxs-lookup"><span data-stu-id="16c78-980">Enabling ECC Support for TLS</span></span>

<span data-ttu-id="16c78-981">ECC по умолчанию включен для протокола TLS.</span><span class="sxs-lookup"><span data-stu-id="16c78-981">ECC is enabled by default for TLS.</span></span> <span data-ttu-id="16c78-982">Чтобы отключить поддержку ECC, необходимо определить символ NX_SECURE_DISABLE_ECC_CIPHERSUITE.</span><span class="sxs-lookup"><span data-stu-id="16c78-982">To disable ECC support, the symbol NX_SECURE_DISABLE_ECC_CIPHERSUITE must be defined.</span></span>

<span data-ttu-id="16c78-983">Чтобы изменения вступили в силу, необходимо перестроить библиотеку NetX Secure и все приложения, использующие эту библиотеку.</span><span class="sxs-lookup"><span data-stu-id="16c78-983">For the change to take effect, you will need to rebuild the NetX Secure Library and all applications that use that library.</span></span>

<span data-ttu-id="16c78-984">В коде приложения после создания сеанса TLS должен вызываться API *nx_secure_tls_ecc_initialize()* .</span><span class="sxs-lookup"><span data-stu-id="16c78-984">In the application code, the API n *x_secure_tls_ecc_initialize()* must be called after the TLS session is created.</span></span> <span data-ttu-id="16c78-985">Этот API уведомляет сеанс TLS о типе кривых, используемых для операций обмена ключами TLS и проверки сертификатов.</span><span class="sxs-lookup"><span data-stu-id="16c78-985">This API notifies the TLS session of the type of curves to be used for TLS key exchange operations and certificate verification.</span></span> <span data-ttu-id="16c78-986">Если выбран алгоритм ECC, то на этапе подтверждения TLS клиент и сервер обмениваются параметрами, связанными с кривой ECC, чтобы определить, какую кривую использовать.</span><span class="sxs-lookup"><span data-stu-id="16c78-986">During the TLS handshake phase, if an ECC algorithm is selected the client and server exchange ECC curve-related parameters to decide which curve to use.</span></span>

<span data-ttu-id="16c78-987">В следующем фрагменте кода показано, как использовать данный API.</span><span class="sxs-lookup"><span data-stu-id="16c78-987">The following code segment illustrates how to use the API.</span></span> <span data-ttu-id="16c78-988">Обратите внимание на то, что аргументы (*nx_crypto_ecc_supported_groups, nx_crypto_ecc_supported_groups_size и nx_crypto_ecc_curves)* определены в файле *nx_crypto_generic_ciphersuites.c*.</span><span class="sxs-lookup"><span data-stu-id="16c78-988">Note that the arguments (*nx_crypto_ecc_supported_groups, nx_crypto_ecc_supported_groups_size, and nx_crypto_ecc_curves)* are all defined in *nx_crypto_generic_ciphersuites.c*.</span></span> <span data-ttu-id="16c78-989">Поэтому эти символы можно использовать напрямую.</span><span class="sxs-lookup"><span data-stu-id="16c78-989">Therefore these symbols can be used directly.</span></span>

```C
status = nx_secure_tls_ecc_initialize(&tls_session,     
                    nx_crypto_ecc_supported_groups,      
                    nx_crypto_ecc_supported_groups_size,     
                    nx_crypto_ecc_curves);
```
<span data-ttu-id="16c78-990">Пример конфигурации в nx_crypto_generic_ciphersuites.c содержит таблицу подстановки комплектов шифров ECC, которая используется, если включен алгоритм ECC.</span><span class="sxs-lookup"><span data-stu-id="16c78-990">The example configuration in nx_crypto_generic_ciphersuites.c contains an ECC ciphersuite lookup table that is used when ECC is enabled.</span></span> <span data-ttu-id="16c78-991">Чтобы использовать ECC, просто передавайте nx_crypto_tls_ciphers_ecc как параметр таблицы комплектов шифров при создании сеансов TLS с помощью nx_secure_tls_session_create.</span><span class="sxs-lookup"><span data-stu-id="16c78-991">To use ECC, simply pass nx_crypto_tls_ciphers_ecc as the ciphersuite table parameter when creating TLS sessions with nx_secure_tls_session_create.</span></span> <span data-ttu-id="16c78-992">В примере таблицы содержатся комплекты шифров ECC и другие комплекты шифров.</span><span class="sxs-lookup"><span data-stu-id="16c78-992">The example table contains both ECC and non-ECC ciphersuites.</span></span>

### <a name="tls-cryptographic-cipher-table"></a><span data-ttu-id="16c78-993">Таблица криптографических шифров TLS</span><span class="sxs-lookup"><span data-stu-id="16c78-993">TLS Cryptographic Cipher Table</span></span>

<span data-ttu-id="16c78-994">Структура NX_SECURE_TLS_CRYPTO определяется следующим образом.</span><span class="sxs-lookup"><span data-stu-id="16c78-994">The NX_SECURE_TLS_CRYPTO structure is defined as:</span></span>

```C
typedef struct NX_SECURE_METHODS_STRUCT
{
    /* Table that maps ciphersuites to crypto methods. */
    NX_SECURE_TLS_CIPHERSUITE_INFO* nx_secure_tls_ciphersuite_lookup_table;
    USHORT nx_secure_tls_ciphersuite_lookup_table_size;

    /* Table that maps X.509 cipher identifiers to crypto methods. */
    NX_SECURE_X509_CRYPTO *nx_secure_tls_x509_cipher_table;
    USHORT nx_secure_tls_x509_cipher_table_size;

    /* Specific routines needed for specific TLS versions. */
#if (NX_SECURE_TLS_TLS_1_0_ENABLED || NX_SECURE_TLS_TLS_1_1_ENABLED)
    NX_CRYPTO_METHOD *nx_secure_tls_handshake_hash_md5_method;
    NX_CRYPTO_METHOD *nx_secure_tls_handshake_hash_sha1_method;
    NX_CRYPTO_METHOD *nx_secure_tls_prf_1_method;
#endif

#if (NX_SECURE_TLS_TLS_1_2_ENABLED)
    NX_CRYPTO_METHOD *nx_secure_tls_handshake_hash_sha256_method;
    NX_CRYPTO_METHOD *nx_secure_tls_prf_sha256_method;
#endif

#if (NX_SECURE_TLS_TLS_1_3_ENABLED)
    const NX_CRYPTO_METHOD *nx_secure_tls_hkdf_method;
    const NX_CRYPTO_METHOD *nx_secure_tls_hmac_method;
    const NX_CRYPTO_METHOD *nx_secure_tls_ecdhe_method;
#endif

} NX_SECURE_TLS_CRYPTO;
```
<span data-ttu-id="16c78-995">Таблица создается путем заполнения записей для этой структуры в статической константе, расположенной в проекте NetX Secure TLS, который обычно размещается с помощью криптографических процедур и модулей.</span><span class="sxs-lookup"><span data-stu-id="16c78-995">The table is created by filling in the entries for this structure in a static constant located within the NetX Secure TLS project, usually located with the cryptographic routines and modules.</span></span>

<span data-ttu-id="16c78-996">Например, полностью программная ("универсальная") библиотека шифрования, предоставляемая с NetX Secure, содержит следующее определение таблицы (для поддержки комплектов шифров, не относящихся к ECC<sup>19</sup>).</span><span class="sxs-lookup"><span data-stu-id="16c78-996">As an example, the software-only ("generic") cryptographic library provided with NetX Secure contains the following table definition (for non-ECC ciphersuite support<sup>19</sup>):</span></span>

```C
/* Define the cipher table object we can pass into TLS. */
const NX_SECURE_TLS_CRYPTO nx_crypto_tls_ciphers =
{
    /* TLS Ciphersuite lookup table and size. */
    _nx_crypto_ciphersuite_lookup_table,
    sizeof(_nx_crypto_ciphersuite_lookup_table) / 
    sizeof(NX_SECURE_TLS_CIPHERSUITE_INFO),

    /* X.509 certificate cipher table and size. */
    _nx_crypto_x509_cipher_lookup_table,
    sizeof(_nx_crypto_x509_cipher_lookup_table) / sizeof(NX_SECURE_X509_CRYPTO),

    /* TLS version-specific methods. */
#if (NX_SECURE_TLS_TLS_1_0_ENABLED || NX_SECURE_TLS_TLS_1_1_ENABLED)
    &crypto_method_md5,
    &crypto_method_sha1,
    &crypto_method_tls_prf_1,
#endif

#if (NX_SECURE_TLS_TLS_1_2_ENABLED)
    &crypto_method_sha256,
    &crypto_method_tls_prf_sha_256
#endif

#if (NX_SECURE_TLS_TLS_1_3_ENABLED)
    &crypto_method_hkdf,
    &crypto_method_hmac,
    &crypto_method_ecdhe,
#endif
};
```
<span data-ttu-id="16c78-997">В структуре первая запись является таблицей комплекта шифров TLS.</span><span class="sxs-lookup"><span data-stu-id="16c78-997">In the structure, the first entry is the TLS ciphersuite table.</span></span> <span data-ttu-id="16c78-998">Структура NX_SECURE_TLS_CIPHERSUITE_INFO сопоставляет криптографические процедуры (в виде указателей NX_CRYPTO_METHOD) с конкретными комплектами шифров, как определено в спецификациях TLS.</span><span class="sxs-lookup"><span data-stu-id="16c78-998">The NX_SECURE_TLS_CIPHERSUITE_INFO structure maps cryptographic routines (in the form of NX_CRYPTO_METHOD pointers) to specific ciphersuites as defined in the TLS specifications.</span></span> <span data-ttu-id="16c78-999">Второе значение — это число записей в таблице, на которое указывает первое поле.</span><span class="sxs-lookup"><span data-stu-id="16c78-999">The second value is the number of entries in the table pointed to by the first field.</span></span>

<span data-ttu-id="16c78-1000">Следующее поле указывает на таблицу процедур, используемых протоколом X.509 при обработке цифровых сертификатов, а структура NX_SECURE_X509_CRYPTO по форме аналогична NX_SECURE_TLS_CIPHERSUITE_INFO.</span><span class="sxs-lookup"><span data-stu-id="16c78-1000">The next field points to a table of routines used by X.509 when processing digital certificates and the structure NX_SECURE_X509_CRYPTO is similar in form to NX_SECURE_TLS_CIPHERSUITE_INFO.</span></span> <span data-ttu-id="16c78-1001">Следующее поле — число записей в таблице.</span><span class="sxs-lookup"><span data-stu-id="16c78-1001">The following field is the number of entries in the table.</span></span>

<span data-ttu-id="16c78-1002">За таблицей подстановки указывается ряд процедур, необходимых для конкретных версий протокола TLS.</span><span class="sxs-lookup"><span data-stu-id="16c78-1002">Following the lookup table are a number of routines needed for specific versions of TLS.</span></span> <span data-ttu-id="16c78-1003">Например, до выпуска протокола TLS версии 1.2 процедуры создания ключей и хэширования для подтверждения были запрограммированы для использования сочетания SHA-1 и MD5. Методы для этих процедур вызывались специально в структуре шифра, так как они не привязаны к определенным комплектам шифров.</span><span class="sxs-lookup"><span data-stu-id="16c78-1003">For example, prior to TLS version 1.2, the key generation and handshake hashing routines were fixed to use a combination of SHA-1 and MD5 – the methods for these routines are called out specifically in the cipher structure since they are not tied to specific ciphersuites.</span></span> <span data-ttu-id="16c78-1004">В протоколе TLS версии 1.2 процедуры создания ключей и хэширования выбираются комплектом шифров, но для комплектов шифров, которые не указывают применяемые процедуры, используется метод хэширования SHA-256, а структура шифра вызывает именно соответствующую процедуру.</span><span class="sxs-lookup"><span data-stu-id="16c78-1004">In TLS version 1.2, the key generation and hashing routines are chosen by the ciphersuite, but for ciphersuites which do not specify the routines to use, the SHA-256 hash method is used, and the cipher structure calls out that routine specifically.</span></span>

<span data-ttu-id="16c78-1005">В протоколе TLS 1.3 требуются дополнительные определенные шифры для различных операций.</span><span class="sxs-lookup"><span data-stu-id="16c78-1005">TLS 1.3 requires a few extra specific ciphers for various operations.</span></span>

19. <span data-ttu-id="16c78-1006">Обратите внимание на то, что для поддержки TLS 1.3 требуется алгоритм ECC. Используйте nx_crypto_tls_ciphers_ecc, если включен протокол TLS 1.3.</span><span class="sxs-lookup"><span data-stu-id="16c78-1006">Note that TLS 1.3 support requires ECC – use nx_crypto_tls_ciphers_ecc if TLS 1.3 is enabled.</span></span>

### <a name="tls-ciphersuite-lookup-table"></a><span data-ttu-id="16c78-1007">Таблица подстановки комплектов шифров TLS</span><span class="sxs-lookup"><span data-stu-id="16c78-1007">TLS Ciphersuite Lookup Table</span></span>

<span data-ttu-id="16c78-1008">Чтобы заполнить таблицу шифров для протокола TLS, потребуется также создать таблицу подстановки комплектов шифров, которая сопоставляет криптографические процедуры с конкретными идентификаторами комплектов шифров.</span><span class="sxs-lookup"><span data-stu-id="16c78-1008">To fill in the cipher table for TLS, you will also need to create a ciphersuite lookup table that maps cryptographic routines to specific ciphersuite identifiers.</span></span> <span data-ttu-id="16c78-1009">Эти идентификаторы представляют собой универсальные значения, зарегистрированные в IANA.</span><span class="sxs-lookup"><span data-stu-id="16c78-1009">The identifiers are IANA-registered values that are universal.</span></span> <span data-ttu-id="16c78-1010">Дополнительные сведения см. в документах RFC по протоколу TLS.</span><span class="sxs-lookup"><span data-stu-id="16c78-1010">See the TLS RFCs for more information.</span></span> <span data-ttu-id="16c78-1011">Процедуры представляют 5 отдельных методов, используемых в каждом комплекте шифров (некоторые комплекты шифров могут не использовать все 5 методов): общедоступное шифрование, проверка подлинности с открытым ключом, шифрование сеансов, процедура хэширования сеансов и псевдослучайная функция TLS (PRF).</span><span class="sxs-lookup"><span data-stu-id="16c78-1011">The routines represent the 5 separate methods used in each ciphersuite (some ciphersuites may not use all 5): public cipher, public-key authentication, session cipher, session hash routine, and TLS Pseudo-Random Function (PRF).</span></span> <span data-ttu-id="16c78-1012">В следующей таблице описаны все 5 методов.</span><span class="sxs-lookup"><span data-stu-id="16c78-1012">The following table explains each of the 5 methods:</span></span>

| <span data-ttu-id="16c78-1013">**Категория процедуры**</span><span class="sxs-lookup"><span data-stu-id="16c78-1013">**Routine category**</span></span>      | <span data-ttu-id="16c78-1014">**Описание**</span><span class="sxs-lookup"><span data-stu-id="16c78-1014">**Description**</span></span>                                                                                       | <span data-ttu-id="16c78-1015">**Примеры алгоритмов**</span><span class="sxs-lookup"><span data-stu-id="16c78-1015">**Example algorithms**</span></span>                                            |
| ------------------------- | ----------------------------------------------------------------------------------------------------- | ----------------------------------------------------------------- |
| <span data-ttu-id="16c78-1016">Общедоступное шифрование</span><span class="sxs-lookup"><span data-stu-id="16c78-1016">Public cipher</span></span>             | <span data-ttu-id="16c78-1017">Используется для обмена ключами во время подтверждения TLS.</span><span class="sxs-lookup"><span data-stu-id="16c78-1017">Used to exchange keys during the TLS handshake</span></span>                                                        | <span data-ttu-id="16c78-1018">RSA, Диффи-Хелмана, ECC</span><span class="sxs-lookup"><span data-stu-id="16c78-1018">RSA, Diffie-Hellman, ECC</span></span>                                          |
| <span data-ttu-id="16c78-1019">Проверка подлинности с открытым ключом</span><span class="sxs-lookup"><span data-stu-id="16c78-1019">Public-key authentication</span></span> | <span data-ttu-id="16c78-1020">Используется для проверки подлинности или подписывания данных во время подтверждения TLS.</span><span class="sxs-lookup"><span data-stu-id="16c78-1020">Used to authenticate or sign data during the TLS handshake</span></span>                                            | <span data-ttu-id="16c78-1021">RSA, DSS</span><span class="sxs-lookup"><span data-stu-id="16c78-1021">RSA, DSS</span></span>                                                          |
| <span data-ttu-id="16c78-1022">Шифрование сеансов</span><span class="sxs-lookup"><span data-stu-id="16c78-1022">Session cipher</span></span>            | <span data-ttu-id="16c78-1023">Алгоритм с симметричным ключом, используемый для шифрования данных приложения во время сеанса TLS.</span><span class="sxs-lookup"><span data-stu-id="16c78-1023">Symmetric-key algorithm used to encrypt application data during the TLS session</span></span>                       | <span data-ttu-id="16c78-1024">AES, RC4</span><span class="sxs-lookup"><span data-stu-id="16c78-1024">AES, RC4</span></span>                                                          |
| <span data-ttu-id="16c78-1025">Хэширование сеансов</span><span class="sxs-lookup"><span data-stu-id="16c78-1025">Session hash</span></span>              | <span data-ttu-id="16c78-1026">Используется для обеспечения целостности сообщений во время сеанса TLS (гарантирует, что данные не изменяются).</span><span class="sxs-lookup"><span data-stu-id="16c78-1026">Used to preserve the integrity of messages during the TLS session (assures that data has not changed)</span></span> | <span data-ttu-id="16c78-1027">SHA-1, SHA-256</span><span class="sxs-lookup"><span data-stu-id="16c78-1027">SHA-1, SHA-256</span></span>                                                    |
| <span data-ttu-id="16c78-1028">Псевдослучайная функция (PRF) TLS</span><span class="sxs-lookup"><span data-stu-id="16c78-1028">TLS PRF</span></span>                   | <span data-ttu-id="16c78-1029">Используется для создания материала ключа, а также в хэше подтверждения при подтверждении TLS.</span><span class="sxs-lookup"><span data-stu-id="16c78-1029">Used to generate key material and in the handshake hash in the TLS handshake</span></span>                          | <span data-ttu-id="16c78-1030">Метод PRF основан на процедурах хэширования: SHA-1 и MD5, SHA-256, SHA-512.</span><span class="sxs-lookup"><span data-stu-id="16c78-1030">The PRF is based on hash routines – SHA-1 + MD5, SHA-256, SHA-512</span></span> |

<span data-ttu-id="16c78-1031">Определение структуры NX_SECURE_TLS_CIPHERSUITE_INFO показано ниже.</span><span class="sxs-lookup"><span data-stu-id="16c78-1031">The NX_SECURE_TLS_CIPHERSUITE_INFO structure is defined as follows:</span></span>

```C
typedef struct NX_SECURE_TLS_CIPHERSUITE_INFO_struct
{
    /* The IANA value of the ciphersuite as defined by the TLS spec.*/
    USHORT nx_secure_tls_ciphersuite;

    /* The Public Key operation in this suite - RSA or DH. */
    NX_CRYPTO_METHOD *nx_secure_tls_public_cipher;

    /* The Public Authentication method used for signing data. */
    NX_CRYPTO_METHOD *nx_secure_tls_public_auth;

    /* The session cipher being used - AES, RC4, etc. */
    NX_CRYPTO_METHOD *nx_secure_tls_session_cipher;

    /* The size of the initialization vectors for the session cipher (bytes).*/
    USHORT nx_secure_tls_iv_size;

    /* The key size for the session cipher (bytes). */
    UCHAR nx_secure_tls_session_key_size;

    /* The hash being used - MD5, SHA-1, SHA-256, etc. */
    NX_CRYPTO_METHOD *nx_secure_tls_hash;

    /* The size of the hash being used. SHA-1 is 20 bytes, MD5 is 16 bytes.*/
    USHORT nx_secure_tls_hash_size;

    /* The TLS PRF being used – this is only for TLSv1.2. */
    NX_CRYPTO_METHOD *nx_secure_tls_prf;

} NX_SECURE_TLS_CIPHERSUITE_INFO;
```
<span data-ttu-id="16c78-1032">Поле nx_secure_tls_ciphersuite содержит значение IANA комплекта шифров, а указатели NX_CRYPTO_METHOD представляют 5 методов, используемых этим комплектом шифров.</span><span class="sxs-lookup"><span data-stu-id="16c78-1032">The nx_secure_tls_ciphersuite field contains the IANA ciphersuite value, and the NX_CRYPTO_METHOD pointers represent the 5 methods used by that ciphersuite.</span></span> <span data-ttu-id="16c78-1033">Скалярные значения (nx_secure_tls_iv_size, nx_secure_tls_key_size и nx_secure_tls_hash_size) предоставляют сведения, которые могут быть недоступны в записях NX_CRYPTO_METHOD.</span><span class="sxs-lookup"><span data-stu-id="16c78-1033">The scalar values (nx_secure_tls_iv_size, nx_secure_tls_key_size, and nx_secure_tls_hash_size) are informational, providing information that might not be available in the NX_CRYPTO_METHOD entries.</span></span>

<span data-ttu-id="16c78-1034">В качестве примера мы рассмотрим комплект шифров по умолчанию для протокола TLS, TLS_RSA_WITH_AES_128_CBC_SHA, который предписывает использование RSA, AES-CBC с 128-разрядными ключами и SHA-1 для хэширования сеансов.</span><span class="sxs-lookup"><span data-stu-id="16c78-1034">As an example, we will look at the default ciphersuite for TLS, TLS_RSA_WITH_AES_128_CBC_SHA, which specifies the use of RSA, AES-CBC with 128-bit keys, and SHA-1 for session hashing.</span></span> <span data-ttu-id="16c78-1035">Для этого комплекта шифров не задан метод PRF TLS, поэтому в режиме TLS 1.2 будет использоваться метод PRF по умолчанию, SHA-256.</span><span class="sxs-lookup"><span data-stu-id="16c78-1035">No TLS PRF is specified for this ciphersuite, so in TLSv1.2 mode, it will use the default SHA-256 PRF.</span></span> <span data-ttu-id="16c78-1036">Обратите внимание на то, что все комплекты шифров используют метод PRF на основе SHA-1 и MD5 в протоколах TLS версий 1.0 и 1.1, независимо от состояния PRF, указанного в таблице.</span><span class="sxs-lookup"><span data-stu-id="16c78-1036">Note that all ciphersuites use the SHA-1+MD5 PRF in TLS 1.0 and 1.1, regardless of the PRF specified in the table.</span></span>

<span data-ttu-id="16c78-1037">Запись в таблице NX_SECURE_TLS_CIPHERSUITE_INFO в универсальной криптографической библиотеке определяется следующим образом.</span><span class="sxs-lookup"><span data-stu-id="16c78-1037">The entry in the NX_SECURE_TLS_CIPHERSUITE_INFO table in the generic cryptographic library is defined as follows:</span></span>

```C
{ 
  TLS_RSA_WITH_AES_128_CBC_SHA,     /* Ciphersuite identifier */
  &crypto_method_rsa,               /* Public-key cipher (NX_CRYPTO_METHOD)*/
  &crypto_method_rsa,               /* Authentication method(NX_CRYPTO_METHOD)*/
  &crypto_method_aes_cbc_128,       /* Session cipher method(NX_CRYPTO_METHOD)*/
  16,                               /* Session cipher IV size in bytes */
  16,                               /* Session cipher key size in bytes */
  &crypto_method_hmac_sha1,         /* Session hash routine(NX_CRYPTO_METHOD) */
  20,                               /* Session hash output size in bytes */
  &crypto_method_tls_prf_sha_256    /* TLSv1.2 PRF */
},
```

<span data-ttu-id="16c78-1038">Обратите внимание на то, что для шифрования сеансов размер ключа определяется комплектом шифров, но для методов с открытым ключом размер ключа не известен до тех пор, пока не выполнено подтверждение TLS, так как открытые ключи содержатся в цифровых сертификатах, которыми обмениваются во время подтверждения.</span><span class="sxs-lookup"><span data-stu-id="16c78-1038">Note that for the session cipher the key size is determined by the ciphersuite, but for the public-key methods the key size is not known until the TLS handshake is underway since the public keys are contained in the digital certificates exchanged during the handshake.</span></span>

### <a name="x509-cipher-lookup-table"></a><span data-ttu-id="16c78-1039">Таблица подстановки шифров X.509</span><span class="sxs-lookup"><span data-stu-id="16c78-1039">X.509 Cipher Lookup Table</span></span>

<span data-ttu-id="16c78-1040">Как и в таблице NX_SECURE_TLS_CIPHERSUITE_INFO, структура NX_SECURE_X509_CRYPTO сопоставляет криптографические процедуры с известными значениями.</span><span class="sxs-lookup"><span data-stu-id="16c78-1040">Like the NX_SECURE_TLS_CIPHERSUITE_INFO table, the NX_SECURE_X509_CRYPTO structure maps cryptographic routines to known values.</span></span> <span data-ttu-id="16c78-1041">В случае протокола X.509 идентификаторами фактически являются значения OID, определяемые X.509 и зарегистрированные в текстах стандартов ISO и ITU.</span><span class="sxs-lookup"><span data-stu-id="16c78-1041">In the case of X.509, the identifiers are actually OIDs defined by X.509 and registered with the ISO and ITU standards bodies.</span></span> <span data-ttu-id="16c78-1042">Значения OID — это многобайтовые значения переменной длины, предназначенные для уникальной идентификации различных данных в разных телекоммуникационных стандартах, включая криптографические процедуры, используемые в цифровых сертификатах.</span><span class="sxs-lookup"><span data-stu-id="16c78-1042">OIDs are variable-length multi-byte values designed to uniquely identify various information in various telecommunication standards, including cryptographic routines used in digital certificates.</span></span> <span data-ttu-id="16c78-1043">Так как значения OID имеют переменную длину, NetX Secure TLS сопоставляет официальные значения OID с константами фиксированной длины, которые используются внутри протокола (ознакомьтесь с файлом nx_secure_x509.h).</span><span class="sxs-lookup"><span data-stu-id="16c78-1043">Due to the fact that OIDs are variable length, NetX Secure TLS maps the official OID values to fixed-length constants that are used internally (see nx_secure_x509.h).</span></span> <span data-ttu-id="16c78-1044">Эти константы используются в структуре NX_SECURE_X509_CRYPTO, которая определяется следующим образом.</span><span class="sxs-lookup"><span data-stu-id="16c78-1044">These constants are used in the NX_SECURE_X509_CRYPTO structure, which is defined as follows:</span></span>

```C
/* Structure to hold X.509 cryptographic routine information. */
typedef struct NX_SECURE_X509_CRYPTO_struct
{
    /* Internal NetX Secure identifier for certificate "ciphersuite" which consists
       of a hash and a public key operation. These can be mapped to OIDs in X.509.
        */
    USHORT nx_secure_x509_crypto_identifier;

    /* Public-Key Cryptographic method used by certificates. */
    NX_CRYPTO_METHOD *nx_secure_x509_public_cipher_method;

    /* Hash method used by certificates. */
    NX_CRYPTO_METHOD *nx_secure_x509_hash_method;
} NX_SECURE_X509_CRYPTO;
```

<span data-ttu-id="16c78-1045">Первое поле, *nx_secure_x509_crypto_identifier*, является внутренним представлением OID, используемым NetX Secure.</span><span class="sxs-lookup"><span data-stu-id="16c78-1045">The first field, *nx_secure_x509_crypto_identifier*, is the internal OID representation used by NetX Secure.</span></span>

<span data-ttu-id="16c78-1046">Второе и третье поля указывают на объекты NX_CRYPTO_METHOD, представляющие криптографические методы, идентифицируемые по значению OID, и операцию с открытым ключом, связанную с процедурой хэширования.</span><span class="sxs-lookup"><span data-stu-id="16c78-1046">The second and third fields point to NX_CRYPTO_METHOD objects that represent the cryptographic methods identified by the OID, a public-key operation paired with a hash routine.</span></span> <span data-ttu-id="16c78-1047">Обратите внимание на то, что каждый цифровой сертификат может иметь несколько значений OID для криптографических процедур.</span><span class="sxs-lookup"><span data-stu-id="16c78-1047">Note that each digital certificate may have more than one OID for cryptographic routines.</span></span>

<span data-ttu-id="16c78-1048">Таблица методов для протокола X.509 составлена таким же образом, как и таблица подстановки комплектов шифров.</span><span class="sxs-lookup"><span data-stu-id="16c78-1048">The method table for X.509 is constructed in the same manner as the ciphersuite lookup table.</span></span> <span data-ttu-id="16c78-1049">В качестве примера мы рассмотрим значение OID для RSA_SHA1.</span><span class="sxs-lookup"><span data-stu-id="16c78-1049">As an example, we will look at the OID for RSA_SHA1.</span></span> <span data-ttu-id="16c78-1050">Фактическое значение OID для RSA_SHA1 выглядит следующим образом.</span><span class="sxs-lookup"><span data-stu-id="16c78-1050">The actual OID for RSA_SHA1 is as follows:</span></span>

```C
{iso(1) member-body(2) us(840) rsadsi(113549) pkcs(1) pkcs-1(1) sha1-with-rsa-
signature(5)}
```
<span data-ttu-id="16c78-1051">Это значение OID представлено в синтаксисе ASN.1 и имеет числовое значение 1.2.840.113549.1.1.5.</span><span class="sxs-lookup"><span data-stu-id="16c78-1051">The OID is represented in ASN.1 syntax and has a numeric value of 1.2.840.113549.1.1.5.</span></span> <span data-ttu-id="16c78-1052">Затем это значение кодируется в двоичный формат и преобразовывается в приведенные ниже байты.</span><span class="sxs-lookup"><span data-stu-id="16c78-1052">This value is then encoded in binary format, creating the following bytes:</span></span>

```C
UCHAR RSA_SHA1_OID = { 0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, 0x01, 0x05 };
```
<span data-ttu-id="16c78-1053">Сам процесс преобразования из ASN.1 в двоичный формат выходит за рамки данного документа.</span><span class="sxs-lookup"><span data-stu-id="16c78-1053">The actual conversion from ASN.1 to the binary format is beyond the scope of this document.</span></span> <span data-ttu-id="16c78-1054">Чтобы получить дополнительные сведения, выполните поиск кодировок ASN.1 для значений OID.</span><span class="sxs-lookup"><span data-stu-id="16c78-1054">Search for ASN.1 encodings for OIDs for more information.</span></span> <span data-ttu-id="16c78-1055">Двоичное представление значений OID, поддерживаемых NetX Secure, можно найти в файле *nx_secure_x509.c*.</span><span class="sxs-lookup"><span data-stu-id="16c78-1055">The binary representation of the OIDs supported by NetX Secure can be found in the file *nx_secure_x509.c*.</span></span>

<span data-ttu-id="16c78-1056">После сопоставления фактического OID с распознанной внутри протокола константой можно создать запись для RSA_SHA1 в таблице NX_SECURE_X509_CRYPTO.</span><span class="sxs-lookup"><span data-stu-id="16c78-1056">Once we have a mapping of the actual OID to an internally-recognized constant, we can create an entry for RSA_SHA1 in the NX_SECURE_X509_CRYPTO table:</span></span>

```C
{ 
    NX_SECURE_TLS_X509_TYPE_RSA_SHA_1,    /* Internal OID constant. */
    &crypto_method_rsa,                   /* RSA method (NX_CRYPTO_METHOD). */ 
    &crypto_method_sha1                   /* SHA-1 method (NX_CRYPTO_METHOD). */
}, 
```
### <a name="default-tls-routines"></a><span data-ttu-id="16c78-1057">Процедуры TLS по умолчанию</span><span class="sxs-lookup"><span data-stu-id="16c78-1057">Default TLS Routines</span></span>

<span data-ttu-id="16c78-1058">Как упоминалось выше, протоколу TLS требуется несколько процедур по умолчанию для создания ключей и проверки сообщений во время подтверждения.</span><span class="sxs-lookup"><span data-stu-id="16c78-1058">As mentioned above, TLS requires some default routines for key generation and message verification during the handshake.</span></span> <span data-ttu-id="16c78-1059">Основная процедура — это псевдослучайная функция TLS (PRF).</span><span class="sxs-lookup"><span data-stu-id="16c78-1059">The primary routine is the TLS Pseudo-Random Function, or PRF.</span></span> <span data-ttu-id="16c78-1060">Процедура PRF основана на процедурах хэширования и может использоваться для создания произвольного объема псевдослучайных данных<sup>20</sup>, применяемых для создания ключей или других целей.</span><span class="sxs-lookup"><span data-stu-id="16c78-1060">The PRF is based on hash routines and can be used to generate an arbitrary amount of pseudo-random data<sup>20</sup> for key generation or other purposes.</span></span>

<span data-ttu-id="16c78-1061">Помимо процедуры PRF в каждой версии протокола TLS используются процедуры хэширования по умолчанию, которые также необходимо предоставить.</span><span class="sxs-lookup"><span data-stu-id="16c78-1061">In addition to the PRF, each version of TLS utilizes default hash routines that also need to be provided.</span></span> <span data-ttu-id="16c78-1062">Для протоколов TLS версий 1.0 и 1.1 этими процедурами хэширования являются MD5 и SHA-1.</span><span class="sxs-lookup"><span data-stu-id="16c78-1062">For TLS versions 1.0 and 1.1, those hash routines are MD5 and SHA-1.</span></span> <span data-ttu-id="16c78-1063">Для протокола TLS версии 1.2 требуется только алгоритм SHA-256.</span><span class="sxs-lookup"><span data-stu-id="16c78-1063">TLS version 1.2 requires only SHA-256.</span></span>

<span data-ttu-id="16c78-1064">В структуре NX_SECURE_TLS_CRYPTO есть указатели NX_CRYPTO_METHOD для MD5, SHA-1, SHA-256 — процедуры PRF для протокола TLS версии 1.0 или 1.1 и процедура PRF для протокола TLS 1.2 по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="16c78-1064">In the NX_SECURE_TLS_CRYPTO structure, there are NX_CRYPTO_METHOD pointers for MD5, SHA-1, SHA-256, the TLS version 1.0/1.1 PRF, and the default TLS 1.2 PRF.</span></span>

<span data-ttu-id="16c78-1065">Для поддержки протокола TLS 1.3 добавляются поля для HKDF (создание ключей), HMAC (для определенных операций хэширования, используемых во время подтверждения) и ECDHE (требуется для обеспечения функциональных возможностей TLS 1.3).</span><span class="sxs-lookup"><span data-stu-id="16c78-1065">TLS 1.3 support adds fields for HKDF (key generation), HMAC (for specific hashing operations used during the handshake) and ECDHE (required for TLS 1.3 functionality).</span></span>

<span data-ttu-id="16c78-1066">В состав универсальной программной криптографической библиотеки входят программные версии PRF для TLS.</span><span class="sxs-lookup"><span data-stu-id="16c78-1066">Provided in the generic software cryptography library are software versions of the TLS PRF.</span></span> <span data-ttu-id="16c78-1067">Для протоколов TLS 1.0 и TLS 1.1 эта функция называется *nx_crypto_tls_prf_1*.</span><span class="sxs-lookup"><span data-stu-id="16c78-1067">For TLS 1.0/1.1, this function is called *nx_crypto_tls_prf_1*.</span></span> <span data-ttu-id="16c78-1068">Для протокола TLS 1.2 эта функция называется *nx_secure_tls_prf_sha256*.</span><span class="sxs-lookup"><span data-stu-id="16c78-1068">For TLS 1.2, the function is called *nx_secure_tls_prf_sha256*.</span></span> <span data-ttu-id="16c78-1069">Суффикс "1" представляет устаревшую версию PRF для протокола TLS 1.0, а суффикс "SHA256" означает, что функция PRF по умолчанию для протокола TLS 1.2 основана на алгоритме SHA-256.</span><span class="sxs-lookup"><span data-stu-id="16c78-1069">The suffix "1" represents the legacy TLS 1.0 PRF, and the "sha256" suffix refers to the fact that the TLS 1.2 default PRF is based on SHA-256.</span></span> <span data-ttu-id="16c78-1070">Если требуется поддержка других процедур PRF, то суффикс для этих процедур будет отражать используемый метод хэширования.</span><span class="sxs-lookup"><span data-stu-id="16c78-1070">When support for other PRF routines is needed, the suffix for those routines will reflect the hash method used.</span></span> <span data-ttu-id="16c78-1071">Так как процедуры PRF основаны на методах хэширования, базовые процедуры хэширования могут использовать независимое аппаратное ускорение на разных целевых платформах.</span><span class="sxs-lookup"><span data-stu-id="16c78-1071">Since the PRF routines are based on hash methods, the underlying hash routines may be hardware-accelerated independently on different target platforms.</span></span>

<span data-ttu-id="16c78-1072">В дополнение к таблицам подстановки комплектов шифров TLS и X.509 можно добавить в структуру NX_SECURE_TLS_CRYPTO процедуры PRF и процедуры хэширования по умолчанию, чтобы использовать их для инициализации сеанса TLS.</span><span class="sxs-lookup"><span data-stu-id="16c78-1072">In addition to the TLS ciphersuite and X.509 lookup tables, with the default PRF and hash routines filled in the NX_SECURE_TLS_CRYPTO structure can be populated and used to initialize a TLS session.</span></span>

20. <span data-ttu-id="16c78-1073">"Псевдослучайный" означает, что процедура PRF является детерминированной, то есть она всегда будет выдавать одинаковые выходные данные для одних и тех же входных данных, а элемент случайности заключается в том, что эти данные невозможно спрогнозировать.</span><span class="sxs-lookup"><span data-stu-id="16c78-1073">“Pseudo-random” refers to the fact that the PRF is deterministic, meaning it will always produce the same output given the same input, but random in the fact that the output is not predictable.</span></span> <span data-ttu-id="16c78-1074">Протокол TLS использует это свойство PRF для создания ключей сеанса на основе различных общедоступных данных и главной копии секрета, которые передаются во время подтверждения с использованием шифрования с открытым ключом, например RSA.</span><span class="sxs-lookup"><span data-stu-id="16c78-1074">TLS uses this property of the PRF to generate the session keys from various public data combined with the master secret exchanged during the handshake using a public-key cipher like RSA.</span></span>

### <a name="cryptographic-metadata"></a><span data-ttu-id="16c78-1075">Криптографические метаданные</span><span class="sxs-lookup"><span data-stu-id="16c78-1075">Cryptographic Metadata</span></span>

<span data-ttu-id="16c78-1076">Прежде чем инициализировать сеанс TLS с помощью таблицы NX_SECURE_TLS_CRYPTO, необходимо выделить пространство буфера для метаданных криптографических процедур.</span><span class="sxs-lookup"><span data-stu-id="16c78-1076">Before we can initialize the TLS session with the NX_SECURE_TLS_CRYPTO table, we need to allocate buffer space for the cryptographic routine metadata.</span></span> <span data-ttu-id="16c78-1077">Эти метаданные используются для хранения всех состояний, связанных с конкретной процедурой и представленных ее блоком управления.</span><span class="sxs-lookup"><span data-stu-id="16c78-1077">The metadata is used to store all the state associated with a particular routine, represented by its control block.</span></span> <span data-ttu-id="16c78-1078">В поле *nx_crypto_metadata_area_size* каждой структуры NX_CRYPTO_METHOD должен быть задан размер структуры управления, связанной с этой процедурой, иначе при инициализации TLS не удастся правильно вычислить необходимое пространство, что может привести к проблемам переполнения буфера.</span><span class="sxs-lookup"><span data-stu-id="16c78-1078">The *nx_crypto_metadata_area_size* field of each NX_CRYPTO_METHOD must be set to the size of the control structure associated with that routine or the TLS initialization will fail to properly account for the space needed, possibly causing buffer overrun issues.</span></span>

<span data-ttu-id="16c78-1079">Перед созданием сеанса TLS необходимо выделить буфер метаданных.</span><span class="sxs-lookup"><span data-stu-id="16c78-1079">Before the TLS session is created, the metadata buffer must be allocated.</span></span> <span data-ttu-id="16c78-1080">Этот буфер автоматически распределяется между nx_secure_tls_session_create и пространством, резервируемым для каждой из процедур, предоставленных в таблице криптографических методов.</span><span class="sxs-lookup"><span data-stu-id="16c78-1080">The buffer is automatically divided up by nx_secure_tls_session_create and space is reserved for each of the routines that are provided in the cryptographic method table.</span></span> <span data-ttu-id="16c78-1081">Учтите, что так как в сеансе TLS одновременно активен только один комплект шифров, то число поддерживаемых комплектов шифров не влияет на необходимое пространство метаданных. Это пространство резервируется для каждой из 5 процедур комплекта шифров на основе максимального размера блока управления для этой категории, указанного в таблице подстановки комплектов шифров.</span><span class="sxs-lookup"><span data-stu-id="16c78-1081">Note that since only one ciphersuite is active at a time in a TLS session, the number of supported ciphersuites does not affect the needed metadata space – space is reserved for each of the 5 ciphersuite routines using the maximum control block size for that category in the ciphersuite lookup table.</span></span>

<span data-ttu-id="16c78-1082">Чтобы упростить вычисление размера буфера метаданных, служба *nx_secure_metadata_size_calculate* выполняет те же вычисления, что и nx_secure_tls_session_create, но просто возвращает общий размер буфера метаданных в байтах.</span><span class="sxs-lookup"><span data-stu-id="16c78-1082">In order to make calculating the metadata buffer size easy, the service *nx_secure_metadata_size_calculate* performs the same calculations as nx_secure_tls_session_create but simply returns the total required metadata buffer size in bytes.</span></span>

### <a name="initializing-the-tls-session"></a><span data-ttu-id="16c78-1083">Инициализация сеанса TLS</span><span class="sxs-lookup"><span data-stu-id="16c78-1083">Initializing the TLS session</span></span>

<span data-ttu-id="16c78-1084">После создания объектов NX_CRYPTO_METHOD и NX_SECURE_TLS_CRYPTO и резервирования области метаданных можно инициализировать сеанс TLS, как показано ниже (значения взяты из приведенных выше примеров).</span><span class="sxs-lookup"><span data-stu-id="16c78-1084">Once the NX_CRYPTO_METHOD and NX_SECURE_TLS_CRYPTO objects are created and the metadata area reserved, we can initialize a TLS session as follows (values taken from the above examples):</span></span>

```C
/* Pointer to the platform-specific cipher table. */
extern nx_crypto_tls_ciphers;

/* Cryptographic routine metadata buffer. Size is determined by calling 
nx_secure_tls_metadata_size_calculate with the nx_crypto_tls_ciphers table referenced 
above. */
UCHAR crypto_metadata[4500];

/* Initialize our TLS session using our cipher table and metadata area. Note that we can 
use sizeof for the metadata array because the size parameter expects the size in bytes.*/

nx_secure_tls_session_create(
    &tls_session,            /* Pointer to TLS session.      */
    &nx_crypto_tls_ciphers,  /* Pointer to cipher table.     */
    crypto_metadata,         /* Cryptography metadata buffer.*/
    sizeof(crypto_metadata), /* Size of metadata buffer.     */
);
```
