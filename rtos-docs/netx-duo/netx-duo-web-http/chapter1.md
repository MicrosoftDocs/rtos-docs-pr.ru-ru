---
title: Глава 1. Введение в протоколы HTTP и HTTPS
description: В этой главе описывается модуль ОСРВ Azure NetX Duo HTTP/HTTPS для Интернета.
author: philmea
ms.author: philmea
ms.date: 07/24/2020
ms.topic: article
ms.service: rtos
ms.openlocfilehash: c784843e4d3f11ee306e866223c0a19bfcba3b85
ms.sourcegitcommit: e3d42e1f2920ec9cb002634b542bc20754f9544e
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/22/2021
ms.locfileid: "104815383"
---
# <a name="chapter-1---introduction-to-http-and-https"></a><span data-ttu-id="e325b-103">Глава 1. Введение в протоколы HTTP и HTTPS</span><span class="sxs-lookup"><span data-stu-id="e325b-103">Chapter 1 - Introduction to HTTP and HTTPS</span></span>

<span data-ttu-id="e325b-104">Протокол HTTP предназначен для передачи содержимого в Интернете.</span><span class="sxs-lookup"><span data-stu-id="e325b-104">The Hypertext Transfer Protocol (HTTP) is a protocol designed for transferring content on the Web.</span></span> <span data-ttu-id="e325b-105">HTTP — это простой протокол, который использует для передачи содержимого надежные службы протокола TCP.</span><span class="sxs-lookup"><span data-stu-id="e325b-105">HTTP is a simple protocol that utilizes reliable Transmission Control Protocol (TCP) services to perform its content transfer function.</span></span> <span data-ttu-id="e325b-106">Благодаря этому HTTP считается очень надежным протоколом для обмена содержимым.</span><span class="sxs-lookup"><span data-stu-id="e325b-106">Because of this, HTTP is a highly reliable content transfer protocol.</span></span> <span data-ttu-id="e325b-107">Также HTTP является одним из самых часто используемых протоколов приложений.</span><span class="sxs-lookup"><span data-stu-id="e325b-107">HTTP is one of the most used application protocols.</span></span> <span data-ttu-id="e325b-108">Все операции в Интернете используют протокол HTTP.</span><span class="sxs-lookup"><span data-stu-id="e325b-108">All operations on the Web utilize the HTTP protocol.</span></span>

<span data-ttu-id="e325b-109">HTTPS — это безопасная версия протокола HTTP, которая реализует протокол HTTP с использованием протокола TLS для защиты базового TCP-подключения.</span><span class="sxs-lookup"><span data-stu-id="e325b-109">HTTPS is the secure version of the HTTP protocol, which implements HTTP using Transport Layer Security (TLS) to secure the underlying TCP connection.</span></span> <span data-ttu-id="e325b-110">За исключением дополнительной конфигурации, необходимой для настройки TLS, использование протокола HTTPS по сути не отличается от протокола HTTP.</span><span class="sxs-lookup"><span data-stu-id="e325b-110">Other than the additional configuration required to set up TLS, HTTPS is basically identical to HTTP in use.</span></span>

## <a name="general-http-requirements"></a><span data-ttu-id="e325b-111">Общие требования для протокола HTTP</span><span class="sxs-lookup"><span data-stu-id="e325b-111">General HTTP Requirements</span></span>

<span data-ttu-id="e325b-112">Для правильной работы пакета NetX Web HTTP требуется установить NetX Duo 5.10 или более поздней версии.</span><span class="sxs-lookup"><span data-stu-id="e325b-112">In order to function properly, the NetX Web HTTP package requires that NetX Duo (version 5.10 or later) is installed.</span></span> <span data-ttu-id="e325b-113">Кроме того, должен быть создан экземпляр IP, для которого включено использование протокола TCP.</span><span class="sxs-lookup"><span data-stu-id="e325b-113">In addition, an IP instance must be created, and TCP must be enabled on that same IP instance.</span></span> <span data-ttu-id="e325b-114">Для поддержки HTTPS также необходимо установить NetX Secure TLS 5.11 или более поздней версии (см. следующий раздел).</span><span class="sxs-lookup"><span data-stu-id="e325b-114">For HTTPS support, NetX Secure TLS (version 5.11 or later) must also be installed (see next section).</span></span> <span data-ttu-id="e325b-115">Этот процесс показан в демонстрационном файле в разделе "Пример небольшой системы" **главы 2**.</span><span class="sxs-lookup"><span data-stu-id="e325b-115">The demo file in section “Small Example System” in **Chapter 2** demonstrates how this is done.</span></span>

<span data-ttu-id="e325b-116">Для HTTP-клиента из пакета NetX Web HTTP больше нет дополнительных требований.</span><span class="sxs-lookup"><span data-stu-id="e325b-116">The HTTP Client portion of the NetX Web HTTP package has no further requirements.</span></span>

<span data-ttu-id="e325b-117">Но HTTP-сервер из пакета NetX Web HTTP определяет еще несколько дополнительных требований.</span><span class="sxs-lookup"><span data-stu-id="e325b-117">The HTTP Server portion of the NetX Web HTTP package has several additional requirements.</span></span> <span data-ttu-id="e325b-118">Во-первых, ему требуется полный доступ к *известному TCP-порту 80* для обработки всех запросов HTTP-клиента (приложение может указать любой другой допустимый порт TCP).</span><span class="sxs-lookup"><span data-stu-id="e325b-118">First, it requires complete access to TCP *well-known port 80* for handling all Client HTTP requests (this can be changed by the application to any other valid TCP port).</span></span> <span data-ttu-id="e325b-119">HTTP-сервер также разработан для работы с внедренной файловой системой FileX.</span><span class="sxs-lookup"><span data-stu-id="e325b-119">The HTTP Server is also designed for use with the FileX embedded file system.</span></span> <span data-ttu-id="e325b-120">Если система FileX недоступна, пользователь может перенести используемые разделы FileX в собственную среду.</span><span class="sxs-lookup"><span data-stu-id="e325b-120">If FileX is not available, the user may port the portions of FileX used to their own environment.</span></span> <span data-ttu-id="e325b-121">Этот процесс рассматривается в последующих разделах этого руководства.</span><span class="sxs-lookup"><span data-stu-id="e325b-121">This is discussed in later sections of this guide.</span></span>

## <a name="https-requirements"></a><span data-ttu-id="e325b-122">Требования для протокола HTTPS</span><span class="sxs-lookup"><span data-stu-id="e325b-122">HTTPS Requirements</span></span>

<span data-ttu-id="e325b-123">Для правильной работы протокола HTTPS на основе пакета NetX Web HTTP требуется, чтобы были установлены NetX Duo 5.10 или более поздней версии и NetX Secure TLS 5.11 или более поздней версии.</span><span class="sxs-lookup"><span data-stu-id="e325b-123">For HTTPS to function properly, the NetX Web HTTP package requires that NetX Duo (version 5.10 or later) and NetX Secure TLS (version 5.11 or later) are both installed.</span></span> <span data-ttu-id="e325b-124">Кроме того, должен быть создан экземпляр IP, для которого включено использование протокола TCP для работы с протоколом TLS.</span><span class="sxs-lookup"><span data-stu-id="e325b-124">In addition, an IP instance must be created, and TCP must be enabled on that same IP instance for use with TLS.</span></span> <span data-ttu-id="e325b-125">Сеанс TLS необходимо будет инициализировать с помощью соответствующих криптографических процедур и сертификата доверенного ЦС. Кроме того, потребуется выделить пространство для сертификатов, которые будут предоставляться удаленными узлами сервера во время подтверждения TLS.</span><span class="sxs-lookup"><span data-stu-id="e325b-125">The TLS session will need to be initialized with appropriate cryptographic routines, a trusted CA certificate, and space must be allocated for certificates that will be provided by remote server hosts during the TLS handshake.</span></span> <span data-ttu-id="e325b-126">Этот процесс показан в демонстрационном файле в разделе "Пример небольшой системы HTTPS" **главы 2**.</span><span class="sxs-lookup"><span data-stu-id="e325b-126">The demo file in section “Small Example HTTPS System” in **Chapter 2** will demonstrate how this is done.</span></span>

<span data-ttu-id="e325b-127">Для HTTPS-клиента из пакета NetX Web HTTP больше нет дополнительных требований.</span><span class="sxs-lookup"><span data-stu-id="e325b-127">The HTTPS Client portion of the NetX Web HTTP package has no further requirements.</span></span>

<span data-ttu-id="e325b-128">Но HTTPS-сервер из пакета NetX Web HTTP определяет еще несколько дополнительных требований.</span><span class="sxs-lookup"><span data-stu-id="e325b-128">The HTTPS Server portion of the NetX Web HTTP package has several additional requirements.</span></span> <span data-ttu-id="e325b-129">Во-первых, ему требуется полный доступ к *известному TCP-порту 443* для обработки всех HTTPS-запросов клиента (как и в случае протокола HTTP без шифрования, приложение может изменить этот порт).</span><span class="sxs-lookup"><span data-stu-id="e325b-129">First, it requires complete access to TCP *well-known port 443* for handling all Client HTTPS requests (as with plaintext HTTP, this port can be changed by the application).</span></span> <span data-ttu-id="e325b-130">Во-вторых, потребуется инициализировать сеанс TLS с помощью соответствующих криптографических процедур и сертификата удостоверения сервера (или общего ключа).</span><span class="sxs-lookup"><span data-stu-id="e325b-130">Second, the TLS session will need to be initialized with proper cryptographic routines and a server identity certificate (or Pre-Shared Key).</span></span> <span data-ttu-id="e325b-131">HTTPS-сервер также разработан для работы с внедренной файловой системой FileX.</span><span class="sxs-lookup"><span data-stu-id="e325b-131">The HTTPS Server is also designed for use with the FileX embedded file system.</span></span> <span data-ttu-id="e325b-132">Если система FileX недоступна, пользователь может перенести используемые разделы FileX в собственную среду.</span><span class="sxs-lookup"><span data-stu-id="e325b-132">If FileX is not available, the user may port the portions of FileX used to their own environment.</span></span> <span data-ttu-id="e325b-133">Использование FileX рассматривается в последующих разделах этого руководства.</span><span class="sxs-lookup"><span data-stu-id="e325b-133">The use of FileX is discussed in later sections of this guide.</span></span>

<span data-ttu-id="e325b-134">Дополнительные сведения о параметрах конфигурации TLS см. в документации по NetX Secure.</span><span class="sxs-lookup"><span data-stu-id="e325b-134">Refer to the NetX Secure documentation for more information on configuration options for TLS.</span></span>

<span data-ttu-id="e325b-135">Если не указано иное, все функции HTTP, описанные в этом документе, также относятся к протоколу HTTPS.</span><span class="sxs-lookup"><span data-stu-id="e325b-135">Unless noted, all HTTP functionality described in this document also applies to HTTPS.</span></span>

## <a name="http-and-https-constraints"></a><span data-ttu-id="e325b-136">Ограничения протоколов HTTP и HTTPS</span><span class="sxs-lookup"><span data-stu-id="e325b-136">HTTP and HTTPS Constraints</span></span>

<span data-ttu-id="e325b-137">NetX Web HTTP реализует стандарт HTTP 1.1.</span><span class="sxs-lookup"><span data-stu-id="e325b-137">NetX Web HTTP implements the HTTP 1.1 standard.</span></span> <span data-ttu-id="e325b-138">Но существует ряд ограничений, которые приведены ниже:</span><span class="sxs-lookup"><span data-stu-id="e325b-138">However, here are following constraints:</span></span>

1. <span data-ttu-id="e325b-139">не поддерживаются конвейеры обработки запросов;</span><span class="sxs-lookup"><span data-stu-id="e325b-139">Request pipelining is not supported</span></span>
1. <span data-ttu-id="e325b-140">HTTP-сервер поддерживает обычную проверку подлинности и дайджест-проверку подлинности MD5, но не поддерживает MD5-sess;</span><span class="sxs-lookup"><span data-stu-id="e325b-140">The HTTP Server supports both basic and MD5 digest authentication, but not MD5-sess.</span></span> <span data-ttu-id="e325b-141">в настоящее время HTTP-клиент поддерживает только обычную проверку подлинности;</span><span class="sxs-lookup"><span data-stu-id="e325b-141">At present, the HTTP Client supports only basic authentication.</span></span> <span data-ttu-id="e325b-142">при использовании протокола TLS для протокола HTTPS можно использовать проверку подлинности HTTP;</span><span class="sxs-lookup"><span data-stu-id="e325b-142">When using TLS for HTTPS, HTTP authentication may still be used.</span></span>
1. <span data-ttu-id="e325b-143">не поддерживается сжатие содержимого;</span><span class="sxs-lookup"><span data-stu-id="e325b-143">No content compression is supported.</span></span>
1. <span data-ttu-id="e325b-144">не поддерживаются запросы TRACE, OPTIONS и CONNECT;</span><span class="sxs-lookup"><span data-stu-id="e325b-144">TRACE, OPTIONS, and CONNECT requests are not supported.</span></span>
1. <span data-ttu-id="e325b-145">пул пакетов, связанный с HTTP-сервером или HTTP-клиентом, должен быть достаточно большим для размещения заголовка HTTP целиком;</span><span class="sxs-lookup"><span data-stu-id="e325b-145">The packet pool associated with the HTTP Server or Client must be large enough to hold the complete HTTP header.</span></span>
1. <span data-ttu-id="e325b-146">службы HTTP-клиента предназначены только для передачи содержимого, а средства для отображения в этом пакете не предоставляются.</span><span class="sxs-lookup"><span data-stu-id="e325b-146">HTTP Client services are for content transfer only—there are no display utilities provided in this package.</span></span>

## <a name="http-url-resource-names"></a><span data-ttu-id="e325b-147">URL-адрес HTTP (имена ресурсов)</span><span class="sxs-lookup"><span data-stu-id="e325b-147">HTTP URL (Resource Names)</span></span>

<span data-ttu-id="e325b-148">Протокол HTTP разработан для передачи содержимого через Интернет.</span><span class="sxs-lookup"><span data-stu-id="e325b-148">The HTTP protocol is designed to transfer content on Web.</span></span> <span data-ttu-id="e325b-149">Запрашиваемое содержимое определяется URL-адресом.</span><span class="sxs-lookup"><span data-stu-id="e325b-149">The requested content is specified by the Universal Resource Locator (URL).</span></span> <span data-ttu-id="e325b-150">Это основной компонент каждого HTTP-запроса.</span><span class="sxs-lookup"><span data-stu-id="e325b-150">This is the primary component of every HTTP request.</span></span> <span data-ttu-id="e325b-151">URL-адреса всегда начинаются с символа "/" и обычно обозначают определенные файлы на HTTP-сервере.</span><span class="sxs-lookup"><span data-stu-id="e325b-151">URLs always start with a “/” character and typically correspond to files on the HTTP Server.</span></span> <span data-ttu-id="e325b-152">Ниже приведены типичные расширения файлов, используемые с протоколом HTTP:</span><span class="sxs-lookup"><span data-stu-id="e325b-152">Common HTTP file extensions are shown below:</span></span>

- <span data-ttu-id="e325b-153">**HTM** (или **HTML**): HTML-файлы (HTML);</span><span class="sxs-lookup"><span data-stu-id="e325b-153">**.htm** (or **.html**) Hypertext Markup Language (HTML)</span></span>
- <span data-ttu-id="e325b-154">**TXT**: открытый текст ASCII;</span><span class="sxs-lookup"><span data-stu-id="e325b-154">**.txt** Plain ASCII text</span></span>
- <span data-ttu-id="e325b-155">**GIF**: двоичное изображение GIF;</span><span class="sxs-lookup"><span data-stu-id="e325b-155">**.gif** Binary GIF image</span></span>
- <span data-ttu-id="e325b-156">**XBM**: двоичное изображение Xbitmap.</span><span class="sxs-lookup"><span data-stu-id="e325b-156">**.xbm** Binary Xbitmap image</span></span>

## <a name="http-client-requests"></a><span data-ttu-id="e325b-157">Запросы HTTP-клиента</span><span class="sxs-lookup"><span data-stu-id="e325b-157">HTTP Client Requests</span></span>

<span data-ttu-id="e325b-158">В протоколе HTTP есть простой механизм для запроса содержимого в Интернете.</span><span class="sxs-lookup"><span data-stu-id="e325b-158">The HTTP has a simple mechanism for requesting Web content.</span></span> <span data-ttu-id="e325b-159">Доступен стандартные набор команд HTTP, которые отправляются клиентом после успешного установления подключения по *стандартному TCP-порту 80 (или порту 443 для HTTPS)* .</span><span class="sxs-lookup"><span data-stu-id="e325b-159">There is a set of standard HTTP commands that are issued by the Client after a connection has been successfully established on the TCP *well-known port 80 (port 443 for HTTPS)*.</span></span> <span data-ttu-id="e325b-160">Ниже приведены некоторые основные команды HTTP.</span><span class="sxs-lookup"><span data-stu-id="e325b-160">The following shows some of the basic HTTP commands:</span></span>

- <span data-ttu-id="e325b-161">**GET *ресурс* HTTP/1.1**: получение указанного ресурса.</span><span class="sxs-lookup"><span data-stu-id="e325b-161">**GET *resource* HTTP/1.1** Get the specified resource</span></span>
- <span data-ttu-id="e325b-162">**POST *ресурс* HTTP/1.1**: получение указанного ресурса и передача вложенных входных данных на HTTP-сервер.</span><span class="sxs-lookup"><span data-stu-id="e325b-162">**POST *resource* HTTP/1.1** Get the specified resource and pass attached input to the HTTP Server</span></span>
- <span data-ttu-id="e325b-163">**HEAD *ресурс* HTTP/1.1**: выполняется так же, как GET, но HTTP-сервер не возвращает содержимое.</span><span class="sxs-lookup"><span data-stu-id="e325b-163">**HEAD *resource* HTTP/1.1** Treated like a GET but not content is returned by the HTTP Server</span></span>
- <span data-ttu-id="e325b-164">**PUT *ресурс* HTTP/1.1**: размещение ресурса на HTTP-сервере.</span><span class="sxs-lookup"><span data-stu-id="e325b-164">**PUT *resource* HTTP/1.1** Place resource on HTTP Server</span></span>
- <span data-ttu-id="e325b-165">**DELETE *ресурс* HTTP/1.1**: удаление ресурса с сервера.</span><span class="sxs-lookup"><span data-stu-id="e325b-165">**DELETE *resource* HTTP/1.1** Delete resource on the Server</span></span>

<span data-ttu-id="e325b-166">Эти команды ASCII обычно генерируются веб-браузерами и службами клиента NetX Web HTTP для выполнения операций HTTP на HTTP-сервере.</span><span class="sxs-lookup"><span data-stu-id="e325b-166">These ASCII commands are generated internally by Web browsers and the NetX Web HTTP Client services to perform HTTP operations with an HTTP Server.</span></span>

<span data-ttu-id="e325b-167">Обратите внимание на то, что приложение HTTP-клиента должно использовать порт 80 (или порт 443, если используется протокол HTTPS).</span><span class="sxs-lookup"><span data-stu-id="e325b-167">Note that the HTTP Client application should use port 80, or port 443 if HTTPS is used.</span></span> <span data-ttu-id="e325b-168">Интерфейсы API HTTP-клиента и HTTP-сервера принимают порт в качестве параметра. Для удобства использования определены соответствующие макросы, NX_WEB_HTTP_SERVER_PORT (порт 80) и NX_WEB_HTTPS_SERVER_PORT (порт 443).</span><span class="sxs-lookup"><span data-stu-id="e325b-168">Both the Client and Server HTTP APIs take the port as a parameter – the macros NX_WEB_HTTP_SERVER_PORT (port 80) and NX_WEB_HTTPS_SERVER_PORT (port 443) are defined for convenience.</span></span> <span data-ttu-id="e325b-169">Порт HTTP-сервера также может быть изменен во время выполнения с помощью службы *nx_web_http_client_set_connect_port()* .</span><span class="sxs-lookup"><span data-stu-id="e325b-169">The HTTP Server port can also be changed at runtime using the *nx_web_http_client_set_connect_port()* service.</span></span> <span data-ttu-id="e325b-170">Дополнительные сведения об этой службе см. в главе 4.</span><span class="sxs-lookup"><span data-stu-id="e325b-170">See Chapter 4 for more details on this service.</span></span>

## <a name="http-server-responses"></a><span data-ttu-id="e325b-171">Ответы HTTP-сервера</span><span class="sxs-lookup"><span data-stu-id="e325b-171">HTTP Server Responses</span></span>

<span data-ttu-id="e325b-172">HTTP-сервер использует для отправки ответов на команды клиента тот же самый *известный TCP-порт 80 (или порт 443 для HTTPS)* .</span><span class="sxs-lookup"><span data-stu-id="e325b-172">The HTTP Server utilizes the same *well-known TCP port 80 (443 for HTTPS)* to send Client command responses.</span></span> <span data-ttu-id="e325b-173">Когда HTTP-сервер завершает обработку команды клиента, он возвращает строку ответа ASCII, которая включает в себя 3-значный числовой код состояния.</span><span class="sxs-lookup"><span data-stu-id="e325b-173">Once the HTTP Server processes the Client command, it returns an ASCII response string that includes a 3-digit numeric status code.</span></span> <span data-ttu-id="e325b-174">Программное обеспечение клиента по этому числовому ответу определяет, была ли операция выполнена успешно или завершилась сбоем.</span><span class="sxs-lookup"><span data-stu-id="e325b-174">The numeric response is used by the HTTP Client software to determine whether the operation succeeded or failed.</span></span> <span data-ttu-id="e325b-175">Ниже приведен список ответов HTTP-сервера на команды клиента.</span><span class="sxs-lookup"><span data-stu-id="e325b-175">Following is a list of various HTTP Server responses to Client commands:</span></span>

- <span data-ttu-id="e325b-176">**200**: запрос выполнен успешно.</span><span class="sxs-lookup"><span data-stu-id="e325b-176">**200** Request was successful</span></span>
- <span data-ttu-id="e325b-177">**400**: запрос не сформирован должным образом.</span><span class="sxs-lookup"><span data-stu-id="e325b-177">**400** Request was not formed properly</span></span>
- <span data-ttu-id="e325b-178">**401**: несанкционированный запрос, клиент должен отправить данные проверки подлинности.</span><span class="sxs-lookup"><span data-stu-id="e325b-178">**401** Unauthorized request, client needs to send authentication</span></span>
- <span data-ttu-id="e325b-179">**404**: указанный в запросе ресурс не найден.</span><span class="sxs-lookup"><span data-stu-id="e325b-179">**404** Specified resource in request was not found</span></span>
- <span data-ttu-id="e325b-180">**500**: внутренняя ошибка HTTP-сервера.</span><span class="sxs-lookup"><span data-stu-id="e325b-180">**500** Internal HTTP Server error</span></span>
- <span data-ttu-id="e325b-181">**501**: запрос не реализован HTTP-сервером.</span><span class="sxs-lookup"><span data-stu-id="e325b-181">**501** Request not implemented by HTTP Server</span></span>
- <span data-ttu-id="e325b-182">**502**: служба недоступна.</span><span class="sxs-lookup"><span data-stu-id="e325b-182">**502** Service is not available</span></span>

<span data-ttu-id="e325b-183">Например, в ответ на успешно выполненный запрос PUT клиента для файла test.htm будет возвращено сообщение "HTTP/1.1 200 OK".</span><span class="sxs-lookup"><span data-stu-id="e325b-183">For example, a successful Client request to PUT the file “test.htm” is responded with the message “HTTP/1.1 200 OK.”</span></span>

## <a name="http-communication"></a><span data-ttu-id="e325b-184">Взаимодействие по протоколу HTTP</span><span class="sxs-lookup"><span data-stu-id="e325b-184">HTTP Communication</span></span>

<span data-ttu-id="e325b-185">Как упоминалось ранее, HTTP-сервер принимает запросы от клиентов через *известный TCP-порт 80 (или порт 443 для HTTPS)* .</span><span class="sxs-lookup"><span data-stu-id="e325b-185">As mentioned previously, the HTTP Server utilizes the *well-known TCP port 80 (443 for HTTPS)* to field Client requests.</span></span> <span data-ttu-id="e325b-186">HTTP-клиенты могут использовать любой доступный TCP-порт для исходящих подключений.</span><span class="sxs-lookup"><span data-stu-id="e325b-186">HTTP Clients may use any available TCP port for outgoing connections.</span></span> <span data-ttu-id="e325b-187">Общая последовательность событий HTTP выглядит следующим образом.</span><span class="sxs-lookup"><span data-stu-id="e325b-187">The general sequence of HTTP events is as follows:</span></span>

<span data-ttu-id="e325b-188">**HTTP-запрос GET**</span><span class="sxs-lookup"><span data-stu-id="e325b-188">**HTTP GET Request**:</span></span>

1. <span data-ttu-id="e325b-189">Клиент отправляет запрос на TCP-подключение к порту 80 сервера (или 443 для HTTPS).</span><span class="sxs-lookup"><span data-stu-id="e325b-189">Client issues TCP connect to Server port 80 (or 443 for HTTPS).</span></span>
1. <span data-ttu-id="e325b-190">Если используется протокол HTTPS, то после установления TCP-подключения следует подтверждение TLS, чтобы проверить подлинность сервера и установить безопасный канал.</span><span class="sxs-lookup"><span data-stu-id="e325b-190">If HTTPS is being used, the TCP connection is followed by a TLS handshake to authenticate the server and establish a secure channel.</span></span>
1. <span data-ttu-id="e325b-191">Клиент отправляет запрос **GET *ресурс* HTTP/1.1** и другие сведения заголовка.</span><span class="sxs-lookup"><span data-stu-id="e325b-191">Client sends “**GET *resource* HTTP/1.1**” request (along with other header information).</span></span>
1. <span data-ttu-id="e325b-192">Сервер создает сообщение **HTTP/1.1 200 OK** с дополнительной информацией, за которой следует содержимое запрошенного ресурса (при наличии).</span><span class="sxs-lookup"><span data-stu-id="e325b-192">Server builds an “**HTTP/1.1 200 OK**” message with additional information followed immediately by the resource content (if any).</span></span>
1. <span data-ttu-id="e325b-193">Сервер отключается от клиента (протокол TLS завершает работу, если используется протокол HTTPS).</span><span class="sxs-lookup"><span data-stu-id="e325b-193">Server disconnects from the client (TLS is shut down if HTTPS is being used).</span></span>
1. <span data-ttu-id="e325b-194">Клиент отключается от сокета (протокол TLS завершает работу после оповещения об отключении от сервера).</span><span class="sxs-lookup"><span data-stu-id="e325b-194">Client disconnects from the socket (TLS is shut down following the disconnection alert from the server).</span></span>

<span data-ttu-id="e325b-195">**HTTP-запрос PUT**</span><span class="sxs-lookup"><span data-stu-id="e325b-195">**HTTP PUT Request**:</span></span>

1. <span data-ttu-id="e325b-196">Клиент отправляет запрос на TCP-подключение к порту 80 (или 443) сервера.</span><span class="sxs-lookup"><span data-stu-id="e325b-196">Client issues TCP connect to Server port 80 (or 443).</span></span>
1. <span data-ttu-id="e325b-197">Если используется протокол HTTPS, то после установления TCP-подключения следует подтверждение TLS, чтобы проверить подлинность сервера и установить безопасный канал.</span><span class="sxs-lookup"><span data-stu-id="e325b-197">If HTTPS is being used, the TCP connection is followed by a TLS handshake to authenticate the server and establish a secure channel.</span></span>
1. <span data-ttu-id="e325b-198">Клиент отправляет запрос PUT <ресурс> HTTP/1.1 и другие сведения заголовка, за которыми следует содержимое ресурса.</span><span class="sxs-lookup"><span data-stu-id="e325b-198">Client sends “PUT resource HTTP/1.1” request, along with other header information, and followed by the resource content.</span></span>
1. <span data-ttu-id="e325b-199">Сервер создает сообщение "HTTP/1.1 200 OK" с дополнительной информацией, за которой следует содержимое запрошенного ресурса.</span><span class="sxs-lookup"><span data-stu-id="e325b-199">Server builds an “HTTP/1.1 200 OK” message with additional information followed immediately by the resource content.</span></span>
1. <span data-ttu-id="e325b-200">Сервер разрывает подключение.</span><span class="sxs-lookup"><span data-stu-id="e325b-200">Server performs a disconnection.</span></span>
1. <span data-ttu-id="e325b-201">Клиент разрывает подключение.</span><span class="sxs-lookup"><span data-stu-id="e325b-201">Client performs a disconnection.</span></span>

> [!NOTE]
> <span data-ttu-id="e325b-202">Как уже упоминалось, HTTP-сервер может изменить стандартный порт подключения (80 или 443) на любой другой порт с помощью службы *nx_web_http_client_set_connect_port()* , что позволяет веб-серверам, использующим альтернативные порты, подключаться к клиентам.</span><span class="sxs-lookup"><span data-stu-id="e325b-202">As mentioned previously, the HTTP Server can change the default connect port (80 or 443) at runtime another port using the *nx_web_http_client_set_connect_port()* for web servers that use alternate ports to connect to clients.</span></span>

## <a name="http-authentication"></a><span data-ttu-id="e325b-203">Проверка подлинности HTTP</span><span class="sxs-lookup"><span data-stu-id="e325b-203">HTTP Authentication</span></span>

<span data-ttu-id="e325b-204">Проверка подлинности HTTP является необязательной, то есть требуется не для всех веб-запросов.</span><span class="sxs-lookup"><span data-stu-id="e325b-204">HTTP authentication is optional and is not required for all Web requests.</span></span> <span data-ttu-id="e325b-205">Существуют две разновидности проверки подлинности: *обычная* и *на основе дайджеста*.</span><span class="sxs-lookup"><span data-stu-id="e325b-205">There are two flavors of authentication, namely *basic* and *digest*.</span></span> <span data-ttu-id="e325b-206">Обычная проверка подлинности по *имени* и *паролю* работает точно так же, как во многих других протоколах.</span><span class="sxs-lookup"><span data-stu-id="e325b-206">Basic authentication is equivalent to the *name* and *password* authentication found in many protocols.</span></span> <span data-ttu-id="e325b-207">При обычной проверке подлинности HTTP имя и пароли объединяются в одну строку и кодируются в формате Base64.</span><span class="sxs-lookup"><span data-stu-id="e325b-207">In HTTP basic authentication, the name and passwords are concatenated and encoded in the base64 format.</span></span> <span data-ttu-id="e325b-208">Основным недостатком обычной проверки подлинности является то, что имя и пароль передаются в запросе в открытом виде.</span><span class="sxs-lookup"><span data-stu-id="e325b-208">The main disadvantage of basic authentication is the name and password are transmitted openly in the request.</span></span> <span data-ttu-id="e325b-209">Это позволяет достаточно легко похищать такие имена и пароли.</span><span class="sxs-lookup"><span data-stu-id="e325b-209">This makes it somewhat easy for the name and password to be stolen.</span></span> <span data-ttu-id="e325b-210">Дайджест-проверка подлинности устраняет эту проблему, так как при ней имя и пароль не передаются вместе с запросом.</span><span class="sxs-lookup"><span data-stu-id="e325b-210">Digest authentication addresses this problem by never transmitting the name and password in the request.</span></span> <span data-ttu-id="e325b-211">Вместо этого применяется специальный механизм вычисления 128-разрядного дайджеста по имени пользователя, паролю и некоторым другим параметрам.</span><span class="sxs-lookup"><span data-stu-id="e325b-211">Instead, an algorithm is used to derive a 128-bit digest from the name, password, and other information.</span></span> <span data-ttu-id="e325b-212">Сервер NetX Web HTTP поддерживает стандартный алгоритм дайджестов MD5.</span><span class="sxs-lookup"><span data-stu-id="e325b-212">The NetX Web HTTP Server supports the standard MD5 digest algorithm.</span></span>

<span data-ttu-id="e325b-213">Когда нужна проверка подлинности?</span><span class="sxs-lookup"><span data-stu-id="e325b-213">When is authentication required?</span></span> <span data-ttu-id="e325b-214">HTTP-сервер самостоятельно решает, требуется ли проверка подлинности для запрошенного ресурса.</span><span class="sxs-lookup"><span data-stu-id="e325b-214">The HTTP Server decides if a requested resource requires authentication.</span></span> <span data-ttu-id="e325b-215">Если проверка подлинности нужна, но в запросе от клиента нет необходимых данных проверки подлинности, то клиенту возвращается ответ "HTTP/1.1 401 Unauthorized" с указанием требуемого типа проверки подлинности.</span><span class="sxs-lookup"><span data-stu-id="e325b-215">If authentication is required and the Client request did not include the proper authentication, a “HTTP/1.1 401 Unauthorized” response with the type of authentication required is sent to the Client.</span></span> <span data-ttu-id="e325b-216">Ожидается, что клиент в этом случае сформирует новый запрос с правильными данными проверки подлинности.</span><span class="sxs-lookup"><span data-stu-id="e325b-216">The Client is then expected to form a new request with the proper authentication.</span></span>

<span data-ttu-id="e325b-217">При использовании протокола HTTPS HTTPS-сервер по-прежнему может использовать проверку подлинности HTTP.</span><span class="sxs-lookup"><span data-stu-id="e325b-217">When HTTPS is used, the HTTPS Server can still utilize HTTP authentication.</span></span> <span data-ttu-id="e325b-218">В этом случае для шифрования всего трафика HTTP используется протокол TLS, поэтому использование *обычной* проверки подлинности HTTP не обуславливает угрозу безопасности.</span><span class="sxs-lookup"><span data-stu-id="e325b-218">In this case, TLS is used to encrypt all HTTP traffic so using *basic* HTTP authentication does not pose a security risk.</span></span> <span data-ttu-id="e325b-219">*Дайджест*-проверка подлинности также допускается, но не обеспечивает значительного повышения безопасности по сравнению с обычной проверкой подлинности на основе протокола TLS.</span><span class="sxs-lookup"><span data-stu-id="e325b-219">*Digest* authentication is also permitted but provides no significant security improvement over basic authentication over TLS.</span></span>

## <a name="http-authentication-callback"></a><span data-ttu-id="e325b-220">Обратный вызов проверки подлинности HTTP</span><span class="sxs-lookup"><span data-stu-id="e325b-220">HTTP Authentication Callback</span></span>

<span data-ttu-id="e325b-221">Как уже упоминалось, проверка подлинности HTTP является необязательной, то есть используется не при любой передаче данных через Интернет.</span><span class="sxs-lookup"><span data-stu-id="e325b-221">As mentioned before, HTTP authentication is optional and isn’t required on all Web transfers.</span></span> <span data-ttu-id="e325b-222">Кроме того, проверка подлинности обычно зависит от конкретного ресурса.</span><span class="sxs-lookup"><span data-stu-id="e325b-222">In addition, authentication is typically resource dependent.</span></span> <span data-ttu-id="e325b-223">Один и тот же сервер может требовать проверку подлинности для доступа к некоторым ресурсам и не требовать для доступа к другим.</span><span class="sxs-lookup"><span data-stu-id="e325b-223">Access of some resources on the Server require authentication, while others do not.</span></span> <span data-ttu-id="e325b-224">Пакет сервера NetX Web HTTP позволяет приложению указать (с помощью вызова ***nx_http_server_create***) подпрограмму обратного вызова проверки подлинности, которая будет вызываться в начале обработки каждого запроса от HTTP-клиента.</span><span class="sxs-lookup"><span data-stu-id="e325b-224">The NetX Web HTTP Server package allows the application to specify (via the ***nx_web_http_server_create*** call) an authentication callback routine that is called at the beginning of handling each HTTP Client request.</span></span>

<span data-ttu-id="e325b-225">Эта подпрограмма обратного вызова предоставляет серверу NetX Web HTTP строковые значения имени пользователя, пароля и области, которые связаны с конкретным ресурсом, и возвращает необходимый тип проверки подлинности.</span><span class="sxs-lookup"><span data-stu-id="e325b-225">The callback routine provides the NetX Web HTTP Server with the username, password, and realm strings associated with the resource and return the type of authentication necessary.</span></span> <span data-ttu-id="e325b-226">Если для ресурса не требуется проверка подлинности, обратный вызов проверки подлинности должен возвращать значение **NX_WEB_HTTP_DONT_AUTHENTICATE**.</span><span class="sxs-lookup"><span data-stu-id="e325b-226">If no authentication is necessary for the resource, the authentication callback should return the value of **NX_WEB_HTTP_DONT_AUTHENTICATE**.</span></span> <span data-ttu-id="e325b-227">Если для указанного ресурса требуется обычная проверка подлинности, эта подпрограмма должна возвращать **NX_WEB_HTTP_BASIC_AUTHENTICATE**.</span><span class="sxs-lookup"><span data-stu-id="e325b-227">Otherwise, if basic authentication is required for the specified resource, the routine should return **NX_WEB_HTTP_BASIC_AUTHENTICATE**.</span></span> <span data-ttu-id="e325b-228">Наконец, если требуется дайджест-проверка подлинности MD5, подпрограмма обратного вызова должна возвращать **NX_WEB_HTTP_DIGEST_AUTHENTICATE**.</span><span class="sxs-lookup"><span data-stu-id="e325b-228">And finally, if MD5 digest authentication is required, the callback routine should return **NX_WEB_HTTP_DIGEST_AUTHENTICATE**.</span></span> <span data-ttu-id="e325b-229">Если ни для одного из ресурсов, предоставляемого HTTP-сервером, не требуется проверка подлинности, обратный вызов можно не указывать, передав в вызов для создания HTTP-сервера пустой указатель.</span><span class="sxs-lookup"><span data-stu-id="e325b-229">If no authentication is required for any resource provided by the HTTP Server, the callback is not needed, and a NULL pointer can be provided to the HTTP Server create call.</span></span>

<span data-ttu-id="e325b-230">Формат подпрограммы обратного вызова проверки подлинности для приложения достаточно прост и определен ниже.</span><span class="sxs-lookup"><span data-stu-id="e325b-230">The format of the application authenticate callback routine is very simple and is defined below:</span></span>

```C
UINT nx_web_http_server_authentication_check(NX_WEB_HTTP_SERVER *server_ptr,
    UINT request_type, CHAR *resource,
    CHAR **name, CHAR **password,
    CHAR **realm);
```

<span data-ttu-id="e325b-231">Входные параметры определяются следующим образом.</span><span class="sxs-lookup"><span data-stu-id="e325b-231">The input parameters are defined as follows:</span></span>

- <span data-ttu-id="e325b-232">**request_type**: указывает запрос HTTP-клиента, который может иметь одно из следующих значений:</span><span class="sxs-lookup"><span data-stu-id="e325b-232">**request_type** Specifies the HTTP Client request, valid requests are defined as:</span></span>
  - <span data-ttu-id="e325b-233">**NX_WEB_HTTP_SERVER_GET_REQUEST**</span><span class="sxs-lookup"><span data-stu-id="e325b-233">**NX_WEB_HTTP_SERVER_GET_REQUEST**</span></span>
  - <span data-ttu-id="e325b-234">**NX_WEB_HTTP_SERVER_POST_REQUEST**</span><span class="sxs-lookup"><span data-stu-id="e325b-234">**NX_WEB_HTTP_SERVER_POST_REQUEST**</span></span>
  - <span data-ttu-id="e325b-235">**NX_WEB_HTTP_SERVER_HEAD_REQUEST**</span><span class="sxs-lookup"><span data-stu-id="e325b-235">**NX_WEB_HTTP_SERVER_HEAD_REQUEST**</span></span>
  - <span data-ttu-id="e325b-236">**NX_WEB_HTTP_SERVER_PUT_REQUEST**</span><span class="sxs-lookup"><span data-stu-id="e325b-236">**NX_WEB_HTTP_SERVER_PUT_REQUEST**</span></span>
  - <span data-ttu-id="e325b-237">**NX_WEB_HTTP_SERVER_DELETE_REQUEST**</span><span class="sxs-lookup"><span data-stu-id="e325b-237">**NX_WEB_HTTP_SERVER_DELETE_REQUEST**</span></span>
- <span data-ttu-id="e325b-238">**resource**: запрашиваемый ресурс.</span><span class="sxs-lookup"><span data-stu-id="e325b-238">**resource** Specific resource requested.</span></span>
- <span data-ttu-id="e325b-239">**name**: указатель на требуемое имя пользователя.</span><span class="sxs-lookup"><span data-stu-id="e325b-239">**name** Destination for the pointer to the required username.</span></span>
- <span data-ttu-id="e325b-240">**password**: указатель на требуемый пароль.</span><span class="sxs-lookup"><span data-stu-id="e325b-240">**password** Destination for the pointer to the required password.</span></span>
- <span data-ttu-id="e325b-241">**realm**: указатель на область определения приложений для данной проверки подлинности.</span><span class="sxs-lookup"><span data-stu-id="e325b-241">**realm** Destination for the pointer to the realm for this authentication.</span></span>

<span data-ttu-id="e325b-242">Возвращаемое значение подпрограммы проверки подлинности указывает, требуется ли проверка подлинности.</span><span class="sxs-lookup"><span data-stu-id="e325b-242">The return value of the authentication routine specifies if authentication is required.</span></span> <span data-ttu-id="e325b-243">Указатели на имя, пароль и область определения приложения не используются, если подпрограмма обратного вызова проверки подлинности возвращает значение **NX_WEB_HTTP_DONT_AUTHENTICATE**.</span><span class="sxs-lookup"><span data-stu-id="e325b-243">name, password, and realm pointers are not used if **NX_WEB_HTTP_DONT_AUTHENTICATE** is returned by the authentication callback routine.</span></span> <span data-ttu-id="e325b-244">В противном случае разработчик HTTP-сервера должен убедиться, что значения **NX_WEB_HTTP_MAX_USERNAME** и **NX_WEB_HTTP_MAX_PASSWORD**, определенные в файле *nx_web_http_server.h*, достаточно велики для размещения имени пользователя и пароля, указанных в обратном вызове проверки подлинности.</span><span class="sxs-lookup"><span data-stu-id="e325b-244">Otherwise the HTTP server developer must ensure that **NX_WEB_HTTP_MAX_USERNAME** and **NX_WEB_HTTP_MAX_PASSWORD** defined in *nx_web_http_server.h* are large enough for the username and password specified in the authentication callback.</span></span> <span data-ttu-id="e325b-245">По умолчанию оба значения равны 20 символам.</span><span class="sxs-lookup"><span data-stu-id="e325b-245">These both have a default size of 20 characters.</span></span>

## <a name="http-invalid-usernamepassword-callback"></a><span data-ttu-id="e325b-246">Обратный вызов для недопустимых значений имени пользователя или пароля HTTP</span><span class="sxs-lookup"><span data-stu-id="e325b-246">HTTP Invalid Username/Password Callback</span></span>

<span data-ttu-id="e325b-247">Необязательный обратный вызов для недопустимых значений имени пользователя или пароля на сервере NetX Web HTTP вызывается в тех случаях, когда HTTP-сервер получает в запросе от клиента недопустимое сочетание имени пользователя и пароля.</span><span class="sxs-lookup"><span data-stu-id="e325b-247">The optional invalid username/password callback in the NetX Web HTTP Server is invoked if the HTTP server receives an invalid username and password combination in a Client request.</span></span> <span data-ttu-id="e325b-248">Если приложение HTTP-сервера зарегистрирует обратный вызов, то указанная подпрограмма будет вызываться в случае ошибки обычной проверки подлинности или дайджест-проверки подлинности в *nx_web_http_server_get_process()* , *nx_web_http_server_put_process()* или *nx_web_http_server_delete_process()* .</span><span class="sxs-lookup"><span data-stu-id="e325b-248">If the HTTP server application registers a callback with HTTP server it will be invoked if either basic or digest authentication fails *in nx_web_http_server_get_process()*, in *nx_web_http_server_put_process(),* or *in nx_web_http_server_delete_process().*</span></span>

<span data-ttu-id="e325b-249">Чтобы зарегистрировать обратный вызов на HTTP-сервере, используется приведенная ниже служба, которая определена на сервере NetX Web HTTP.</span><span class="sxs-lookup"><span data-stu-id="e325b-249">To register a callback with the HTTP server, the following service is defined for the NetX Web HTTP Server.</span></span>

```C
UINT nx_web_http_server_invalid_userpassword_notify_set(
    NX_WEB_HTTP_SERVER *http_server_ptr,
    UINT (*invalid_username_password_callback)
        (CHAR *resource, ULONG *client_nx_address,
        UINT request_type));
```

<span data-ttu-id="e325b-250">Определены следующие типы запроса:</span><span class="sxs-lookup"><span data-stu-id="e325b-250">The request types are defined as follows:</span></span>

- <span data-ttu-id="e325b-251">**NX_WEB_HTTP_SERVER_GET_REQUEST**</span><span class="sxs-lookup"><span data-stu-id="e325b-251">**NX_WEB_HTTP_SERVER_GET_REQUEST**</span></span>
- <span data-ttu-id="e325b-252">**NX_WEB_HTTP_SERVER_POST_REQUEST**</span><span class="sxs-lookup"><span data-stu-id="e325b-252">**NX_WEB_HTTP_SERVER_POST_REQUEST**</span></span>
- <span data-ttu-id="e325b-253">**NX_WEB_HTTP_SERVER_HEAD_REQUEST**</span><span class="sxs-lookup"><span data-stu-id="e325b-253">**NX_WEB_HTTP_SERVER_HEAD_REQUEST**</span></span>
- <span data-ttu-id="e325b-254">**NX_WEB_HTTP_SERVER_PUT_REQUEST**</span><span class="sxs-lookup"><span data-stu-id="e325b-254">**NX_WEB_HTTP_SERVER_PUT_REQUEST**</span></span>
- <span data-ttu-id="e325b-255">**NX_WEB_HTTP_SERVER_DELETE_REQUEST**</span><span class="sxs-lookup"><span data-stu-id="e325b-255">**NX_WEB_HTTP_SERVER_DELETE_REQUEST**</span></span>

## <a name="http-insert-gmt-date-header-callback"></a><span data-ttu-id="e325b-256">Обратный вызов для добавления заголовка даты GMT в HTTP</span><span class="sxs-lookup"><span data-stu-id="e325b-256">HTTP Insert GMT Date Header Callback</span></span>

<span data-ttu-id="e325b-257">Этот необязательный обратный вызов на сервере NetX Web HTTP позволяет добавлять в ответные сообщения заголовок со значением даты.</span><span class="sxs-lookup"><span data-stu-id="e325b-257">There is an optional callback in the NetX Web HTTP Server to insert a date header in its response messages.</span></span> <span data-ttu-id="e325b-258">Он вызывается, когда HTTP-сервер отвечает на запрос PUT или GET.</span><span class="sxs-lookup"><span data-stu-id="e325b-258">This callback is invoked when the HTTP Server is responding to a put or get request</span></span>

<span data-ttu-id="e325b-259">Чтобы зарегистрировать обратный вызов для добавления даты GMT на HTTP-сервере, определена приведенная ниже служба.</span><span class="sxs-lookup"><span data-stu-id="e325b-259">To register a GMT date callback with the HTTP Server, the following service is defined.</span></span>

```C
UINT nx_web_http_server_gmt_callback_set(
    NX_WEB_HTTP_SERVER *server_ptr,
    VOID (*gmt_get)(NX_WEB_HTTP_SERVER_DATE *date);
```

<span data-ttu-id="e325b-260">Тип данных NX_WEB_HTTP_SERVER_DATE определяется следующим образом:</span><span class="sxs-lookup"><span data-stu-id="e325b-260">The NX_WEB_HTTP_SERVER_DATE data type is defined as follows:</span></span>

```C
typedef struct NX_WEB_HTTP_SERVER_DATE_STRUCT
{
    USHORT nx_web_http_server_year; /* Year */
    UCHAR nx_web_http_server_month; /* Month */
    UCHAR nx_web_http_server_day; /* Day */
    UCHAR nx_web_http_server_hour; /* Hour */
    UCHAR nx_web_http_server_minute; /* Minute */
    UCHAR nx_web_http_server_second; /* Second */
    UCHAR nx_web_http_server_weekday; /* Weekday */
} NX_WEB_HTTP_SERVER_DATE;
```

## <a name="http-cache-info-get-callback"></a><span data-ttu-id="e325b-261">Обратный вызов для получения сведений из кэша HTTP</span><span class="sxs-lookup"><span data-stu-id="e325b-261">HTTP Cache Info Get Callback</span></span>

<span data-ttu-id="e325b-262">HTTP-сервер поддерживает обратный вызов для запроса ограничений по возрасту и датам для определенного ресурса в приложении HTTP.</span><span class="sxs-lookup"><span data-stu-id="e325b-262">The HTTP Server has a callback to request the maximum age and date from the HTTP application for a specific resource.</span></span> <span data-ttu-id="e325b-263">Эти сведения позволяют определить, будет ли HTTP-сервер отправлять всю страницу клиенту по запросу GET.</span><span class="sxs-lookup"><span data-stu-id="e325b-263">This information is used to determine if the HTTP server sends an entire page in response to a Client Get request.</span></span> <span data-ttu-id="e325b-264">Если в запросе клиента нет строки "if modified since" (если изменено позднее) или это значение не совпадает с датой "last modified" (последнее изменение), полученной в обратном вызове запроса сведений из кэша, то клиенту отправляется вся страница.</span><span class="sxs-lookup"><span data-stu-id="e325b-264">If the “if modified since” in the Client request is not found or does not match the “last modified” date returned by the get cache callback, the entire page is sent.</span></span>

<span data-ttu-id="e325b-265">Чтобы зарегистрировать обратный вызов на HTTP-сервере, определена приведенная ниже служба.</span><span class="sxs-lookup"><span data-stu-id="e325b-265">To register the callback with the HTTP server the following service is defined:</span></span>

```C
UINT nx_web_http_server_cache_info_callback_set(
    NX_WEB_HTTP_SERVER *server_ptr,
    UINT (*cache_info_get)
    (CHAR *, UINT *, NX_WEB_HTTP_SERVER_DATE *));
```

## <a name="http-chunked-transfer-coding-support"></a><span data-ttu-id="e325b-266">Поддержка поблочного кодирования HTTP</span><span class="sxs-lookup"><span data-stu-id="e325b-266">HTTP Chunked Transfer Coding Support</span></span>

<span data-ttu-id="e325b-267">Если определить общую длину сообщения HTTP перед отправкой невозможно, то можно использовать функцию поблочного кодирования для отправки сообщений в виде серий блоков без поля заголовка Content-Length.</span><span class="sxs-lookup"><span data-stu-id="e325b-267">When the total length of HTTP message cannot be determined before sending it, the Chunked Transfer Coding feature can be used to send messages as series of chunks without the “Content-Length” header field.</span></span> <span data-ttu-id="e325b-268">Эта функция поддерживается во всех сообщениях HTTP-запросов и HTTP-ответов.</span><span class="sxs-lookup"><span data-stu-id="e325b-268">This feature is supported in all HTTP request and response messages.</span></span> <span data-ttu-id="e325b-269">Эта функция поддерживается на стороне получателя, а заголовок блока автоматически обрабатывается внутренней логикой.</span><span class="sxs-lookup"><span data-stu-id="e325b-269">As a receiver, this feature is supported, and the chunk header is processed transparently by internal logic.</span></span> <span data-ttu-id="e325b-270">На стороне отправителя клиентом и сервером должны вызываться интерфейсы API *nx_web_http_client_request_chunked_set* и *nx_web_http_server_response_chunked_set* соответственно.</span><span class="sxs-lookup"><span data-stu-id="e325b-270">As a sender, the API *nx_web_http_client_request_chunked_set* and *nx_web_http_server_response_chunked_set* must be invoked by client and server respectively.</span></span>

```C
UINT nx_web_http_client_request_chunked_set(NX_WEB_HTTP_CLIENT *client_ptr,
    UINT chunk_size,
    NX_PACKET *packet_ptr);

UINT nx_web_http_server_response_chunked_set(NX_WEB_HTTP_SERVER *server_ptr,
    UINT chunk_size,
    NX_PACKET *packet_ptr);
```

<span data-ttu-id="e325b-271">Дополнительные сведения об использовании этих служб можно найти в главе 3 "Описание служб HTTP".</span><span class="sxs-lookup"><span data-stu-id="e325b-271">For more details on these services, see their descriptions in Chapter 3 “Description of HTTP Services”.</span></span>

## <a name="http-multipart-support"></a><span data-ttu-id="e325b-272">Поддержка многокомпонентных сообщений HTTP</span><span class="sxs-lookup"><span data-stu-id="e325b-272">HTTP Multipart Support</span></span>

<span data-ttu-id="e325b-273">Протокол MIME изначально предназначался для взаимодействия с протоколом SMTP, но теперь он используется и с протоколом HTTP.</span><span class="sxs-lookup"><span data-stu-id="e325b-273">Multipurpose Internet Mail Extensions (MIME) was originally intended for the SMTP protocol, but its use has spread to HTTP.</span></span> <span data-ttu-id="e325b-274">Протокол MIME позволяет включать в одно сообщение смешанные типы данных (например, image/jpg и text/plain).</span><span class="sxs-lookup"><span data-stu-id="e325b-274">MIME allows messages to contain mixed message types (e.g. image/jpg and text/plain) within the same message.</span></span> <span data-ttu-id="e325b-275">Сервер NetX Web HTTP включает в себя службы для определения типа содержимого в полученных от клиента сообщениях HTTP, содержащих данные MIME.</span><span class="sxs-lookup"><span data-stu-id="e325b-275">The NetX Web HTTP Server has services to determine content type in HTTP messages containing MIME from the Client.</span></span> <span data-ttu-id="e325b-276">Чтобы включить поддержку многокомпонентных сообщений HTTP и использовать эти службы, необходимо определить параметр конфигурации **NX_WEB_HTTP_MULTIPART_ENABLE**.</span><span class="sxs-lookup"><span data-stu-id="e325b-276">To enable HTTP multipart support and use these services, the configuration option **NX_WEB_HTTP_MULTIPART_ENABLE** must be defined.</span></span>

```C
UINT nx_web_http_server_get_entity_header(NX_WEB_HTTP_SERVER *server_ptr,
    NX_PACKET **packet_pptr,
    UCHAR *entity_header_buffer,
    ULONG buffer_size);

UINT nx_web_http_server_get_entity_content(NX_WEB_HTTP_SERVER *server_ptr,
    NX_PACKET **packet_pptr,
    ULONG *available_offset,
    ULONG *available_length);
```

<span data-ttu-id="e325b-277">Дополнительные сведения об использовании этих служб можно найти в главе 3 "Описание служб HTTP".</span><span class="sxs-lookup"><span data-stu-id="e325b-277">For more details on the use of these services, see their description in Chapter 3 “Description of HTTP Services”.</span></span>

## <a name="http-multi-thread-support"></a><span data-ttu-id="e325b-278">Поддержка многопоточности HTTP</span><span class="sxs-lookup"><span data-stu-id="e325b-278">HTTP Multi-Thread Support</span></span>

<span data-ttu-id="e325b-279">Службы клиента NetX Web HTTP можно вызывать из нескольких потоков одновременно.</span><span class="sxs-lookup"><span data-stu-id="e325b-279">The NetX Web HTTP Client services can be called from multiple threads simultaneously.</span></span> <span data-ttu-id="e325b-280">Но запросы на чтение или запись для конкретного экземпляра HTTP-клиента должны выполняться последовательно из одного потока.</span><span class="sxs-lookup"><span data-stu-id="e325b-280">However, read or write requests for a particular HTTP Client instance should be done in sequence from the same thread.</span></span>

<span data-ttu-id="e325b-281">При использовании протокола HTTPS службы клиента NetX Web HTTP могут вызываться из нескольких потоков, но ввиду повышенной сложности базовых функций TLS каждый поток должен использовать отдельный, независимый экземпляр HTTP-клиента (структуру управления NX_WEB_HTTP_CLIENT).</span><span class="sxs-lookup"><span data-stu-id="e325b-281">If using HTTPS, NetX Web HTTP Client services may be called from multiple threads but due to the added complexity of the underlying TLS functionality each thread should have a single, independent HTTP Client instance (NX_WEB_HTTP_CLIENT control structure).</span></span>

## <a name="http-rfcs"></a><span data-ttu-id="e325b-282">Соответствие протокола HTTP положениям документов RFC</span><span class="sxs-lookup"><span data-stu-id="e325b-282">HTTP RFCs</span></span>

<span data-ttu-id="e325b-283">NetX Web HTTP соответствует требованиям документов RFC 1945 "Hypertext Transfer Protocol/1.0" (Протокол передачи гипертекста, версия 1.0), RFC 2616 "Hypertext Transfer Protocol/1.1" (Протокол передачи гипертекста, версия 1.1), RFC 2581 "TCP Congestion Control" (Контроль перегрузки TCP), RFC 1122 "Requirements for Internet Hosts" (Требования к Интернет-узлам) и других связанных с ними документов RFC.</span><span class="sxs-lookup"><span data-stu-id="e325b-283">NetX Web HTTP is compliant with RFC1945 “Hypertext Transfer Protocol/1.0”, RFC 2616 “Hypertext Transfer Protocol – HTTP/1.1”, RFC 2581 “TCP Congestion Control”, RFC 1122 “Requirements for Internet Hosts”, and related RFCs.</span></span>

<span data-ttu-id="e325b-284">Реализация протокола HTTPS в NetX Web HTTP соответствует требованиям документа RFC 2818 "HTTP over TLS" (Передача данных HTTP по протоколу TLS).</span><span class="sxs-lookup"><span data-stu-id="e325b-284">For HTTPS, NetX Web HTTP is compliant with RFC 2818 “HTTP over TLS”.</span></span>
