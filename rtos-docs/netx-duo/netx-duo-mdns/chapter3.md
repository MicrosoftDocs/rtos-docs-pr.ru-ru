---
title: Глава 3. Описание внутреннего кэша служб
description: 'Модуль mDNS в NetX Duo управляет двумя внутренними кэшами служб: локальным и одноранговым.'
author: philmea
ms.author: philmea
ms.date: 07/09/2020
ms.topic: article
ms.service: rtos
ms.openlocfilehash: 007f1080a076730cfbcdedc9f063ac0c427a414c
ms.sourcegitcommit: e3d42e1f2920ec9cb002634b542bc20754f9544e
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/22/2021
ms.locfileid: "104814663"
---
# <a name="chapter-3---description-of-internal-service-cache"></a><span data-ttu-id="807c2-103">Глава 3. Описание внутреннего кэша служб</span><span class="sxs-lookup"><span data-stu-id="807c2-103">Chapter 3 - Description of internal service cache</span></span>

<span data-ttu-id="807c2-104">Модуль mDNS в NetX Duo управляет двумя внутренними кэшами служб: локальным и одноранговым.</span><span class="sxs-lookup"><span data-stu-id="807c2-104">NetX Duo mDNS module manages two internal services caches: the local service cache, and the peer service cache.</span></span> <span data-ttu-id="807c2-105">В локальном кэше служб хранятся записи ресурсов, которые связаны со службами, предоставляемыми приложениями на узле.</span><span class="sxs-lookup"><span data-stu-id="807c2-105">The local service cache stores Resource Records related to services offered by applications running on the node.</span></span> <span data-ttu-id="807c2-106">В случае с входящими запросами, если вопрос соответствует предлагаемой службе, mDNS выдает ответ, хранящийся в локальном кэше служб.</span><span class="sxs-lookup"><span data-stu-id="807c2-106">For incoming queries, if the question matches the service offered, mDNS responses with answers stored in the local service cache.</span></span> <span data-ttu-id="807c2-107">Приложения регистрируют службы, вызывая интерфейс API *nx_mdns_service_add()* .</span><span class="sxs-lookup"><span data-stu-id="807c2-107">Applications register services by calling the API *nx_mdns_service_add()*.</span></span> <span data-ttu-id="807c2-108">Для удаления служб приложения используют интерфейс API *nx_mdns_service_delete()* , который, в свою очередь, рассылает сообщения о завершении перед удалением соответствующих записей из локального кэша службы.</span><span class="sxs-lookup"><span data-stu-id="807c2-108">To remove services, applications use the API *nx_mdns_service_delete()*, which will in turn send "goodbye" messages before removing the corresponding entries in the local service cache.</span></span>

<span data-ttu-id="807c2-109">При добавлении службы mDNS сохраняет по крайней мере три записи ресурсов в локальном кэше служб: SRV, PTR и TXT.</span><span class="sxs-lookup"><span data-stu-id="807c2-109">When a service is added, mDNS maintains at least 3 Resource Records in the local service cache: SRV, PTR, and TXT.</span></span> <span data-ttu-id="807c2-110">Если тип службы включает подтип, может быть добавлена дополнительная запись ресурса PTR.</span><span class="sxs-lookup"><span data-stu-id="807c2-110">Additional PTR Resource Record may be added if the service type includes subtype.</span></span> <span data-ttu-id="807c2-111">Например, приложение регистрирует службу.</span><span class="sxs-lookup"><span data-stu-id="807c2-111">For example, an application registers a service:</span></span>

```
*name*._*subtype*._sub._*type*._tcp.local,
```

<span data-ttu-id="807c2-112">В локальный кэш служб добавляются две записи ресурсов PTR: одна для</span><span class="sxs-lookup"><span data-stu-id="807c2-112">two PTR Resource Records are added to the local service cache, one for</span></span>

```
“*_subtype._*sub*._type._*tcp.local *PTR name.type._*tcp*.*local”
```

<span data-ttu-id="807c2-113">и еще одна для</span><span class="sxs-lookup"><span data-stu-id="807c2-113">and the other one for</span></span>

```
*“_type._*tcp*.*local *PTR name.type._*tcp*.*local”.
```

<span data-ttu-id="807c2-114">Одноранговый кэш служб содержит записи ресурсов mDNS, полученные от соседних узлов.</span><span class="sxs-lookup"><span data-stu-id="807c2-114">The peer service cache contains mDNS Resource Records received from neighboring nodes.</span></span> <span data-ttu-id="807c2-115">Модуль mDNS собирает записи ресурсов, объявленные другими узлами в сети, и сохраняет полученные сведения в одноранговом кэше служб.</span><span class="sxs-lookup"><span data-stu-id="807c2-115">mDNS module collects Resource Records advertised by other nodes on the network, and stores the received information in the peer service cache.</span></span> <span data-ttu-id="807c2-116">Когда приложение запрашивает сведения, такие как IPv4- или IPv6-адреса узлов, mDNS ищет локально кэшированные ответы в одноранговом кэше служб.</span><span class="sxs-lookup"><span data-stu-id="807c2-116">When application queries for information such as host IPv4 or IPv6 addresses, mDNS searches the peer service cache for locally cached responses.</span></span> <span data-ttu-id="807c2-117">Когда приложение запрашивает службы, предлагаемые одноранговыми узлами, mDNS ищет в кэше связанные записи PTR, SRV, TXT, а также IPv4- и IPv6-адресов.</span><span class="sxs-lookup"><span data-stu-id="807c2-117">When application queries for services offered by peers, mDNS searches through the cache for related PTR, SRV, TXT, and IPv4/IPv6 address records.</span></span> <span data-ttu-id="807c2-118">В одноранговом кэше служб также хранятся запросы, отправленные узлу.</span><span class="sxs-lookup"><span data-stu-id="807c2-118">The peer service cache also stores queries sent to the node.</span></span> <span data-ttu-id="807c2-119">Например, приложение может запросить определенную службу, вызвав *nx_mdns_service_one_shot_query*.</span><span class="sxs-lookup"><span data-stu-id="807c2-119">For example, an application may request a particular service by calling *nx_mdns_service_one_shot_query.*</span></span> <span data-ttu-id="807c2-120">Если служба не найдена в одноранговом кэше служб, mDNS создает вопросы запроса (PTR, SRV и TXT) в одноранговом кэше служб.</span><span class="sxs-lookup"><span data-stu-id="807c2-120">If the service is not found in the peer service cache, mDNS creates query questions (PTR, SRV, and TXT) in the peer service cache.</span></span> <span data-ttu-id="807c2-121">Эти вопросы будут периодически отправляться в сеть, пока служба не будет разрешена или не истечет время ожидания. Аналогичным образом, приложение может использовать интерфейс API *nx_mdns_service_continous_query()* для запроса определенной службы в течение длительного периода времени (приложение отменяет ранее отправленный непрерывный запрос с помощью интерфейса API *nx_mdns_service_query_stop()* ).</span><span class="sxs-lookup"><span data-stu-id="807c2-121">These query questions will be sent to the network periodically till the service is resolved, or times out. Similar, the application may use the API *nx_mdns_service_continous_query()* to request a particular service over a long period of time (application cancels a previously issued continuous query by using the API *nx_mdns_service_query_stop()* ).</span></span> <span data-ttu-id="807c2-122">Чтобы найти определенную службу в одноранговом кэше служб, не отправляя запросы в сеть, приложения могут использовать интерфейс API *nx_mdns_serivce_lookup()* .</span><span class="sxs-lookup"><span data-stu-id="807c2-122">To search for a particular service in the peer service cache without sending queries to the network, applications can use the API *nx_mdns_serivce_lookup().*</span></span> <span data-ttu-id="807c2-123">Этот интерфейс API ищет записи ресурсов только в одноранговом кэше служб.</span><span class="sxs-lookup"><span data-stu-id="807c2-123">This API only searches the resource records in the peer service cache.</span></span>

<span data-ttu-id="807c2-124">Каждая запись ресурса хранится в кэшах служб в структуре данных *NX_MDNS_RR*.</span><span class="sxs-lookup"><span data-stu-id="807c2-124">Each Resource Record is stored in a data structure *NX_MDNS_RR* in the service caches.</span></span> <span data-ttu-id="807c2-125">Строки в записях ресурсов имеют переменную длину, поэтому не хранятся в структуре *NX_MDNS_RR*.</span><span class="sxs-lookup"><span data-stu-id="807c2-125">Strings in Resource Records are variable length, therefore are not stored in the *NX_MDNS_RR* structure.</span></span> <span data-ttu-id="807c2-126">Запись ресурса содержит указатель на фактическую область памяти, в которой хранится строка.</span><span class="sxs-lookup"><span data-stu-id="807c2-126">The Resource Record contains a pointer to the actual memory location where the string is stored.</span></span> <span data-ttu-id="807c2-127">Таблица строк и записи ресурсов совместно используют кэш служб.</span><span class="sxs-lookup"><span data-stu-id="807c2-127">The string table and the Resource Records share the service cache.</span></span> <span data-ttu-id="807c2-128">Записи ресурсов хранятся с начала кэша служб и нарастают по направлению к его концу.</span><span class="sxs-lookup"><span data-stu-id="807c2-128">Resource Records are stored from the beginning of the service cache, and grow towards the end of the cache.</span></span> <span data-ttu-id="807c2-129">Таблица строк начинается с конца кэша служб и нарастает в сторону его начала.</span><span class="sxs-lookup"><span data-stu-id="807c2-129">The string table starts from the end of the service cache and grows towards the beginning of the cache.</span></span> <span data-ttu-id="807c2-130">Каждая строка в таблице строк имеет поле длины и поле счетчика.</span><span class="sxs-lookup"><span data-stu-id="807c2-130">Each string in the string table has a length field and a counter field.</span></span> <span data-ttu-id="807c2-131">Если при добавлении строки в таблицу строк там уже присутствует такая же строка, значение счетчика увеличивается, а память для строки не выделяется.</span><span class="sxs-lookup"><span data-stu-id="807c2-131">When a string is added to the string table, if the same string is already present in the table, the counter value is incremented and no memory is allocated for the string.</span></span> <span data-ttu-id="807c2-132">Кэш служб считается заполненным, если в него больше нельзя добавить записи ресурсов или новые строки.</span><span class="sxs-lookup"><span data-stu-id="807c2-132">The service cache is considered full if no more resource records or new strings can be added to the service cache.</span></span>

<span data-ttu-id="807c2-133">Приложение может найти службы, предлагаемые в локальной сети, двумя способами.</span><span class="sxs-lookup"><span data-stu-id="807c2-133">There are two ways for an application to find services offered on the local network.</span></span> <span data-ttu-id="807c2-134">Оно может либо произвести поиск определенной службы с помощью однократного запроса, либо инициировать непрерывный запрос для отслеживания действий в сети.</span><span class="sxs-lookup"><span data-stu-id="807c2-134">It can either issue a specific service look up through a one-shot query, or it can initiate a continuous query to “monitor” the activities on the network.</span></span> <span data-ttu-id="807c2-135">В случае однократного запроса приложение должно указать тип службы.</span><span class="sxs-lookup"><span data-stu-id="807c2-135">In the one-short query scenario, the application must specify the service type.</span></span> <span data-ttu-id="807c2-136">mDNS выполняет поиск в локальном и одноранговом кэшах служб.</span><span class="sxs-lookup"><span data-stu-id="807c2-136">mDNS searches through the local service cache and the peer service cache.</span></span> <span data-ttu-id="807c2-137">Если экземпляры службы найдены, однократный запрос возвращает сведения из записей ресурсов.</span><span class="sxs-lookup"><span data-stu-id="807c2-137">If a service instances is located, the one-shot query returns with the information found in the Resource Records.</span></span> <span data-ttu-id="807c2-138">Если в локальном или одноранговом кэше служб нет записей, mDNS отправляет сообщения запроса.</span><span class="sxs-lookup"><span data-stu-id="807c2-138">If there are no records in the local service cache or peer service cache, mDNS sends out query messages.</span></span> <span data-ttu-id="807c2-139">Если указано имя экземпляра, то в локальную сеть отправляется тип *ANY* (запрос типа SRV и TXT) с определенным именем экземпляра в формате имя.тип.local.</span><span class="sxs-lookup"><span data-stu-id="807c2-139">If the instance name is specified, an *ANY* type (query the SRV and TXT type) with the specific instance name, in the form of “name.type.local”, is sent to the local network.</span></span> <span data-ttu-id="807c2-140">Если имя экземпляра не указано, в локальную сеть отправляется запрос типа PTR.</span><span class="sxs-lookup"><span data-stu-id="807c2-140">If the instance name is not specified, a PTR type of query is sent to the local network.</span></span> <span data-ttu-id="807c2-141">Вызывающей стороне возвращается первая полученная служба.</span><span class="sxs-lookup"><span data-stu-id="807c2-141">The first complete service received is returned to the caller.</span></span>

<span data-ttu-id="807c2-142">Непрерывный запрос работает иначе.</span><span class="sxs-lookup"><span data-stu-id="807c2-142">Continuous query works differently.</span></span> <span data-ttu-id="807c2-143">Типичный вариант использования непрерывного запроса — отслеживание определенной службы в локальной сети (например, постоянный поиск служб печати).</span><span class="sxs-lookup"><span data-stu-id="807c2-143">The typical use case for a continuous query is to monitor the local network for a specific service (for example to constantly look for printing services on the local network).</span></span> <span data-ttu-id="807c2-144">В этом случае приложение выдает поисковый запрос (через интерфейс API *nx_mdns_service_continious_query*) для определенного типа служб.</span><span class="sxs-lookup"><span data-stu-id="807c2-144">In this case the application issues a search query (via the API *nx_mdns_service_continious_* query) for certain type of services.</span></span> <span data-ttu-id="807c2-145">Вызывающая сторона обычно не ожидает определенного ответа.</span><span class="sxs-lookup"><span data-stu-id="807c2-145">The caller typically does not wait for a particular response.</span></span> <span data-ttu-id="807c2-146">В случае с непрерывным запросом модуль mDNS периодически отправляет запросы через экспоненциально увеличивающиеся интервалы времени.</span><span class="sxs-lookup"><span data-stu-id="807c2-146">For queries submitted as continuous query, the mDNS module transmits the queries periodically with exponentially increasing intervals.</span></span> <span data-ttu-id="807c2-147">Чтобы прерывать запрос, приложение должно с помощью интерфейса API *nx_mdns_service_query_stop* остановить его внутренний таймер.</span><span class="sxs-lookup"><span data-stu-id="807c2-147">To stop the query, application must use the API *nx_mdns_service_query_stop* to stop the internal timer in these queries.</span></span> <span data-ttu-id="807c2-148">Тип запроса может иметь значение NULL. В этом случае задается специальный тип запроса PTR _services._dns-sd._udp.local.</span><span class="sxs-lookup"><span data-stu-id="807c2-148">The query type can be NULL, in which case the query type is set to special PTR type “_services._dns-sd._udp.local”.</span></span> <span data-ttu-id="807c2-149">Он определяется в mDNS как способ обнаружения всех служб, доступных в локальной сети.</span><span class="sxs-lookup"><span data-stu-id="807c2-149">This service type is defined by mDNS as a way to discover all services available on the local network.</span></span> <span data-ttu-id="807c2-150">Если указано имя экземпляра, то в локальную сеть отправляется тип ANY (запрос типов SRV и TXT) с определенным именем экземпляра в формате имя.тип.local.</span><span class="sxs-lookup"><span data-stu-id="807c2-150">If the instance name is supplied, an ANY type (query the SRV and TXT type) with the specific instance name “name.type.local” is sent to the local network.</span></span> <span data-ttu-id="807c2-151">Если имя экземпляра имеет значение NULL, в локальную сеть отправляется запрос типа PTR.</span><span class="sxs-lookup"><span data-stu-id="807c2-151">If the instance name is NULL, a PTR type of query is sent to the local network,</span></span>

<span data-ttu-id="807c2-152">Все ответы, в том числе на незатребованные запросы, записываются в одноранговый кэш служб.</span><span class="sxs-lookup"><span data-stu-id="807c2-152">All responses, including responses from unsolicited queries, are recorded in the peer service cache.</span></span> <span data-ttu-id="807c2-153">В дальнейшем приложение использует интерфейс API *nx_mdns_service_lookup* для получения определенной службы из однорангового кэша служб.</span><span class="sxs-lookup"><span data-stu-id="807c2-153">At a later time, the application uses the API *nx_mdns_service_lookup* to retrieve specific service from the peer service cache.</span></span>

<span data-ttu-id="807c2-154">Особое замечание о фрагментации: каждая структура *NX_MDNS_RR* имеет фиксированный размер, поэтому не подвергается фрагментации, когда mDNS добавляет и удаляет записи ресурсов.</span><span class="sxs-lookup"><span data-stu-id="807c2-154">Special note on fragmentation: Each *NX_MDNS_RR* structure is fixed in size, and therefore is not subject to fragmentation as mDNS adds and deletes RRs.</span></span> <span data-ttu-id="807c2-155">Однако строки имеют переменную длину.</span><span class="sxs-lookup"><span data-stu-id="807c2-155">However strings are variable length.</span></span> <span data-ttu-id="807c2-156">После удаления строки пространство освобождается и может использоваться для новой строки, если она помещается.</span><span class="sxs-lookup"><span data-stu-id="807c2-156">After a string is deleted, the space becomes available and could be used for a new string if the new string is able to fit in.</span></span> <span data-ttu-id="807c2-157">Однако эта операция приводит к фрагментации памяти.</span><span class="sxs-lookup"><span data-stu-id="807c2-157">But this operation causes the memory to fragment.</span></span> <span data-ttu-id="807c2-158">По мере добавления и удаления служб таблица строк может оказаться фрагментированной настолько, что новые строки больше невозможно добавить, хотя в кэше служб достаточно свободных байтов для строки.</span><span class="sxs-lookup"><span data-stu-id="807c2-158">As services are added and removed, the string table may be fragmented to the point that no new strings can be added even though the service cache contains enough unused bytes for the string.</span></span> <span data-ttu-id="807c2-159">Локальные приложения, как правило, являются более стабильными и предсказуемыми.</span><span class="sxs-lookup"><span data-stu-id="807c2-159">Local applications tend to be more stable and predictable.</span></span> <span data-ttu-id="807c2-160">Поэтому локальный кэш служб меньше подвержен фрагментации.</span><span class="sxs-lookup"><span data-stu-id="807c2-160">Therefore the local service cache is less likely to suffer from fragmentation.</span></span> <span data-ttu-id="807c2-161">В случае же с одноранговым кэшем служб записи ресурсов постоянно добавляются, когда службы становятся доступны, или удаляются, когда службы удаляются узлами сети.</span><span class="sxs-lookup"><span data-stu-id="807c2-161">The peer service cache, on the other hand, constantly add RRs as the services become available, or remove RRs as services are deleted by the nodes on the network.</span></span> <span data-ttu-id="807c2-162">Службы в сети появляются и исчезают, из-за чего в таблице строк чаще происходят операции выделения и удаления.</span><span class="sxs-lookup"><span data-stu-id="807c2-162">Services on the network come and go, causing more frequent allocate/delete operations on the string table.</span></span> <span data-ttu-id="807c2-163">Со временем таблица строк может оказаться фрагментированной.</span><span class="sxs-lookup"><span data-stu-id="807c2-163">Over time it is possible the string table becomes fragmented.</span></span> <span data-ttu-id="807c2-164">В такой ситуации проще всего очистить весь одноранговый кэш служб.</span><span class="sxs-lookup"><span data-stu-id="807c2-164">When this situation happens, a simple solution is to flush the entire peer service cache.</span></span> <span data-ttu-id="807c2-165">Для этого можно вызвать интерфейс API *nx_mdns_peer_cache_clear()* .</span><span class="sxs-lookup"><span data-stu-id="807c2-165">This can be done by calling the API *nx_mdns_peer_cache_clear().*</span></span> <span data-ttu-id="807c2-166">Обратите внимание, что этот интерфейс API автоматически завершает все текущие непрерывные запросы.</span><span class="sxs-lookup"><span data-stu-id="807c2-166">Note that this API automatically terminates any outstanding continuous queries.</span></span>
