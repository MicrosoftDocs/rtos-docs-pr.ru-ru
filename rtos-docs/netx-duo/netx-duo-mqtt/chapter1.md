---
title: Глава 1 - Введение в Azure RTOS NetX Duo MQTT
description: Пакет клиента NetX Duo MQTT требует установки и правильной настройки NetX Duo (версии 5.10 или новее), а также создания экземпляра IP.
author: philmea
ms.author: philmea
ms.date: 05/19/2020
ms.topic: article
ms.service: rtos
ms.openlocfilehash: be650186b233d0f1202beecc22f4bd8bc0af4dbe0f677704d09df057fcbc34fc
ms.sourcegitcommit: 93d716cf7e3d735b18246d659ec9ec7f82c336de
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/07/2021
ms.locfileid: "116797744"
---
# <a name="chapter-1---introduction-to-azure-rtos-netx-duo-mqtt"></a>Глава 1 - Введение в Azure RTOS NetX Duo MQTT

## <a name="netx-duo-mqtt-requirements"></a>Требования NetX Duo MQTT

Для клиентского пакета Azure RTOS NetX Duo MQTT требуется, чтобы NetX Duo (версия 5.10 или новее) был установлен, правильно настроен и был создан экземпляр IP. В системе должен быть включен модуль TCP. Помимо этого, если требуется безопасность TLS, модуль NetX Secure TLS необходимо настроить в соответствии с параметром безопасности, требуемым брокером.

## <a name="netx-duo-mqtt-specification"></a>Технические характеристики NetX Duo MQTT

Реализация клиента NetX Duo MQTT соответствует требованиям OASIS MQTT версии 3.1.1, 29<sup>-е</sup> октября 2014 г. Технические характеристики можно найти по адресу:

- [http://mqtt.org/](http://mqtt.org/)

## <a name="netx-duo-mqtt-basic-operation"></a>Основные операции NetX Duo MQTT

MQTT (передача телеметрии очереди сообщений) основан на модели издатель-подписчик. Клиент может публиковать информацию другим клиентам через брокера. Клиент, если он заинтересован в теме, может подписаться на нее через брокера. Брокер отвечает за доставку опубликованных сообщений своим клиентам, подписавшимся на данную тему. В рамках данной модели типа «издатель-подписчик» несколько клиентов могут публиковать данные с одной и той же темой. Клиент получит сообщение, которое он публикует, если он подписывается на ту же тему.

В зависимости от варианта использования клиент может выбрать один из 3 уровней QoS при публикации сообщения:

- **QoS 0**: Сообщение доставляется не более одного раза. Сообщения, отправленные с QoS 0, могут быть потеряны.
- **QoS 1**: Сообщение доставляется не менее одного раза. Сообщения, отправленные с QoS 1, могут быть доставлены более одного раза.
- **QoS 2**: Сообщение доставляется ровно один раз. Сообщения, отправленные с QoS 2, гарантированно будут доставлены без дублирования.

> [!NOTE]
> Данная реализация клиента MQTT не поддерживает сообщения QoS уровня 2.

Поскольку QoS 1 и QoS 2 гарантированно будут доставлены, брокер отслеживает состояние сообщений QoS 1 и QoS 2, отправленных каждому клиенту. Это является особенно важным для клиентов, ожидающих сообщений QoS1 или QoS 2. Клиент может быть отключен от брокера (например, когда клиент перезагружается или канал связи временно теряется). Брокер должен хранить сообщения QoS 1 и QoS 2, чтобы сообщения можно было доставить позже, когда клиент повторно подключится к брокеру. Тем не менее, клиент может решить не получать устаревшие сообщения от брокера после повторного подключения. Клиент может сделать это, инициировав соединение с пометкой *clean_session*, установленной на ***NX_TRUE** _. В данном случае, получив сообщение MQTT CONNECT, брокер должен отбросить любую информацию о сеансе, связанную с данным клиентом, включая недоставленные или неподтвержденные сообщения QoS 1 или QoS 2. Если пометка _clean_session* установлена на **NX_FALSE**_, сервер должен повторно отправить сообщения QoS 1 и QoS 2. Клиент MQTT также повторно отправляет любые неподтвержденные сообщения, если для _clean_session * установлено значение ***NX_TRUE*.** Данный тип подтверждения отличается от ACK уровня TCP, хотя возможно и такое. Клиент MQTT отправляет брокеру подтверждение.

Приложение создает экземпляр клиента MQTT, вызывая ***nxd_mqtt_client_create()** _. После создания клиента приложение может подключиться к брокеру, вызвав _*_nxd_mqtt_client_connect()_*_. После подключения к брокеру клиент может подписаться на тему, вызвав _*_nxd_mqtt_client_subscribe()_*_, или опубликовать тему, вызвав _*_nxd_mqtt_client_publish()_ **.

Входящие сообщения MQTT хранятся в очереди приема в экземпляре клиента MQTT. Приложение извлекает это сообщение, вызывая ***nxd_mqtt_client_message_get()***. Если в очереди приема есть сообщения, вызывающему возвращается первое сообщение (например, самое старое) из очереди. При этом также возвращается строка темы из сообщения.

> [!NOTE]
> Функция ***nxd_mqtt_client_message_get()** _ не осуществляет блокировку, если очередь приема клиента MQTT пуста. Функция немедленно возвращается с кодом возврата _*_NXD_MQTT_NO_MESSAGE_**. Приложение должно рассматривать данное возвращаемое значение как указание на то, что очередь приема пуста, а не как ошибку.

Во избежание опроса очереди приема входящих сообщений, приложение может зарегистрировать функцию обратного вызова в клиенте MQTT, вызвав ***nxd_mqtt_client_recieve_notify_set()***. Функция обратного вызова обозначается следующим образом:

```c
VOID (*receive_notify_callback)(NXD_MQTT_CLIENT *client_ptr, 
    UINT message_count);
```

Когда клиент MQTT получает сообщения от брокера, он вызывает функцию обратного вызова, если функция установлена. Функция обратного вызова передает указатель на блок управления клиента и значение счетчика сообщений. Значение счетчика сообщений указывает количество сообщений MQTT в очереди приема. Обратите внимание, что данная функция обратного вызова выполняется в контексте клиентского потока MQTT. Следовательно, функция обратного вызова не должна выполнять какие-либо процедуры, которые могут блокировать клиентский поток MQTT. Функция обратного вызова должна инициировать вызов потока приложения ***nxd_mqtt_client_message_get()*** для получения сообщений.

Чтобы отключить и завершить работу клиентской службы MQTT, приложение должно использовать службу ***nxd_mqtt_client_disconnect()** _ и _*_nxd_mqtt_client_delete()._*_ Вызов _*_nxd_mqtt_client_disconnect()_*_ просто отключает TCP-соединение с брокером. В результате освобождаются сообщения, уже полученные и хранящиеся в очереди приема. Тем не менее, вызов не выпускает сообщения QoS уровня 1 в очереди на передачу. Сообщения уровня QoS 1 передаются повторно при подключении, если для пометки _*_clean_session_*_ установлено значение _ *_NX_FALSE._**

Брокер также может отключиться от клиента. Когда TCP-соединение между клиентом и брокером прерывается, приложение может быть уведомлено с помощью функции уведомления о разъединении. Чтобы использовать механизм уведомления, приложение устанавливает функцию уведомления об отключении, вызывая ***nxd_mqtt_client_disconnect_notify_set*.** Как только наблюдается отключение TCP и создается сеанс MQTT, вызывается функция уведомления.

В результате вызова ***nxd_mqtt_client_delete()*** освобождаются все блоки сообщений в очереди передачи и очереди приема. Неподтвержденные сообщения QoS уровня 1 также удаляются.

## <a name="secure-mqtt-connection"></a>Безопасное соединение MQTT

Клиент MQTT устанавливает безопасное соединение с брокером с помощью модуля NetX Secure TLS. Номер порта по умолчанию для MQTT с безопасностью TLS - 8883, определенный в ***NXD_MQTT_TLS_PORT***.

Чтобы создать безопасное MQTT-соединение с брокером, после установления TCP-соединения необходимо согласовать сеанс TLS, прежде чем сообщения MQTT CONNECT могут быть отправлены брокеру. Установка сеанса TLS выполняется путем вызова ***nxd_mqtt_client_secure_connect()*** и передачи определяемой пользователем функции обратного вызова установки TLS. Во время фазы соединения MQTT, как только TCP-соединение установлено, клиент вызывает функцию обратного вызова установки TLS, чтобы запустить надлежащий процесс установления связи TLS. После того, как сеанс TLS установлен, клиент продолжает сообщение MQTT CONNECT по защищенному каналу.

Пользовательская функция обратного вызова принимает пять входных значений и объявляется следующим образом:

```c
UINT tls_Setup_callback(NXD_MQTT_CLIENT *client_ptr,
    NX_SECURE_TLS_SESSION *session_ptr,
    NX_SECURE_TLS_CERTIFICATE *certificate_ptr,
    NX_SECURE_TLS_CERTIFICATE *trusted_cerfiticate);
```

Ниже приводится описание входных параметров:

- **client_ptr**: Указатель на клиентский блок управления MQTT.
- **session_ptr**: Указатель на блок управления сеансом TLS.
- **certificate_ptr**: Указатель на блок управления сертификатом. Функция настройки настраивает данный сертификат перед его отправкой брокеру.
- **trusted_certificate_ptr**: Указатель на доверенный сертификат. Функция настройки TLS настраивает доверенный сертификат для аутентификации сервера.

В функции настройки TLS приложение отвечает за создание сеанса TLS и настройку сеанса с использованием надлежащего сертификата. Следующий псевдокод описывает типичную процедуру запуска сеанса TLS. Читателю предлагается ознакомиться с Руководством пользователя NetX Secure TLS для получения подробной информации об использовании TLS API.

Ниже приведен пример обратного вызова установки TLS:

```c
UINT tls_setup_callback(NXD_MQTT_CLIENT *client_pt
    NX_SECURE_TLS_SESSION *session_ptr,
    NX_SECURE_TLS_CERTIFICATE *certrifcate_ptr,
    NX_SECURE_TLS_CERTIFICATE *trusted_certificate_ptr)
{
    /* Initialize TLS module */
    nx_secure_tls_initialize();

    /* Create a TLS session */
    nx_secure_tls_session_create(session_ptr, …);

    /* Need to allocate space for the certificate coming in from the broker. */
    memset(certificate_ptr), 0, sizeof(NX_SECURE_TLS_CERTIFICATE));

    nx_secure_tls_remote_certificate_allocate(session_ptr, certificate_ptr);

    /* Add a CA Certificate to our trusted store for verifying incomingserver certificates. */
    nx_secure_tls_certificate_initialize(
        trusted_certificate_ptr,
        ca_cert_der,
        ca_cert_der_len, NULL, 0);
    nx_secure_tls_trusted_certificate_add(session_ptr,
        trusted_certificate));
}
```

## <a name="known-limitations-of-the-netx-duo-mqtt-client"></a>Известные ограничения клиента NetX Duo MQTT

- NetX Duo MQTT не поддерживает отправку и получение сообщений QoS уровня 2.
- NetX Duo MQTT не поддерживает связанные пакеты.
