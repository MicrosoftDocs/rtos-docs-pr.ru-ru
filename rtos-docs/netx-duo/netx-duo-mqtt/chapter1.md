---
title: Глава 1 - Введение в Azure RTOS NetX Duo MQTT
description: Пакет клиента NetX Duo MQTT требует установки и правильной настройки NetX Duo (версии 5.10 или новее), а также создания экземпляра IP.
author: philmea
ms.author: philmea
ms.date: 05/19/2020
ms.topic: article
ms.service: rtos
ms.openlocfilehash: 2e13b997f987e2fd82569bcb1904218908313d70
ms.sourcegitcommit: e3d42e1f2920ec9cb002634b542bc20754f9544e
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/22/2021
ms.locfileid: "104814660"
---
# <a name="chapter-1---introduction-to-azure-rtos-netx-duo-mqtt"></a><span data-ttu-id="f7c1e-103">Глава 1 - Введение в Azure RTOS NetX Duo MQTT</span><span class="sxs-lookup"><span data-stu-id="f7c1e-103">Chapter 1 - Introduction to Azure RTOS NetX Duo MQTT</span></span>

## <a name="netx-duo-mqtt-requirements"></a><span data-ttu-id="f7c1e-104">Требования NetX Duo MQTT</span><span class="sxs-lookup"><span data-stu-id="f7c1e-104">NetX Duo MQTT Requirements</span></span>

<span data-ttu-id="f7c1e-105">Для клиентского пакета Azure RTOS NetX Duo MQTT требуется, чтобы NetX Duo (версия 5.10 или новее) был установлен, правильно настроен и был создан экземпляр IP.</span><span class="sxs-lookup"><span data-stu-id="f7c1e-105">The Azure RTOS NetX Duo MQTT client package requires that NetX Duo (version 5.10 or later) be installed, properly configured, and the IP instance has been created.</span></span> <span data-ttu-id="f7c1e-106">В системе должен быть включен модуль TCP.</span><span class="sxs-lookup"><span data-stu-id="f7c1e-106">The TCP module must be enabled in the system.</span></span> <span data-ttu-id="f7c1e-107">Помимо этого, если требуется безопасность TLS, модуль NetX Secure TLS необходимо настроить в соответствии с параметром безопасности, требуемым брокером.</span><span class="sxs-lookup"><span data-stu-id="f7c1e-107">In addition, if TLS security is required, the NetX Secure TLS module needs to be configured according to the security parameter required by the broker.</span></span>

## <a name="netx-duo-mqtt-specification"></a><span data-ttu-id="f7c1e-108">Технические характеристики NetX Duo MQTT</span><span class="sxs-lookup"><span data-stu-id="f7c1e-108">NetX Duo MQTT Specification</span></span>

<span data-ttu-id="f7c1e-109">Реализация клиента NetX Duo MQTT соответствует требованиям OASIS MQTT версии 3.1.1, 29<sup>-е</sup> октября 2014 г.</span><span class="sxs-lookup"><span data-stu-id="f7c1e-109">NetX Duo MQTT client implement is compliant with OASIS MQTT Version 3.1.1 Oct 29<sup>th</sup> 2014.</span></span> <span data-ttu-id="f7c1e-110">Технические характеристики можно найти по адресу:</span><span class="sxs-lookup"><span data-stu-id="f7c1e-110">The specification can be found at:</span></span>

- [http://mqtt.org/](http://mqtt.org/)

## <a name="netx-duo-mqtt-basic-operation"></a><span data-ttu-id="f7c1e-111">Основные операции NetX Duo MQTT</span><span class="sxs-lookup"><span data-stu-id="f7c1e-111">NetX Duo MQTT Basic Operation</span></span>

<span data-ttu-id="f7c1e-112">MQTT (передача телеметрии очереди сообщений) основан на модели издатель-подписчик.</span><span class="sxs-lookup"><span data-stu-id="f7c1e-112">MQTT (Message Queue Telemetry Transport) is based on publisher-subscriber model.</span></span> <span data-ttu-id="f7c1e-113">Клиент может публиковать информацию другим клиентам через брокера.</span><span class="sxs-lookup"><span data-stu-id="f7c1e-113">A client can publish information to other clients through a broker.</span></span> <span data-ttu-id="f7c1e-114">Клиент, если он заинтересован в теме, может подписаться на нее через брокера.</span><span class="sxs-lookup"><span data-stu-id="f7c1e-114">A client, if interested in a topic, can subscribe to the topic through the broker.</span></span> <span data-ttu-id="f7c1e-115">Брокер отвечает за доставку опубликованных сообщений своим клиентам, подписавшимся на данную тему.</span><span class="sxs-lookup"><span data-stu-id="f7c1e-115">A broker is responsible for delivering published messages to its clients who subscribe to the topic.</span></span> <span data-ttu-id="f7c1e-116">В рамках данной модели типа «издатель-подписчик» несколько клиентов могут публиковать данные с одной и той же темой.</span><span class="sxs-lookup"><span data-stu-id="f7c1e-116">In this publisher-subscriber model, multiple clients may publish data with the same topic.</span></span> <span data-ttu-id="f7c1e-117">Клиент получит сообщение, которое он публикует, если он подписывается на ту же тему.</span><span class="sxs-lookup"><span data-stu-id="f7c1e-117">A client will receive a message it publishes if the client subscribes to the same topic.</span></span>

<span data-ttu-id="f7c1e-118">В зависимости от варианта использования клиент может выбрать один из 3 уровней QoS при публикации сообщения:</span><span class="sxs-lookup"><span data-stu-id="f7c1e-118">Depending on the use case, a client may choose one of the 3 QoS levels when publishing a message:</span></span>

- <span data-ttu-id="f7c1e-119">**QoS 0**: Сообщение доставляется не более одного раза.</span><span class="sxs-lookup"><span data-stu-id="f7c1e-119">**QoS 0**: The message is delivered at most once.</span></span> <span data-ttu-id="f7c1e-120">Сообщения, отправленные с QoS 0, могут быть потеряны.</span><span class="sxs-lookup"><span data-stu-id="f7c1e-120">Messages sent with QoS 0 may be lost.</span></span>
- <span data-ttu-id="f7c1e-121">**QoS 1**: Сообщение доставляется не менее одного раза.</span><span class="sxs-lookup"><span data-stu-id="f7c1e-121">**QoS 1**: The message is delivered at least once.</span></span> <span data-ttu-id="f7c1e-122">Сообщения, отправленные с QoS 1, могут быть доставлены более одного раза.</span><span class="sxs-lookup"><span data-stu-id="f7c1e-122">Messages sent with QoS 1 may be delivered more than once.</span></span>
- <span data-ttu-id="f7c1e-123">**QoS 2**: Сообщение доставляется ровно один раз.</span><span class="sxs-lookup"><span data-stu-id="f7c1e-123">**QoS 2**: The message is delivered exactly once.</span></span> <span data-ttu-id="f7c1e-124">Сообщения, отправленные с QoS 2, гарантированно будут доставлены без дублирования.</span><span class="sxs-lookup"><span data-stu-id="f7c1e-124">Messages sent with QoS 2 is guaranteed to be delivered, with no duplication.</span></span>

> [!NOTE]
> <span data-ttu-id="f7c1e-125">Данная реализация клиента MQTT не поддерживает сообщения QoS уровня 2.</span><span class="sxs-lookup"><span data-stu-id="f7c1e-125">This implementation of MQTT client does not support QoS level 2 messages.</span></span>

<span data-ttu-id="f7c1e-126">Поскольку QoS 1 и QoS 2 гарантированно будут доставлены, брокер отслеживает состояние сообщений QoS 1 и QoS 2, отправленных каждому клиенту.</span><span class="sxs-lookup"><span data-stu-id="f7c1e-126">Since QoS 1 and QoS 2 are guaranteed to be delivered, the broker keeps track the state of QoS 1 and QoS 2 messages sent to each client.</span></span> <span data-ttu-id="f7c1e-127">Это является особенно важным для клиентов, ожидающих сообщений QoS1 или QoS 2.</span><span class="sxs-lookup"><span data-stu-id="f7c1e-127">This is particularly important for clients that expect QoS1 or QoS 2 messages.</span></span> <span data-ttu-id="f7c1e-128">Клиент может быть отключен от брокера (например, когда клиент перезагружается или канал связи временно теряется).</span><span class="sxs-lookup"><span data-stu-id="f7c1e-128">The client may be disconnected from the broker (for example when the client reboots, or the communication link is temporarily lost).</span></span> <span data-ttu-id="f7c1e-129">Брокер должен хранить сообщения QoS 1 и QoS 2, чтобы сообщения можно было доставить позже, когда клиент повторно подключится к брокеру.</span><span class="sxs-lookup"><span data-stu-id="f7c1e-129">The broker must store QoS 1 and QoS 2 messages so the messages can be delivered later once the client is reconnected to the broker.</span></span> <span data-ttu-id="f7c1e-130">Тем не менее, клиент может решить не получать устаревшие сообщения от брокера после повторного подключения.</span><span class="sxs-lookup"><span data-stu-id="f7c1e-130">However, the client may choose not to receive any stale messages from the broker after reconnection.</span></span> <span data-ttu-id="f7c1e-131">Клиент может сделать это, инициировав соединение с пометкой *clean_session*, установленной на \***NX_TRUE** _.</span><span class="sxs-lookup"><span data-stu-id="f7c1e-131">The client can do so by initiating the connection with the *clean_session* flag set to \***NX_TRUE** _.</span></span> <span data-ttu-id="f7c1e-132">В данном случае, получив сообщение MQTT CONNECT, брокер должен отбросить любую информацию о сеансе, связанную с данным клиентом, включая недоставленные или неподтвержденные сообщения QoS 1 или QoS 2.</span><span class="sxs-lookup"><span data-stu-id="f7c1e-132">In this case, upon receiving the MQTT CONNECT message, the broker shall discard any session information associated with this client, including undelivered or unconfirmed QoS 1 or QoS 2 messages.</span></span> <span data-ttu-id="f7c1e-133">Если пометка _clean_session\* установлена на **NX_FALSE**_, сервер должен повторно отправить сообщения QoS 1 и QoS 2.</span><span class="sxs-lookup"><span data-stu-id="f7c1e-133">If the _clean_session\* flag is to \***NX_FALSE**_, the server shall resend the QoS 1 and QoS 2 messages.</span></span> <span data-ttu-id="f7c1e-134">Клиент MQTT также повторно отправляет любые неподтвержденные сообщения, если для _clean_session \* установлено значение \***NX_TRUE\*.**</span><span class="sxs-lookup"><span data-stu-id="f7c1e-134">The MQTT Client also resends any un-acknowledged messages if _clean_session\* is set to \***NX_TRUE\*.**</span></span> <span data-ttu-id="f7c1e-135">Данный тип подтверждения отличается от ACK уровня TCP, хотя возможно и такое.</span><span class="sxs-lookup"><span data-stu-id="f7c1e-135">This acknowledgment is different from the TCP layer ACK, although that happens as well.</span></span> <span data-ttu-id="f7c1e-136">Клиент MQTT отправляет брокеру подтверждение.</span><span class="sxs-lookup"><span data-stu-id="f7c1e-136">The MQTT client sends an acknowledgment to the broker.</span></span>

<span data-ttu-id="f7c1e-137">Приложение создает экземпляр клиента MQTT, вызывая \***nxd_mqtt_client_create()** _.</span><span class="sxs-lookup"><span data-stu-id="f7c1e-137">An application creates an MQTT client instance by calling \***nxd_mqtt_client_create()** _.</span></span> <span data-ttu-id="f7c1e-138">После создания клиента приложение может подключиться к брокеру, вызвав _*_nxd_mqtt_client_connect()_*_.</span><span class="sxs-lookup"><span data-stu-id="f7c1e-138">Once the client is created, the application can connect to the broker by calling _*_nxd_mqtt_client_connect()_*_.</span></span> <span data-ttu-id="f7c1e-139">После подключения к брокеру клиент может подписаться на тему, вызвав _*_nxd_mqtt_client_subscribe()_*_, или опубликовать тему, вызвав _\*_nxd_mqtt_client_publish()_ \*\*.</span><span class="sxs-lookup"><span data-stu-id="f7c1e-139">After connecting to the broker, the client can subscribe to a topic by calling _*_nxd_mqtt_client_subscribe()_*_, or publish a topic by calling _\*_nxd_mqtt_client_publish()_\*\*.</span></span>

<span data-ttu-id="f7c1e-140">Входящие сообщения MQTT хранятся в очереди приема в экземпляре клиента MQTT.</span><span class="sxs-lookup"><span data-stu-id="f7c1e-140">Incoming MQTT messages are stored in the receive queue in the MQTT client instance.</span></span> <span data-ttu-id="f7c1e-141">Приложение извлекает это сообщение, вызывая ***nxd_mqtt_client_message_get()***.</span><span class="sxs-lookup"><span data-stu-id="f7c1e-141">Application retrieves these message by calling ***nxd_mqtt_client_message_get()***.</span></span> <span data-ttu-id="f7c1e-142">Если в очереди приема есть сообщения, вызывающему возвращается первое сообщение (например, самое старое) из очереди.</span><span class="sxs-lookup"><span data-stu-id="f7c1e-142">If there are messages in the receive queue, the first message (e.g. the oldest) from the queue is returned to the caller.</span></span> <span data-ttu-id="f7c1e-143">При этом также возвращается строка темы из сообщения.</span><span class="sxs-lookup"><span data-stu-id="f7c1e-143">The topic string from the message is also returned.</span></span>

> [!NOTE]
> <span data-ttu-id="f7c1e-144">Функция \***nxd_mqtt_client_message_get()** _ не осуществляет блокировку, если очередь приема клиента MQTT пуста.</span><span class="sxs-lookup"><span data-stu-id="f7c1e-144">The function \***nxd_mqtt_client_message_get()** _ does not block if the MQTT client receive queue is empty.</span></span> <span data-ttu-id="f7c1e-145">Функция немедленно возвращается с кодом возврата _\*_NXD_MQTT_NO_MESSAGE_\*\*.</span><span class="sxs-lookup"><span data-stu-id="f7c1e-145">The function returns immediately with the return code _\*_NXD_MQTT_NO_MESSAGE_\*\*.</span></span> <span data-ttu-id="f7c1e-146">Приложение должно рассматривать данное возвращаемое значение как указание на то, что очередь приема пуста, а не как ошибку.</span><span class="sxs-lookup"><span data-stu-id="f7c1e-146">The application shall treat this return value as an indication that the receive queue is empty, not an error.</span></span>

<span data-ttu-id="f7c1e-147">Во избежание опроса очереди приема входящих сообщений, приложение может зарегистрировать функцию обратного вызова в клиенте MQTT, вызвав ***nxd_mqtt_client_recieve_notify_set()***.</span><span class="sxs-lookup"><span data-stu-id="f7c1e-147">To avoid polling the receive queue for incoming messages, the application can register a callback function with the MQTT client by calling ***nxd_mqtt_client_recieve_notify_set()***.</span></span> <span data-ttu-id="f7c1e-148">Функция обратного вызова обозначается следующим образом:</span><span class="sxs-lookup"><span data-stu-id="f7c1e-148">The callback function is declared as:</span></span>

```c
VOID (*receive_notify_callback)(NXD_MQTT_CLIENT *client_ptr, 
    UINT message_count);
```

<span data-ttu-id="f7c1e-149">Когда клиент MQTT получает сообщения от брокера, он вызывает функцию обратного вызова, если функция установлена.</span><span class="sxs-lookup"><span data-stu-id="f7c1e-149">As the MQTT client receives messages from the broker, it invokes the callback function if the function is set.</span></span> <span data-ttu-id="f7c1e-150">Функция обратного вызова передает указатель на блок управления клиента и значение счетчика сообщений.</span><span class="sxs-lookup"><span data-stu-id="f7c1e-150">The callback function passes the pointer to the client control block and a message count value.</span></span> <span data-ttu-id="f7c1e-151">Значение счетчика сообщений указывает количество сообщений MQTT в очереди приема.</span><span class="sxs-lookup"><span data-stu-id="f7c1e-151">The message count value indicates the number of MQTT messages in the receive queue.</span></span> <span data-ttu-id="f7c1e-152">Обратите внимание, что данная функция обратного вызова выполняется в контексте клиентского потока MQTT.</span><span class="sxs-lookup"><span data-stu-id="f7c1e-152">Note that this callback function executes in the MQTT client thread context.</span></span> <span data-ttu-id="f7c1e-153">Следовательно, функция обратного вызова не должна выполнять какие-либо процедуры, которые могут блокировать клиентский поток MQTT.</span><span class="sxs-lookup"><span data-stu-id="f7c1e-153">Therefore, the callback function should not execute any procedures that may block the MQTT client thread.</span></span> <span data-ttu-id="f7c1e-154">Функция обратного вызова должна инициировать вызов потока приложения ***nxd_mqtt_client_message_get()*** для получения сообщений.</span><span class="sxs-lookup"><span data-stu-id="f7c1e-154">The callback function should trigger the application thread to call ***nxd_mqtt_client_message_get()*** to retrieve the messages.</span></span>

<span data-ttu-id="f7c1e-155">Чтобы отключить и завершить работу клиентской службы MQTT, приложение должно использовать службу ***nxd_mqtt_client_disconnect()** _ и _*_nxd_mqtt_client_delete()._\*_</span><span class="sxs-lookup"><span data-stu-id="f7c1e-155">To disconnect and terminate the MQTT client service, the application shall use the service ***nxd_mqtt_client_disconnect()** _ and _*_nxd_mqtt_client_delete()._\*_</span></span> <span data-ttu-id="f7c1e-156">Вызов _*_nxd_mqtt_client_disconnect()_*_ просто отключает TCP-соединение с брокером.</span><span class="sxs-lookup"><span data-stu-id="f7c1e-156">Calling _*_nxd_mqtt_client_disconnect()_*_ simply disconnects the TCP connection to the broker.</span></span> <span data-ttu-id="f7c1e-157">В результате освобождаются сообщения, уже полученные и хранящиеся в очереди приема.</span><span class="sxs-lookup"><span data-stu-id="f7c1e-157">It releases messages already received and stored in the receive queue.</span></span> <span data-ttu-id="f7c1e-158">Тем не менее, вызов не выпускает сообщения QoS уровня 1 в очереди на передачу.</span><span class="sxs-lookup"><span data-stu-id="f7c1e-158">However, it does not release QoS level 1 messages in the transmit queue.</span></span> <span data-ttu-id="f7c1e-159">Сообщения уровня QoS 1 передаются повторно при подключении, если для пометки _*_clean_session_*_ установлено значение _ *_NX_FALSE._*\*</span><span class="sxs-lookup"><span data-stu-id="f7c1e-159">QoS level 1 messages are retransmitted upon connection, assuming the _*_clean_session_*_ flag is set to _ *_NX_FALSE._*\*</span></span>

<span data-ttu-id="f7c1e-160">Брокер также может отключиться от клиента.</span><span class="sxs-lookup"><span data-stu-id="f7c1e-160">The broker may also disconnect from the client.</span></span> <span data-ttu-id="f7c1e-161">Когда TCP-соединение между клиентом и брокером прерывается, приложение может быть уведомлено с помощью функции уведомления о разъединении.</span><span class="sxs-lookup"><span data-stu-id="f7c1e-161">When the TCP connection between the client and the broker is terminated, the application can be notified by the disconnect notify function.</span></span> <span data-ttu-id="f7c1e-162">Чтобы использовать механизм уведомления, приложение устанавливает функцию уведомления об отключении, вызывая \***nxd_mqtt_client_disconnect_notify_set\*.**</span><span class="sxs-lookup"><span data-stu-id="f7c1e-162">To use the notification mechanism, application installs the disconnect notify function by calling \***nxd_mqtt_client_disconnect_notify_set\*.**</span></span> <span data-ttu-id="f7c1e-163">Как только наблюдается отключение TCP и создается сеанс MQTT, вызывается функция уведомления.</span><span class="sxs-lookup"><span data-stu-id="f7c1e-163">Once a TCP disconnect is observed and the MQTT session has been created, the notification function is invoked.</span></span>

<span data-ttu-id="f7c1e-164">В результате вызова ***nxd_mqtt_client_delete()*** освобождаются все блоки сообщений в очереди передачи и очереди приема.</span><span class="sxs-lookup"><span data-stu-id="f7c1e-164">Calling ***nxd_mqtt_client_delete()*** releases all message blocks in the transmit queue and the receive queue.</span></span> <span data-ttu-id="f7c1e-165">Неподтвержденные сообщения QoS уровня 1 также удаляются.</span><span class="sxs-lookup"><span data-stu-id="f7c1e-165">Unacknowledged QoS level 1 messages are also deleted.</span></span>

## <a name="secure-mqtt-connection"></a><span data-ttu-id="f7c1e-166">Безопасное соединение MQTT</span><span class="sxs-lookup"><span data-stu-id="f7c1e-166">Secure MQTT Connection</span></span>

<span data-ttu-id="f7c1e-167">Клиент MQTT устанавливает безопасное соединение с брокером с помощью модуля NetX Secure TLS.</span><span class="sxs-lookup"><span data-stu-id="f7c1e-167">The MQTT client makes a secure connection to the broker using the NetX Secure TLS module.</span></span> <span data-ttu-id="f7c1e-168">Номер порта по умолчанию для MQTT с безопасностью TLS - 8883, определенный в ***NXD_MQTT_TLS_PORT***.</span><span class="sxs-lookup"><span data-stu-id="f7c1e-168">The default port number for MQTT with TLS security is 8883, defined in ***NXD_MQTT_TLS_PORT***.</span></span>

<span data-ttu-id="f7c1e-169">Чтобы создать безопасное MQTT-соединение с брокером, после установления TCP-соединения необходимо согласовать сеанс TLS, прежде чем сообщения MQTT CONNECT могут быть отправлены брокеру.</span><span class="sxs-lookup"><span data-stu-id="f7c1e-169">To create a secure MQTT connection to the broker, a TLS session needs to be negotiated after a TCP connection is established, before MQTT CONNECT messages can be sent to the broker.</span></span> <span data-ttu-id="f7c1e-170">Установка сеанса TLS выполняется путем вызова ***nxd_mqtt_client_secure_connect()*** и передачи определяемой пользователем функции обратного вызова установки TLS.</span><span class="sxs-lookup"><span data-stu-id="f7c1e-170">The TLS session set up is accomplished by calling ***nxd_mqtt_client_secure_connect()*** and passing in a user-defined TLS setup callback function.</span></span> <span data-ttu-id="f7c1e-171">Во время фазы соединения MQTT, как только TCP-соединение установлено, клиент вызывает функцию обратного вызова установки TLS, чтобы запустить надлежащий процесс установления связи TLS.</span><span class="sxs-lookup"><span data-stu-id="f7c1e-171">During the MQTT connection phase, once the TCP connection is established, the client invokes the TLS setup callback function to start a proper TLS handshake process.</span></span> <span data-ttu-id="f7c1e-172">После того, как сеанс TLS установлен, клиент продолжает сообщение MQTT CONNECT по защищенному каналу.</span><span class="sxs-lookup"><span data-stu-id="f7c1e-172">After the TLS session is established, the client continues the MQTT CONNECT message over the secure channel.</span></span>

<span data-ttu-id="f7c1e-173">Пользовательская функция обратного вызова принимает пять входных значений и объявляется следующим образом:</span><span class="sxs-lookup"><span data-stu-id="f7c1e-173">The user defined callback function takes five input values and is declared as:</span></span>

```c
UINT tls_Setup_callback(NXD_MQTT_CLIENT *client_ptr,
    NX_SECURE_TLS_SESSION *session_ptr,
    NX_SECURE_TLS_CERTIFICATE *certificate_ptr,
    NX_SECURE_TLS_CERTIFICATE *trusted_cerfiticate);
```

<span data-ttu-id="f7c1e-174">Ниже приводится описание входных параметров:</span><span class="sxs-lookup"><span data-stu-id="f7c1e-174">Below is a description of the input parameters:</span></span>

- <span data-ttu-id="f7c1e-175">**client_ptr**: Указатель на клиентский блок управления MQTT.</span><span class="sxs-lookup"><span data-stu-id="f7c1e-175">**client_ptr**: Pointer to the MQTT client control block.</span></span>
- <span data-ttu-id="f7c1e-176">**session_ptr**: Указатель на блок управления сеансом TLS.</span><span class="sxs-lookup"><span data-stu-id="f7c1e-176">**session_ptr**: Pointer to the TLS session control block.</span></span>
- <span data-ttu-id="f7c1e-177">**certificate_ptr**: Указатель на блок управления сертификатом.</span><span class="sxs-lookup"><span data-stu-id="f7c1e-177">**certificate_ptr**: Pointer to the certificate control block.</span></span> <span data-ttu-id="f7c1e-178">Функция настройки настраивает данный сертификат перед его отправкой брокеру.</span><span class="sxs-lookup"><span data-stu-id="f7c1e-178">The setup function configures this certificate before sending it to the broker.</span></span>
- <span data-ttu-id="f7c1e-179">**trusted_certificate_ptr**: Указатель на доверенный сертификат.</span><span class="sxs-lookup"><span data-stu-id="f7c1e-179">**trusted_certificate_ptr**: Pointer to the trusted certificate.</span></span> <span data-ttu-id="f7c1e-180">Функция настройки TLS настраивает доверенный сертификат для аутентификации сервера.</span><span class="sxs-lookup"><span data-stu-id="f7c1e-180">TLS setup function configures the trusted certificate to authenticate the server.</span></span>

<span data-ttu-id="f7c1e-181">В функции настройки TLS приложение отвечает за создание сеанса TLS и настройку сеанса с использованием надлежащего сертификата.</span><span class="sxs-lookup"><span data-stu-id="f7c1e-181">In the TLS setup function, the application is responsible for creating a TLS session, and configuring the session with a proper certificate.</span></span> <span data-ttu-id="f7c1e-182">Следующий псевдокод описывает типичную процедуру запуска сеанса TLS.</span><span class="sxs-lookup"><span data-stu-id="f7c1e-182">The following pseudo code outlines a typical TLS session start up procedure.</span></span> <span data-ttu-id="f7c1e-183">Читателю предлагается ознакомиться с Руководством пользователя NetX Secure TLS для получения подробной информации об использовании TLS API.</span><span class="sxs-lookup"><span data-stu-id="f7c1e-183">The reader is referred to the NetX Secure TLS User Guide for details on using TLS APIs.</span></span>

<span data-ttu-id="f7c1e-184">Ниже приведен пример обратного вызова установки TLS:</span><span class="sxs-lookup"><span data-stu-id="f7c1e-184">Below is an example TLS setup callback:</span></span>

```c
UINT tls_setup_callback(NXD_MQTT_CLIENT *client_pt
    NX_SECURE_TLS_SESSION *session_ptr,
    NX_SECURE_TLS_CERTIFICATE *certrifcate_ptr,
    NX_SECURE_TLS_CERTIFICATE *trusted_certificate_ptr)
{
    /* Initialize TLS module */
    nx_secure_tls_initialize();

    /* Create a TLS session */
    nx_secure_tls_session_create(session_ptr, …);

    /* Need to allocate space for the certificate coming in from the broker. */
    memset(certificate_ptr), 0, sizeof(NX_SECURE_TLS_CERTIFICATE));

    nx_secure_tls_remote_certificate_allocate(session_ptr, certificate_ptr);

    /* Add a CA Certificate to our trusted store for verifying incomingserver certificates. */
    nx_secure_tls_certificate_initialize(
        trusted_certificate_ptr,
        ca_cert_der,
        ca_cert_der_len, NULL, 0);
    nx_secure_tls_trusted_certificate_add(session_ptr,
        trusted_certificate));
}
```

## <a name="known-limitations-of-the-netx-duo-mqtt-client"></a><span data-ttu-id="f7c1e-185">Известные ограничения клиента NetX Duo MQTT</span><span class="sxs-lookup"><span data-stu-id="f7c1e-185">Known Limitations of the NetX Duo MQTT Client</span></span>

- <span data-ttu-id="f7c1e-186">NetX Duo MQTT не поддерживает отправку и получение сообщений QoS уровня 2.</span><span class="sxs-lookup"><span data-stu-id="f7c1e-186">NetX Duo MQTT does not support sending or receiving QoS level 2 messages.</span></span>
- <span data-ttu-id="f7c1e-187">NetX Duo MQTT не поддерживает связанные пакеты.</span><span class="sxs-lookup"><span data-stu-id="f7c1e-187">NetX Duo MQTT does not support chained-packets.</span></span>
