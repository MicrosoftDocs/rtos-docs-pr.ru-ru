---
title: Глава 1. Общие сведения
author: philmea
description: В этой статье представлены общие сведения о решении "Модули ThreadX для ОСРВ Azure".
ms.author: philmea
ms.date: 07/15/2020
ms.topic: article
ms.service: rtos
ms.openlocfilehash: 0c9698086468d7bb41c33ebe9fa9d1ebb61b5f1f
ms.sourcegitcommit: e3d42e1f2920ec9cb002634b542bc20754f9544e
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/22/2021
ms.locfileid: "104814384"
---
# <a name="chapter-1-overview"></a><span data-ttu-id="a9bf3-103">Глава 1. Общие сведения</span><span class="sxs-lookup"><span data-stu-id="a9bf3-103">Chapter 1: Overview</span></span>

<span data-ttu-id="a9bf3-104">Компонент "Модули ThreadX" предоставляет инфраструктуру для приложений, позволяющую динамически загружать модули, созданные отдельно от резидентной части приложения.</span><span class="sxs-lookup"><span data-stu-id="a9bf3-104">The ThreadX Module component provides an infrastructure for applications to dynamically load modules that are built separately from the resident portion of the application.</span></span> <span data-ttu-id="a9bf3-105">Это особенно полезно в ситуациях, когда размер кода приложения превышает объем доступной памяти.</span><span class="sxs-lookup"><span data-stu-id="a9bf3-105">This is especially useful in situations where the application code size exceeds available memory.</span></span> <span data-ttu-id="a9bf3-106">Решение также позволяет добавлять новые функции после развертывания образа ядра.</span><span class="sxs-lookup"><span data-stu-id="a9bf3-106">It can also help when new features are required to be added after the core image is deployed.</span></span> <span data-ttu-id="a9bf3-107">Кроме того, можно частично обновлять встроенное ПО путем динамической загрузки модулей.</span><span class="sxs-lookup"><span data-stu-id="a9bf3-107">In addition, dynamically loading modules can be used when partial firmware updates are required.</span></span>

<span data-ttu-id="a9bf3-108">Защита памяти для загруженного модуля не является обязательной и определяется по свойствам в преамбуле модуля.</span><span class="sxs-lookup"><span data-stu-id="a9bf3-108">Memory protection for the loaded module is optional, based on the properties specified in the module preamble.</span></span> <span data-ttu-id="a9bf3-109">Если защита памяти требуется, оборудование управления памятью процессора настраивается таким образом, что все потоки модуля получают доступ только к коду модуля и памяти данных.</span><span class="sxs-lookup"><span data-stu-id="a9bf3-109">When memory protection is specified, the processor's memory management hardware is configured such that all threads of the module are only allowed access to the module's code and data memory.</span></span> <span data-ttu-id="a9bf3-110">Любой доступ к внешней памяти или попытка выполнения внешнего кода приведет к ошибке операции с памятью и завершению потока модуля, вызвавшего эту ошибку.</span><span class="sxs-lookup"><span data-stu-id="a9bf3-110">Any extraneous memory access or execution will result in a memory fault and the offending module thread will be terminated.</span></span> <span data-ttu-id="a9bf3-111">Если приложение зарегистрирует обратный вызов для уведомлений о сбое операций с памятью, этот вызов также позволит уведомить приложение о таком сбое.</span><span class="sxs-lookup"><span data-stu-id="a9bf3-111">If the application registers a memory fault notification callback, this will also be called to alert the application of the memory fault.</span></span>

<span data-ttu-id="a9bf3-112">Компонент "Модули ThreadX" рассчитывает, что приложение предоставит область памяти для загрузки модулей.</span><span class="sxs-lookup"><span data-stu-id="a9bf3-112">The ThreadX Module component relies on the application to provide a memory area where modules can be loaded.</span></span> <span data-ttu-id="a9bf3-113">Область инструкций для каждого модуля может выполняться на месте или копироваться для выполнения в область памяти модуля в ОЗУ.</span><span class="sxs-lookup"><span data-stu-id="a9bf3-113">The instruction area of each module may execute in place or be copied into the RAM module memory area for execution.</span></span> <span data-ttu-id="a9bf3-114">Во всех случаях требуемая для данных модуля память выделяется из области памяти модуля.</span><span class="sxs-lookup"><span data-stu-id="a9bf3-114">In all cases, the module data memory requirements are allocated from the module memory area.</span></span>

<span data-ttu-id="a9bf3-115">Количество одновременно загруженных модулей ничем не ограничено (помимо объема доступной памяти), но всегда есть только одна копия кода резидентного диспетчера модулей.</span><span class="sxs-lookup"><span data-stu-id="a9bf3-115">There are no limits on the number of modules that can be loaded at the same time (aside from the amount of memory available), while there is only one copy of the resident Module Manager code.</span></span> <span data-ttu-id="a9bf3-116">На рис. 1 представлена связь между диспетчером модулей и модулями.</span><span class="sxs-lookup"><span data-stu-id="a9bf3-116">Figure 1 illustrates the relationship of the Module Manager and the modules themselves.</span></span>

![Отношения между модулями и диспетчером модулей](media/image2.png)

<span data-ttu-id="a9bf3-118">**Рис. 1.** Модули и диспетчер модулей</span><span class="sxs-lookup"><span data-stu-id="a9bf3-118">**Figure 1** Modules and Module Manager</span></span>

<span data-ttu-id="a9bf3-119">Каждый модуль должен иметь собственную область памяти, которую выделяет приложение.</span><span class="sxs-lookup"><span data-stu-id="a9bf3-119">Each module must have its own memory area, which is the application's responsibility to define.</span></span> <span data-ttu-id="a9bf3-120">Модуль и диспетчер модулей взаимодействуют через программную функцию диспетчеризации, используя заранее определенные идентификаторы запросов для служб ThreadX, запрошенных модулем.</span><span class="sxs-lookup"><span data-stu-id="a9bf3-120">The Module and the Module Manager interact through a software dispatch function via pre-defined request IDs that correspond to ThreadX services requested by the module.</span></span> <span data-ttu-id="a9bf3-121">Кроме того, модуль обязан предоставить сведения о единой точке входа в поток, размере и приоритете требуемого стека, а также идентификатор модуля и сведения о размере и приоритете стека для потока обратного вызова. Вся эта информация определяется в преамбуле каждого модуля.</span><span class="sxs-lookup"><span data-stu-id="a9bf3-121">In addition, the module is required to provide a single thread entry point as well as the required stack size, priority, module ID, callback thread stack size/priority, etc. This information is defined in each module's preamble.</span></span>

<span data-ttu-id="a9bf3-122">Диспетчер модулей отвечает за создание исходного потока модуля и инициализацию его выполнения.</span><span class="sxs-lookup"><span data-stu-id="a9bf3-122">The Module Manager is responsible for creating the initial module thread and initiating its execution.</span></span> <span data-ttu-id="a9bf3-123">После выполнения начального потока модуля диспетчер модулей контролирует и направляет все запросы к API ThreadX, выполняемые модулем.</span><span class="sxs-lookup"><span data-stu-id="a9bf3-123">Once the module's initial thread is executing, the Module Manager is responsible for fielding all ThreadX API requests made by the module.</span></span> <span data-ttu-id="a9bf3-124">Модуль получает полный доступ к API ThreadX, включая возможность создания дополнительных потоков в пределах модуля.</span><span class="sxs-lookup"><span data-stu-id="a9bf3-124">A module has full access to the ThreadX API, including the ability to create additional threads within the module.</span></span>  
  
<span data-ttu-id="a9bf3-125">Соглашения об именовании для исходного кода модуля достаточно просты: все исходные файлы диспетчера модулей имеют префикс имени ***txm_module_manager_\**** а файлы, предназначенные для конкретного модуля, не имеют сегмента имени **_manager_ *_. Главный файл включений с именем _* _txm_module.h_** является общим для диспетчера и исходного кода модуля.</span><span class="sxs-lookup"><span data-stu-id="a9bf3-125">The module source code naming conventions are straightforward: all Module Manager source files are named ***txm_module_manager_\**** and all files associated exclusively with the module omit the "**_manager_*_" portion of the name. The main include file _*_txm_module.h_** is shared by the manager and module source code.</span></span>
