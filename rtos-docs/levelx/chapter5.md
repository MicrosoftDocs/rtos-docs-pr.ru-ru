---
title: Глава 5. Поддержка NOR для LevelX в ОСРВ Azure
description: Флэш-память NOR состоит из блоков, размер которых обычно составляет 512 байтов. LevelX в ОСРВ Azure делит каждый блок флэш-памяти NOR на 512-байтовые логические сектора.
author: philmea
ms.author: philmea
ms.date: 05/19/2020
ms.topic: article
ms.service: rtos
ms.openlocfilehash: 3a0c73c2b45c32bf3f1ef56de684fa83c334b59e
ms.sourcegitcommit: e3d42e1f2920ec9cb002634b542bc20754f9544e
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/22/2021
ms.locfileid: "104814892"
---
# <a name="chapter-5---azure-rtos-levelx-nor-support"></a><span data-ttu-id="a13fe-104">Глава 5. Поддержка NOR для LevelX в ОСРВ Azure</span><span class="sxs-lookup"><span data-stu-id="a13fe-104">Chapter 5 - Azure RTOS LevelX NOR support</span></span>

<span data-ttu-id="a13fe-105">Флэш-память NOR состоит из *блоков*, размер которых обычно составляет 512 байтов.</span><span class="sxs-lookup"><span data-stu-id="a13fe-105">NOR flash memory is composed of *blocks* that are typically evenly divisible by 512 bytes.</span></span> <span data-ttu-id="a13fe-106">Во флэш-памяти NOR нет понятия *страницы*.</span><span class="sxs-lookup"><span data-stu-id="a13fe-106">There are no concept of a flash *page* in NOR flash memory.</span></span> <span data-ttu-id="a13fe-107">Кроме того, в ней нет *свободных* байтов, поэтому для получения всех сведений об управлении LevelX в ОСРВ Azure должен использовать саму флэш-память NOR.</span><span class="sxs-lookup"><span data-stu-id="a13fe-107">Also, there are no *spare* bytes in NOR flash memory, hence Azure RTOS LevelX must use the NOR flash memory itself for all management information.</span></span> <span data-ttu-id="a13fe-108">Во флэш-памяти NOR существует прямой доступ для чтения.</span><span class="sxs-lookup"><span data-stu-id="a13fe-108">Direct read access is possible in NOR flash memory.</span></span> <span data-ttu-id="a13fe-109">Для получения доступа на запись обычно требуется выполнить особую последовательность операций.</span><span class="sxs-lookup"><span data-stu-id="a13fe-109">Write access typically requires a special sequence of operations.</span></span> <span data-ttu-id="a13fe-110">Флэш-память NOR поддерживает многократную запись при условии предварительной очистки битов.</span><span class="sxs-lookup"><span data-stu-id="a13fe-110">NOR flash memory may be written to multiple times, providing that bits are being cleared.</span></span> <span data-ttu-id="a13fe-111">Биты во флэш-памяти NOR можно задать только один раз с помощью операции очистки блока.</span><span class="sxs-lookup"><span data-stu-id="a13fe-111">Bits in NOR flash memory can only be set once, via the erase block operation.</span></span>

<span data-ttu-id="a13fe-112">LevelX делит каждый блок флэш-памяти NOR на 512-байтовые логические *сектора*.</span><span class="sxs-lookup"><span data-stu-id="a13fe-112">LevelX divides each NOR flash block into 512-byte logical *sectors*.</span></span> <span data-ttu-id="a13fe-113">Кроме того, LevelX использует первые "n" секторов для каждого блока флэш-памяти NOR для хранения данных об управлении.</span><span class="sxs-lookup"><span data-stu-id="a13fe-113">Furthermore, LevelX uses the first "n" sectors of each NOR flash block to store management information.</span></span> <span data-ttu-id="a13fe-114">Ниже приведен формат данных об управлении для флэш-памяти NOR для LevelX.</span><span class="sxs-lookup"><span data-stu-id="a13fe-114">The format of the LevelX NOR flash memory management information is:</span></span>

<span data-ttu-id="a13fe-115">**Формат блока NOR для LevelX**</span><span class="sxs-lookup"><span data-stu-id="a13fe-115">**LevelX NOR Block Format**</span></span>

| <span data-ttu-id="a13fe-116">Смещение в байтах</span><span class="sxs-lookup"><span data-stu-id="a13fe-116">Byte Offset</span></span>  | <span data-ttu-id="a13fe-117">Содержимое</span><span class="sxs-lookup"><span data-stu-id="a13fe-117">Contents</span></span>                     |
| ------------ | ---------------------------- |
| <span data-ttu-id="a13fe-118">0</span><span class="sxs-lookup"><span data-stu-id="a13fe-118">0</span></span>            | <span data-ttu-id="a13fe-119">[Число очисток блока]</span><span class="sxs-lookup"><span data-stu-id="a13fe-119">[Block Erase Count]</span></span>          |
| <span data-ttu-id="a13fe-120">4</span><span class="sxs-lookup"><span data-stu-id="a13fe-120">4</span></span>            | <span data-ttu-id="a13fe-121">[Минимальный сопоставленный сектор]</span><span class="sxs-lookup"><span data-stu-id="a13fe-121">[Minimum Mapped Sector]</span></span>      |
| <span data-ttu-id="a13fe-122">8</span><span class="sxs-lookup"><span data-stu-id="a13fe-122">8</span></span>            | <span data-ttu-id="a13fe-123">[Максимальный сопоставленный сектор]</span><span class="sxs-lookup"><span data-stu-id="a13fe-123">[Maximum Mapped Sector]</span></span>      |
| <span data-ttu-id="a13fe-124">12</span><span class="sxs-lookup"><span data-stu-id="a13fe-124">12</span></span>           | <span data-ttu-id="a13fe-125">[Битовая карта свободного сектора]</span><span class="sxs-lookup"><span data-stu-id="a13fe-125">[Free Sector Bit Map]</span></span>        |
| <span data-ttu-id="a13fe-126">m</span><span class="sxs-lookup"><span data-stu-id="a13fe-126">m</span></span>            | <span data-ttu-id="a13fe-127">[Запись сопоставления сектора 0]</span><span class="sxs-lookup"><span data-stu-id="a13fe-127">[Sector 0 Mapping Entry]</span></span>     |
|              | <span data-ttu-id="a13fe-128">…</span><span class="sxs-lookup"><span data-stu-id="a13fe-128">…</span></span>                            |
| <span data-ttu-id="a13fe-129">m+4\*(n-1)</span><span class="sxs-lookup"><span data-stu-id="a13fe-129">m+4\*(n-1)</span></span>    | <span data-ttu-id="a13fe-130">[Запись сопоставления сектора "n"]</span><span class="sxs-lookup"><span data-stu-id="a13fe-130">[Sector "n" Mapping Entry]</span></span>   |
|              | <span data-ttu-id="a13fe-131">…</span><span class="sxs-lookup"><span data-stu-id="a13fe-131">…</span></span>                            |
| <span data-ttu-id="a13fe-132">s</span><span class="sxs-lookup"><span data-stu-id="a13fe-132">s</span></span>            | <span data-ttu-id="a13fe-133">[Содержимое сектора 0]</span><span class="sxs-lookup"><span data-stu-id="a13fe-133">[Sector 0 Contents]</span></span>          |
|              | <span data-ttu-id="a13fe-134">…</span><span class="sxs-lookup"><span data-stu-id="a13fe-134">…</span></span>                            |
| <span data-ttu-id="a13fe-135">s+512\*(n-1)</span><span class="sxs-lookup"><span data-stu-id="a13fe-135">s+512\*(n-1)</span></span> | <span data-ttu-id="a13fe-136">[Содержимое сектора "n"]</span><span class="sxs-lookup"><span data-stu-id="a13fe-136">[Sector "n" Contents]</span></span>         |

<span data-ttu-id="a13fe-137">32-разрядное *число очисток блока* означает, сколько раз выполнялась очистка блока.</span><span class="sxs-lookup"><span data-stu-id="a13fe-137">The 32-bit *Block Erase Count* contains the number of times the block has been erased.</span></span> <span data-ttu-id="a13fe-138">Основная цель LevelX заключается в том, чтобы число очисток всех блоков было относительно близко к указанному, чтобы избежать преждевременного выхода блока из строя.</span><span class="sxs-lookup"><span data-stu-id="a13fe-138">The main goal of LevelX is to keep the erase count of all blocks relatively close to help prevent any one block from wearing out prematurely.</span></span> <span data-ttu-id="a13fe-139">32-разрядные поля *Минимальный сопоставленный сектор* и *Максимальный сопоставленный сектор* записываются только в том случае, если все логические секторы в блоке были сопоставлены и в них выполнена запись.</span><span class="sxs-lookup"><span data-stu-id="a13fe-139">The 32-bit *Minimum Mapped Sector* and *Maximum Mapped Sector* fields are written only when all the logical sectors in the block have been mapped and written to.</span></span> <span data-ttu-id="a13fe-140">Эти поля полезны для оптимизации операции чтения секторов.</span><span class="sxs-lookup"><span data-stu-id="a13fe-140">These fields are useful for optimization of the sector read operation.</span></span> <span data-ttu-id="a13fe-141">Запись *Битовая карта свободного сектора* является битовой картой, где каждый заданный бит соответствует несопоставленному сектору в блоке.</span><span class="sxs-lookup"><span data-stu-id="a13fe-141">The *Free Sector Bit Map* entry is a bit map where each set bit corresponds to an unmapped sector in the block.</span></span> <span data-ttu-id="a13fe-142">Это поле используется для повышения эффективности поиска в свободных секторов.</span><span class="sxs-lookup"><span data-stu-id="a13fe-142">This field is used to make the free sector search more efficient.</span></span> <span data-ttu-id="a13fe-143">Это поле переменной длины, требующее указания одного слова для каждых 32 секторов в блоке.</span><span class="sxs-lookup"><span data-stu-id="a13fe-143">This is a variable length field that requires one word for every 32 sectors in the block.</span></span> <span data-ttu-id="a13fe-144">Массив *Запись сопоставления секторов* содержит сведения о сопоставлении для каждого сектора в блоке.</span><span class="sxs-lookup"><span data-stu-id="a13fe-144">The *Sector Mapping Entry* array contains mapping information for each sector in the block.</span></span> <span data-ttu-id="a13fe-145">Формат каждой записи приведен ниже.</span><span class="sxs-lookup"><span data-stu-id="a13fe-145">Each entry has the following format:</span></span>

<span data-ttu-id="a13fe-146">**Запись сопоставления секторов**</span><span class="sxs-lookup"><span data-stu-id="a13fe-146">**Sector Mapping Entry**</span></span>

| <span data-ttu-id="a13fe-147">Биты</span><span class="sxs-lookup"><span data-stu-id="a13fe-147">Bit(s)</span></span> | <span data-ttu-id="a13fe-148">Значение</span><span class="sxs-lookup"><span data-stu-id="a13fe-148">Meaning</span></span>  |
| ------ | -------- |
| <span data-ttu-id="a13fe-149">31</span><span class="sxs-lookup"><span data-stu-id="a13fe-149">31</span></span>     | <span data-ttu-id="a13fe-150">Флаг допустимости.</span><span class="sxs-lookup"><span data-stu-id="a13fe-150">Valid flag.</span></span> <span data-ttu-id="a13fe-151">Если установлен, и логический сектор не состоит только из единиц, значит сопоставление допустимо.</span><span class="sxs-lookup"><span data-stu-id="a13fe-151">When set and logical sector not all ones indicates mapping is valid</span></span> |
| <span data-ttu-id="a13fe-152">30</span><span class="sxs-lookup"><span data-stu-id="a13fe-152">30</span></span>     | <span data-ttu-id="a13fe-153">Флаг устаревания.</span><span class="sxs-lookup"><span data-stu-id="a13fe-153">Obsolete flag.</span></span> <span data-ttu-id="a13fe-154">Если не установлен, это сопоставление является устаревшим или находится в процессе устаревания.</span><span class="sxs-lookup"><span data-stu-id="a13fe-154">When clear, this mapping is either obsolete or is in the process of becoming obsolete.</span></span> |
| <span data-ttu-id="a13fe-155">29</span><span class="sxs-lookup"><span data-stu-id="a13fe-155">29</span></span>     | <span data-ttu-id="a13fe-156">Запись сопоставления завершена, если этот бит равен 0.</span><span class="sxs-lookup"><span data-stu-id="a13fe-156">Mapping entry write is complete when this bit is 0</span></span> |
| <span data-ttu-id="a13fe-157">0–28</span><span class="sxs-lookup"><span data-stu-id="a13fe-157">0-28</span></span>   | <span data-ttu-id="a13fe-158">Логический сектор сопоставлен с этой физическим сектором (если не состоит только из единиц).</span><span class="sxs-lookup"><span data-stu-id="a13fe-158">Logical sector mapped to this physical sector—when not all ones.</span></span> |

<span data-ttu-id="a13fe-159">Верхний бит 32-разрядного поля (бит 31) используется для обозначения допустимости сопоставления логического сектора.</span><span class="sxs-lookup"><span data-stu-id="a13fe-159">The upper bit of the 32-bit field (bit 31) is used to indicate the logical sector mapping is valid.</span></span> <span data-ttu-id="a13fe-160">Если этот бит равен 0, информация в этой записи (и соответствующее содержимое сектора) больше недействительна.</span><span class="sxs-lookup"><span data-stu-id="a13fe-160">If this bit is 0, the information in this entry (and corresponding sector contents) is no longer valid.</span></span> <span data-ttu-id="a13fe-161">Следующий бит — 30 — используется, чтобы указать, что этот сектор находится в процессе устаревания и запись осуществляется в новый сектор.</span><span class="sxs-lookup"><span data-stu-id="a13fe-161">The next bit - bit 30 - is used to indicate this sector is in the process of becoming obsolete and a new sector is being written.</span></span> <span data-ttu-id="a13fe-162">Бит 29 используется для указания завершения записи сопоставления.</span><span class="sxs-lookup"><span data-stu-id="a13fe-162">Bit 29 is used to indicate when the mapping entry write is complete.</span></span> <span data-ttu-id="a13fe-163">Если бит 29 равен 0, запись сопоставления завершена.</span><span class="sxs-lookup"><span data-stu-id="a13fe-163">If bit 29 is 0, the mapping entry write is complete.</span></span> <span data-ttu-id="a13fe-164">Если бит 29 задан, запись сопоставления находилась в процессе записи.</span><span class="sxs-lookup"><span data-stu-id="a13fe-164">If bit 29 is set, the mapping entry was in the process of being written.</span></span> <span data-ttu-id="a13fe-165">Биты 30 и 29 используются при восстановлении после возможного отключения питания, одновременно обновляя новый сектор.</span><span class="sxs-lookup"><span data-stu-id="a13fe-165">Bits 30 and 29 are used in recovering from a potential power loss while updating a new sector mapping.</span></span> <span data-ttu-id="a13fe-166">Наконец, нижние 29 битов (28–0) содержат номер логического сектора.</span><span class="sxs-lookup"><span data-stu-id="a13fe-166">Finally, the lower 29-bits (28-0) contain the logical sector number for the sector.</span></span> <span data-ttu-id="a13fe-167">Если сектор не был сопоставлен, будут заданы биты, то есть сектор будет иметь значение 0xFFFFFFFF.</span><span class="sxs-lookup"><span data-stu-id="a13fe-167">If a sector has not been mapped, all bits will be set, i.e., it will have a value of 0xFFFFFFFF.</span></span>

## <a name="nor-driver-requirements"></a><span data-ttu-id="a13fe-168">Требования к драйверу NOR</span><span class="sxs-lookup"><span data-stu-id="a13fe-168">NOR Driver Requirements</span></span>

<span data-ttu-id="a13fe-169">Для LevelX требуется базовый драйвер флэш-памяти NOR, соответствующий базовой части флэш-памяти и реализации оборудования.</span><span class="sxs-lookup"><span data-stu-id="a13fe-169">LevelX requires an underlying NOR flash driver that is specific to the underlying flash part and hardware implementation.</span></span> <span data-ttu-id="a13fe-170">Драйвер задается для LevelX во время инициализации через API ***lx_nor_flash_open***.</span><span class="sxs-lookup"><span data-stu-id="a13fe-170">The driver is specified to LevelX during initialization via the API ***lx_nor_flash_open***.</span></span> <span data-ttu-id="a13fe-171">Прототип драйвера LevelX выглядит следующим образом.</span><span class="sxs-lookup"><span data-stu-id="a13fe-171">The prototype of the LevelX driver is:</span></span>

```c
INT nor_driver_initialize(LX_NOR_FLASH *instance);
```

<span data-ttu-id="a13fe-172">Параметр *instance* указывает блок управления NOR для LevelX.</span><span class="sxs-lookup"><span data-stu-id="a13fe-172">The "*instance*" parameter specifies the LevelX NOR control block.</span></span> <span data-ttu-id="a13fe-173">Функция инициализации драйвера отвечает за настройку всех остальных служб на уровне драйвера для связанного экземпляра LevelX.</span><span class="sxs-lookup"><span data-stu-id="a13fe-173">The driver initialization function is responsible for setting up all the other driver-level services for the associated LevelX instance.</span></span> <span data-ttu-id="a13fe-174">Ниже перечислены службы, необходимые для каждого экземпляра NOR для LevelX.</span><span class="sxs-lookup"><span data-stu-id="a13fe-174">The services required for each LevelX NOR instance are:</span></span>

- <span data-ttu-id="a13fe-175">Чтение сектора</span><span class="sxs-lookup"><span data-stu-id="a13fe-175">Read Sector</span></span>
- <span data-ttu-id="a13fe-176">Запись сектора</span><span class="sxs-lookup"><span data-stu-id="a13fe-176">Write Sector</span></span>
- <span data-ttu-id="a13fe-177">Очистка блока</span><span class="sxs-lookup"><span data-stu-id="a13fe-177">Block Erase</span></span>
- <span data-ttu-id="a13fe-178">Проверка очищенного блока</span><span class="sxs-lookup"><span data-stu-id="a13fe-178">Block Erased Verify</span></span>
- <span data-ttu-id="a13fe-179">Обработчик системных ошибок</span><span class="sxs-lookup"><span data-stu-id="a13fe-179">System Error Handler</span></span>

## <a name="driver-initialization"></a><span data-ttu-id="a13fe-180">Инициализация драйвера</span><span class="sxs-lookup"><span data-stu-id="a13fe-180">Driver Initialization</span></span>

<span data-ttu-id="a13fe-181">Эти службы устанавливаются посредством установки указателей функций в экземпляре **LX_NOR_FLASH** в функции инициализации драйвера.</span><span class="sxs-lookup"><span data-stu-id="a13fe-181">These services are setup via setting function pointers in the **LX_NOR_FLASH** instance within the driver's initialization function.</span></span> <span data-ttu-id="a13fe-182">Функция инициализации драйвера также отвечает за выполнение следующих задач:</span><span class="sxs-lookup"><span data-stu-id="a13fe-182">The driver initialization function also is responsible for:</span></span>

1. <span data-ttu-id="a13fe-183">Указание базового адреса флэш-памяти.</span><span class="sxs-lookup"><span data-stu-id="a13fe-183">Specifying the base address of the flash.</span></span>
1. <span data-ttu-id="a13fe-184">Указание общего числа блоков и числа слов на блок.</span><span class="sxs-lookup"><span data-stu-id="a13fe-184">Specifying the total number of blocks and the number of words per block.</span></span>
1. <span data-ttu-id="a13fe-185">Буфер ОЗУ для чтения одного сектора флэш-памяти (512 байт) и поддержки доступа к ULONG.</span><span class="sxs-lookup"><span data-stu-id="a13fe-185">A RAM buffer for reading one sector of flash (512 bytes) and aligned for ULONG access.</span></span>

<span data-ttu-id="a13fe-186">Функция инициализации драйвера, скорее всего, также выполнит дополнительные задачи, связанные с инициализацией устройства и (или реализации), прежде чем возвращать **LX_SUCCESS**.</span><span class="sxs-lookup"><span data-stu-id="a13fe-186">The driver initialization function likely also performs additional device and/or implementation-specific initialization duties before returning **LX_SUCCESS**.</span></span>

## <a name="driver-read-sector"></a><span data-ttu-id="a13fe-187">Чтение сектора драйвера</span><span class="sxs-lookup"><span data-stu-id="a13fe-187">Driver Read Sector</span></span>

<span data-ttu-id="a13fe-188">Служба "Чтение сектора" драйвера NOR для LevelX за чтение определенного сектора в определенном блоке флэш-памяти NOR.</span><span class="sxs-lookup"><span data-stu-id="a13fe-188">The LevelX NOR driver "read sector" service is responsible for reading a specific sector in a specific block of the NOR flash.</span></span> <span data-ttu-id="a13fe-189">Служба драйвера реализует логику проверки и исправления ошибок.</span><span class="sxs-lookup"><span data-stu-id="a13fe-189">All error checking and correcting logic is the responsibility of the driver service.</span></span> <span data-ttu-id="a13fe-190">В случае успешного выполнения драйвер NOR для LevelX возвращает **LX_SUCCESS**.</span><span class="sxs-lookup"><span data-stu-id="a13fe-190">If successful, the LevelX NOR driver returns **LX_SUCCESS**.</span></span> <span data-ttu-id="a13fe-191">В случае неудачи драйвер NOR для LevelX возвращает *LX_ERROR*.</span><span class="sxs-lookup"><span data-stu-id="a13fe-191">If not successful, the LevelX NOR driver returns *LX_ERROR*.</span></span> <span data-ttu-id="a13fe-192">Ниже приведен прототип службы "Чтение сектора" драйвера NOR для LevelX.</span><span class="sxs-lookup"><span data-stu-id="a13fe-192">The prototype of the LevelX NOR driver "read sector" service is:</span></span>

```c
INT nor_driver_read_sector(
    ULONG *flash_address,
    ULONG *destination, 
    ULONG words);
```

<span data-ttu-id="a13fe-193">*flash_address* указывает адрес логического сектора в блоке флэш-памяти NOR, а *destination* и *words* указывают место размещения содержимого сектора и количество 32-разрядных слов для считывания.</span><span class="sxs-lookup"><span data-stu-id="a13fe-193">Where "*flash_address*" specifies the address of a logical sector within a NOR flash block of memory and "*destination*" and "*words*" specify where to place the sector contents and how many 32-bit words to read.</span></span>

## <a name="driver-write-sector"></a><span data-ttu-id="a13fe-194">Запись сектора драйвера</span><span class="sxs-lookup"><span data-stu-id="a13fe-194">Driver Write Sector</span></span>

<span data-ttu-id="a13fe-195">Служба "Запись сектора" драйвера NOR для LevelX за запись определенного сектора в блоке флэш-памяти NOR.</span><span class="sxs-lookup"><span data-stu-id="a13fe-195">The LevelX NOR driver "write sector" service is responsible for writing a specific sector into a block of the NOR flash.</span></span> <span data-ttu-id="a13fe-196">Служба драйвера реализует логику проверки ошибок.</span><span class="sxs-lookup"><span data-stu-id="a13fe-196">All error checking is the responsibility of the driver service.</span></span> <span data-ttu-id="a13fe-197">В случае успешного выполнения драйвер NOR для LevelX возвращает **LX_SUCCESS**.</span><span class="sxs-lookup"><span data-stu-id="a13fe-197">If successful, the LevelX NOR driver returns **LX_SUCCESS**.</span></span> <span data-ttu-id="a13fe-198">В случае неудачи драйвер NOR для LevelX возвращает **LX_ERROR**.</span><span class="sxs-lookup"><span data-stu-id="a13fe-198">If not successful, the LevelX NOR driver returns **LX_ERROR**.</span></span> <span data-ttu-id="a13fe-199">Ниже приведен прототип службы "Запись сектора" драйвера NOR для LevelX.</span><span class="sxs-lookup"><span data-stu-id="a13fe-199">The prototype of the LevelX NOR driver "write sector" service is:</span></span>

```c
INT nor_driver_write_sector(
    ULONG *flash_address,
    ULONG *source, 
    ULONG words);
```

<span data-ttu-id="a13fe-200">*flash_address* указывает адрес логического сектора в блоке флэш-памяти NOR, а *source* и *words* указывают источник записи и число 32-разрядных слов для записи.</span><span class="sxs-lookup"><span data-stu-id="a13fe-200">Where "*flash_address*" specifies the address of a logical sector within a NOR flash block of memory and "*source*" and "*words*" specify the source of the write and how many 32-bit words to write.</span></span>

> [!NOTE]
> <span data-ttu-id="a13fe-201">LevelX использует драйвер для проверки успешной записи сектора.</span><span class="sxs-lookup"><span data-stu-id="a13fe-201">LevelX relies on the driver to verify that the write sector was successful.</span></span> <span data-ttu-id="a13fe-202">Обычно это делается путем считывания запрограммированного значения, чтобы убедиться, что оно соответствует запрошенному для записи значению.</span><span class="sxs-lookup"><span data-stu-id="a13fe-202">This is typically done by reading back the programmed value to ensure it matches the requested value to be written.</span></span>

## <a name="driver-block-erase"></a><span data-ttu-id="a13fe-203">Очистка блока драйвера</span><span class="sxs-lookup"><span data-stu-id="a13fe-203">Driver Block Erase</span></span>

<span data-ttu-id="a13fe-204">Служба "Очистка блока" драйвера NOR для LevelX отвечает за очистку указанного блока флэш-памяти NOR.</span><span class="sxs-lookup"><span data-stu-id="a13fe-204">The LevelX NOR driver "block erase" service is responsible for erasing the specified block of the NOR flash.</span></span> <span data-ttu-id="a13fe-205">В случае успешного выполнения драйвер NOR для LevelX возвращает **LX_SUCCESS**.</span><span class="sxs-lookup"><span data-stu-id="a13fe-205">If successful, the LevelX NOR driver returns **LX_SUCCESS**.</span></span> <span data-ttu-id="a13fe-206">В случае неудачи драйвер NOR для LevelX возвращает **LX_ERROR**.</span><span class="sxs-lookup"><span data-stu-id="a13fe-206">If not successful, the LevelX NOR driver returns **LX_ERROR**.</span></span> <span data-ttu-id="a13fe-207">Ниже приведен прототип службы "Очистка блока" драйвера NOR для LevelX.</span><span class="sxs-lookup"><span data-stu-id="a13fe-207">The prototype of the LevelX NOR driver "block erase" service is:</span></span>

```c
INT nor_driver_block_erase(ULONG block,  
    ULONG erase_count);
```

<span data-ttu-id="a13fe-208">*block* указывает блок NOR для очистки.</span><span class="sxs-lookup"><span data-stu-id="a13fe-208">Where "*block*" identifies which NOR block to erase.</span></span> <span data-ttu-id="a13fe-209">Параметр *erase_count* указывается в целях диагностики.</span><span class="sxs-lookup"><span data-stu-id="a13fe-209">The parameter "*erase_count*" is provided for diagnostic purposes.</span></span> <span data-ttu-id="a13fe-210">Например, драйверу может потребоваться предупредить другую часть программного обеспечения приложения о том, что число очисток превышает заданное пороговое значение.</span><span class="sxs-lookup"><span data-stu-id="a13fe-210">For example, the driver may want to alert another portion of the application software when the erase count exceeds a specific threshold.</span></span>

> [!NOTE]
> <span data-ttu-id="a13fe-211">LevelX использует драйвер для проверки всех байтов блока, чтобы убедиться, что они очищены (содержат только единицы).</span><span class="sxs-lookup"><span data-stu-id="a13fe-211">LevelX relies on the driver to examine all bytes of the block to ensure they are erased (contain all ones).</span></span>

## <a name="driver-block-erased-verify"></a><span data-ttu-id="a13fe-212">Проверка очищенного блока драйвера</span><span class="sxs-lookup"><span data-stu-id="a13fe-212">Driver Block Erased Verify</span></span>

<span data-ttu-id="a13fe-213">Служба "Проверка очищенного блока" драйвера NOR для LevelX отвечает за проверку очистки указанного блока флэш-памяти NOR.</span><span class="sxs-lookup"><span data-stu-id="a13fe-213">The LevelX NOR driver "block erased verify" service is responsible for verifying that the specified block of the NOR flash is erased.</span></span> <span data-ttu-id="a13fe-214">В случае успешной очистки драйвер NOR для LevelX возвращает **LX_SUCCESS**.</span><span class="sxs-lookup"><span data-stu-id="a13fe-214">If it is erased, the LevelX NOR driver returns **LX_SUCCESS**.</span></span> <span data-ttu-id="a13fe-215">Если блок не очищен, драйвер NOR для LevelX возвращает **LX_ERROR**.</span><span class="sxs-lookup"><span data-stu-id="a13fe-215">If the block is not erased, the LevelX NOR driver returns **LX_ERROR**.</span></span> <span data-ttu-id="a13fe-216">Ниже приведен прототип службы "Проверка очищенного блока" драйвера NOR для LevelX.</span><span class="sxs-lookup"><span data-stu-id="a13fe-216">The prototype of the LevelX NOR driver "block erased verify" service is:</span></span>

```c
INT nor_driver_block_erased_verify(ULONG block);
```

<span data-ttu-id="a13fe-217">*block* указывает, проверку очистки какого блока следует выполнить.</span><span class="sxs-lookup"><span data-stu-id="a13fe-217">Where "*block*" specifies which block to verify that it is erased.</span></span>

> [!NOTE]
> <span data-ttu-id="a13fe-218">LevelX использует драйвер для проверки всех байтов указанного блока, чтобы убедиться, что они очищены (содержат только единицы).</span><span class="sxs-lookup"><span data-stu-id="a13fe-218">LevelX relies on the driver to examine all bytes of the specified to ensure they are erased (contain all ones).</span></span>

## <a name="driver-system-error"></a><span data-ttu-id="a13fe-219">Системная ошибка</span><span class="sxs-lookup"><span data-stu-id="a13fe-219">Driver System Error</span></span>

<span data-ttu-id="a13fe-220">Служба "Обработчик системных ошибок" драйвера NOR LevelX отвечает за настройку обработки системных ошибок, обнаруженных LevelX.</span><span class="sxs-lookup"><span data-stu-id="a13fe-220">The LevelX NOR driver "system error handler" service is responsible for setting handling system errors detected by LevelX.</span></span> <span data-ttu-id="a13fe-221">Обработка в этой подпрограмме зависит от приложения.</span><span class="sxs-lookup"><span data-stu-id="a13fe-221">The processing in this routine is application dependent.</span></span> <span data-ttu-id="a13fe-222">В случае успешного выполнения драйвер NOR для LevelX возвращает **LX_SUCCESS**.</span><span class="sxs-lookup"><span data-stu-id="a13fe-222">If it is successful, the LevelX NOR driver returns **LX_SUCCESS**.</span></span> <span data-ttu-id="a13fe-223">В случае неудачи драйвер NOR для LevelX возвращает **LX_ERROR**.</span><span class="sxs-lookup"><span data-stu-id="a13fe-223">If it is not successful, the LevelX NOR driver returns **LX_ERROR**.</span></span> <span data-ttu-id="a13fe-224">Ниже приведен прототип службы "Системная ошибка" драйвера NOR для LevelX.</span><span class="sxs-lookup"><span data-stu-id="a13fe-224">The prototype of the LevelX NOR driver "system error" service is:</span></span>

```c
INT nor_driver_system_error(UINT error_code);
```

<span data-ttu-id="a13fe-225">*error_code* представляет возникшую ошибку.</span><span class="sxs-lookup"><span data-stu-id="a13fe-225">Where "*error_code*" represents the error that occurred.</span></span>

## <a name="nor-simulated-driver"></a><span data-ttu-id="a13fe-226">Имитированный драйвер NOR</span><span class="sxs-lookup"><span data-stu-id="a13fe-226">NOR Simulated Driver</span></span>

<span data-ttu-id="a13fe-227">LevelX предоставляет имитированный драйвер флэш-памяти NOR, который просто использует ОЗУ для имитации работы части флэш-памяти NOR.</span><span class="sxs-lookup"><span data-stu-id="a13fe-227">LevelX provides a simulated NOR flash driver that simply uses RAM to simulate the operation of a NOR flash part.</span></span> <span data-ttu-id="a13fe-228">По умолчанию имитированный драйвер NOR предоставляет 8 блоков флэш-памяти NOR с 16 512-байтными секторами для каждого блока.</span><span class="sxs-lookup"><span data-stu-id="a13fe-228">By default, the NOR simulated driver provides 8 NOR flash blocks with 16 512-byte sectors per block.</span></span>

<span data-ttu-id="a13fe-229">Функцией инициализации имитированного драйвера флэш-памяти NOR является ***lx_nor_flash_simulator_initialize** _. Она определена в файле _*_lx_nor_flash_simulator.c_\*\*.</span><span class="sxs-lookup"><span data-stu-id="a13fe-229">The simulated NOR flash driver initialization function is ***lx_nor_flash_simulator_initialize** _ and is defined in _*_lx_nor_flash_simulator.c_\*\*.</span></span> <span data-ttu-id="a13fe-230">Этот драйвер также является хорошим шаблоном для написания конкретных драйверов флэш-памяти NOR.</span><span class="sxs-lookup"><span data-stu-id="a13fe-230">This driver also provides a good template for writing specific NOR flash drivers.</span></span>

## <a name="nor-filex-integration"></a><span data-ttu-id="a13fe-231">Интеграция NOR с FileX</span><span class="sxs-lookup"><span data-stu-id="a13fe-231">NOR FileX Integration</span></span>

<span data-ttu-id="a13fe-232">Как упоминалось ранее, LevelX не использует для работы FileX.</span><span class="sxs-lookup"><span data-stu-id="a13fe-232">As mentioned earlier, LevelX does not rely on FileX for operation.</span></span> <span data-ttu-id="a13fe-233">Все API-интерфейсы LevelX могут вызываться непосредственно программным обеспечением приложения для хранения и извлечения необработанных данных в логические сектора, предоставляемые LevelX.</span><span class="sxs-lookup"><span data-stu-id="a13fe-233">All the LevelX APIs may be called directly by the application software to store/retrieve raw data to the logical sectors provided by LevelX.</span></span> <span data-ttu-id="a13fe-234">Однако LevelX также поддерживает FileX.</span><span class="sxs-lookup"><span data-stu-id="a13fe-234">However, LevelX also supports FileX.</span></span>

<span data-ttu-id="a13fe-235">Файл ***fx_nor_flash_simulated_driver.c*** содержит пример драйвера FileX для использования с имитацией флэш-памяти NOR.</span><span class="sxs-lookup"><span data-stu-id="a13fe-235">The file ***fx_nor_flash_simulated_driver.c*** contains an example FileX driver for use with the NOR flash simulation.</span></span> <span data-ttu-id="a13fe-236">Драйвер FileX флэш-памяти NOR для LevelX является хорошей отправной точкой написания пользовательских драйверов FileX.</span><span class="sxs-lookup"><span data-stu-id="a13fe-236">The NOR flash FileX driver for LevelX provides a good starting point for writing custom FileX drivers.</span></span>

> [!NOTE]
> <span data-ttu-id="a13fe-237">Формат флэш-памяти NOR для FileX должен представлять размер одного полного блока секторов, меньший, чем предоставляемый NOR.</span><span class="sxs-lookup"><span data-stu-id="a13fe-237">The FileX NOR flash format should be one full block size of sectors less than the NOR flash provides.</span></span> <span data-ttu-id="a13fe-238">Это позволит обеспечить лучшую производительность во время обработки выравнивания нагрузки.</span><span class="sxs-lookup"><span data-stu-id="a13fe-238">This will help ensure best performance during the wear level processing.</span></span> <span data-ttu-id="a13fe-239">Ниже приведены дополнительные способы повышения производительности записи в алгоритме выравнивания нагрузки LevelX.</span><span class="sxs-lookup"><span data-stu-id="a13fe-239">Additional techniques to improve write performance in the LevelX wear leveling algorithm include:</span></span>
> 1. <span data-ttu-id="a13fe-240">Убедитесь, что размер всех операций записи соответствует размеру ровно одного или нескольких кластеров и что все они начинаются точно с границ кластера.</span><span class="sxs-lookup"><span data-stu-id="a13fe-240">Ensure that all writes are exactly one or more clusters in size and start on exact cluster boundaries.</span></span>
> 2. <span data-ttu-id="a13fe-241">Перед выполнением крупных операций записи файлов предварительно выделите кластеры с помощью класса FileX ***fx_file_allocate*** API-интерфейсов.</span><span class="sxs-lookup"><span data-stu-id="a13fe-241">Pre-allocate clusters before performing large file write operations via the FileX ***fx_file_allocate*** class of APIs.</span></span>
> 3.  <span data-ttu-id="a13fe-242">Периодически используйте ***lx_nor_flash_defragment*** для высвобождения максимально возможного количества блоков NOR, чтобы повысить производительность записи.</span><span class="sxs-lookup"><span data-stu-id="a13fe-242">Periodic use of ***lx_nor_flash_defragment*** to free up as many NOR blocks as possible and thus improve write performance.</span></span>
> 4. <span data-ttu-id="a13fe-243">Убедитесь, что драйвер FileX включен для получения сведений об освобождении сектора, и запросы к драйверу для освобождения секторов обрабатываются в драйвере путем вызова ***lx_nor_flash_sector_release***.</span><span class="sxs-lookup"><span data-stu-id="a13fe-243">Ensure the FileX driver is enabled to receive release sector information and requests made to the driver to release sectors are handled in the driver by calling ***lx_nor_flash_sector_release***.</span></span>
