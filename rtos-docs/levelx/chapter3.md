---
title: Поддержка NAND для LevelX в ОСРВ Azure
description: Обычно флэш-память NAND используется в LevelX для больших хранилищ данных, что характерно для файловых систем.
author: philmea
ms.author: philmea
ms.date: 05/19/2020
ms.topic: article
ms.service: rtos
ms.openlocfilehash: 3286e4ea7f16b28ff55fc95a87a1e0c313ec4240
ms.sourcegitcommit: e3d42e1f2920ec9cb002634b542bc20754f9544e
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/22/2021
ms.locfileid: "104814899"
---
# <a name="chapter-3---azure-rtos-levelx-nand-support"></a><span data-ttu-id="aa691-103">Глава 3. Поддержка NAND для LevelX в ОСРВ Azure</span><span class="sxs-lookup"><span data-stu-id="aa691-103">Chapter 3 - Azure RTOS LevelX NAND support</span></span>

<span data-ttu-id="aa691-104">Обычно флэш-память NAND используется для больших хранилищ данных, что характерно для файловых систем.</span><span class="sxs-lookup"><span data-stu-id="aa691-104">NAND flash memory is commonly utilized for large data storage, which is typical of file systems.</span></span> <span data-ttu-id="aa691-105">Память NAND состоит из *блоков*.</span><span class="sxs-lookup"><span data-stu-id="aa691-105">NAND memory consists of *blocks*.</span></span> <span data-ttu-id="aa691-106">Внутри каждого блока NAND находится ряд *страниц*.</span><span class="sxs-lookup"><span data-stu-id="aa691-106">Within each NAND block is a series of *pages*.</span></span> <span data-ttu-id="aa691-107">Блоки NAND являются очищаемыми. Это означает, что очищаются все страницы в блоке NAND (задаются все единицы).</span><span class="sxs-lookup"><span data-stu-id="aa691-107">NAND blocks are erasable, which means that all pages within the NAND block are erased (set to all ones).</span></span> <span data-ttu-id="aa691-108">Каждая страница блока NAND имеет набор *свободных байтов*, используемых LevelX в ОСРВ Azure для учета, управления поврежденными блоками и обнаружения ошибок.</span><span class="sxs-lookup"><span data-stu-id="aa691-108">Each NAND block page has a set of *spare bytes* that are utilized by Azure RTOS LevelX for bookkeeping, bad block management, and error detection.</span></span> <span data-ttu-id="aa691-109">Страницы блоков NAND могут иметь разные размеры.</span><span class="sxs-lookup"><span data-stu-id="aa691-109">NAND block pages are available in a variety of sizes.</span></span> <span data-ttu-id="aa691-110">Ниже приведены наиболее распространенные размеры страниц.</span><span class="sxs-lookup"><span data-stu-id="aa691-110">The most common page sizes are:</span></span> 

| <span data-ttu-id="aa691-111">**Page Size**</span><span class="sxs-lookup"><span data-stu-id="aa691-111">**Page Size**</span></span> | <span data-ttu-id="aa691-112">**Свободные байты**</span><span class="sxs-lookup"><span data-stu-id="aa691-112">**Spare Bytes**</span></span> |
| ------------- | --------------- |
| <span data-ttu-id="aa691-113">256</span><span class="sxs-lookup"><span data-stu-id="aa691-113">256</span></span>           | <span data-ttu-id="aa691-114">8</span><span class="sxs-lookup"><span data-stu-id="aa691-114">8</span></span>               |
| <span data-ttu-id="aa691-115">512</span><span class="sxs-lookup"><span data-stu-id="aa691-115">512</span></span>           | <span data-ttu-id="aa691-116">16</span><span class="sxs-lookup"><span data-stu-id="aa691-116">16</span></span>              |
| <span data-ttu-id="aa691-117">2048</span><span class="sxs-lookup"><span data-stu-id="aa691-117">2048</span></span>          | <span data-ttu-id="aa691-118">64</span><span class="sxs-lookup"><span data-stu-id="aa691-118">64</span></span>              |

<span data-ttu-id="aa691-119">Память NAND отличается от памяти NOR тем, что не имеет прямого доступа, то есть память NAND не может быть считана непосредственно из процессора, как память NOR.</span><span class="sxs-lookup"><span data-stu-id="aa691-119">NAND memory differs from NOR memory in that there is no direct access, i.e., NAND memory cannot be read directly from the processor like NOR memory.</span></span> <span data-ttu-id="aa691-120">Запись в память NAND можно выполнять лишь ограниченное количество раз после очистки.</span><span class="sxs-lookup"><span data-stu-id="aa691-120">NAND memory can only be written to after an erase a limited number of times.</span></span> <span data-ttu-id="aa691-121">Опять же, этим она отличается от памяти NOR, запись в которую можно выполнять неограниченное количество раз при условии, что запрос на запись очищает заданные биты.</span><span class="sxs-lookup"><span data-stu-id="aa691-121">Again, this differs from NOR memory that can be written an unlimited number of times providing the write request is clearing set bits.</span></span> <span data-ttu-id="aa691-122">Наконец, уникальной особенностью флэш-памяти NAND являются свободные байты, связанные с каждой ее страницей.</span><span class="sxs-lookup"><span data-stu-id="aa691-122">Finally, the spare bytes associated with each page are unique to NAND flash.</span></span> <span data-ttu-id="aa691-123">В таблице ниже приведены стандартные конфигурации свободных байтов.</span><span class="sxs-lookup"><span data-stu-id="aa691-123">Typical spare byte configurations are as shown in the table below.</span></span>

| <span data-ttu-id="aa691-124">**Свободные байты**</span><span class="sxs-lookup"><span data-stu-id="aa691-124">**Spare Bytes**</span></span> | <span data-ttu-id="aa691-125">**Номера байтов**</span><span class="sxs-lookup"><span data-stu-id="aa691-125">**Byte numbers**</span></span> | <span data-ttu-id="aa691-126">**Конфигурация**</span><span class="sxs-lookup"><span data-stu-id="aa691-126">**Configuration**</span></span>     |
| ------------------------- | -------------- | --------------------- |
| <span data-ttu-id="aa691-127">8</span><span class="sxs-lookup"><span data-stu-id="aa691-127">8</span></span>                         | <span data-ttu-id="aa691-128">Байты 0–2:</span><span class="sxs-lookup"><span data-stu-id="aa691-128">Bytes 0-2:</span></span>     | <span data-ttu-id="aa691-129">Байты ECC</span><span class="sxs-lookup"><span data-stu-id="aa691-129">ECC bytes</span></span>             |
|                           | <span data-ttu-id="aa691-130">Байты 3, 4, 6, 7:</span><span class="sxs-lookup"><span data-stu-id="aa691-130">Bytes 3,4,6,7:</span></span> | <span data-ttu-id="aa691-131">Сопоставление секторов LevelX</span><span class="sxs-lookup"><span data-stu-id="aa691-131">LevelX Sector Mapping</span></span> |
|                           | <span data-ttu-id="aa691-132">Байт 5:</span><span class="sxs-lookup"><span data-stu-id="aa691-132">Byte 5:</span></span>        | <span data-ttu-id="aa691-133">Флаг поврежденного блока</span><span class="sxs-lookup"><span data-stu-id="aa691-133">Bad block flag</span></span>        |
| <span data-ttu-id="aa691-134">16</span><span class="sxs-lookup"><span data-stu-id="aa691-134">16</span></span>                        | <span data-ttu-id="aa691-135">Байты 0–3, 6–7:</span><span class="sxs-lookup"><span data-stu-id="aa691-135">Bytes 0-3,6-7:</span></span> | <span data-ttu-id="aa691-136">Байты ECC</span><span class="sxs-lookup"><span data-stu-id="aa691-136">ECC bytes</span></span>             |
|                           | <span data-ttu-id="aa691-137">Байты 8–11:</span><span class="sxs-lookup"><span data-stu-id="aa691-137">Bytes 8-11:</span></span>    | <span data-ttu-id="aa691-138">Сопоставление секторов LevelX</span><span class="sxs-lookup"><span data-stu-id="aa691-138">LevelX Sector Mapping</span></span> |
|                           | <span data-ttu-id="aa691-139">Байты 12–15:</span><span class="sxs-lookup"><span data-stu-id="aa691-139">Bytes 12-15:</span></span>   | <span data-ttu-id="aa691-140">Не используется</span><span class="sxs-lookup"><span data-stu-id="aa691-140">Unused</span></span>                |
|                           | <span data-ttu-id="aa691-141">Байт 5:</span><span class="sxs-lookup"><span data-stu-id="aa691-141">Byte 5:</span></span>        | <span data-ttu-id="aa691-142">Флаг поврежденного блока</span><span class="sxs-lookup"><span data-stu-id="aa691-142">Bad block flag</span></span>        |
| <span data-ttu-id="aa691-143">64</span><span class="sxs-lookup"><span data-stu-id="aa691-143">64</span></span>                        | <span data-ttu-id="aa691-144">Байт 0:</span><span class="sxs-lookup"><span data-stu-id="aa691-144">Byte 0:</span></span>        | <span data-ttu-id="aa691-145">Флаг поврежденного блока</span><span class="sxs-lookup"><span data-stu-id="aa691-145">Bad block flag</span></span>        |
|                           | <span data-ttu-id="aa691-146">Байты 2–5:</span><span class="sxs-lookup"><span data-stu-id="aa691-146">Bytes 2-5:</span></span>     | <span data-ttu-id="aa691-147">Сопоставление секторов LevelX</span><span class="sxs-lookup"><span data-stu-id="aa691-147">LevelX Sector Mapping</span></span> |
|                           | <span data-ttu-id="aa691-148">Байты 6–39:</span><span class="sxs-lookup"><span data-stu-id="aa691-148">Bytes 6-39:</span></span>    | <span data-ttu-id="aa691-149">Не используется</span><span class="sxs-lookup"><span data-stu-id="aa691-149">Unused</span></span>                |
|                           | <span data-ttu-id="aa691-150">Байты 40–63:</span><span class="sxs-lookup"><span data-stu-id="aa691-150">Bytes 40-63:</span></span>   | <span data-ttu-id="aa691-151">Байты ECC</span><span class="sxs-lookup"><span data-stu-id="aa691-151">ECC bytes</span></span>             |

<span data-ttu-id="aa691-152">LevelX использует 4 свободных байта каждой страницы NAND для отслеживания логического сектора, сопоставленного с физической страницей NAND.</span><span class="sxs-lookup"><span data-stu-id="aa691-152">LevelX Utilizes 4 of the spare bytes of each NAND page for keeping track of the logical sector mapped to the physical NAND page.</span></span> <span data-ttu-id="aa691-153">Эти 4 байта используются для представления 32-разрядного целого числа без знака в собственном формате LevelX.</span><span class="sxs-lookup"><span data-stu-id="aa691-153">These 4 bytes are used to implement a 32-bit unsigned integer with a LevelX proprietary format.</span></span> <span data-ttu-id="aa691-154">Верхний бит 32-разрядного поля (бит 31) используется для обозначения допустимости сопоставления логического сектора со страницей.</span><span class="sxs-lookup"><span data-stu-id="aa691-154">The upper bit of the 32-bit field (bit 31) is used to indicate the logical sector-to-page mapping is valid.</span></span> <span data-ttu-id="aa691-155">Если этот бит равен 0, сведения на этой странице больше не являются допустимыми.</span><span class="sxs-lookup"><span data-stu-id="aa691-155">If this bit is 0, the information in this page is no longer valid.</span></span> <span data-ttu-id="aa691-156">Следующий бит — 30 — используется, чтобы указать, что эта страница находится в процессе устаревания и запись осуществляется в новый сектор.</span><span class="sxs-lookup"><span data-stu-id="aa691-156">The next bit—bit 30—is used to indicate this page is in the process of becoming obsolete and a new sector is being written.</span></span> <span data-ttu-id="aa691-157">Бит 29 используется для указания завершения записи сопоставления.</span><span class="sxs-lookup"><span data-stu-id="aa691-157">Bit 29 is used to indicate when the mapping entry write is complete.</span></span> <span data-ttu-id="aa691-158">Если бит 29 равен 0, запись сопоставления завершена.</span><span class="sxs-lookup"><span data-stu-id="aa691-158">If bit 29 is 0, the mapping entry write is complete.</span></span> <span data-ttu-id="aa691-159">Если бит 29 задан, запись сопоставления находилась в процессе записи.</span><span class="sxs-lookup"><span data-stu-id="aa691-159">If bit 29 is set, the mapping entry was in the process of being written.</span></span> <span data-ttu-id="aa691-160">Биты 30 и 29 используются при восстановлении после возможного отключения питания и одновременно обновляют новую страницу флэш-памяти.</span><span class="sxs-lookup"><span data-stu-id="aa691-160">Bits 30 and 29 are used in recovering from a potential power loss while updating a new flash page.</span></span> <span data-ttu-id="aa691-161">Наконец, нижние 29 битов (28–0) содержат номер логического сектора для страницы.</span><span class="sxs-lookup"><span data-stu-id="aa691-161">Finally, the lower 29-bits (28-0) contain the logical sector number for the page.</span></span>

<span data-ttu-id="aa691-162">**Запись сопоставления LevelX**</span><span class="sxs-lookup"><span data-stu-id="aa691-162">**LevelX Mapping Entry**</span></span>

| <span data-ttu-id="aa691-163">Биты</span><span class="sxs-lookup"><span data-stu-id="aa691-163">Bit(s)</span></span> | <span data-ttu-id="aa691-164">Значение</span><span class="sxs-lookup"><span data-stu-id="aa691-164">Meaning</span></span> |
| ------ | ------- |
| <span data-ttu-id="aa691-165">31</span><span class="sxs-lookup"><span data-stu-id="aa691-165">31</span></span>     | <span data-ttu-id="aa691-166">Флаг допустимости.</span><span class="sxs-lookup"><span data-stu-id="aa691-166">Valid flag.</span></span> <span data-ttu-id="aa691-167">Если установлен и логический сектор не состоит только из единиц, значит, сопоставление допустимо.</span><span class="sxs-lookup"><span data-stu-id="aa691-167">When set and logical sector is not all ones indicates mapping is valid</span></span> |
| <span data-ttu-id="aa691-168">30</span><span class="sxs-lookup"><span data-stu-id="aa691-168">30</span></span>     | <span data-ttu-id="aa691-169">Флаг устаревания.</span><span class="sxs-lookup"><span data-stu-id="aa691-169">Obsolete flag.</span></span> <span data-ttu-id="aa691-170">Если не установлен, это сопоставление является устаревшим или находится в процессе устаревания.</span><span class="sxs-lookup"><span data-stu-id="aa691-170">When clear, this mapping is either obsolete or is in the process of becoming obsolete.</span></span> |
| <span data-ttu-id="aa691-171">29</span><span class="sxs-lookup"><span data-stu-id="aa691-171">29</span></span>     | <span data-ttu-id="aa691-172">Запись сопоставления завершена, если этот бит равен 0.</span><span class="sxs-lookup"><span data-stu-id="aa691-172">Mapping entry write is complete when this bit is 0</span></span> |
| <span data-ttu-id="aa691-173">0–28</span><span class="sxs-lookup"><span data-stu-id="aa691-173">0-28</span></span>   | <span data-ttu-id="aa691-174">Логический сектор сопоставлен с этой физической страницей (если не состоит только из единиц).</span><span class="sxs-lookup"><span data-stu-id="aa691-174">Logical sector mapped to this physical page—when not all ones.</span></span> |

<span data-ttu-id="aa691-175">LevelX также использует первую страницу каждого блока NAND для счетчика стираний блока, а также для вывода списка сопоставленных страниц при заполнении блока.</span><span class="sxs-lookup"><span data-stu-id="aa691-175">LevelX also utilizes the first page of each NAND block for the block erase count as well as the list of mapped pages when the block is full.</span></span> <span data-ttu-id="aa691-176">Ниже показан формат первой страницы блока NAND в LevelX.</span><span class="sxs-lookup"><span data-stu-id="aa691-176">The format of the first page of a NAND block in LevelX is shown below:</span></span>

| <span data-ttu-id="aa691-177">Формат страницы 0 блока LevelX</span><span class="sxs-lookup"><span data-stu-id="aa691-177">LevelX Block Page 0 Format</span></span> |
|:--------------------------:|
| <span data-ttu-id="aa691-178">[Число очисток блока]</span><span class="sxs-lookup"><span data-stu-id="aa691-178">[Block Erase Count]</span></span>        |
| <span data-ttu-id="aa691-179">[Сопоставление сектора страницы 1]</span><span class="sxs-lookup"><span data-stu-id="aa691-179">[Page 1 Sector Mapping]</span></span>    |
| <span data-ttu-id="aa691-180">...</span><span class="sxs-lookup"><span data-stu-id="aa691-180">...</span></span>                        |
| <span data-ttu-id="aa691-181">[Сопоставление сектора страницы "n"]</span><span class="sxs-lookup"><span data-stu-id="aa691-181">[Page "n" Sector Mapping]</span></span>  |
| <span data-ttu-id="aa691-182">[0xF0F0F0F0]</span><span class="sxs-lookup"><span data-stu-id="aa691-182">[0xF0F0F0F0]</span></span>               |

> [!NOTE]
> <span data-ttu-id="aa691-183">Сведения о сопоставлении страниц записываются только в том случае, если блок заполнен, то есть запись выполнена во все страницы блока.</span><span class="sxs-lookup"><span data-stu-id="aa691-183">The page mapping information is only written when the block is full, i.e., all the pages of the block have been written to.</span></span> <span data-ttu-id="aa691-184">Это ускоряет поиск сопоставления свободных страниц и логических секторов во время выполнения.</span><span class="sxs-lookup"><span data-stu-id="aa691-184">This enables faster search for free pages and logical sector mapping during run-time.</span></span>

## <a name="nand-bad-block-support"></a><span data-ttu-id="aa691-185">Поддержка поврежденных блоков NAND</span><span class="sxs-lookup"><span data-stu-id="aa691-185">NAND Bad Block Support</span></span>

<span data-ttu-id="aa691-186">Вероятность наличия поврежденных блоков в памяти NAND выше, чем в памяти NOR.</span><span class="sxs-lookup"><span data-stu-id="aa691-186">NAND memory is also more likely to have bad blocks than NOR memory.</span></span> <span data-ttu-id="aa691-187">В основном это обусловлено тем, что производители NAND могут увеличивать объем выпускаемой продукции, просто оставляя поврежденные блоки и указывая программному обеспечению находить возможные решения без их использования.</span><span class="sxs-lookup"><span data-stu-id="aa691-187">This is largely because NAND manufacturers can increase yield by allowing bad blocks and requiring software to work-around such bad blocks.</span></span> <span data-ttu-id="aa691-188">LevelX управляет поврежденными блоками NAND, сопоставляя их.</span><span class="sxs-lookup"><span data-stu-id="aa691-188">LevelX handles NAND bad block management by simply mapping around bad blocks.</span></span>

<span data-ttu-id="aa691-189">LevelX также предоставляет API-интерфейсы для 256-байтных кодов ECC Хэмминга для базового драйвера LevelX, которые используются для вычисления новых кодов ECC или исправления 1-битной ошибки при чтении страницы в каждом 256-байтном разделе страницы.</span><span class="sxs-lookup"><span data-stu-id="aa691-189">LevelX also provides APIs for 256-byte Hamming Error Correction Codes (ECC) for the underlying LevelX driver to utilize for calculating new ECC codes or to perform 1-bit error correction on page reading within each 256-byte section of the page.</span></span>

## <a name="nand-driver-requirements"></a><span data-ttu-id="aa691-190">Требования к драйверу NAND</span><span class="sxs-lookup"><span data-stu-id="aa691-190">NAND Driver Requirements</span></span>

<span data-ttu-id="aa691-191">Для LevelX требуется базовый драйвер флэш-памяти NAND, соответствующий базовой части флэш-памяти и реализации оборудования.</span><span class="sxs-lookup"><span data-stu-id="aa691-191">LevelX requires an underlying NAND flash driver that is specific to the underlying flash part and hardware implementation.</span></span> <span data-ttu-id="aa691-192">Драйвер задается для LevelX во время инициализации через API ***lx_nand_flash_open***.</span><span class="sxs-lookup"><span data-stu-id="aa691-192">The driver is specified to LevelX during initialization via the API ***lx_nand_flash_open***.</span></span> <span data-ttu-id="aa691-193">Прототип драйвера LevelX выглядит следующим образом.</span><span class="sxs-lookup"><span data-stu-id="aa691-193">The prototype of the LevelX driver is as follows.</span></span>

```c
INT nand_driver_initialize(LX_NAND_FLASH *instance);
```

<span data-ttu-id="aa691-194">Параметр *instance* указывает блок управления NAND для LevelX.</span><span class="sxs-lookup"><span data-stu-id="aa691-194">The *instance* parameter specifies the LevelX NAND control block.</span></span> <span data-ttu-id="aa691-195">Функция инициализации драйвера отвечает за настройку всех остальных служб на уровне драйвера для связанного экземпляра LevelX.</span><span class="sxs-lookup"><span data-stu-id="aa691-195">The driver initialization function is responsible for setting up all the other driver-level services for the associated LevelX instance.</span></span> <span data-ttu-id="aa691-196">Ниже приведены службы, необходимые для каждого экземпляра NAND для LevelX.</span><span class="sxs-lookup"><span data-stu-id="aa691-196">The services required for each LevelX NAND instance are shown in the list below.</span></span>

- <span data-ttu-id="aa691-197">Чтение страницы</span><span class="sxs-lookup"><span data-stu-id="aa691-197">Read Page</span></span>
- <span data-ttu-id="aa691-198">Запись страницы</span><span class="sxs-lookup"><span data-stu-id="aa691-198">Write Page</span></span>
- <span data-ttu-id="aa691-199">Очистка блока</span><span class="sxs-lookup"><span data-stu-id="aa691-199">Block Erase</span></span>
- <span data-ttu-id="aa691-200">Проверка очищенного блока</span><span class="sxs-lookup"><span data-stu-id="aa691-200">Block Erased Verify</span></span>
- <span data-ttu-id="aa691-201">Проверка очищенной страницы</span><span class="sxs-lookup"><span data-stu-id="aa691-201">Page Erased Verify</span></span>
- <span data-ttu-id="aa691-202">Получение состояния блока</span><span class="sxs-lookup"><span data-stu-id="aa691-202">Block Status Get</span></span>
- <span data-ttu-id="aa691-203">Здание состояния блока</span><span class="sxs-lookup"><span data-stu-id="aa691-203">Block Status Set</span></span>
- <span data-ttu-id="aa691-204">Получение дополнительных байтов блока</span><span class="sxs-lookup"><span data-stu-id="aa691-204">Block Extra Bytes Get</span></span>
- <span data-ttu-id="aa691-205">Задание дополнительных байтов блока</span><span class="sxs-lookup"><span data-stu-id="aa691-205">Block Extra Bytes Set</span></span>
- <span data-ttu-id="aa691-206">Обработчик системных ошибок</span><span class="sxs-lookup"><span data-stu-id="aa691-206">System Error Handler</span></span>

## <a name="driver-initialization"></a><span data-ttu-id="aa691-207">Инициализация драйвера</span><span class="sxs-lookup"><span data-stu-id="aa691-207">Driver Initialization</span></span>

<span data-ttu-id="aa691-208">Эти службы устанавливаются посредством установки указателей функций в экземпляре **LX_NAND_FLASH** в функции инициализации драйвера.</span><span class="sxs-lookup"><span data-stu-id="aa691-208">These services are setup via setting function pointers in the **LX_NAND_FLASH** instance within the driver's initialization function.</span></span> <span data-ttu-id="aa691-209">Функция инициализации драйвера также указывает общее количество блоков, страниц на блок, байтов на страницу и область ОЗУ, достаточную для считывания одной страницы в память.</span><span class="sxs-lookup"><span data-stu-id="aa691-209">The driver initialization function also specifies the total number of block, pages per block, bytes per page, and a RAM area large enough to read one page into memory.</span></span> <span data-ttu-id="aa691-210">Функция инициализации драйвера, скорее всего, также выполнит дополнительные задачи, связанные с инициализацией устройства и (или реализации), прежде чем возвращать **LX_SUCCESS**.</span><span class="sxs-lookup"><span data-stu-id="aa691-210">The driver initialization function likely also performs additional device and/or implementation-specific initialization duties before returning **LX_SUCCESS**.</span></span>

## <a name="driver-read-page"></a><span data-ttu-id="aa691-211">Чтение страницы драйвера</span><span class="sxs-lookup"><span data-stu-id="aa691-211">Driver Read Page</span></span>

<span data-ttu-id="aa691-212">Служба "Чтение страницы" драйвера NAND для LevelX отвечает за чтение определенной страницы в определенном блоке флэш-памяти NAND.</span><span class="sxs-lookup"><span data-stu-id="aa691-212">The LevelX NAND driver "read page" service is responsible for reading a specific page in a specific block of the NAND flash.</span></span> <span data-ttu-id="aa691-213">Служба драйвера реализует логику проверки и исправления ошибок.</span><span class="sxs-lookup"><span data-stu-id="aa691-213">All error checking and correcting logic is the responsibility of the driver service.</span></span> <span data-ttu-id="aa691-214">В случае успешного выполнения драйвер NAND для LevelX возвращает **LX_SUCCESS**.</span><span class="sxs-lookup"><span data-stu-id="aa691-214">If successful, the LevelX NAND driver returns **LX_SUCCESS**.</span></span> <span data-ttu-id="aa691-215">В случае неудачи драйвер NAND для LevelX возвращает **LX_ERROR**.</span><span class="sxs-lookup"><span data-stu-id="aa691-215">If not successful, the LevelX NAND driver returns **LX_ERROR**.</span></span> <span data-ttu-id="aa691-216">Ниже приведен прототип службы "Чтение страницы" драйвера NAND для LevelX.</span><span class="sxs-lookup"><span data-stu-id="aa691-216">The prototype of the LevelX NAND driver "read page" service is given below.</span></span>

```c
INT nand_driver_read_page(
    ULONG block,
    ULONG page,
    ULONG *destination, 
    ULONG words);
```

<span data-ttu-id="aa691-217">*block* и *page* определяют, какую страницу следует считать. *destination* и *words* указывают место размещения содержимого страницы и количество 32-разрядных слов для считывания.</span><span class="sxs-lookup"><span data-stu-id="aa691-217">Where *block* and *page* identify which page to read and *destination* and *words* specify where to place the page contents and how many 32-bit words to read.</span></span>

## <a name="driver-write-page"></a><span data-ttu-id="aa691-218">Запись страницы драйвера</span><span class="sxs-lookup"><span data-stu-id="aa691-218">Driver Write Page</span></span>

<span data-ttu-id="aa691-219">Служба "Запись страницы" драйвера NAND для LevelX отвечает за запись определенной страницы в определенном блоке флэш-памяти NAND.</span><span class="sxs-lookup"><span data-stu-id="aa691-219">The LevelX NAND driver "write page" service is responsible for writing a specific page into the specified block of the NAND flash.</span></span> <span data-ttu-id="aa691-220">Служба драйвера реализует логику проверки ошибок и вычисления ECC.</span><span class="sxs-lookup"><span data-stu-id="aa691-220">All error checking and ECC computation is the responsibility of the driver service.</span></span> <span data-ttu-id="aa691-221">В случае успешного выполнения драйвер NAND для LevelX возвращает **LX_SUCCESS**.</span><span class="sxs-lookup"><span data-stu-id="aa691-221">If successful, the LevelX NAND driver returns **LX_SUCCESS**.</span></span> <span data-ttu-id="aa691-222">В случае неудачи драйвер NAND для LevelX возвращает **LX_ERROR**.</span><span class="sxs-lookup"><span data-stu-id="aa691-222">If not successful, the LevelX NAND driver returns **LX_ERROR**.</span></span> <span data-ttu-id="aa691-223">Ниже приведен прототип службы "Записи страницы" драйвера NAND для LevelX.</span><span class="sxs-lookup"><span data-stu-id="aa691-223">The prototype of the LevelX NAND driver "write page" service is shown below.</span></span>

```c
INT nand_driver_write_page(
    ULONG block, 
    ULONG page,
    ULONG *source, 
    ULONG words);
```

<span data-ttu-id="aa691-224">*block* и *page* определяют, на какую страницу следует выполнять запись. *source* и *words* указывают источник записи и количество записываемых 32-разрядных слов.</span><span class="sxs-lookup"><span data-stu-id="aa691-224">Where *block* and *page* identify which page to write and *source* and *words* specify the source of the write and how many 32-bit words to write.</span></span>

> [!NOTE]
> <span data-ttu-id="aa691-225">При записи на страницу флэш-памяти LevelX использует драйвер для обнаружения ошибок низкого уровня. Это обычно предполагает чтение страницы и сравнение с буфером записи, чтобы гарантировать успешную запись.</span><span class="sxs-lookup"><span data-stu-id="aa691-225">LevelX relies on the driver for low-level error detection when writing to the flash page, which typically involves reading back the page and comparing with the write buffer to ensure the write was successful.</span></span>

## <a name="driver-block-erase"></a><span data-ttu-id="aa691-226">Очистка блока драйвера</span><span class="sxs-lookup"><span data-stu-id="aa691-226">Driver Block Erase</span></span>

<span data-ttu-id="aa691-227">Служба "Очистка блока" драйвера NAND для LevelX отвечает за очистку определенного блока флэш-памяти NAND.</span><span class="sxs-lookup"><span data-stu-id="aa691-227">The LevelX NAND driver "block erase" service is responsible for erasing the specified block of the NAND flash.</span></span> <span data-ttu-id="aa691-228">В случае успешного выполнения драйвер NAND для LevelX возвращает **LX_SUCCESS**.</span><span class="sxs-lookup"><span data-stu-id="aa691-228">If successful, the LevelX NAND driver returns **LX_SUCCESS**.</span></span> <span data-ttu-id="aa691-229">В случае неудачи драйвер NAND для LevelX возвращает **LX_ERROR**.</span><span class="sxs-lookup"><span data-stu-id="aa691-229">If not successful, the LevelX NAND driver returns **LX_ERROR**.</span></span> <span data-ttu-id="aa691-230">Ниже приведен прототип службы "Очистка блока" драйвера NAND для LevelX.</span><span class="sxs-lookup"><span data-stu-id="aa691-230">The prototype of the LevelX NAND driver "block erase" service is as follows.</span></span>

```c
INT nand_driver_block_erase(ULONG block,  
    ULONG erase_count);
```

<span data-ttu-id="aa691-231">*block* указывает блок для очистки.</span><span class="sxs-lookup"><span data-stu-id="aa691-231">Where *block* identifies which block to erase.</span></span> <span data-ttu-id="aa691-232">Параметр *erase_count* указывается в целях диагностики.</span><span class="sxs-lookup"><span data-stu-id="aa691-232">The parameter *erase_count* is provided for diagnostic purposes.</span></span> <span data-ttu-id="aa691-233">Например, драйверу может потребоваться предупредить другую часть программного обеспечения приложения о том, что число очисток превышает заданное пороговое значение.</span><span class="sxs-lookup"><span data-stu-id="aa691-233">For example, the driver may want to alert another portion of the application software when the erase count exceeds a specific threshold.</span></span>

> [!NOTE]
> <span data-ttu-id="aa691-234">При очистке блока LevelX использует драйвер для обнаружения ошибок низкого уровня. Это обычно предполагает проверку того, что все страницы блока состоят только из единиц.</span><span class="sxs-lookup"><span data-stu-id="aa691-234">LevelX relies on the driver for low-level error detection when the block is erased, which typically involves ensuring that all pages of the block are all ones.</span></span>

## <a name="driver-block-erased-verify"></a><span data-ttu-id="aa691-235">Проверка очищенного блока драйвера</span><span class="sxs-lookup"><span data-stu-id="aa691-235">Driver Block Erased Verify</span></span>

<span data-ttu-id="aa691-236">Служба "Проверка очищенного блока" драйвера NAND для LevelX отвечает за проверку очистки указанного блока флэш-памяти NAND.</span><span class="sxs-lookup"><span data-stu-id="aa691-236">The LevelX NAND driver "block erased verify" service is responsible for verifying that the specified block of the NAND flash is erased.</span></span> <span data-ttu-id="aa691-237">В случае успешной очистки драйвер NAND для LevelX возвращает **LX_SUCCESS**.</span><span class="sxs-lookup"><span data-stu-id="aa691-237">If it is erased, the LevelX NAND driver returns **LX_SUCCESS**.</span></span> <span data-ttu-id="aa691-238">Если блок не очищен, драйвер NAND для LevelX возвращает **LX_ERROR**.</span><span class="sxs-lookup"><span data-stu-id="aa691-238">If the block is not erased, the LevelX NAND driver returns **LX_ERROR**.</span></span> <span data-ttu-id="aa691-239">Ниже приведен прототип службы "Проверка очищенного блока" драйвера NAND для LevelX.</span><span class="sxs-lookup"><span data-stu-id="aa691-239">The prototype of the LevelX NAND driver "block erased verify" service is:</span></span>

```c
INT nand_driver_block_erased_verify(ULONG block);
```

<span data-ttu-id="aa691-240">*block* указывает, проверку очистки какого блока следует выполнить.</span><span class="sxs-lookup"><span data-stu-id="aa691-240">Where *block* specifies which block to verify that it is erased.</span></span>

> [!NOTE]
> <span data-ttu-id="aa691-241">LevelX использует драйвер для проверки всех страниц и всех байтов на каждой странице, включая свободные байты и байты данных, чтобы убедиться, что они очищены (содержат только единицы).</span><span class="sxs-lookup"><span data-stu-id="aa691-241">LevelX relies on the driver to examine all pages and all bytes of each page – including spare and data bytes – to ensure they are erased (contain all ones).</span></span>

## <a name="driver-page-erased-verify"></a><span data-ttu-id="aa691-242">Проверка очищенной страницы драйвера</span><span class="sxs-lookup"><span data-stu-id="aa691-242">Driver Page Erased Verify</span></span>

<span data-ttu-id="aa691-243">Служба "Проверка очищенной страницы" драйвера NAND для LevelX отвечает за проверку очистки указанной страницы указанного блока флэш-памяти NAND.</span><span class="sxs-lookup"><span data-stu-id="aa691-243">The LevelX NAND driver "page erased verify" service is responsible for verifying that the specified page of the specified block of the NAND flash is erased.</span></span> <span data-ttu-id="aa691-244">В случае успешной очистки драйвер NAND для LevelX возвращает **LX_SUCCESS**.</span><span class="sxs-lookup"><span data-stu-id="aa691-244">If it is erased, the LevelX NAND driver returns **LX_SUCCESS**.</span></span> <span data-ttu-id="aa691-245">Если страница не очищена, драйвер NAND для LevelX возвращает **LX_ERROR**.</span><span class="sxs-lookup"><span data-stu-id="aa691-245">If the page is not erased, the LevelX NAND driver returns **LX_ERROR**.</span></span> <span data-ttu-id="aa691-246">Ниже приведен прототип службы "Проверка очищенной страницы" драйвера NAND для LevelX.</span><span class="sxs-lookup"><span data-stu-id="aa691-246">The prototype of the LevelX NAND driver "page erased verify" service is:</span></span>

```c
INT nand_driver_page_erased_verify(
    ULONG block,  
    ULONG page);
```
<span data-ttu-id="aa691-247">*block* указывает, проверку очистки какого блока нужно выполнить, а *page* указывает, проверку очистки какой страницы нужно выполнить.</span><span class="sxs-lookup"><span data-stu-id="aa691-247">Where *block* specifies which block and *page* specifies the page to verify that it is erased.</span></span>

> [!NOTE]
> <span data-ttu-id="aa691-248">LevelX использует драйвер для проверки всех байтов на указанной странице, включая свободные байты и байты данных, чтобы убедиться, что они очищены (содержат только единицы).</span><span class="sxs-lookup"><span data-stu-id="aa691-248">LevelX relies on the driver to examine all bytes of the specified page – including spare and data bytes – to ensure they are erased (contain all ones).</span></span>

## <a name="driver-block-status-get"></a><span data-ttu-id="aa691-249">Получение состояния блока драйвера</span><span class="sxs-lookup"><span data-stu-id="aa691-249">Driver Block Status Get</span></span>

<span data-ttu-id="aa691-250">Служба "Получение состояния блока" драйвера NAND для LevelX отвечает за получение флага поврежденного блока для указанного блока флэш-памяти NAND.</span><span class="sxs-lookup"><span data-stu-id="aa691-250">The LevelX NAND driver "block status get" service is responsible for retrieving the bad block flag of the specified block of the NAND flash.</span></span> <span data-ttu-id="aa691-251">В случае успешного выполнения драйвер NAND для LevelX возвращает **LX_SUCCESS**.</span><span class="sxs-lookup"><span data-stu-id="aa691-251">If it is successful, the LevelX NAND driver returns **LX_SUCCESS**.</span></span> <span data-ttu-id="aa691-252">В случае неудачи драйвер NAND для LevelX возвращает **LX_ERROR**.</span><span class="sxs-lookup"><span data-stu-id="aa691-252">If it is not successful, the LevelX NAND driver returns **LX_ERROR**.</span></span> <span data-ttu-id="aa691-253">Ниже приведен прототип службы "Получение состояния блока" драйвера NAND для LevelX.</span><span class="sxs-lookup"><span data-stu-id="aa691-253">The prototype of the LevelX NAND driver "block status get" service is: shown below.</span></span>

```c
INT nand_driver_block_status_get(
    ULONG block,  
    UCHAR *bad_block_byte);
```

<span data-ttu-id="aa691-254">*block* указывает блок, а *bad_block_byte* указывает назначение для флага поврежденного блока.</span><span class="sxs-lookup"><span data-stu-id="aa691-254">Where *block* specifies which block and *bad_block_byte* specifies the destination for the bad block flag.</span></span>

## <a name="driver-block-status-set"></a><span data-ttu-id="aa691-255">Задание состояния блока</span><span class="sxs-lookup"><span data-stu-id="aa691-255">Driver Block Status Set</span></span>

<span data-ttu-id="aa691-256">Служба "Задание состояния блока" драйвера NAND для LevelX отвечает за установку флага поврежденного блока для указанного блока флэш-памяти NAND.</span><span class="sxs-lookup"><span data-stu-id="aa691-256">The LevelX NAND driver "block status set" service is responsible for setting the bad block flag of the specified block of the NAND flash.</span></span> <span data-ttu-id="aa691-257">В случае успешного выполнения драйвер NAND для LevelX возвращает **LX_SUCCESS**.</span><span class="sxs-lookup"><span data-stu-id="aa691-257">If it is successful, the LevelX NAND driver returns **LX_SUCCESS**.</span></span> <span data-ttu-id="aa691-258">В случае неудачи драйвер NAND для LevelX возвращает **LX_ERROR**.</span><span class="sxs-lookup"><span data-stu-id="aa691-258">If it is not successful, the LevelX NAND driver returns **LX_ERROR**.</span></span> <span data-ttu-id="aa691-259">Ниже приведен прототип службы "Задание состояния блока" драйвера NAND для LevelX.</span><span class="sxs-lookup"><span data-stu-id="aa691-259">The prototype of the LevelX NAND driver "block status set" service is:</span></span>

```c
INT nand_driver_block_status_set(
    ULONG block,
    UCHAR bad_block_byte);
```

<span data-ttu-id="aa691-260">*block* указывает блок, а *bad_block_byte* указывает значение флага поврежденного блока.</span><span class="sxs-lookup"><span data-stu-id="aa691-260">Where *block* specifies which block and *bad_block_byte* specifies the value of the bad block flag.</span></span>

## <a name="driver-block-extra-bytes-get"></a><span data-ttu-id="aa691-261">Получение дополнительных байтов</span><span class="sxs-lookup"><span data-stu-id="aa691-261">Driver Block Extra Bytes Get</span></span>

<span data-ttu-id="aa691-262">Служба "Получение дополнительных байтов" драйвера NAND для LevelX отвечает за получение дополнительных байтов, связанных с определенной страницей определенного блока флэш-памяти NAND.</span><span class="sxs-lookup"><span data-stu-id="aa691-262">The LevelX NAND driver "block extra bytes get" service is responsible for retrieving extra bytes associated with a specific page of a specific block of the NAND flash.</span></span> <span data-ttu-id="aa691-263">В случае успешного выполнения драйвер NAND для LevelX возвращает **LX_SUCCESS**.</span><span class="sxs-lookup"><span data-stu-id="aa691-263">If it is successful, the LevelX NAND driver returns **LX_SUCCESS**.</span></span> <span data-ttu-id="aa691-264">В случае неудачи драйвер NAND для LevelX возвращает **LX_ERROR**.</span><span class="sxs-lookup"><span data-stu-id="aa691-264">If it is not successful, the LevelX NAND driver returns **LX_ERROR**.</span></span> <span data-ttu-id="aa691-265">Ниже приведен прототип службы "Получение дополнительных байтов блока" драйвера NAND для LevelX.</span><span class="sxs-lookup"><span data-stu-id="aa691-265">The prototype of the LevelX NAND driver "block extra bytes get" service is:</span></span>

```c
INT nand_driver_block_extra_bytes_get(
    ULONG block,  
    ULONG page, 
    UCHAR *destination, 
    UINT size);
```

<span data-ttu-id="aa691-266">*block* указывает конкретный блок, *page* —конкретную страницу, а *destination* — назначение для дополнительных байтов.</span><span class="sxs-lookup"><span data-stu-id="aa691-266">Where *block* specifies which block, *page* specifies the specific page and *destination* specifies the destination for the extra bytes.</span></span> <span data-ttu-id="aa691-267">Параметр *size* указывает, сколько дополнительных байтов необходимо получить.</span><span class="sxs-lookup"><span data-stu-id="aa691-267">The parameter *size* specifies how many extra bytes to get.</span></span>

## <a name="driver-block-extra-bytes-set"></a><span data-ttu-id="aa691-268">Задание дополнительных байтов</span><span class="sxs-lookup"><span data-stu-id="aa691-268">Driver Block Extra Bytes Set</span></span>

<span data-ttu-id="aa691-269">Служба "Задание дополнительных байтов" драйвера NAND для LevelX отвечает за задание дополнительных байтов на определенной странице определенного блока флэш-памяти NAND.</span><span class="sxs-lookup"><span data-stu-id="aa691-269">The LevelX NAND driver "block extra bytes set" service is responsible for setting extra bytes in a specific page of a specific block of the NAND flash.</span></span> <span data-ttu-id="aa691-270">В случае успешного выполнения драйвер NAND для LevelX возвращает **LX_SUCCESS**.</span><span class="sxs-lookup"><span data-stu-id="aa691-270">If it is successful, the LevelX NAND driver returns **LX_SUCCESS**.</span></span> <span data-ttu-id="aa691-271">В случае неудачи драйвер NAND для LevelX возвращает **LX_ERROR**.</span><span class="sxs-lookup"><span data-stu-id="aa691-271">If it is not successful, the LevelX NAND driver returns **LX_ERROR**.</span></span> <span data-ttu-id="aa691-272">Ниже приведен прототип службы "Задание дополнительных байтов блока" драйвера NAND для LevelX.</span><span class="sxs-lookup"><span data-stu-id="aa691-272">The prototype of the LevelX NAND driver "block extra bytes set" service is:</span></span>

```c
INT nand_driver_block_extra_bytes_set(
    ULONG block,  
    ULONG page, 
    UCHAR *source, 
    UINT size);
```

<span data-ttu-id="aa691-273">*block* указывает конкретный блок, *page* — конкретную страницу, а *source* — источник дополнительных байтов.</span><span class="sxs-lookup"><span data-stu-id="aa691-273">Where *block* specifies which block, *page* specifies the specific page and *source* specifies the source of the extra bytes.</span></span> <span data-ttu-id="aa691-274">Параметр *size* указывает, сколько дополнительных байтов необходимо задать.</span><span class="sxs-lookup"><span data-stu-id="aa691-274">The parameter *size* specifies how many extra bytes to set.</span></span>

## <a name="driver-system-error"></a><span data-ttu-id="aa691-275">Системная ошибка</span><span class="sxs-lookup"><span data-stu-id="aa691-275">Driver System Error</span></span>

<span data-ttu-id="aa691-276">Служба "Обработчик системных ошибок" драйвера NAND LevelX отвечает за настройку обработки системных ошибок, обнаруженных LevelX.</span><span class="sxs-lookup"><span data-stu-id="aa691-276">The LevelX NAND driver "system error handler" service is responsible for setting handling system errors detected by LevelX.</span></span> <span data-ttu-id="aa691-277">Обработка в этой подпрограмме зависит от приложения.</span><span class="sxs-lookup"><span data-stu-id="aa691-277">The processing in this routine is application dependent.</span></span> <span data-ttu-id="aa691-278">В случае успешного выполнения драйвер NAND для LevelX возвращает **LX_SUCCESS**.</span><span class="sxs-lookup"><span data-stu-id="aa691-278">If it is successful, the LevelX NAND driver returns **LX_SUCCESS**.</span></span> <span data-ttu-id="aa691-279">В случае неудачи драйвер NAND для LevelX возвращает **LX_ERROR**.</span><span class="sxs-lookup"><span data-stu-id="aa691-279">If it is not successful, the LevelX NAND driver returns **LX_ERROR**.</span></span> <span data-ttu-id="aa691-280">Ниже приведен прототип службы "Системная ошибка" драйвера NAND для LevelX.</span><span class="sxs-lookup"><span data-stu-id="aa691-280">The prototype of the LevelX NAND driver "system error" service is:</span></span>

```c
INT nand_driver_system_error(
    UINT error_code,  
    ULONG block, 
    ULONG page);
```

<span data-ttu-id="aa691-281">*block* указывает конкретный блок, а *page* — конкретную страницу, на которой произошла ошибка, представленная *error_code*.</span><span class="sxs-lookup"><span data-stu-id="aa691-281">Where *block* specifies which block, and *page* specifies the specific page the error represented by *error_code* occurred.</span></span>

## <a name="nand-simulated-driver"></a><span data-ttu-id="aa691-282">Имитированный драйвер NAND</span><span class="sxs-lookup"><span data-stu-id="aa691-282">NAND Simulated Driver</span></span>

<span data-ttu-id="aa691-283">LevelX предоставляет имитированный драйвер флэш-памяти NAND, который просто использует ОЗУ для имитации работы части флэш-памяти NAND.</span><span class="sxs-lookup"><span data-stu-id="aa691-283">LevelX provides a simulated NAND flash driver that simply uses RAM to simulate the operation of a NAND flash part.</span></span> <span data-ttu-id="aa691-284">По умолчанию имитированный драйвер NAND предоставляет 8 блоков флэш-памяти NAND с 16 страницами на блок и 2048 байтами на страницу.</span><span class="sxs-lookup"><span data-stu-id="aa691-284">By default, the NAND simulated driver provides 8 NAND flash blocks with 16 pages per block and 2048 bytes per page.</span></span>

<span data-ttu-id="aa691-285">Функцией инициализации имитированного драйвера флэш-памяти NAND является **lx_nand_flash_simulator_initialize** _. Она определена в файле _\*_lx_nand_flash_simulator.c_\*\*.</span><span class="sxs-lookup"><span data-stu-id="aa691-285">The simulated NAND flash driver initialization function is ***lx_nand_flash_simulator_initialize** _ and is defined in _*_lx_nand_flash_simulator.c_\*\*.</span></span> <span data-ttu-id="aa691-286">Этот драйвер также является хорошим шаблоном для написания конкретных драйверов флэш-памяти NAND.</span><span class="sxs-lookup"><span data-stu-id="aa691-286">This driver also provides a good template for writing specific NAND flash drivers.</span></span>

## <a name="nand-filex-integration"></a><span data-ttu-id="aa691-287">Интеграция NAND с FileX</span><span class="sxs-lookup"><span data-stu-id="aa691-287">NAND FileX Integration</span></span>

<span data-ttu-id="aa691-288">Как упоминалось ранее, LevelX не использует для работы FileX.</span><span class="sxs-lookup"><span data-stu-id="aa691-288">As mentioned earlier, LevelX does not rely on FileX for operation.</span></span> <span data-ttu-id="aa691-289">Все API-интерфейсы LevelX могут вызываться непосредственно программным обеспечением приложения для хранения и извлечения необработанных данных в логические сектора, предоставляемые LevelX.</span><span class="sxs-lookup"><span data-stu-id="aa691-289">All the LevelX APIs may be called directly by the application software to store/retrieve raw data to the logical sectors provided by LevelX.</span></span> <span data-ttu-id="aa691-290">Однако LevelX также поддерживает FileX.</span><span class="sxs-lookup"><span data-stu-id="aa691-290">However, LevelX also supports FileX.</span></span>

<span data-ttu-id="aa691-291">Файл ***fx_nand_flash_simulated_driver.c*** содержит пример драйвера FileX для использования с имитацией флэш-памяти NAND.</span><span class="sxs-lookup"><span data-stu-id="aa691-291">The file ***fx_nand_flash_simulated_driver.c*** contains an example FileX driver for use with the NAND flash simulation.</span></span> <span data-ttu-id="aa691-292">Интересным аспектом этого драйвера является то, что он объединяет 512-байтовые логические секторы, обычно используемые FileX, в отдельные запросы на чтение логического сектора или запись в него к симулятору LevelX, использующему 2048-байтовые страницы.</span><span class="sxs-lookup"><span data-stu-id="aa691-292">An interesting aspect of this driver is that it combines 512-byte logical sectors typically used by FileX into single logical sector read/write requests to the LevelX simulator using 2048-byte pages.</span></span> <span data-ttu-id="aa691-293">Это приводит к более эффективному использованию флэш-памяти NAND.</span><span class="sxs-lookup"><span data-stu-id="aa691-293">This results in more efficient use of the NAND flash memory.</span></span> <span data-ttu-id="aa691-294">Драйвер FileX флэш-памяти NAND для LevelX является хорошей отправной точкой написания пользовательских драйверов FileX.</span><span class="sxs-lookup"><span data-stu-id="aa691-294">The NAND flash FileX driver for LevelX provides a good starting point for writing custom FileX drivers.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="aa691-295">Формат флэш-памяти NAND для FileX должен представлять размер одного полного блока секторов, меньший, чем предоставляемый NAND.</span><span class="sxs-lookup"><span data-stu-id="aa691-295">The FileX NAND flash format should be one full block size of sectors less than the NAND flash provides.</span></span> <span data-ttu-id="aa691-296">Это позволит обеспечить лучшую производительность во время обработки выравнивания нагрузки.</span><span class="sxs-lookup"><span data-stu-id="aa691-296">This will help ensure best performance during the wear level processing.</span></span> <span data-ttu-id="aa691-297">Ниже приведены дополнительные способы повышения производительности записи в алгоритме выравнивания нагрузки LevelX.</span><span class="sxs-lookup"><span data-stu-id="aa691-297">Additional techniques to improve write performance in the LevelX wear leveling algorithm include the following.</span></span>

1. <span data-ttu-id="aa691-298">Убедитесь, что размер всех операций записи соответствует размеру ровно одного или нескольких кластеров и что все они начинаются точно с границ кластера.</span><span class="sxs-lookup"><span data-stu-id="aa691-298">Ensure that all writes are exactly one or more clusters in size and start on exact cluster boundaries.</span></span>
1. <span data-ttu-id="aa691-299">Перед выполнением крупных операций записи файлов предварительно выделите кластеры с помощью класса FileX ***fx_file_allocate*** API-интерфейсов.</span><span class="sxs-lookup"><span data-stu-id="aa691-299">Pre-allocate clusters before performing large file write operations via the FileX ***fx_file_allocate*** class of APIs.</span></span>
1. <span data-ttu-id="aa691-300">Убедитесь, что драйвер FileX включен для получения сведений об освобождении сектора, и запросы к драйверу для освобождения секторов обрабатываются в драйвере путем вызова ***lx_nor_flash_sector_release***.</span><span class="sxs-lookup"><span data-stu-id="aa691-300">Ensure the FileX driver is enabled to receive release sector information and requests made to the driver to release sectors are handled in the driver by calling ***lx_nor_flash_sector_release***.</span></span>
1. <span data-ttu-id="aa691-301">Периодически используйте ***lx_nand_flash_defragment*** для высвобождения максимально возможного количества блоков NAND, чтобы повысить производительность записи.</span><span class="sxs-lookup"><span data-stu-id="aa691-301">Periodic use of ***lx_nand_flash_defragment*** to free up as many NAND blocks as possible and thus improve write performance.</span></span>
1. <span data-ttu-id="aa691-302">Используйте API ***lx_nand_flash_extended_cache_enable***, чтобы предоставить кэш ОЗУ различных ресурсов блоков NAND для повышения производительности.</span><span class="sxs-lookup"><span data-stu-id="aa691-302">Utilize the ***lx_nand_flash_extended_cache_enable*** API to provide a RAM cache of various NAND block resources for faster performance.</span></span>
