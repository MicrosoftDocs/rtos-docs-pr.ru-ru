---
title: Глава 2. Установка стека устройства USBX в ОСРВ Azure
description: Сведения об установке стека устройства USBX в ОСРВ Azure, а также важные рекомендации по размещению, которые необходимо учитывать перед установкой.
author: philmea
ms.author: philmea
ms.date: 5/19/2020
ms.service: rtos
ms.topic: article
ms.openlocfilehash: dd58f77130fa252be9163bd70c29f7deee400d30
ms.sourcegitcommit: 60ad844b58639d88830f2660ab0c4ff86b92c10f
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/07/2021
ms.locfileid: "106549782"
---
# <a name="chapter-2---azure-rtos-usbx-device-stack-installation"></a>Глава 2. Установка стека устройства USBX в ОСРВ Azure

## <a name="host-considerations"></a>Рекомендации по размещению

### <a name="computer-type"></a>Тип компьютера

Разработка внедренных решений обычно выполняется на главных компьютерах с Windows или Unix. После компиляции, связывания и размещения на узле приложение скачивается на целевое оборудование для выполнения.

### <a name="download-interfaces"></a>Интерфейсы скачивания

Как правило, скачивание на целевое оборудование выполняется через последовательный интерфейс RS-232, хотя становятся все более популярными параллельные интерфейсы, USB и Ethernet. Доступные варианты представлены в документации по инструменту разработки.

### <a name="debugging-tools"></a>Инструменты отладки

Отладка обычно выполняется по той же ссылке, что и скачивание образа программы. Существует множество отладчиков, от небольших программ мониторинга, выполняющихся на целевом объекте, до инструментов Background Debug Monitor (BDM) и In-Circuit Emulator (ICE). Инструмент ICE обеспечивает наиболее надежную отладку фактического целевого оборудования.

### <a name="required-hard-disk-space"></a>Требуемое место на жестком диске

Исходный код USBX поставляется в формате ASCII и требует примерно 500 КБ пространства на жестком диске главного компьютера.

### <a name="target-considerations"></a>Рекомендации по целевому оборудованию

Для USBX требуется от 24 до 64 КБ доступной только для чтения памяти (ПЗУ) на целевом оборудовании в режиме узла. Необходимый объем памяти зависит от типа используемого контроллера и классов USB, связанных с USBX. Для глобальных структур данных и пула памяти USBX требуется еще 32 КБ памяти (ОЗУ) на целевом оборудовании. Этот пул памяти также может быть скорректирован в зависимости от ожидаемого количества устройств на шине USB и типа контроллера USB. На стороне устройства USBX требуется примерно 10–12 КБ ПЗУ, в зависимости от типа контроллера устройства. Использование памяти ОЗУ зависит от типа класса, эмулируемого устройством.

USBX также использует семафоры, мьютексы и потоки ThreadX для защиты многопоточности, как и приостановку ввода-вывода и периодическую обработку для мониторинга топологии шины USB.

### <a name="product-distribution"></a>Дистрибутивы продукта

ОСРВ Azure USBX можно получить из нашего репозитория общедоступного исходного кода по адресу <https://github.com/azure-rtos/usbx/>.

Ниже приведен список основных файлов в этом репозитории.

* ***ux_api.h*** — это файл заголовка C, который содержит все системные равенства, структуры данных и прототипы служб.
* ***ux_port.h*** — это файл заголовка C, который содержит все определения и структуры данных, относящиеся к конкретным инструментам разработки.
* ***ux.lib*** — это двоичная версия библиотеки C для USBX. Она распространяется с помощью стандартного пакета.
* ***demo_usbx.c*** — это файл C, содержащий простую демоверсию для USBX.

Все имена файлов указаны в нижнем регистре. Такое соглашение об именовании упрощает преобразование команд для платформ разработки UNIX.

## <a name="usbx-installation"></a>Установка USBX

USBX устанавливается путем клонирования репозитория GitHub на локальный компьютер. Ниже приведен типичный синтаксис для создания клона репозитория USBX на вашем компьютере.

```c
    git clone https://github.com/azure-rtos/usbx
```

Вы также можете скачать копию репозитория с помощью соответствующей кнопки на главной странице GitHub.

Кроме того, вы можете найти инструкции по созданию библиотеки USBX на главной странице веб-репозитория.

Приведенные ниже общие инструкции применимы практически к любой установке.

1. Используйте тот же каталог на жестком диске узла, в который вы ранее установили ThreadX. Все имена USBX уникальны и не повлияют на предыдущую установку USBX.
1. Добавьте вызов ***ux_system_initialize** _ в начало _*_tx_application_define_** или рядом. Именно здесь инициализируются ресурсы USBX.
1. Добавьте вызов в ***ux_device_stack_initialize*.**
1. Добавьте один или несколько вызовов для инициализации требуемых классов USBX (классов узла и (или) устройств).
1. Добавьте один или несколько вызовов для инициализации контроллера устройства, доступного в системе.
1. Возможно нужно будет изменить файл tx_low_level_initialize.c, чтобы добавить инициализацию низкого уровня для оборудования и маршрутизацию векторов прерывания. Это относится к особенностям аппаратной платформы и не будет рассматриваться в этом документе.
1. Выполните компиляцию исходного кода приложения и связывание с библиотеками времени выполнения USBX и ThreadX — ux.a (или ux.lib) и tx.a (или tx.lib). Могут также потребоваться FileX и (или) NetX, если требуется скомпилировать класс хранения USB и (или) классы сети USB. Полученный пакет можно скачать на целевой объект и выполнить.

## <a name="configuration-options"></a>Параметры конфигурации

Существует ряд параметров конфигурации для сборки библиотеки USBX. Все параметры находятся в файле ***ux_user.h***.

Каждый параметр конфигурации подробно описан в списке ниже.

| Параметр&nbsp;конфигурации | Описание |
| --- | --- |
| **UX_PERIODIC_RATE** | Это значение представляет число тактов в секунду для конкретной аппаратной платформы. Значение по умолчанию — 1000. Оно задает 1 такт на миллисекунду. |
| **UX_THREAD_STACK_SIZE** | Это значение размера стека в байтах для потоков USBX. Обычно это может быть 1024 байт или 2048 байт, в зависимости от используемого процессора и хост-контроллера. |
| **UX_THREAD_PRIORITY_ENUM** | Это значение приоритета ThreadX для потоков перечисления USBX, которые отслеживают топологию шины. |
| **UX_THREAD_PRIORITY_CLASS** | Это значение приоритета ThreadX для стандартных потоков USBX. |
| **UX_THREAD_PRIORITY_KEYBOARD** | Это значение приоритета ThreadX для класса HID клавиатуры USBX. |
| **UX_THREAD_PRIORITY_DCD** | Это значение приоритета ThreadX для потока контроллера устройства. |
| **UX_NO_TIME_SLICE** | Это значение фактически определяет интервал времени, который будет использоваться для потоков. Например, если задано значение 0, то целевой порт ThreadX не будет использовать интервалы времени. |
| **UX_MAX_SLAVE_CLASS_DRIVER** | Это максимальное количество классов USBX, которые можно зарегистрировать с помощью ux_device_stack_class_register. |
| **UX_MAX_SLAVE_LUN** | Это значение представляет текущее количество логических единиц SCSI в драйвере класса хранения устройства. |
| **UX_SLAVE_CLASS_STORAGE_INCLUDE_MMC** | Если этот параметр определен, класс хранения будет работать с несколькими мультимедийными командами (MMC), например DVD-диск. |
| **UX_DEVICE_CLASS_CDC_ECM_NX_PKPOOL_ENTRIES** | Это значение представляет количество пакетов NetX в пуле пакетов класса CDC-ECM. Значение по умолчанию равно 16. |
| **UX_SLAVE_REQUEST_CONTROL_MAX_LENGTH** | Это значение представляет максимальное количество байтов, полученных в конечной точке элемента управления в стеке устройств. Значение по умолчанию — 256 байт, но его можно уменьшить в окружении с ограничением памяти. |
| **UX_DEVICE_CLASS_HID_EVENT_BUFFER_LENGTH** | Это значение представляет максимальную длину в байтах для отчета HID. |
| **UX_DEVICE_CLASS_HID_MAX_EVENTS_QUEUE** | Это значение представляет максимальное количество отчетов HID, которые могут быть поставлены в очередь одновременно. |
| **UX_SLAVE_REQUEST_DATA_MAX_LENGTH** | Это значение представляет максимальное количество байтов, полученных в групповой конечной точке в стеке устройств. Значение по умолчанию — 4096 байт, но его можно уменьшить в окружении с ограничением памяти. |

## <a name="source-code-tree"></a>Дерево исходного кода

Файлы USBX предоставлены в нескольких каталогах.

![Дерево исходного кода](media/usbx-device-stack/source-code-tree.png)

Чтобы файлы можно было распознавать по именам, принято приведенное ниже соглашение.

| Имя суффикса файла  | Описание файла                          |
| ----------------- | ----------------------------------------- |
| ux_host_stack   | Основные файлы стека узлов USBX                |
| ux_host_class   | Файлы классов стека узлов USBX             |
| ux_hcd           | Файлы драйвера контроллера стека узлов USBX   |
| ux_device_stack | Основные файлы стека устройств USBX              |
| ux_device_class | Файлы классов стека устройств USBX           |
| ux_dcd           | Файлы драйвера контроллера стека устройств USBX |
| ux_otg           | Файлы, связанные с драйвером контроллера OTG для USBX  |
| ux_pictbridge    | Файлы PictBridge для USBX                     |
| ux_utility       | Служебные функции USBX                    |
| demo_usbx        | Демонстрационные файлы для USBX              |

## <a name="initialization-of-usbx-resources"></a>Инициализация ресурсов USBX

В USBX имеется собственный диспетчер памяти. Память для USBX необходимо выделить перед инициализацией узла или устройства USBX. Диспетчер памяти USBX поддерживает системы с кэшированием памяти.

Приведенная ниже функция инициализирует ресурсы памяти USBX: 128 КБ обычной памяти без отдельного пула для некэшируемой памяти:

```c
/* Initialize USBX Memory */
ux_system_initialize(memory_pointer,(128*1024),UX_NULL,0);
```

Прототип для ux_system_initialize выглядит следующим образом:

```c
UINT ux_system_initialize(VOID *regular_memory_pool_start,
        ULONG regular_memory_size,
        VOID *cache_safe_memory_pool_start,
        ULONG cache_safe_memory_size);
```

Входные параметры:

| Параметр                          | Описание                             |
| ---------------------------------- | --------------------------------------- |
| VOID *regular_memory_pool_start    | Начало пула обычной памяти    |
| ULONG regular_memory_size          | Размер пула обычной памяти         |
| VOID *cache_safe_memory_pool_start | Начало пула некэшируемой памяти |
| ULONG cache_safe_memory_size       | Размер пула некэшируемой памяти      |

Не для всех систем нужно определять некэшируемую память. В такой системе во время инициализации для указателя памяти будут переданы значения UX_NULL, а размер пула будет равен 0. После этого USBX будет использовать стандартный пул памяти вместо некэшируемого пула.

В системе, где обычная память не является некэшируемой и для контроллера требуется память с прямым доступом (DMA), необходимо определить пул памяти в некэшируемой зоне.

## <a name="uninitialization-of-usbx-resources"></a>Отмена инициализации ресурсов USBX

Работу экземпляра USBX можно завершить, освободив его ресурсы. Перед завершением работы экземпляра USBX нужно правильно завершить работу всех ресурсов классов и контроллеров. Приведенная ниже функция отменяет инициализацию ресурсов памяти USBX.

```c
/* Unitialize USBX Resources */

ux_system_uninitialize();
```

Прототип для ux_system_initialize выглядит следующим образом:

```c
UINT ux_system_uninitialize(VOID);
```

## <a name="definition-of-usb-device-controller"></a>Определение контроллера USB-устройства

В режиме устройства в любое время может быть определен только один контроллер USB-устройства. Это определение должно находиться в файле инициализации приложения. Следующая строка выполняет определение универсального контроллера USB:

```c
ux_dcd_controller_initialize(0x7BB00000, 0, 0xB7A00000);
```

Инициализация USB-устройства имеет следующий прототип:

```c
UINT ux_dcd_controller_initialize(ULONG dcd_io,
    ULONG dcd_irq, ULONG dcd_vbus_address);
```

Поддерживаются следующие параметры:

| Параметр               | Описание                      |
| ------------------------ | -------------------------------- |
| ULONG dcd_io            | Адрес ввода-вывода контроллера     |
| ULONG dcd_irq           | Прерывание, используемое контроллером |
| ULONG dcd_vbus_address | Адрес VBUS GPIO         |

В следующем примере показана инициализация USBX в режиме устройства с классом запоминающих устройств и универсальным контроллером:

```c
/* Initialize USBX Memory */

ux_system_initialize(memory_pointer,(128*1024), 0, 0);

/* The code below is required for installing the device portion of USBX */
status = ux_device_stack_initialize(&device_framework_high_speed,
    DEVICE_FRAMEWORK_LENGTH_HIGH_SPEED, &device_framework_full_speed,
    DEVICE_FRAMEWORK_LENGTH_FULL_SPEED, &string_framework,
    STRING_FRAMEWORK_LENGTH, &language_id_framework,
    LANGUAGE_ID_FRAMEWORK_LENGTH, UX_NULL);

/* If status equals UX_SUCCESS, installation was successful. */

/* Store the number of LUN in this device storage instance: single LUN. */
storage_parameter.ux_slave_class_storage_parameter_number_lun = 1;

/* Initialize the storage class parameters for reading/writing to the Flash Disk. */
storage_parameter.ux_slave_class_storage_parameter_lun[0].ux_slave_class_storage_media_last_lba = 0x1e6bfe;
storage_parameter.ux_slave_class_storage_parameter_lun[0].ux_slave_class_storage_media_block_length = 512;
storage_parameter.ux_slave_class_storage_parameter_lun[0].ux_slave_class_storage_media_type = 0;
storage_parameter.ux_slave_class_storage_parameter_lun[0].ux_slave_class_storage_media_removable_flag = 0x80;
storage_parameter.ux_slave_class_storage_parameter_lun[0].ux_slave_class_storage_media_read = tx_demo_thread_flash_media_read;
storage_parameter.ux_slave_class_storage_parameter_lun[0].ux_slave_class_storage_media_write = tx_demo_thread_flash_media_write;
storage_parameter.ux_slave_class_storage_parameter_lun[0].ux_slave_class_storage_media_status = tx_demo_thread_flash_media_status;

/* Initialize the device storage class. The class is connected with interface 0 */
status = ux_device_stack_class_register(ux_system_slave_class_storage_name ux_device_class_storage_entry,
    ux_device_class_storage_thread,0, (VOID *)&storage_parameter);

/* Register the device controllers available in this system */
status = ux_dcd_controller_initialize(0x7BB00000, 0, 0xB7A00000);

/* If status equals UX_SUCCESS, registration was successful. */
```

## <a name="troubleshooting"></a>Устранение неполадок

USBX поставляется с демонстрационным файлом и окружением моделирования. Рекомендуется сначала запустить демонстрационную систему — на целевом оборудовании или соответствующей демонстрационной платформе.

## <a name="usbx-version-id"></a>Идентификатор версии USBX

Сведения о текущей версии USBX доступны во время выполнения как пользователю, так и программному обеспечению приложения. Программист может получить данные о версии USBX, ознакомившись с файлом ***ux_port.h** _. Кроме того, этот файл содержит журнал версий для соответствующей платформы. Программное обеспечение приложения может получить версию USBX, проанализировав глобальную строку _ *_ _ux_version_id_* _, которая определена в файле _*_ux_port.h_**.
