---
title: Глава 3. Функциональные компоненты стека устройств USBX
description: В этой главе приведено описание высокопроизводительного внедренного в USBX стека USB-устройств с точки зрения функциональности.
author: philmea
ms.author: philmea
ms.date: 5/19/2020
ms.service: rtos
ms.topic: article
ms.openlocfilehash: 104badcbf1ec682cd8b09008578ba91768834d694473ecccf59e35637dfd9f3c
ms.sourcegitcommit: 93d716cf7e3d735b18246d659ec9ec7f82c336de
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/07/2021
ms.locfileid: "116791363"
---
# <a name="chapter-3---functional-components-of-usbx-device-stack"></a>Глава 3. Функциональные компоненты стека устройств USBX

В этой главе приведено описание высокопроизводительного внедренного в USBX стека USB-устройств с точки зрения функциональности.

## <a name="execution-overview"></a>Общие сведения о выполнении

USBX для устройства включает несколько компонентов:

- Инициализация
- вызовы интерфейса приложения;
- классы устройств;
- стек USB-устройств;
- контроллер устройства;
- диспетчер VBUS.

Стек устройств USBX показан на схеме ниже.

![Стек устройств USBX](media/usbx-device-stack/usbx-device-stack.png)

### <a name="initialization"></a>Инициализация

Чтобы активировать USBX, нужно вызвать функцию ***ux_system_initialize***. Эта функция инициализирует ресурсы памяти USBX.

Чтобы активировать аппаратные ресурсы устройства USBX, необходимо вызвать функцию ***ux_device_stack_initialize***. Эта функция в свою очередь инициализирует все ресурсы, используемые стеком устройств USBX, например потоки ThreadX, мьютексы и семафоры.

Активация контроллера USB-устройств и одного или нескольких классов USB выполняется уже при инициализации приложения. В отличие от компьютера с USB, на стороне устройства в любое время может работать только один драйвер контроллера USB. Если классы зарегистрированы в стеке и функция инициализации контроллеров устройств вызвана, шина активируется и стек будет реагировать на команды сброса шины и перечисления узла.

### <a name="application-interface-calls"></a>Вызовы интерфейса приложения

В USBX доступно два уровня API:

- API стека USB-устройств;
- API классов USB-устройств.

Как правило, приложение USBX не должно вызывать API стека USB-устройств. Большинство приложений обращаются только к API классов USB.

### <a name="usb-device-stack-apis"></a>API стека USB-устройств

API стека устройств отвечают за регистрацию компонентов устройств USBX, таких как классы и структура устройств.

### <a name="usb-device-class-apis"></a>API классов USB-устройств

Интерфейсы API классов для каждого класса USB сильно различаются. Большинство популярных API для классов USB предоставляют такие возможности, как выключение/включение устройства и считывание/запись на устройстве. Эти API по своей природе похожи на API на стороне компьютера.

## <a name="device-framework"></a>Структура устройства

Сторона USB-устройства отвечает за определение структуры устройства. Структура устройства разделяется на три категории, как описано в следующих разделах.

### <a name="definition-of-the-components-of-the-device-framework"></a>Определение компонентов структуры устройства

Определение каждого компонента в структуре устройства зависит от особенностей устройства и используемых им ресурсов. Основные категории:

- дескриптор устройства;
- дескриптор конфигурации;
- дескриптор интерфейса;
- дескриптор конечной точки.

USBX поддерживает определение компонентов устройства для спецификаций High Speed и Full Speed (Low Speed рассматривается как Full Speed). Это позволяет устройству менять режим работы при подключении к компьютеру в зависимости от интерфейса (High Speed или Full Speed). Отличаются обычно размер каждой конечной точки и потребляемая устройством энергия.

Определение компонента устройства принимает вид байтовой строки, соответствующей USB-спецификации. Определение не фрагментируется, а порядок, в котором структура представляется в памяти, не отличается от порядка, в котором структура возвращается компьютеру при перечислении.

Ниже приведен пример структуры устройства для флэш-накопителя USB с подключением High Speed.

```c
#define DEVICE_FRAMEWORK_LENGTH_HIGH_SPEED 60
UCHAR device_framework_high_speed[] = {
    /* Device descriptor */
    0x12, 0x01, 0x00, 0x02, 0x00, 0x00, 0x00, 0x40, 0x0a, 0x07, 0x25, 0x40, 0x01, 0x00, 0x01, 0x02, 0x03, 0x01,

    /* Device qualifier descriptor */
    0x0a, 0x06, 0x00, 0x02, 0x00, 0x00, 0x00, 0x40, 0x01, 0x00,

    /* Configuration descriptor */
    0x09, 0x02, 0x20, 0x00, 0x01, 0x01, 0x00, 0xc0, 0x32,

    /* Interface descriptor */
    0x09, 0x04, 0x00, 0x00, 0x02, 0x08, 0x06, 0x50, 0x00,

    /* Endpoint descriptor (Bulk Out) */
    0x07, 0x05, 0x01, 0x02, 0x00, 0x02, 0x00,

    /* Endpoint descriptor (Bulk In) */
    0x07, 0x05, 0x82, 0x02, 0x00, 0x02, 0x00
};
```

### <a name="definition-of-the-strings-of-the-device-framework"></a>Определение строк структуры устройства

Строки необязательны на устройстве. Их назначение — сообщить компьютеру с USB о производителе устройства, имени продукта и номере редакции с помощью строк в формате Юникода.

Основные строки представляют собой индексы, внедренные в дескрипторы устройств. Дополнительные индексы строк можно внедрить в отдельные интерфейсы.

Если приведенная выше структура устройства включает три строковых индекса, внедренных в дескриптор устройства, строковое определение структуры будет выглядеть примерно так, как показано в этом примере кода.

```c
/* String Device Framework:
    Byte 0 and 1: Word containing the language ID: 0x0904 for US
    Byte 2 : Byte containing the index of the descriptor
    Byte 3 : Byte containing the length of the descriptor string
*/

#define STRING_FRAMEWORK_LENGTH 38
UCHAR string_framework[] = {
    /* Manufacturer string descriptor: Index 1 */
    0x09, 0x04, 0x01, 0x0c,
    0x45, 0x78, 0x70, 0x72, 0x65, 0x73, 0x20, 0x4c,
    0x6f, 0x67, 0x69, 0x63,

    /* Product string descriptor: Index 2 */
    0x09, 0x04, 0x02, 0x0c,
    0x4D, 0x4C, 0x36, 0x39, 0x36, 0x35, 0x30, 0x30,
    0x20, 0x53, 0x44, 0x4B,

    /* Serial Number string descriptor: Index 3 */
    0x09, 0x04, 0x03, 0x04,
    0x30, 0x30, 0x30, 0x31
};
```

Если нужно использовать разные строки для отдельных скоростных режимов, также потребуются и разные индексы, так как они не зависят от скорости.

При кодировании строки используется формат Юникода. Дополнительные сведения о стандарте кодирования "Юникод" см. в следующей публикации:

*The Unicode Standard, Worldwide Character Encoding, Version 1., Volumes 1 and 2, The Unicode Consortium, Addison-Wesley Publishing Company, Reading MA* (Юникод — международный стандарт кодирования символов).

### <a name="definition-of-the-languages-supported-by-the-device-for-each-string"></a>Определение языков, поддерживаемых устройством для каждой строки

USBX может поддерживать различные языки, хотя по умолчанию используется английский. Определение каждого языка для строковых дескрипторов представлено в виде массива определений языков следующим образом.

```c
#define LANGUAGE_ID_FRAMEWORK_LENGTH 2
UCHAR language_id_framework[] = {
    /* English. */
    0x09, 0x04
};
```

Для поддержки дополнительных языков просто добавьте двухбайтовое определение кода языка после кода для английского языка. Коды языков определены корпорацией Майкрософт в следующем документе:

*Developing International Software for Windows 95 and Windows NT, Nadine Kano, Microsoft Press, Redmond WA* (Разработка международного программного обеспечения для Windows 95 и Windows NT)

## <a name="vbus-manager"></a>Диспетчер VBUS

В большинстве архитектур USB-устройств VBUS не является частью ядра USB-устройства, а подключается к внешнему интерфейсу GPIO, который отслеживает линейный сигнал.

Поэтому VBUS необходимо управлять отдельно от драйвера контроллера устройств.

Именно приложение должно предоставить контроллеру устройств адрес ввода-вывода для VBUS. VBUS нужно инициализировать до инициализации контроллера устройств.

Некоторые спецификации платформы для мониторинга VBUS позволяют передать драйверу контроллера обработку сигналов VBUS после инициализации ввода-вывода для VBUS или, если это возможно, приложение должно предоставить код для обработки сигналов VBUS.

Если приложение должно обрабатывать сигналы VBUS самостоятельно, ему нужно вызывать функцию ***ux_device_stack_disconnect***, когда оно определяет, что устройство было отключено. Сообщать контроллеру о подключении устройства необязательно, так как контроллер включается автоматически при обнаружении сигнала активации или отмены BUS RESET.
