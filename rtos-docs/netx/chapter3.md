---
title: Глава 3. Функциональные компоненты ОСРВ Azure NetX
description: В этой главе описывается высокопроизводительный стек TCP/IP ОСРВ Azure NetX с точки зрения функциональности.
author: philmea
ms.author: philmea
ms.date: 05/19/2020
ms.topic: article
ms.service: rtos
ms.openlocfilehash: 4ebb002bc82d13210acf8db44cafb141d33a1b45fa8710295437e2dd15cbcf22
ms.sourcegitcommit: 93d716cf7e3d735b18246d659ec9ec7f82c336de
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/07/2021
ms.locfileid: "116784410"
---
# <a name="chapter-3---functional-components-of-azure-rtos-netx"></a>Глава 3. Функциональные компоненты ОСРВ Azure NetX

В этой главе описывается высокопроизводительный стек TCP/IP ОСРВ Azure NetX с точки зрения функциональности. 

## <a name="execution-overview"></a>Общие сведения о выполнении

В приложении NetX существует пять типов выполнения программы: инициализация, вызовы интерфейса приложения, внутренний IP-поток, периодические IP-таймеры и драйвер сети.

> [!IMPORTANT]
> NetX использует выполнение потока, приостановку, периодические таймеры и средства взаимного исключения системы ThreadX, поэтому ее необходимо установить.

### <a name="initialization"></a>Инициализация

Службу ***nx_system_initialize** _ необходимо вызывать до вызова любой другой службы NetX. Инициализацию системы можно вызвать с помощью подпрограммы _ *_tx_application_define_** или с помощью потоков приложения.

После возврата ***nx_system_initialize** _ система готова к созданию пулов пакетов и IP-экземпляров. Так как для создания IP-экземпляра требуется пул пакетов по умолчанию, на момент его создания должен существовать по крайней мере один пул пакетов NetX. Создавать пулы пакетов и IP-экземпляры разрешено из функции инициализации ThreadX _ *_tx_application_define_** и из потоков приложения.

С точки зрения внутренних процессов создание IP-экземпляра состоит из двух частей. Первая часть выполняется в контексте вызывающего объекта из ***tx_application_define*** либо из контекста потока приложения. Она предусматривает настройку структуры данных IP и создание различных ресурсов IP, в том числе внутреннего IP-потока. Вторая часть осуществляется во время начального выполнения из внутреннего IP-потока. Именно на этом этапе первый раз вызывается драйвер сети, предоставляемый при выполнении первой части процесса создания IP-экземпляра. Вызов сетевого драйвера из внутреннего IP-потока позволяет драйверу выполнять операции ввода-вывода и приостанавливать выполнение при обработке инициализации. Когда сетевой драйвер возвращает результат обработки инициализации, создание IP-экземпляра завершается.

> [!IMPORTANT]
> Для получения сведений об IP-экземпляре и состоянии его основного интерфейса можно воспользоваться службой NetX **nx_ip_status_check**. В числе сведений о состоянии можно получить информацию о том, был ли инициализирован и включен канал и разрешен ли IP-адрес. Эти сведения используются для синхронизации потоков приложения, необходимых для использования только что созданного IP-экземпляра. Сведения, касающиеся систем с множественной адресацией, см. ниже в разделе "Поддержка множественной адресации". Для получения сведений об указанном интерфейсе можно воспользоваться службой **nx_ip_interface_status_check**.

### <a name="application-interface-calls"></a>Вызовы интерфейса приложения

Вызовы из приложения в основном выполняются из потоков приложений, работающих под управлением ОСРВ ThreadX. Однако некоторые службы инициализации, создания и включения могут вызваться из ***tx_application_define***. В разделах "Допустимые источники" главы 4 указывается, откуда можно вызывать каждую службу NetX.

В большинстве случаев обработка ресурсоемких операций, таких как вычисление контрольных сумм, выполняется в контексте вызывающего потока и не приводит к блокированию доступа других потоков к IP-экземпляру. Например, при передаче перед вызовом базовой функции отправки IP-пакетов в службе ***nx_udp_socket_send*** выполняется расчет контрольной суммы UDP. Для полученного пакета контрольная сумма UDP вычисляется в службе ***nx_udp_socket_receive***, которая выполняется в контексте потока приложения. Это помогает предотвратить приостановку обработки сетевых запросов с более высоким приоритетом в связи с ресурсоемким вычислением контрольной суммы в потоках с более низким приоритетом.

Такие значения, как IP-адреса и номера портов, передаются функциям API в соответствии с порядком байтов узла. Для внутренних целей эти значения также хранятся в соответствии с этим порядком. Это позволяет разработчикам легко просматривать значения с помощью отладчика. Если эти значения запрограммированы в кадре для передачи, они преобразуются в сетевой порядок байтов.

### <a name="internal-ip-thread"></a>Внутренний IP-поток

Как уже упоминалось, у каждого IP-экземпляра в NetX имеется собственный поток. Приоритет и размер стека внутреннего IP-потока определяются в службе ***nx_ip_create***. Внутренний IP-поток создается в режиме готовности к выполнению. Если IP-поток имеет более высокий приоритет, чем вызывающий поток, при вызове операции создания IP-адреса может произойти вытеснение.

Точка входа во внутренний IP-поток находится во внутренней функции ***_nx_ip_thread_entry***. При запуске внутренний IP-поток сначала выполняет инициализацию драйвера сети, которая заключается в выполнении трех вызовов драйвера сети конкретного приложения. Первый вызов обеспечивает присоединение сетевого драйвера к IP-экземпляру. Далее следует вызов инициализации, который позволяет сетевому драйверу пройти процесс инициализации. После того как сетевой драйвер возвращается из состояния инициализации (он может быть приостановлен, ожидая правильной настройки оборудования), внутренний IP-поток снова вызывает его, чтобы включить канал. 

После возврата сетевого драйвера из вызова включения канала внутренний IP-поток переходит в бесконечный цикл проверки для различных событий, требующих обработки для данного IP-экземпляра. События, обрабатываемые в этом цикле, включают отложенное получение IP-пакетов, сборку фрагментов IP-пакетов, обработку проверки связи ICMP, обработку IGMP, обработку очереди пакетов TCP, периодическую обработку TCP, истечение времени ожидания сборки фрагментов IP-адресов и периодическую обработку IGMP. К событиям также относятся действия по разрешению адресов: обработка ARP-пакетов и периодическая обработка ARP в IP-сети.

> [!NOTE]
> *Функции обратного вызова NetX, включая обратные вызовы операций ожидания передачи данных и отключения, вызываются не из исходного вызывающего потока, а из внутреннего IP-потока. В приложении должны быть приняты меры для предотвращения приостановки внутри любой функции обратного вызова NetX.*

### <a name="ip-periodic-timers"></a>Периодические таймеры IP-экземпляра
Для каждого IP-экземпляра используется два периодических таймера ThreadX. Первый — это секундный таймер для времени ожидания ARP, IGMP и TCP, а также для инициализации обработки повторной сборки фрагмента IP-пакета. Второй таймер — это таймер на 100 мс, позволяющий управлять временем ожидания повторной отправки TCP-пакетов.

### <a name="network-driver"></a>Сетевой драйвер
Каждый IP-экземпляр в NetX имеет основной интерфейс, который определяется драйвером устройства, указанным в службе ***nx_ip_create***. Сетевой драйвер отвечает за обработку различных запросов NetX, в том числе запросов на передачу и получение пакетов, а также запросов состояния и управления.

В системах с множественной адресацией IP-экземпляр имеет несколько интерфейсов, у каждого из которых имеется соответствующий сетевой драйвер, выполняющий эти задачи для соответствующего интерфейса.

Сетевой драйвер также должен обрабатывать асинхронные события, происходящие на носителе. Асинхронные события с носителя включают в себя получение пакетов, завершение передачи пакетов и изменение состояния. NetX предоставляет сетевой драйвер с несколькими функциями доступа для управления различными событиями. Эти функции предназначены для вызова из части сетевого драйвера, связанной с подпрограммой обработки прерываний. Для IP-сетей сетевой драйвер должен пересылать все полученные ARP-пакеты внутренней функции * **_nx_arp_packet_deferred_receive** _. Все пакеты RARP должны перенаправляться на внутреннюю функцию _ *_ _nx_rarp_packet_deferred_receive_* _. Для IP-пакетов существует два варианта. Если требуется быстрая отправка IP-пакетов, входящие IP-пакеты должны перенаправляться в _ *_ _nx_ip_packet_receive_* _ для немедленной обработки. Это значительно повышает производительность NetX при обработке IP-пакетов. В противном случае сетевой драйвер должен пересылать IP-пакеты в _*_ _nx_ip_packet_deferred_receive_**. Эта служба помещает IP-пакет в очередь отложенной обработки, где он обрабатывается внутренним IP-потоком, что обеспечивает минимальное время обработки ISR.

Сетевой драйвер также может отложить обработку прерываний для выполнения вне контекста IP-потока. В этом режиме ISR сохраняет необходимые сведения, вызывает внутреннюю функцию ***_nx_ip_driver_deferred_processing*** и подтверждает использование контроллера прерываний. Эта служба уведомляет IP-поток о том, что необходимо запланировать обратный вызов драйвера устройства для завершения обработки события, вызывающего прерывание.

Некоторые сетевые контроллеры способны выполнять вычисление и проверку контрольной суммы заголовков TCP/IP аппаратными средствами, не расходуя ценные ресурсы ЦП. Чтобы воспользоваться преимуществами возможностей оборудования, NetX предоставляет параметры для включения и отключения различных вычислений контрольной суммы программными средствами во время компиляции, а также включения и отключения вычислений контрольной суммы во время выполнения. Более подробные сведения о создании сетевых драйверов NetX см. в главе 5 [Сетевые драйверы NetX](chapter5.md).

### <a name="multihome-support"></a>Поддержка множественной адресации
NetX поддерживает системы, подключенные к нескольким физическим устройствам с помощью одного IP-экземпляра. Каждый физический интерфейс назначается блоку управления взаимодействием в IP-экземпляре. Приложения, желающие использовать систему с множественной адресацией, должны задать для **NX_MAX_PHSYCIAL_INTERFACES** значение, равное числу физических устройств, подключенных к системе, и перестроить библиотеку NetX. По умолчанию значение **NX_MAX_PHYSICAL_INTERFACES** равно единице, что обеспечивает создание одного блока управления взаимодействием в IP-экземпляре.

Приложение NetX создает один экземпляр IP-адреса для основного устройства с помощью службы ***nx_ip_create** _. Для каждого дополнительного сетевого устройства приложение подключает устройство к IP-экземпляру с помощью службы _ *_nx_ip_interface_attach_**.

Каждая структура сетевого интерфейса содержит подмножество сетевых сведений о сетевом интерфейсе, который содержится в блоке управления IP-экземпляра, в том числе IP-адрес интерфейса, маску подсети, размер MTU IP-экземпляра и сведения об адресе MAC-уровня.

> [!IMPORTANT]
> *NetX с поддержкой множественной адресации обеспечивает обратную совместимость с более ранними версиями NetX. Службы, которые не принимают явные сведения об интерфейсе, используют в качестве устройства по умолчанию основное сетевое устройство.*

Первичный интерфейс имеет нулевой индекс в списке IP-экземпляров. Каждому последующему устройству, подключенному к IP-экземпляру, присваивается следующий индекс.

Все службы протокола верхнего уровня, для которых включен экземпляр IP-адресов, в том числе TCP, UDP, ICMP и IGMP, доступны для всех подключенных устройств.

В большинстве случаев NetX может определить оптимальный исходный адрес, который будет использоваться при передаче пакета. Адрес источника выбирается на основе адреса назначения. Чтобы разрешить приложениям указывать конкретный адрес источника для использования в тех случаях, когда наиболее подходящий адрес источника не может быть определен по адресу назначения, предоставляются службы NetX. Например, в системе с множественной адресацией приложение должно отправлять пакет на широковещательный IP-адрес или адрес назначения многоадресной рассылки.

Ниже перечислены службы, предназначенные специально для разработки приложений с множественной адресацией.

*nx_igmp_multicast_interface_join nx_ip_driver_interface_direct_command nx_ip_interface_address_get nx_ip_interface_address_set nx_ip_interface_attach nx_ip_interface_info_get nx_ip_interface_status_check nx_ip_raw_packet_interface_send nx_udp_socket_interface_send*

Эти службы более подробно описаны в главе 4 [Описание служб NetX для ОСРВ Azure](chapter4.md).

### <a name="loopback-interface"></a>Интерфейс замыкания на себя
Интерфейс замыкания на себя — это специальный сетевой интерфейс без подключения физического канала. Интерфейс замыкания на себя позволяет приложениям взаимодействовать с помощью петлевого IP-адреса 127.0.0.1

Чтобы использовать логический интерфейс замыкания на себя, убедитесь, что параметр ***NX_DISABLE_LOOPBACK_INTERFACE*** не задан.

### <a name="interface-control-blocks"></a>Блоки управления взаимодействием
Количество блоков управления взаимодействием в IP-экземпляре — это число физических интерфейсов (определяемое ***NX_MAX_PHYSICAL_INTERFACES** _), плюс интерфейс замыкания на себя, если он включен. Общее число интерфейсов определяется в _*_NX_MAX_IP_INTERFACES_**.

## <a name="protocol-layering"></a>Разделение протокола на уровни

Протокол TCP/IP, реализованный в NetX, является многоуровневым. Это означает, что более сложные протоколы основаны на более простых базовых протоколах. В протоколе TCP/IP протокол самого низкого уровня находится на *канальном уровне* и обрабатывается сетевым драйвером. Этот уровень обычно предназначен для Ethernet, но он также может быть реализован на базе оптоволоконного или последовательного канала или практически любого физического носителя.

Над канальным уровнем находится *сетевой*. В TCP/IP это IP-интерфейс, который, по сути, отвечает за отправку и получение простых пакетов по сети по принципу наименьших затрат. Протоколы, относящиеся к управляющим типам, например ICMP и IGMP, обычно также делятся на сетевые уровни, хотя и используют IP-протокол для отправки и получения.

*Транспортный уровень* располагается поверх сетевого. Этот уровень отвечает за управление потоком данных между узлами в сети. NetX поддерживает два типа транспортных служб: UDP и TCP. Службы UDP обеспечивают отправку и получение данных между двумя узлами по принципу наименьших затрат без установки подключения, в то время как TCP обеспечивает надежное обслуживание с ориентацией на подключение для передачи данных между двумя сущностями узла.

Это разделение на уровни отражается на фактических пакетах сетевых данных. Каждый слой в TCP/IP содержит блок данных, называемый заголовком. Такой метод заключения данных (и, возможно, сведений о протоколе) в заголовок обычно называется инкапсуляцией данных. На рис. 1 показан пример разделения NetX на уровни, а на рис. 2 — итоговая инкапсуляция отправляемых данных UDP.

![Разделение протокола на уровни](./media/user-guide/protocol-layering.png)

**РИС. 1. Разделение протокола на уровни**

![Инкапсуляция данных UDP](./media/user-guide/udp-data-encapsulation.png)

**РИС. 2. Инкапсуляция данных UDP**

## <a name="packet-pools"></a>Пулы пакетов

Быстрое и детерминированное выделение пакетов — вечная проблема в сетевых приложениях реального времени. Ввиду этого NetX предоставляет возможность создания и администрирования нескольких пулов сетевых пакетов фиксированного размера.

Так как пулы пакетов NetX состоят из блоков памяти фиксированного размера, никаких внутренних проблем из-за фрагментации не возникает. Конечно, фрагментация приводит к поведению, которое, по сути, является недетерминированным.

Кроме того, время, необходимое для выделения и освобождения пакета NetX, соответствует времени простой операции со связанным списком. Более того, выделение и освобождение пакета выполняется на уровне заголовка списка доступных ресурсов. Это обеспечивает максимально быструю обработку связанного списка.

Отсутствие гибкости обычно является основным недостатком пулов пакетов фиксированного размера. Определение оптимального размера полезных данных пакета, который также позволит обрабатывать входящие пакеты в худшем случае, — сложная задача. Пакеты NetX устраняют эту проблему с помощью необязательного компонента, называемого *цепочкой пакетов*. Фактический сетевой пакет может состоять из одного или нескольких пакетов NetX, связанных друг с другом. Кроме того, в заголовке пакета хранится указатель на верхнюю часть пакета. По мере добавления дополнительных протоколов этот указатель просто смещается назад, а непосредственно перед данными записывается новый заголовок. Без технологии гибких пакетов стеку пришлось бы выделить другой буфер и скопировать данные в новый буфер с новым заголовком, а это весьма ресурсоемкая задача.

Так как размер полезных данных каждого пакета фиксирован для заданного пула пакетов, данные приложения, превышающие размер полезных данных, требуют объединения нескольких пакетов в цепочку. При заполнении пакета данными пользователя приложение должно использовать службу ***nx_packet_data_append***. Эта служба перемещает данные приложения в пакет. В ситуациях, когда пакета недостаточно для хранения пользовательских данных, для них выделяются дополнительные пакеты. Чтобы использовать цепочку пакетов, у драйвера должна быть возможность получения и передачи данных в объединенных в цепочку пакетах.

Каждый пул памяти пакетов NetX является общедоступным ресурсом. NetX не накладывает ограничений на то, как используются пулы пакетов.

### <a name="packet-pool-memory-area"></a>Область памяти пула пакетов
Область памяти для пула пакетов задается во время его создания. Как и в случае с другими областями памяти для объектов ThreadX и NetX, она может находиться в любом месте целевого адресного пространства. Это важная возможность, так как она обеспечивает значительную гибкость для приложения. Например, предположим, что у продукта взаимодействия имеется высокоскоростная область памяти для операций сетевых буферов. Эту область памяти можно легко использовать, превратив ее в пул памяти пакетов NetX.

### <a name="creating-packet-pools"></a>Создание пулов пакетов
Пулы пакетов создаются во время инициализации или выполнения потоками приложения. Количество пулов памяти пакетов в приложении NetX не ограничено.

### <a name="packet-header-nx_packet"></a>NX_PACKET: заголовок пакета
По умолчанию NetX помещает заголовок пакета непосредственно перед областью полезных данных пакета. Пул памяти пакетов — это, по сути, ряд, состоящий из пакетов: заголовков, непосредственно за которыми следуют полезные данные пакета. Заголовок пакета (***NX_PACKET***) и макет пула пакетов изображены на рис. 3.

Обычно для драйвера сетевых устройств, который может выполнять операции без копирования, начальный адрес области полезных данных пакета запрограммирован в логике DMA. Некоторые модули DMA имеют требование к выравниванию для области полезных данных.

> [!IMPORTANT]
> *Сетевой драйвер должен вызвать функцию ***nx_packet_transmit_release** _ после завершения передачи пакета. Эта функция следит за тем, чтобы пакет не был добавлен в очередь вывода TCP до его фактического помещения обратно в пул доступных ресурсов. Сбой вызова этой функции может привести к непредсказуемому поведению._

![Заголовок пакета и макет пула пакетов](./media/user-guide/packet-header-packet-pool-layout.png)

**РИС. 3. Заголовок пакета и макет пула пакетов**

Поля заголовка пакета определяются, как показано в следующей таблице. Обратите внимание, что эта таблица не является исчерпывающим списком всех элементов структуры *NX_PACKET*.

| Заголовок пакета          | Назначение                                                                                                                                                                                                                                                                                                                            |
|------------------------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| *nx_packet_pool_owner*   | Это поле указывает на пул пакетов, которому принадлежит этот конкретный пакет. После освобождения пакета он становится доступным в этом конкретном пуле. Если владение пулом находится внутри каждого пакета, датаграмма может охватывать несколько пакетов из нескольких пулов пакетов.                                                         |
| *nx_packet_next*         | Это поле указывает на следующий пакет в том же кадре. Если значение равно NULL, дополнительные пакеты, которые являются частью кадра, отсутствуют. |
| *nx_packet_last*         | Это поле указывает на последний пакет в том же сетевом пакете. Если значение равно NULL, этот пакет представляет весь сетевой пакет.  |
| *nx_packet_length*       | Это поле содержит общее число байтов во всем сетевом пакете, включая общее количество байтов во всех пакетах, связанных в цепочку с помощью элемента *nx_packet_next*. |
| *nx_packet_ip_interface* | Это поле является блоком управления взаимодействием, который назначается пакету при его получении драйвером интерфейса и его получении NetX для исходящих пакетов. Блок управления взаимодействием описывает интерфейс, например сетевой адрес, MAC-адрес, IP-адрес, и его состояние, например, включена ли связь и требуется ли физическое сопоставление. |
| *nx_packet_data_start*   | Это поле указывает на начало физической области полезных данных этого пакета. Заголовок NX_PACKET не обязательно должен следовать непосредственно за ним, но для службы ***nx_packet_pool_create*** такая схема используется по умолчанию. |
| *nx_packet_data_end*     | Это поле указывает на конец физической области полезных данных этого пакета. Разница между этим полем и полем nx_packet_data_start соответствует размеру полезных данных. |
| *nx_packet_prepend_ptr*  | Это поле указывает на расположение данных пакетов (заголовка протокола либо фактических данных), добавленных перед имеющимися данными в пакете (если таковые имеются) в области полезных данных пакета. Его значение должно быть большим или равным значению положения указателя *nx_packet_data_start* и меньшим или равным указателю *nx_packet_append_ptr*.  *В целях повышения производительности NetX предполагает, что когда пакет передается в службы NetX для передачи, то указатель в начале указывает на длинный адрес, выровненный по словам.* |
| *nx_packet_append_ptr*    | Это поле указывает на конец данных, находящихся в этот момент в области полезных данных пакета. Он должен находиться между расположением в памяти, на которое указывают *nx_packet_prepend_ptr* и *nx_packet_data_end*. Разница между этим полем и полем *nx_packet_prepend_ptr* соответствует количеству данных в этом пакете. |
| *nx_packet_fragment_next* | Это поле используется для хранения фрагментированных пакетов до тех пор, пока не будет выполнена повторная сборка всего пакета. |
| *nx_packet_pad*           | Эти поля определяют длину заполнения (в 4-байтовых словах) для обеспечения требуемого выравнивания. Это поле удаляется, если значение *NX_PACKET_HEADER_PAD* не определено. |
|  |  |

### <a name="packet-header-offsets"></a>Отступ для заголовка пакета

Чтобы обеспечить достаточно места для размещения заголовка определенного размера, необходимо определить этот размер. Служба *nx_packet_allocate* используется для выделения пакета и корректирует положение указателя, находящегося в начале в пакете, в соответствии с заданным типом пакета. Тип пакета указывает NetX, какой отступ необходим для вставки заголовка протокола (например, UDP, TCP или ICMP) перед данными протокола.

Чтобы учесть заголовок IP и физического уровня (Ethernet) в пакете в NetX определяются следующие типы. В последнем случае предполагается, что отступ равен 16 байтам при условии 4-байтового выравнивания. В NetX по-прежнему определяются IP-пакеты, чтобы приложения выделяли пакеты для IP-сетей. В следующей таблице приведены определенные символы.

| Тип пакета   | Значение |
|---------------|-------|
| NX_IP_PACKET  | 0x24  |
| NX_UDP_PACKET | 0x2c  |
| NX_TCP_PACKET | 0x38  |
|               |       |

### <a name="pool-capacity"></a>Емкость пула
Количество пакетов в пуле пакетов — это функция размера полезных данных, а также общего числа байтов в области памяти, предоставляемой службе создания пула пакетов. Емкость пула вычисляется путем деления размера пакета (с учетом размера заголовка NX_PACKET, размера полезных данных и правильного выравнивания) на общее число байтов в указанной области памяти.

### <a name="thread-suspension"></a>Приостановка потока
Потоки приложения могут быть приостановлены при ожидании пакета из пустого пула. Когда пакет возвращается в пул, приостановленный поток получает этот пакет и его выполнение возобновляется.

Если на одном пуле пакетов приостанавливается несколько потоков, они возобновляются в том же порядке, в котором были приостановлены (FIFO).

### <a name="pool-statistics-and-errors"></a>Статистические показатели и ошибки пула
Если этот параметр включен, в разделе **ошибок** программного обеспечения для управления пакетами NetX отслеживается несколько статистических показателей и ошибок. Эти данные могут быть полезны для приложения. Для пулов пакетов поддерживаются следующие статистические показатели и отчеты об ошибках:

* общее количество пакетов в пуле;
* Количество свободных пакетов в пуле
* Запросы на выделение из пустого пула
* приостановок выделения из пустого пула;
* Освобождения недопустимых пакетов

Все эти статистические показатели и отчеты об ошибках, за исключением общего числа пакетов в пуле и количества тех из них, которые свободны, встроены в библиотеку NetX, если не определено значение ***NX_DISABLE_PACKET_INFO** _. Эти данные предоставляет приложению служба _ *_nx_packet_pool_info_get_**.

### <a name="packet-pool-control-block-nx_packet_pool"></a>Блок управления пула пакетов NX_PACKET_POOL

Характеристики каждого пула памяти пакетов находятся в его блоке управления. Он содержит полезную информацию, в том числе связанный список свободных пакетов, число свободных пакетов и размер полезных данных в пакетах этого пула. Эта структура определена в файле *nx_api.h*.

Блоки управления пула пакетов могут размещаться в любом месте в памяти, но чаще всего они определяются вне области какой-либо функции, благодаря чему функционируют как глобальная структура.

## <a name="ip-protocol"></a>Протокол IP

Компонент протокола Интернета (IP) NetX отвечает за отправку и получение IP-пакетов в Интернете. В NetX этот компонент отвечает преимущественно за отправку и получение сообщений TCP, UDP, ICMP и IGMP с помощью базового драйвера сети.

NetX поддерживает протокол IP (RFC 791)

### <a name="ip-addresses"></a>IP-адреса

Каждый узел в Интернете имеет уникальный 32-разрядный идентификатор, называемый IP-адресом. Существует пять классов IP-адресов, которые продемонстрированы на рис. 4. Ниже перечислены диапазоны этих пяти классов IP-адресов.

| Класс | Диапазон                        |
|-------|------------------------------|
| Объект     | От 0.0.0.0 до 127.255.255.255   |
| B     | От 128.0.0.0 до 191.255.255.255 |
| C     | От 192.0.0.0 до 223.255.255.255 |
| D     | От 224.0.0.0 до 239.255.255.255 |
| E     | С 240.0.0.0 по 247.255.255.255 |

**7 бит 24 бита**

![Структура IP-адресов](./media/user-guide/ip-address-structure.png)

**РИС. 4. Структура IP-адресов**

Существует также три типа спецификаций адресов: *одноадресная*, *широковещательная* и *многоадресная рассылка*. Адреса одноадресной рассылки — это IP-адреса, которые определяют конкретный узел в Интернете. Они могут быть IP-адресами источника или назначения. Широковещательный адрес позволяет идентифицировать все узлы в определенной сети или подсети и может использоваться только в качестве адреса назначения. Чтобы задать широковещательные адреса, необходимо заполнить ту их часть, которая представляет идентификатор узла, единицами. Адреса многоадресной рассылки (класс D) задают динамическую группу узлов в Интернете. Члены группы многоадресной рассылки могут присоединяться к группе и выходить из нее по мере необходимости.

> [!IMPORTANT]
> *Только протоколы без подключения, такие как UDP через IP, могут использовать широковещательную рассылку и ограниченные возможности широковещательной рассылки группы многоадресной рассылки.*

> [!IMPORTANT]
> В  ***nx_api.h** _ *определен* *макрос* IP_ADDRESS. Это позволяет легко определить IP-адреса, используя запятые вместо точек. Например, IP_ADDRESS (128,0,0,0) _задает первый адрес класса B, показанный на рис. 4*.

### <a name="ip-gateway-address"></a>Адрес шлюза IP

Сетевые шлюзы помогают узлам в своих сетях передавать пакеты, предназначенные для мест назначений, находящихся за пределами локального домена. У каждого узла имеются определенные сведения о следующем прыжке для отправки (к месту назначения либо на один из соседних узлов) либо возможность воспользоваться предварительно запрограммированной статической таблицей маршрутизации. Однако если эти подходы не работают, то узел должен перенаправлять пакет в шлюз по умолчанию, который содержит дополнительные сведения о маршрутизации пакета в место назначения. Обратите внимание, что шлюз по умолчанию должен быть напрямую доступен через один из физических интерфейсов, подключенных к IP-экземпляру. Приложение вызывает ***nx_ip_gateway_address_set***, чтобы настроить IP-адрес шлюза по умолчанию.

### <a name="ip-header"></a>Заголовок IP

Для отправки любого IP-пакета в Интернете у него должен быть заголовок IP. Когда протоколы более высокого уровня (UDP, TCP, ICMP или IGMP) вызывают компонент IP для отправки пакета, модуль передачи IP-пакетов помещает заголовок IP перед данными. И наоборот, при получении IP-пакетов из сети компонент IP удаляет заголовок IP из пакета перед его доставкой протоколам более высокого уровня. На рис. 5 показан формат заголовка IP.

![Формат заголовка IP](./media/user-guide/ip-header-format.png)

**РИС. 5. Формат заголовка IP**

> [!IMPORTANT]
> *Все заголовки в реализации TCP/IP должны быть представлены в формате с обратным порядком байтов. В этом формате наиболее значимый байт слова размещается по наименьшему байтовому адресу. Например, в IP-адресе поля "4-разрядное поле версии" и "4-разрядное поле длины заголовка" должны располагаться в первом байте заголовка.*

Ниже приведены определения полей заголовка IP.

**Назначение поля заголовка IP**

***4-разрядное поле версии***. Это поле содержит версию IP-адреса, которую представляет этот заголовок. Для IP версии 4, которую поддерживает NetX, значение этого поля равно 4.

***4-разрядное поле длины заголовка***. В этом поле указывается число 32-разрядных слов в заголовке IP. Если необязательные слова отсутствуют, значение этого поля равно 5.

***8-разрядное поле типа службы (TOS)***. В этом поле указывается тип службы, запрошенной для этого IP-пакета. Допустимые запросы приведены ниже.

| **Запрос TOS**     | **Значение** |
| ------------------- | --------- |
| Норм.              | 0x00      |
| Минимальная задержка       | 0x10      |
| Максимальное количество данных        | 0x08      |
| Максимальная надежность | 0x04      |
| Минимальные издержки        | 0x02      |

***16-разрядное поле общей длины***. Это поле содержит общую длину IP-датаграммы в байтах, включая заголовок IP. IP-датаграмма — это основная единица информации, передаваемая в Интернете по протоколу TCP/IP. Помимо данных, она содержит адреса источника и назначения. Так как это 16-разрядное поле, максимальный размер IP-датаграммы составляет 65 535 байт.

***16-разрядное поле идентификации***. Значение этого поля равно числу, используемому для уникальной идентификации каждой IP-датаграммы, отправленной с узла. Это число обычно увеличивается после отправки IP-датаграммы. Оно играет важную роль при сборке полученных фрагментов IP-пакетов.

***3-разрядное поле флагов***. Это поле содержит сведения о фрагментации IP-пакетов. 14-й бит — это бит, указывающий на отсутствие фрагментации. Если этот бит задан, исходящая IP-датаграмма не фрагментируется. 13-й бит — это бит, требующий дополнительных фрагментов. Если этот бит задан, то существуют дополнительные фрагменты. Если этот бит очищен, это последний фрагмент IP-пакета.

**Назначение поля заголовка IP**

***13-разрядное поле смещения фрагмента***. Это поле содержит старшие 13 бит смещения фрагмента. По этой причине смещения фрагментов разрешены только для 8-байтовых границ. В первом фрагменте фрагментированной IP-датаграммы будет установлен бит наличия дополнительных фрагментов, а смещение будет равно 0.

***8-разрядное поле срока жизни (TTL)***. Это поле содержит число маршрутизаторов, через которые может быть передана эта датаграмма, и тем самым ограничивает время ее существования.

***8-разрядное поле протокола***. В этом поле указывается, какой протокол использует IP-датаграмму. Ниже приведен список допустимых протоколов и их значения.

| Протокол | Значение |
|----------|-------|
| ICMP     | 0x01  |
| IGMP     | 0x02  |
| TCP      | 0x06  |
| UDP      | 0x11  |
|          |       |


***16-разрядное поле контрольной суммы***. Это поле содержит 16-разрядное значение контрольной суммы, охватывающее только заголовок IP. В протоколах более высокого уровня имеются дополнительные контрольные суммы, охватывающие полезные данные IP.

***32-разрядное поле IP-адреса источника***. Это поле содержит IP-адрес отправителя и всегда является адресом узла.

***32-разрядное поле IP-адреса назначения***. Это поле содержит IP-адрес одного или нескольких (если это широковещательный адрес или адрес многоадресной рассылки) получателей.

### <a name="creating-ip-instances"></a>Создание IP-экземпляров

IP-экземпляры создаются во время инициализации или выполнения потоками приложения. Начальный IP-адрес, маска сети, пул пакетов по умолчанию, драйвер носителя, а также память и приоритет внутреннего IP-потока определяются службой *nx_ip_create*. Если приложение инициализирует IP-экземпляр с IP-адресом, значение которого недопустимо (0.0.0.0), предполагается, что адрес интерфейса будет разрешаться позже вручную с помощью RARP либо через DHCP или аналогичный протокол.

Для систем с несколькими сетевыми интерфейсами основной интерфейс назначается при вызове *nx_ip_create*. Все дополнительные интерфейсы можно подключить к одному и тому же IP-экземпляру, вызвав *nx_ip_interface_attach*. Эта служба хранит сведения о сетевом интерфейсе (например, IP-адрес, маску сети) в блоке управления взаимодействием и связывает экземпляр драйвера с блоком управления взаимодействием в IP-экземпляре. Когда драйвер получает пакет данных, ему необходимо сохранить сведения об интерфейсе в структуре NX_PACKET перед отправкой в логику приема IP-пакетов. Обратите внимание, что перед присоединением интерфейсов необходимо сначала создать IP-экземпляр.

 ### <a name="ip-send"></a>Отправка IP-пакетов
 Обработка отправки IP-пакетов в NetX выполняется очень просто.

Указатель в начале пакета перемещается назад для размещения заголовка IP. Заголовок IP-адреса готов (содержит все параметры, заданные на уровне вызывающего протокола), контрольная сумма IP вычисляется в строке, а пакет отправляется в соответствующий драйвер сети. Кроме того, исходящая фрагментация также координируется в рамках обработки отправки IP-пакетов.

Если для IP-адреса назначения требуется физическое сопоставление, NetX инициирует для IP запросы ARP.

> [!IMPORTANT]
> *Для подключений по протоколу IP пакеты, требующие разрешения IP-адресов (т. е. физического сопоставления), помещаются в очередь ARP до тех пор, пока число пакетов в очереди не превысит глубину очереди ARP (определяется* *символом **NX_ARP_MAX_QUEUE_DEPTH**). Если* *глубина очереди достигнута, NetX удалит самый старый пакет в очереди и продолжит ожидание разрешения адреса для оставшихся пакетов, поставленных в очередь. С другой стороны, если разрешение записи ARP не выполнено, ожидающие пакеты в записи ARP освобождаются после истечения времени ожидания записи ARP.*

Для систем с несколькими сетевыми интерфейсами NetX выбирает интерфейс на основе IP-адреса назначения. В процессе выбора применяется следующая процедура.

1. Если адрес назначения является широковещательным или адресом многоадресной рассылки по протоколу IP, а также указан допустимый исходящий интерфейс, используется этот интерфейс. В противном случае используется первый физический интерфейс.

2. Если адрес назначения присутствует в таблице статической маршрутизации, используется интерфейс, связанный со шлюзом.

3. Если назначением является адрес с прямым подключением, используется интерфейс прямого подключения.

4. Если адрес назначения петлевой (127.0.0.1), используется интерфейс замыкания на себя.

5. Если шлюз по умолчанию настроен правильно, для передачи пакета используется интерфейс, связанный со шлюзом по умолчанию.

6. Выходной пакет удаляется, если все вышеуказанные сбои завершились ошибкой.

### <a name="ip-receive"></a>Получение IP-пакетов

Обработка получения IP-пакетов вызывается либо из сетевого драйвера, либо из внутреннего IP-потока (для обработки пакетов в очереди пакетов с отложенным получением). При обработке получения IP-пакетов проверяется поле протокола и предпринимается попытка отправить пакет в соответствующий компонент протокола. Перед тем как пакет будет фактически отправлен, IP-заголовок удаляется путем перемещения расположенного в начале пакета указателя за IP-заголовок.

При обработке получения IP-пакетов также обнаруживаются фрагментированные IP-пакеты и, если включена фрагментация, выполняются необходимые действия для их сборки. Если требуется фрагментация, но она не включена, пакет удаляется.

NetX определяет соответствующий сетевой интерфейс на основе интерфейса, указанного в пакете. Если поле интерфейса пакета имеет значение NULL, по умолчанию NetX будет использовать основной интерфейс. Это делается для обеспечения совместимости с устаревшими драйверами Ethernet NetX.

### <a name="raw-ip-send"></a>Отправка необработанных IP-пакетов

Необработанный IP-пакет — это IP-кадр, который содержит полезные данные протокола верхнего уровня, которые не поддерживаются напрямую (и не обрабатываются) NetX. Необработанный пакет позволяет разработчикам определять собственные приложения на основе протокола IP. Приложение может отправлять необработанные IP-пакеты напрямую с помощью службы ***nx_ip_raw_packet_send** _, если в службе _*_nx_ip_raw_packet_enabled_*_ включена их обработка. Однако если адрес назначения является адресом многоадресной рассылки (или широковещательной рассылки для IP), то NetX по умолчанию будет использовать первый (основной) интерфейс. Таким образом, чтобы отправить такие пакеты во вторичные интерфейсы, приложение должно воспользоваться службой _ *_nx_ip_raw_packet_interface_send_**, чтобы задать исходный адрес, используемый для исходящего пакета.

### <a name="raw-ip-receive"></a>Получение необработанных IP-пакетов

Если включена обработка необработанных IP-пакетов, приложение может получать необработанные IP-пакеты с помощью службы ***nx_ip_raw_packet_receive** _. Все входящие пакеты обрабатываются в соответствии с протоколом, указанным в заголовке IP. Если в поле протокола указан UDP, TCP, IGMP или ICMP, NetX обработает пакет, используя соответствующий обработчик для типа протокола пакетов. Если протокол не является одним из этих протоколов и включено получение необработанных IP-пакетов, входящий пакет будет помещен в очередь необработанных пакетов, ожидая, когда приложение получит его через службу _ *_nx_ip_raw_packet_receive_**. Кроме того, потоки приложений могут быть приостановлены в ожидании необработанного IP-пакета, если задан необязательный параметр времени ожидания.

### <a name="default-packet-pool"></a>Пул пакетов по умолчанию

Каждый IP-экземпляр получает во время создания пул пакетов по умолчанию. Этот пул пакетов используется для выделения пакетов для ARP, RARP, ICMP, IGMP и различных пакетов управления TCP (таких как SYN и ACK). Если пул пакетов по умолчанию пуст, когда система NetX должна выделить пакет, ей, возможно, потребуется прервать эту конкретную операцию. В этом случае она по возможности возвращает сообщение об ошибке.

### <a name="ip-helper-thread"></a>Вспомогательный IP-поток

Каждый IP-экземпляр имеет вспомогательный поток. Этот поток отвечает за выполнение обработки всех отложенных пакетов и периодической обработки. Вспомогательный IP-поток создается в ***nx_ip_create.*** Именно здесь потоку назначается стек и приоритет. Обратите внимание, что первая обработка во вспомогательном IP-потоке заключается в завершении инициализации сетевого драйвера, связанного со службой создания IP-экземпляра. После завершения инициализации сетевого драйвера вспомогательный поток запускает бесконечный цикл обработки пакетов и периодических запросов.

> [!IMPORTANT]
> *Если во вспомогательном IP-потоке наблюдается необъяснимое поведение, первым этапом отладки будет увеличение размера стека во время работы службы создания IP-экземпляра. Если стек слишком мал, вспомогательный IP-поток может перезаписывать память, что может вызвать необычные проблемы.*

### <a name="thread-suspension"></a>Приостановка потока

При попытке получения необработанных IP-пакетов потоки приложения могут быть приостановлены. После получения необработанного пакета первому приостановленному потоку присваивается новый пакет и этот поток возобновляется. У всех служб получения пакетов NetX имеется дополнительная функция возобновления по истечении времени ожидания. При получении пакета или истечении времени ожидания выполнение потока приложения возобновляется с соответствующим состоянием завершения.

### <a name="ip-statistics-and-errors"></a>Статистические показатели и ошибки IP-экземпляра

Если этот параметр включен, NetX отслеживает несколько статистических показателей и ошибок. Эти данные могут быть полезны для приложения. Для каждого IP-экземпляра поддерживаются следующие статистические показатели и отчеты об ошибках:

- общее число отправленных IP-пакетов;
- общее число байтов, отправленных по протоколу IP;
- общее число полученных IP-пакетов;
- общее число байтов, полученных по протоколу IP;
- общее число недопустимых IP-пакетов;
- общее число отброшенных пакетов, получаемых по протоколу IP;
- общее число ошибок контрольной суммы при получении по протоколу IP;
- общее число отброшенных пакетов, отправляемых по протоколу IP;
- общее число отправленных фрагментов IP-пакетов;
- общее число полученных фрагментов IP-пакетов.

Все эти статистические показатели и отчеты об ошибках предоставляются приложению службой ***nx_ip_info_get***.

### <a name="ip-control-block-nx_ip"></a>NX_IP: блок управления IP-экземпляра

Характеристики каждого IP-экземпляра находятся в его блоке управления. Он содержит такие полезные сведения, как IP-адреса и маски сети каждого сетевого устройства, а также таблицу соседних IP-адресов и сопоставления адресов физического оборудования. Эта структура определена в блоках управления IP-экземпляра ***nx_api.h***, которые могут размещаться в любом месте в памяти, но чаще всего определяются вне области какой-либо функции, благодаря чему функционируют как глобальная структура.

### <a name="static-ip-routing"></a>Маршрутизация статических IP-адресов

Функция статической маршрутизации позволяет приложению указать IP-сеть и адрес следующего прыжка для конкретных IP-адресов назначения вне сети. Если включена статическая маршрутизация, NetX выполняет поиск записи, соответствующей адресу назначения отправляемого пакета, в статической таблице маршрутизации. Если совпадений не найдено, NetX выполняет поиск по списку физических интерфейсов и выбирает исходный IP-адрес и адрес следующего прыжка на основе IP-адреса назначения и маски сети. Если назначение не соответствует ни одному из IP-адресов сетевых драйверов, подключенных к экземпляру IP-адреса, NetX выбирает интерфейс, напрямую подключенный к шлюзу по умолчанию, и использует IP-адрес интерфейса в качестве исходного адреса, а шлюз по умолчанию — в качестве места для следующего прыжка.

Записи можно добавлять и удалять из таблицы статической маршрутизации с помощью служб ***nx_ip_static_route_add*** и ***nx_ip_static_route_delete** _ соответственно. Чтобы использовать статическую маршрутизацию, ведущее приложение должно включить эту функцию, определив значение _ *_NX_ENABLE_IP_STATIC_ROUTING_**.

> [!IMPORTANT]
> *При добавлении записи в таблицу статической маршрутизации NetX проверяет наличие соответствующей записи для указанного адреса назначения, уже находящегося в таблице. Если таковая существует, NetX отдает предпочтение записи с меньшей сетью (более длинным префиксом) в маске сети.*

### <a name="ip-fragmentation"></a>Фрагментация IP-пакетов

У сетевого устройства могут быть ограничения на размер исходящих пакетов. Это ограничение называется максимальной единицей передачи данных (MTU). Значение MTU для протокола IP равно размеру наибольшего IP-кадра, который драйвер канального уровня может передавать без фрагментации IP-пакета. На этапе инициализации драйвера устройства модуль драйвера должен настроить его размер MTU для протокола IP с помощью службы ***nx_ip_interface_mtu_set***.

Хотя это и не рекомендуется, приложение может формировать датаграммы, размер которых превышает базовый размер MTU для протокола IP, поддерживаемый устройством. Перед передачей такой IP-датаграммы эти пакеты должны быть фрагментированы на уровне IP. При получении фрагментированных IP-кадров принимающая конечная точка должна хранить все фрагментированные кадры IP-адресов с одинаковым идентификатором фрагментации и повторно собирать их по порядку. Если логике получения IP-пакетов не удается вовремя собрать все фрагменты для восстановления исходного IP-кадра, все фрагменты освобождаются. За обнаружение потери пакетов и их восстановление отвечает протокол верхнего уровня.

Для обеспечения поддержки фрагментации IP-пакетов и операции повторной сборки конструктор систем должен включить функцию фрагментации IP-пакетов в NetX с помощью службы ***nx_ip_fragment_enable***. Если эта функция не включена, входящие фрагментированные IP-пакеты отклоняются, как и пакеты, превышающие MTU сетевого драйвера.

> [!IMPORTANT]
> *Логика фрагментации IP-пакетов может быть полностью удалена путем определения*  ***NX_DISABLE_FRAGMENTATION** _ _при создании библиотеки NetX. Это помогает сократить размер кода NetX*.

## <a name="address-resolution-protocol-arp-in-ip"></a>Протокол разрешения адресов в IP-экземпляре

Протокол разрешения адресов (ARP) отвечает за динамическое сопоставление 32-разрядных IP-адресов с базовыми физическими носителями (RFC 826). Ethernet — это наиболее распространенный физический носитель, который поддерживает 48-разрядные адреса. Необходимость в ARP определяется драйвером сети, предоставленным службе ***nx_ip_create***. Если требуется физическое сопоставление, сетевой драйвер должен установить флаг ***nx_interface_address_mapping_needed*** в структуре интерфейса.

### <a name="arp-enable"></a>Включение ARP
Чтобы протокол ARP правильно функционировал, он должен быть включен приложением с помощью службы ***nx_arp_enable***. Эта служба настраивает различные структуры данных для обработки ARP, включая создание области кэша ARP из памяти, предоставляемой службе включения ARP.

### <a name="arp-cache"></a>Кэш ARP
Кэш ARP можно рассматривать как массив внутренних структур данных сопоставления ARP. Каждая внутренняя структура может поддерживать связь между IP-адресом и адресом физического оборудования. Кроме того, каждая структура данных имеет указатели на каналы, поэтому она может быть включена в несколько связанных списков.

Если сопоставление присутствует в таблице ARP, приложение может найти IP-адрес в кэше ARP, указав MAC-адрес оборудования с помощью службы ***nx_arp_ip_address_find** _. Аналогичным образом служба _ *_nx_arp_hardware_address_find_** возвращает MAC-адрес для заданного IP-адреса.


### <a name="arp-dynamic-entries"></a>Динамические записи ARP

По умолчанию служба включения ARP размещает все записи в кэше ARP в списке доступных динамических записей ARP. При обнаружении запроса на отправку по несопоставленному IP-адресу NetX выделяет из этого списка динамические записи ARP. После выделения настраивается запись ARP, а на физический носитель отправляется запрос ARP.

Динамическая запись также может быть создана службой ***nx_arp_dynamic_entry_setом***.

> [!IMPORTANT]
> *Если используются все динамические записи ARP, то по крайней мере недавно использованная запись ARP заменяется новым сопоставлением.*

### <a name="arp-static-entries"></a>Статические записи ARP
Приложение также может настроить статическое сопоставление ARP с помощью службы ***nx_arp_static_entry_create***. Эта служба выделяет запись ARP из динамического списка записей ARP и помещает ее в статический список с информацией о сопоставлении, предоставленной приложением. Статические записи ARP не предусматривают повторное использование или устаревание. Приложение может удалить статическую запись с помощью службы ***nx_arp_static_entry_delete***.
Чтобы удалить все статические записи в таблице ARP, приложение может использовать службу ***nx_arp_static_entries_delete***.

### <a name="automatic-arp-entry"></a>Автоматическая запись ARP
NetX записывает сопоставление IP/MAC-адресов однорангового узла после его ответов на запрос ARP. NetX также реализует возможность автоматической записи ARP, с помощью которой осуществляется запись сопоставления IP/MAC-адресов однорангового узла на основе непредусмотренных запросов ARP из сети. Эта функция позволяет заполнить таблицу ARP данными однорангового узла, уменьшая задержку, возникающую при прохождении цикла запросов и ответов ARP. Однако у автоматической записи ARP есть и свой недостаток. Он заключается в том, что при включении этой функции в загруженной сети с большим количеством узлов на локальном канале таблица ARP быстро заполняется, что в конечном итоге приводит к замене записи ARP.

Эта функция включена по умолчанию. Чтобы ее отключить, необходимо скомпилировать библиотеку NetX, определив символ ***NX_DISABLE_ARP_AUTO_ENTRY***.

### <a name="arp-messages"></a>Сообщения ARP

Как упоминалось ранее, если при выполнении задачи IP-экземпляра обнаруживается, что для IP-адреса требуется сопоставление, отправляется сообщение запроса ARP. Запросы ARP отправляются периодически (каждые ***NX_ARP_UPDATE_RATE** _ секунд), пока не будет получен соответствующий ответ ARP. Попытки ARP прекращаются после того, как общее количество запросов ARP достигает _ *_NX_ARP_MAXIMUM_RETRIES_**. При получении ответа ARP сведения о связанном физическом адресе сохраняются в записи ARP, которая находится в кэше.

Для систем с множественной адресацией NetX определяет, какой интерфейс будет отправлять запросы и ответы ARP, на основе указанного адреса назначения.

> [!IMPORTANT]
> *Исходящие IP-пакеты помещаются в очередь, NetX ожидает ответа ARP. Число исходящих IP*-*пакетов в очереди определяется константой* ***NX_ARP_MAX_QUEUE_DEPTH***.

NetX также отвечает на запросы ARP от других узлов локальной IP-сети. Когда выполняется внешний запрос ARP, совпадающий с текущим IP-адресом интерфейса, получающего запрос ARP, NetX создает ответное сообщение ARP, содержащее текущий физический адрес.

Форматы запросов и ответов ARP в Ethernet показаны на рис. 6 и описаны ниже.

| Поле запроса или ответа       | Назначение    |
|------------------------------|-----------------|
| Адрес назначения в Ethernet | Это 6-разрядное поле содержит адрес назначения для ответа ARP и является широковещательным для запросов ARP (применяется для всех). Это поле настраивается сетевым драйвером. |
| Адрес источника в Ethernet      | Это 6-разрядное поле содержит адрес отправителя запроса или ответа ARP и настраивается сетевым драйвером. |
| Тип кадра                   | Это 2-разрядное поле содержит тип представления кадра Ethernet. Для запросов и ответов ARP его значение равно 0x0806. Это последнее поле, за настройку которого отвечает сетевой драйвер. |
| Тип оборудования                | Это 2-разрядное поле содержит тип оборудования и имеет значение 0x0001 для Ethernet. |
| Тип протокола                | Это 2-разрядное поле содержит тип протокола и имеет значение 0x0800 для IP-адреса. |
| Размер оборудования                | Это поле размером 1 байт содержит размер аппаратного адреса (6 для адресов Ethernet). |


![Формат пакетов ARP](./media/user-guide/arp-packet-format.png)

**РИС. 6. Формат пакетов ARP**

| Поле запроса или ответа | Назначение  |
|---|---|
| Размер для протокола | Это поле размером 1 байт содержит размер IP-адреса, который равен 4 для IP-адресов.  |
| Код операции | Это 2-байтовое поле содержит операцию для этого пакета ARP. Запрос ARP задается значением 0x0001, а ответ ARP представляется значением 0x0002.  |
| Адрес Ethernet отправителя | В этом 6-байтовом поле содержится адрес Ethernet отправителя. |
| IP-адрес отправителя | В этом 4-байтовом поле содержится IP-адрес отправителя. |
| Целевой адрес Ethernet | В этом 6-байтовом поле содержится целевой адрес Ethernet. |
| Целевой IP-адрес | В этом 4-байтовом поле содержится целевой IP-адрес. |

> [!IMPORTANT]
> *Запросы и ответы ARP — это пакеты уровня Ethernet. Все остальные пакеты TCP/IP инкапсулируются в заголовке IP-пакета.*

> [!IMPORTANT]
> *Все сообщения ARP в реализации TCP/IP должны быть представлены в формате с обратным порядком байтов. В этом формате наиболее значимый байт слова размещается по наименьшему байтовому адресу.*

### <a name="arp-aging"></a>Устаревание ARP

NetX поддерживает автоматическое аннулирование динамической записи ARP. ***NX_ARP_EXPIRATION_RATE** _ задает время (в секундах), в течение которого установленное сопоставление IP-адреса с физическим адресом остается действительным. После истечения срока действия запись ARP удаляется из кэша ARP. Следующая попытка отправить на соответствующий IP-адрес приведет к появлению нового запроса ARP. Установка нулевого значения для _ *_NX_ARP_EXPIRATION_RATE_** отключает устаревание ARP (конфигурация по умолчанию).

### <a name="arp-defend"></a>Защита ARP

Если при получении пакета запроса или ответа ARP отправитель имеет IP-адрес, который конфликтует с IP-адресом этого узла, NetX отправляет запрос ARP для этого адреса в качестве защиты. Если конфликтный пакет ARP получен несколько раз в течение 10 секунд, NetX не отправляет другие пакеты защиты. Заданный по умолчанию интервал в 10 секунд можно переопределить с помощью ***NX_ARP_DEFEND_INTERVAL** _. Это поведение соответствует политике, заданной в разделе 2.4(c) RFC5227. Так как Windows XP игнорирует объявление ARP как ответ на пробу ARP, пользователь может определить _*_NX_ARP_DEFEND_BY_REPLY_** для отправки ответа ARP в качестве дополнительной защиты.

### <a name="arp-statistics-and-errors"></a>Статистические показатели и ошибки ARP

Если этот параметр включен, программное обеспечение ARP NetX отслеживает несколько статистических показателей и ошибок. Эти данные могут быть полезны для приложения. Для каждой обработки ARP в IP-экземпляре поддерживаются следующие статистические показатели и отчеты об ошибках:

- общее число отправленных запросов ARP;
- общее число полученных запросов ARP;
- общее число отправленных ответов ARP;
- общее число полученных ответов ARP;
- общее число динамических записей ARP;
- общее число статических записей ARP;
- общее число устаревших записей ARP;
- общее число недопустимых сообщений ARP.

Все эти статистические показатели и отчеты об ошибках предоставляются приложению службой ***nx_arp_info_get***.

## <a name="reverse-address-resolution-protocol-rarp-in-ip"></a>Протокол обратного разрешения адресов (RARP) в IP-экземпляре

Протокол обратного разрешения адресов (RARP) — это протокол для запроса сетевого назначения 32-разрядных IP-адресов узла (RFC 903). Для этого используется запрос RARP, который периодически повторяется, пока элемент сети не присвоит IP-адрес сетевому интерфейсу узла в ответе RARP. Приложение создает IP-экземпляр с нулевым IP-адресом с помощью службы ***nx_ip_create***. Если в приложении включен протокол RARP, оно может использовать протокол RARP для запроса IP-адреса у сетевого сервера, доступного через интерфейс с нулевым IP-адресом.

### <a name="rarp-enable"></a>Включение RARP

Чтобы использовать RARP, приложение должно создать IP-экземпляр с нулевым IP-адресом, а затем включить RARP с помощью службы ***nx_rarp_enable***. Для систем с множественной адресацией по крайней мере одно сетевое устройство, связанное с IP-экземпляром, должно иметь IP-адрес, равный нулю. При обработке RARP для системы NetX периодически отправляются сообщения о запросах RARP на получение IP-адреса. Это продолжается, пока не будет получен допустимый ответ RARP с назначенным сетевым IP-адресом. На этом обработка RARP завершается.

После включения протокола RARP он автоматически отключается после разрешения всех адресов интерфейсов. Приложение может принудительно завершить использование RARP с помощью службы ***nx_rarp_disable***.

###  <a name="rarp-request"></a>Запрос RARP

Формат пакета запроса службы практически идентичен формату пакета ARP, показанному на рис. 6 в разделе [Сообщения ARP](#arp-messages). Единственное отличие заключается в том, что значение поля типа кадра равно 0x8035, а значение поля *Код операции* равно 3, что соответствует запросу RARP. Как упоминалось ранее, запросы RARP будут отправляться периодически (каждые ***NX_RARP_UPDATE_RATE*** секунд) до получения ответа RARP с назначенным сетью IP-адресом.

> [!IMPORTANT]
> *Все сообщения RARP в реализации TCP/IP должны быть представлены в формате с обратным порядком байтов. В этом формате наиболее значимый байт слова размещается по наименьшему байтовому адресу.*

### <a name="rarp-reply"></a>Ответ RARP

Сообщения с ответами RARP принимаются из сети и содержат IP-адрес, назначенный сетью этому узлу. Формат пакета ответа RARP практически идентичен формату пакета ARP, показанному на рис. 6. Единственное отличие заключается в том, что значение поля типа кадра равно 0x8035, а значение поля *Код операции* равно 4, что соответствует ответу RARP. После получения ответа в IP-экземпляре настраивается IP-адрес, отключается периодическая отправка запроса RARP, а IP-экземпляр переходит в состояние готовности к нормальной работе в сети.

Для узлов с множественной адресацией IP-адрес применяется к запрашивающему сетевому интерфейсу. Если есть другие сетевые интерфейсы, которые по-прежнему запрашивают назначение IP-адресов, периодическое обслуживание RARP продолжается до тех пор, пока не будут разрешены все запросы IP-адресов интерфейса.

> [!IMPORTANT]
> *Приложение не должно использовать IP-экземпляр до завершения обработки RARP. Приложения могут использовать **nx_ip_status_check** для ожидания завершения RARP. Для систем с множественной адресацией приложение не должно использовать запрашивающий интерфейс до завершения обработки RARP на этом интерфейсе. Состояние IP-адреса на вторичном устройстве можно проверить с помощью службы **nx_ip_interface_status_check**.*

### <a name="rarp-statistics-and-errors"></a>Статистические показатели и ошибки RARP

Если этот параметр включен, программное обеспечение RARP NetX отслеживает несколько статистических показателей и ошибок. Эти данные могут быть полезны для приложения. Для каждой обработки RARP в IP-экземпляре поддерживаются следующие статистические показатели и отчеты об ошибках:

- общее число отправленных запросов RARP;
- общее число полученных ответов RARP;
- общее число недопустимых сообщений RARP.

Все эти статистические показатели и отчеты об ошибках предоставляются приложению службой ***nx_rarp_info_get***.

## <a name="internet-control-message-protocol-icmp"></a>Протокол межсетевых управляющих сообщений (ICMP)

Применение протокола межсетевых управляющих сообщений для IP (ICMP) ограничивается передачей сведений об ошибках и управлении между элементами IP-сети.

Как и на большинстве других уровней приложений (например, TCP/IP), сообщения ICMP инкапсулируются в заголовке IP с помощью обозначения протокола ICMP.

### <a name="icmp-statistics-and-errors"></a>Статистические показатели и ошибки ICMP

Если этот параметр включен, NetX отслеживает несколько статистических показателей и ошибок ICMP. Эти данные могут быть полезны для приложения. Для каждой обработки ICMP в IP-экземпляре поддерживаются следующие статистические показатели и отчеты об ошибках:

- общее число отправленных запросов проверки связи ICMP;
- общее число случаев истечения времени ожидания проверки связи ICMP;
- общее число приостановленных потоков проверки связи ICMP;
- общее число полученных ответов проверки связи ICMP;
- общее число ошибок контрольной суммы ICMP;
- общее число необработанных сообщений ICMP.

Все эти статистические показатели и отчеты об ошибках предоставляются приложению службой ***nx_icmp_info_get***.

### <a name="icmp-enable"></a>Включение ICMP
Чтобы система NetX могла обработать сообщения ICMP, приложение должно вызвать службу ***nx_icmp_enable***, включающую обработку ICMP. После этого приложение может отправить запросы проверки связи и принять входящие пакеты проверки связи.

### <a name="icmp-echo-request"></a>Запрос проверки связи ICMP
Запрос проверки связи — это один из типов сообщений ICMP, который обычно используется для проверки существования определенного узла в сети, идентифицируемого по IP-адресу узла. Популярная команда проверки связи реализуется с помощью сообщений с запросами проверки связи и ответами на них по протоколу ICMP. При наличии конкретного узла его сетевой стек обрабатывает запрос проверки связи и ответы на него с помощью ответа на команду проверки связи. На рис. 7 подробно описывается формат сообщения проверки связи ICMP.

![Сообщение проверки связи ICMP](./media/user-guide/icmp-ping-message.png)

**РИС. 7. Сообщение проверки связи ICMP**

> [!IMPORTANT]
> *Все сообщения ICMP в реализации TCP/IP должны быть представлены в формате с обратным порядком байтов. В этом формате наиболее значимый байт слова размещается по наименьшему байтовому адресу.*

В следующей таблице описывается формат заголовка ICMP.

| Поле заголовка    | Назначение |
|-----------------|---------------------------------------------------|
| Тип            | В этом поле указывается сообщение ICMP (биты 31–24). Самые распространенные — это 0 (ответ на запрос проверки связи) и 8 (запрос проверки связи). |
| Код            | Это поле зависит от контекста в поле типа (биты 23–16). Для запроса проверки связи или ответа на него код имеет значение 0. |
| Контрольная сумма        | Это поле содержит 16-разрядную контрольную сумму для суммы, дополняющей единицу, в сообщении ICMP, включая весь заголовок ICMP, начинающийся с поля типа. Перед созданием контрольной суммы поле контрольной суммы очищается.                 |
| Идентификация  | Это поле содержит значение идентификатора, по которому можно определить узел. Для узла должен использоваться идентификатор, извлеченный из запроса проверки связи и ответа на него (биты 31–16). |
| Порядковый номер | Это поле содержит значение идентификатора. Для узла должен использоваться идентификатор, извлеченный из запроса проверки связи и ответа на него (биты 31–16). В отличие от поля идентификатора, это значение изменится в последующем запросе проверки связи, отправленном с того же узла (биты 15–0). |


### <a name="icmp-echo-response"></a>Ответ на запрос проверки связи ICMP
Ответ на запрос проверки связи — это еще один тип сообщения ICMP, который создается внутренними средствами с помощью компонента ICMP в ответ на внешний запрос проверки связи. Кроме подтверждения, ответ на запрос проверки связи также содержит копию данных пользователя, содержащихся в запросе проверки связи.

## <a name="internet-group-management-protocol-igmp"></a>протокол управления группами Интернета (IGMP)

Протокол управления группами Интернета (IGMP) предоставляет устройству возможность взаимодействовать с его соседями и маршрутизаторами, связь с которыми он намеревается установить. Иными словами, он позволяет присоединиться к группе многоадресной рассылки по протоколу IP (RFC 1112 и RFC 2236). Группа многоадресной рассылки, по сути, является динамической коллекцией сетевых элементов и представляется IP-адресом класса D. Группа многоадресной рассылки поддерживает исключение из нее текущих элементов и присоединение новых в любое время. За координацию, связанную с присоединением к группе и выходом из нее, отвечает IGMP.

### <a name="igmp-enable"></a>Включение IGMP

Прежде чем выполнить какую-либо многоадресную операцию в NetX, приложение должно вызвать службу ***nx_igmp_enable***. Эта служба выполняет базовую инициализацию IGMP при подготовке запросов многоадресной рассылки.

### <a name="multicast-ip-addressing"></a>IP-адресация многоадресной рассылки

Как упоминалось ранее, адреса многоадресной рассылки фактически представляют собой IP-адреса класса D, как показано на рис. 4 на стр. 58. Младшие 28 разрядов адреса класса D соответствуют идентификатору группы многоадресной рассылки. Существует ряд предварительно определенных адресов многоадресной рассылки. Однако для обработки IGMP особенно важен *адрес всех узлов* (244.0.0.1). *Адрес всех узлов* используется маршрутизаторами для запроса у участников многоадресной рассылки отчетов о том, к каким группам многоадресной рассылки они принадлежат.

### <a name="physical-address-mapping-in-ip"></a>Сопоставление физических адресов в IP-экземпляре

Адреса многоадресной рассылки класса D сопоставляются непосредственно с физическими адресами Ethernet в диапазоне от 01.00.5e.00.00.00 до 01.00.5e.7f.ff.ff. Младшие 23 бита IP-адреса многоадресной рассылки сопоставляются непосредственно с младшими 23 битами адреса Ethernet.

### <a name="multicast-group-join"></a>Присоединение к группе многоадресной рассылки

Приложения, которым необходимо присоединиться к определенной группе многоадресной рассылки, могут сделать это, вызвав службу ***nx_igmp_multicast_join***. Эта служба отслеживает количество запросов на присоединение к данной группе многоадресной рассылки. Если это первый запрос приложения на присоединение к группе многоадресной рассылки, то в основной сети отправляется отчет IGMP, указывающий на то, что этот узел намерен присоединиться к группе. Затем, чтобы настроить ожидание передачи данных пакетов с адресом Ethernet для этой группы многоадресной рассылки, вызывается драйвер сети.

Если в системе с множественной адресацией группа многоадресной рассылки доступна через конкретный интерфейс, приложение должно использовать службу ***nx_igmp_multicast_interface_join*** вместо службы ***nx_igmp_multicast_join***, действие которой ограничено группами многоадресной рассылки в основной сети.

### <a name="multicast-group-leave"></a>Выход из группы многоадресной рассылки

Приложения, которым необходимо выйти из группы многоадресной рассылки, к которой они присоединились ранее, могут сделать это, вызвав службу ***nx_igmp_multicast_leave***. Эта служба уменьшает значение внутреннего счетчика, связанного с числом операций присоединения к группе. При отсутствии необработанных запросов на присоединение к группе вызывается драйвер сети для отключения ожидания передачи данных пакетов с адресом Ethernet этой группы многоадресной рассылки.

### <a name="multicast-loopback"></a>Замыкание на себя многоадресной рассылки

Приложению может потребоваться получать трафик многоадресной рассылки из одного из источников, находящихся на том же узле. Для этого требуется включить для компонента многоадресной рассылки в IP-экземпляре замыкание на себя с помощью службы ***nx_igmp_loopback_enable***.

### <a name="igmp-report-message"></a>Сообщение с отчетом IGMP

Когда приложение присоединяется к группе многоадресной рассылки, в сети отправляется сообщение с отчетом IGMP, указывающее на намерение узла присоединиться к определенной группе многоадресной рассылки. Формат сообщения с отчетом IGMP показан на рис. 8. Для сообщения группы в сообщении с отчетом IGMP и IP-адреса назначения используется адрес группы многоадресной рассылки.

![Сообщение с отчетом IGMP](./media/user-guide/igmp-report-message.png)

**РИС. 8. Сообщение с отчетом IGMP**

На рисунке выше (рис. 8) заголовок IGMP содержит поле версии и типа, максимальное время отклика, поле контрольной суммы и поле адреса группы многоадресной рассылки. Для сообщений IGMPv1 значение поля максимального времени ответа всегда равно 0, так как оно не предусмотрено в протоколе IGMPv1. Поле максимального времени ответа задается, когда узел получает сообщение IGMP с типом запроса, и удаляется, когда узел получает сообщение с типом отчета другого узла, что предусмотрено определением протокола IGMPv2.

В следующей таблице описывается формат заголовка IGMP.

| **Поле заголовка**          | **Назначение** |
|-----------------------|--------------------------------------------------------------------|
| Version               | В этом поле указывается версия протокола IGMP (биты 31–28).                                                                               |
| Тип                  | В этом поле указывается тип сообщения IGMP (биты 27–24).                                                                       |
| Максимальное время ответа | Не используется в IGMPv1. В IGMPv2 это поле служит для определения максимального времени ответа.                                                      |
| Контрольная сумма              | Это поле содержит 16-разрядную контрольную сумму для суммы, дополняющей единицу, для сообщения IGMP, начинающегося с версии IGMP (биты 0–15). |
| Адрес группы         | 32-разрядный IP-адрес группы класса D. |


Сообщения с отчетами IGMP отправляются в ответ на сообщения с запросами IGMP, отправляемые маршрутизатором многоадресной рассылки. Маршрутизаторы многоадресной рассылки периодически отправляют сообщения с запросами, чтобы установить, какие узлы все еще остаются в группе. Как показано на рис. 8, сообщения с запросами имеют тот же формат, что и сообщение с отчетами IGMP. Единственное отличие состоит в том, что тип IGMP равен 1, а поле адреса группы имеет значение 0. Сообщения с запросами IGMP отправляются маршрутизатором многоадресной рассылки на IP-адрес *всех узлов*. Узел, который по-прежнему хочет сохранить членство в группе, отправляет в ответ еще одно сообщение с отчетом IGMP.

> [!IMPORTANT]
> *Все сообщения в реализации TCP/IP должны быть представлены в формате с **обратным порядком байтов**. В этом формате наиболее значимый байт слова размещается по наименьшему байтовому адресу.*

### <a name="igmp-statistics-and-errors"></a>Статистические показатели и ошибки IGMP

Если этот параметр включен, программное обеспечение IGMP NetX отслеживает несколько статистических показателей и ошибок. Эти данные могут быть полезны для приложения. Для каждой обработки IGMP в IP-экземпляре поддерживаются следующие статистические показатели и отчеты об ошибках:

- общее число отправленных отчетов IGMP;
- общее число полученных запросов IGMP;
- общее число ошибок контрольной суммы IGMP;
- общее число элементов, присоединившихся к текущей группе IGMP.

Все эти статистические показатели и отчеты об ошибках предоставляются приложению службой ***nx_igmp_info_get***.

## <a name="user-datagram-protocol-udp"></a>Протокол пользовательских датаграмм (UDP)

Протокол пользовательских датаграмм (UDP) обеспечивает простейшую форму передачи данных между участниками сети (RFC 768). Пакеты данных UDP отправляются от одного участника сети к другому по принципу наименьших затрат, т. е. встроенный механизм подтверждения получателем пакета отсутствует. Кроме того, в данном случае перед отправкой пакета UDP не требуется устанавливать подключение заранее. По этой причине передача пакетов UDP очень эффективна.

### <a name="udp-header"></a>Заголовок UDP
При передаче UDP помещает простой заголовок пакета перед данными приложения и удаляет аналогичный заголовок UDP из пакета при его получении, прежде чем передавать полученный UDP-пакет приложению. UDP использует протокол IP для отправки и получения пакетов, поэтому, когда пакет находится в сети, перед его заголовком UDP размещается заголовок IP. На рис. 9 показан формат заголовка UDP.

![Заголовок UDP](./media/user-guide/udp-header.png)

**РИС. 9. Заголовок UDP**

> [!IMPORTANT]
> *Все заголовки в реализации UDP/IP должны быть представлены в формате с обратным порядком байтов. В этом формате наиболее значимый байт слова размещается по наименьшему байтовому адресу.*

В следующей таблице описывается формат заголовка UDP.

| Поле заголовка                   | Назначение |
|--------------------------------|---------------------------------------------|
| 16-разрядное поле номера исходного порта      | Это поле содержит порт, из которого отправляется UDP-пакет. Допустимый диапазон UDP-портов — от 1 до 0xFFFF. |
| 16-разрядное поле номера порта назначения | Это поле содержит порт UDP, на который отправляется UDP-пакет. Допустимый диапазон UDP-портов — от 1 до 0xFFFF.   |
| 16-разрядное поле длины UDP-пакета   | Это поле содержит число байтов в UDP-пакете, включая размер заголовка UDP.                                  |
| 16-разрядное поле контрольной суммы UDP | Это поле содержит 16-разрядную контрольную сумму пакета, включая заголовок UDP, область данных пакета и псевдозаголовок IP. |

### <a name="udp-enable"></a>Включение UDP

Перед передачей UDP-пакетов приложение должно сначала включить протокол UDP, вызвав службу ***nx_udp_enable***. После включения приложение может отправлять и получать UDP-пакеты.

### <a name="udp-socket-create"></a>Создание сокета UDP

Сокеты UDP создаются во время инициализации или выполнения потоками приложения. Начальный тип службы, срок жизни и длина очереди получения определяются службой ***nx_udp_socket_create***. Число сокетов UDP в приложении не ограничено.

### <a name="udp-checksum"></a>Контрольная сумма UDP

Протокол UDP указывает свою дополняющую 16-разрядную контрольную сумму, охватывающую псевдозаголовок IP (состоящий из исходного IP-адреса, IP-адреса назначения и IP-слова, указывающего протокол и длину), заголовок UDP и данные пакета UDP. Если вычисленная контрольная сумма UDP равна 0, она сохраняется как значение, состоящее только из единиц (0xFFFF). Если для отправляющего сокета отключена логика контрольной суммы UDP, в поле контрольной суммы UDP помещается нулевое значение, указывающее, что контрольная сумма не вычислена. Если контрольная сумма UDP не совпадает с вычисленной контрольной суммой получателя, пакет UDP просто отбрасывается.

В IP-сети контрольная сумма UDP необязательна. NetX позволяет приложению включать или отключать расчет контрольной суммы UDP для каждого сокета. По умолчанию логика контрольной суммы UDP-сокета включена. Приложение может отключить логику контрольной суммы для определенного сокета UDP, вызвав службу ***nx_udp_socket_checksum_disable***.

Некоторые контроллеры Ethernet могут создавать контрольную сумму UDP на лету. Если система может использовать возможность аппаратного вычисления контрольной суммы, библиотеку NetX можно построить без логики контрольной суммы. Чтобы отключить программное вычисление контрольной суммы UDP, при построении библиотеки NetX необходимо определить следующие символы: ***NX_DISABLE_UDP_TX_CHECKSUM*** и ***NX_DISABLE_UDP_RX_CHECKSUM * *_ (описывается в [главе 2](chapter2.md)). Такие параметры конфигурации приводят к полному удалению логики контрольной суммы UDP из NetX, а вызов службы _* nx_udp_socket_checksum_disable*** позволяет приложению отключить обработку контрольной суммы UDP в IP-экземпляре для каждого сокета.

### <a name="udp-ports-and-binding"></a>Порты и привязка UDP

UDP-порт — это логическая конечная точка в протоколе UDP. В компоненте UDP системы NetX имеется 65 535 допустимых портов в диапазоне от 1 до 0xFFFF. Для отправки или получения данных UDP приложение должно сначала создать сокет UDP, а затем привязать его к нужному порту. После привязки сокета UDP к порту приложение может отправлять и получать данные на этом сокете.

### <a name="udp-fast-pathtrade"></a>UDP Fast Path&trade;

UDP Fast Path&trade; — это имя для пути с низкими временными затратами на передачу пакетов с помощью реализации UDP в NetX. Для отправки UDP-пакета требуется вызов всего нескольких функций (***nx_udp_socket_send** _ и _*_nx_ip_packet_send_*_) с дальнейшим вызовом сетевого драйвера. Функция _*_nx_udp_socket_send_*_ доступна в NetX для имеющихся приложений NetX и применяется только для IP-пакетов. Однако предпочтительным методом является использование службы _ *_nx_udp_socket_send_**, описанной ниже. При получении UDP-пакета он помещается в соответствующую очередь получения в сокете UDP либо доставляется в приостановленный поток приложения в ходе одного вызова функции из обработки прерывания получения сетевого драйвера. Эта логика с высокой степенью оптимизации для отправки и получения пакетов UDP является основой технологии UDP Fast Path.

### <a name="udp-packet-send"></a>Отправка UDP-пакета

Отправка данных UDP через IP-сети легко осуществляется путем вызова функции ***nx_udp_socket_send** _. Вызывающий объект должен задать версию IP в поле _IP-адреса*. NetX определит оптимальный исходный адрес для передаваемых UDP-пакетов на основе IP-адреса назначения. Эта служба помещает заголовок UDP перед данными пакета и отправляет его в сеть с помощью внутренней подпрограммы отправки IP-пакетов. При отправке UDP-пакетов приостановка потока не применяется, так как все операции передачи UDP-пакетов обрабатываются незамедлительно.

Для мест назначения многоадресной или широковещательной рассылки приложение должно указать исходный IP-адрес, который будет использоваться, если у устройства NetX есть несколько IP-адресов на выбор. Это можно сделать с помощью служб ***nx_udp_socket_interface_send.***

> [!IMPORTANT]
> *Если для передачи многоадресных или широковещательных пакетов используется **nx_udp_socket_send**, в качестве исходного адреса используется IP-адрес первого интерфейса.*

> [!IMPORTANT]
> *Если для этого сокета включена логика контрольной суммы UDP, операция вычисления контрольной суммы выполняется в контексте вызывающего потока, не блокируя доступ к структурам данных UDP или IP.*

> [!NOTE]
> *Полезные данные UDP, находящиеся в структуре **NX_PACKET**, должны располагаться на границе длинных слов. Приложению необходимо оставить достаточно места между открывающим указателем и указателем начала данных, чтобы система NetX могла разместить заголовки UDP, IP и физических носителей.*

### <a name="udp-packet-receive"></a>Получение UDP-пакетов

Потоки приложения могут получать UDP-пакеты от определенного сокета, вызвав ***nx_udp_socket_receive***. Функция получения сокета доставляет самый старый пакет в его очереди получения. Если в очереди получения нет пакетов, вызывающий поток может быть приостановлен (с необязательным временем ожидания) до поступления пакета.

Функция обработки получаемых UDP-пакетов (обычно вызывается из обработчика прерываний получения сетевого драйвера) отвечает за помещение пакета в очередь получения UDP-сокета или доставку его первому приостановленному потоку, ожидающему пакет. Если пакет находится в очереди, то при обработке получения проверяется также связанная с сокетом максимальная длина очереди получения. Если размер нового пакета, поступившего в очередь, превышает длину очереди, самый старый пакет в очереди отбрасывается.

### <a name="udp-receive-notify"></a>Уведомление о получении UDP-пакета

Если поток приложения должен обрабатывать полученные данные из нескольких сокетов, следует использовать функцию ***nx_udp_socket_receive_notify***. Эта функция регистрирует функцию обратного вызова получения пакетов для сокета. При каждом получении пакета сокетом выполняется функция обратного вызова.

Содержимое функции обратного вызова зависит от конкретного приложения. Однако, скорее всего, она будет содержать логику для информирования потока обработки о доступности пакета на соответствующем сокете.

### <a name="peer-address-and-port"></a>Адрес и порт однорангового узла

При получении UDP-пакета приложение может найти IP-адрес и номер порта отправителя с помощью службы ***nx_udp_packet_info_extract***. При успешном возвращении результата эта служба предоставляет сведения об IP-адресе и номере порта отправителя, а также локальном интерфейсе, через который был получен пакет.

### <a name="thread-suspension"></a>Приостановка потока

Как упоминалось ранее, потоки приложений могут быть приостановлены при попытке получить UDP-пакет на определенном UDP-порте. После получения пакета на этом порте он передается первому приостановленному потоку, и этот поток возобновляется. Для большинства служб NetX можно использовать необязательный параметр времени ожидания при приостановке получения UDP-пакетов.

### <a name="udp-socket-statistics-and-errors"></a>Статистические показатели и ошибки UDP-сокета

Если этот параметр включен, программное обеспечение UDP NetX отслеживает несколько статистических показателей и ошибок. Эти данные могут быть полезны для приложения. Для каждого IP/UDP-экземпляра поддерживаются следующие статистические показатели и отчеты об ошибках:

- общее число отправленных UDP-пакетов;
- общее число отправленных байтов UDP;
- общее число полученных UDP-пакетов;
- общее число полученных байтов UDP;
- общее число недопустимых UDP-пакетов;
- общее число отброшенных пакетов, получаемых по протоколу UDP;
- общее число ошибок контрольной суммы при получении по протоколу UDP;
- число отправленных пакетов UDP-сокета;
- число отправленных байтов UDP-сокета;
- число полученных пакетов UDP-сокета;
- число полученных байтов UDP-сокета;
- число поставленных в очередь пакетов UDP-сокета;
- число отброшенных пакетов, получаемых от UDP-сокета;
- число ошибок контрольной суммы UDP-сокета.

Все эти статистические показатели и отчеты об ошибках предоставляются приложению службой ***nx_udp_info_get*** (для статистики UDP, собранной по всем UDP-сокетам) и службой ***nx_udp_socket_info_get*** (для статистики UDP, собранной для заданного UDP-сокета).

### <a name="udp-socket-control-block-nx_udp_socket"></a>NX_UDP_SOCKET: блок управления сокетом UDP

Характеристики каждого UDP-сокета находятся в связанном блоке управления **NX_UDP_SOCKET**. Он содержит такие полезные сведения, как ссылка на структуру данных IP, сетевой интерфейс для путей отправки и получения, привязанный порт и очередь получения пакетов. Эта структура определена в файле **_nx_api.h_**.

## <a name="transmission-control-protocol-tcp"></a>Управляющий протокол передачи (TCP)

Управляющий протокол передачи (TCP) обеспечивает надежную потоковую передачу данных между двумя элементами сети (RFC 793). Все данные, отправленные одним элементом сети, проверяются и подтверждаются получающим элементом. Кроме того, перед любой передачей данных эти два элемента должны установить соединение. Все это обеспечивает надежную передачу данных, однако требует значительно больших временных затрат, чем описанная ранее передача данных UDP.

### <a name="tcp-header"></a>Заголовок TCP

При передаче заголовок TCP помещается перед данными, полученными от пользователя. При получении заголовок TCP удаляется из входящего пакета, а для приложения остаются только пользовательские данные. TCP использует протокол IP для отправки и получения пакетов, поэтому, когда пакет находится в сети, перед его заголовком TCP размещается заголовок IP. На рис. 10 показан формат заголовка TCP.

![Заголовок TCP](./media/user-guide/tcp-header.png)

**РИС. 10. Заголовок TCP**

В следующей таблице описывается формат заголовка TCP.

| Поле заголовка | Назначение |
|---|---|
| 16-разрядное поле номера исходного порта | Это поле содержит порт, на который отправляется TCP-пакет. Допустимый диапазон TCP-портов — от 1 до 0xFFFF. |
| 16-разрядное поле номера порта назначения | Это поле содержит TCP-порт, на который отправляется пакет. Допустимый диапазон TCP-портов — от 1 до 0xFFFF. |
| 32-разрядное поле порядкового номера | Это поле содержит порядковый номер для данных, отправляемых с данного конца соединения. Во время начальной последовательности соединения между двумя узлами TCP устанавливается исходная последовательность. С этого момента каждая передача данных приводит к увеличению порядкового номера на количество отправленных байтов. |
| 32-разрядное поле номера подтверждения | Это поле содержит порядковый номер, соответствующий последнему байту, полученному данной стороной соединения. Используется для определения того, были ли отправленные ранее данные успешно получены на другом конце соединения. |
| 4-разрядное поле длины заголовка           | Это поле содержит число 32-разрядных слов в заголовке TCP. Если в заголовке TCP отсутствуют параметры, значение этого поля равно 5. |
| 6-разрядное поле битов кода               | Это поле содержит шесть разных битов кода, используемых для обозначения различных управляющих сведений, связанных с соединением. Управляющие биты определяются следующим образом. |



| Имя | bit | Значение                                                     |
|------|-----|-------------------------------------------------------------|
| URG  | 21  | Имеются срочные данные                                         |
| ACK  | 20  | Допустимый номер подтверждения                             |
| PSH  | 19  | Требуется немедленная обработка этих данных                                |
| RST  | 18  | Требуется сброс соединения                                        |
| SYN  | 17  | Синхронизация порядковых номеров (используется для установления соединения) |
| FIN  | 16  | Отправитель завершил передачу (используется для закрытия соединения) |

**16-разрядное поле окна**

Это поле используется для управления потоком. Оно содержит количество байтов, которое сокет может получить в данный момент. По сути, оно используется для управления потоком. Ответственность за то, чтобы отправляемые данные помещались в объявленное окно получателя, несет отправитель.

| **Поле заголовка**          | **Назначение** |
| ------------------------- | --- |
| **16-разрядное поле контрольной суммы TCP**   | Это поле содержит 16-разрядную контрольную сумму пакета, включая заголовок TCP, область данных пакета и псевдозаголовок IP.                |
| **16-разрядное поле указателя срочности** | Это поле содержит положительное смещение последнего байта срочных данных. Оно допустимо только в случае, если в заголовке задан бит кода URG. |

> [!IMPORTANT]
> *Все заголовки в реализации TCP/IP должны быть представлены в формате с обратным порядком байтов. В этом формате наиболее значимый байт слова размещается по наименьшему байтовому адресу.*

### <a name="tcp-enable"></a>Включение TCP

Перед установкой TCP-соединения и передачей TCP-пакетов приложение должно сначала включить протокол TCP, вызвав службу nx_tcp_enable service. После включения приложение может получить доступ ко всем службам TCP.

### <a name="tcp-socket-create"></a>Создание сокета TCP

Сокеты TCP создаются во время инициализации или выполнения потоками приложения. Начальный тип службы, срок жизни и размер окна определяются службой ***nx_tcp_socket_create***. Число сокетов TCP в приложении не ограничено.

### <a name="tcp-checksum"></a>Контрольная сумма TCP

Протокол TCP указывает свою дополняющую 16-разрядную контрольную сумму, охватывающую псевдозаголовок IP (состоящий из исходного IP-адреса, IP-адреса назначения и IP-слова, указывающего протокол и длину), заголовок TCP и данные пакета TCP.

Некоторые сетевые контроллеры могут выполнять вычисление и проверку контрольной суммы TCP в оборудовании. В таких системах приложения могут в максимальной мере использовать аппаратную логику вычисления контрольной суммы, чтобы сократить количество служебных данных во время выполнения. Приложения могут полностью отключить логику вычисления контрольной суммы TCP в библиотеке NetX во время сборки, определив **NX_DISABLE_TCP_TX_CHECKSUM** и **NX_DISABLE_TCP_RX_CHECKSUM**. В этом случае код для вычисления контрольной суммы TCP не компилируется.

### <a name="tcp-port"></a>TCP-порт

TCP-порт — это логическая точка подключения в протоколе TCP. В компоненте TCP системы NetX имеется 65 535 допустимых портов в диапазоне от 1 до 0xFFFF. В отличие от протокола UDP, в котором данные с одного порта могут отправляться на любой другой порт назначения, один TCP-порт подключается к другому конкретному TCP-порту, а передача данных может осуществляться, только если это подключение установлено. При этом передача возможна только между двумя портами, между которыми установлено соединение.

> [!IMPORTANT]
> *TCP-порты полностью отделены от UDP-портов. Например, UDP-порт с номером 1 не связан с TCP-портом с номером 1.*

## <a name="client-server-model"></a>Модель "клиент — сервер"

Чтобы использовать протокол TCP для передачи данных, необходимо сначала установить соединение между двумя сокетами TCP. Установка соединения выполняется на стороне клиента и на стороне сервера. Клиентская часть соединения — это сторона, которая инициирует соединение, а серверная часть просто ожидает запросы на подключение от клиента до завершения обработки.

> [!IMPORTANT]
> *Для устройств с поддержкой множественной адресации NetX автоматически определяет используемый для подключения исходный адрес и адрес следующего прыжка на основе IP-адреса назначения соединения.*

### <a name="tcp-socket-state-machine"></a>Конечный автомат сокета TCP

Соединение между двумя сокетами TCP (один клиент и один сервер) реализовать сложно. Для управления такими соединениями используется конечный автомат. Каждый сокет TCP запускается в состоянии CLOSED (ЗАКРЫТ). Через события подключения конечный автомат каждого сокета переводит его в состояние ESTABLISHED (УСТАНОВЛЕН), в котором выполняется основная часть передачи данных в TCP. Когда одной стороне соединения больше не требуется отправлять данные, она отключается. После отключения другой стороны сокет TCP фактически возвращается в состояние CLOSED (ЗАКРЫТ). Этот процесс повторяется всякий раз, когда клиент и сервер TCP устанавливают и закрывают соединение. На рис. 11 показаны различные состояния конечного автомата TCP.

![Состояния конечного автомата TCP](./media/user-guide/states-tcp-state-machine.png)

### <a name="figure-11-states-of-the-tcp-state-machine"></a>РИС. 11. Состояния конечного автомата TCP

### <a name="tcp-client-connection"></a>Подключение клиента TCP

Как упоминалось ранее, клиентская сторона TCP-соединения инициирует запрос на подключение к серверу TCP. Перед запросом на подключение необходимо включить протокол TCP на клиентском IP-экземпляре. Кроме того, необходимо создать клиентский сокет TCP с помощью службы ***nx_tcp_socket_create** _ и привязать его к порту посредством службы _*_nx_tcp_client_socket_bind_*_. После привязки клиентского сокета для установления соединения с TCP-сервером используется служба _ *_nx_tcp_client_socket_connect_**. Обратите внимание, что сокет должен находиться в состоянии CLOSED (ЗАКРЫТ) для инициации попытки подключения. Установка подключения начинается с выдачи пакета SYN системой NetX и последующего ожидания передачи пакета SYN ACK с сервера, которая означает принятие запроса на подключение. После получения пакета SYN ACK система NetX реагирует на пакет ACK и переводит сокет клиента в состояние ESTABLISHED (УСТАНОВЛЕН).

### <a name="tcp-client-disconnection"></a>Отключение клиента TCP

Закрытие соединения выполняется путем вызова ***nx_tcp_socket_disconnect***. Если не задана приостановка, сокет клиента отправляет пакет RST на сокет сервера и переводит сокет в состояние CLOSED (ЗАКРЫТ). В противном случае при запросе приостановки выполняется полный протокол отключения TCP, как показано ниже.

- Если сервер ранее инициировал запрос на отключение (сокет клиента уже получил пакет FIN, ответил пакетом ACK и находится в состоянии CLOSE WAIT (ОЖИДАНИЕ ЗАКРЫТИЯ)), NetX переводит сокет TCP клиента в состояние LAST ACK (ПОСЛЕДНЕЕ ПОДТВЕРЖДЕНИЕ) и отправляет пакет FIN. Затем он ожидает подтверждения от сервера перед завершением отключения и переходом в состояние CLOSED (ЗАКРЫТ).

- Если, с другой стороны, клиент первым инициирует запрос на отключение (сервер не был отключен, а сокет по-прежнему находится в состоянии ESTABLISHED (УСТАНОВЛЕН)), NetX отправляет пакет FIN для инициации отключения и ожидает получения пакетов FIN и ACK от сервера, прежде завершить отключение и перевести сокет в состояние CLOSED (ЗАКРЫТ).

Если в очереди передачи сокета остались пакеты, NetX приостанавливается на указанное время ожидания, чтобы обеспечить подтверждение этих пакетов. По истечении времени ожидания NetX очищает очередь передачи сокета клиента.

Чтобы отменить привязку порта к сокету клиента, приложение вызывает ***nx_tcp_client_socket_unbind***. Сокет должен находиться в состоянии CLOSED (ЗАКРЫТ) или в процессе отсоединения (т. е. в состоянии TIMED WAIT (ОЖИДАНИЕ С ПРИВЯЗКОЙ КО ВРЕМЕНИ)) до освобождения порта. В противном случае возвращается ошибка.

Наконец, если сокет клиента приложению больше не требуется, вызывается ***nx_tcp_socket_delete*** для удаления сокета.

### <a name="tcp-server-connection"></a>Подключение к серверу TCP

Серверная сторона TCP-соединения является пассивной; т. е. сервер ожидает инициирования клиентом запроса на подключение. Чтобы принять клиентское подключение, необходимо сначала включить TCP в экземпляре IP, вызвав службу ***nx_tcp_enable** _. Затем приложение должно создать сокет TCP с помощью службы _ *_nx_tcp_socket_create_**.

Сокет сервера также должен быть настроен для ожидания передачи данных запросов на подключение. Для этого используется служба ***nx_tcp_server_socket_listen***. Эта служба переводит сокет сервера в состояние LISTEN (ОЖИДАНИЕ ПЕРЕДАЧИ ДАННЫХ) и привязывает указанный порт сервера к сокету.

> [!IMPORTANT]
> *Чтобы задать подпрограмму обратного вызова для ожидания передачи данных сокета, приложение указывает соответствующую функцию обратного вызова для аргумента tcp_listen_callback службы **nx_tcp_server_socket_listen**. Затем эта функция обратного вызова приложения выполняется системой NetX всякий раз, когда на этом порте сервера запрашивается новое подключение. Обработкой при обратном вызове управляет приложение.*

Чтобы принимать клиентские запросы на подключение, приложение вызывает службу ***nx_tcp_server_socket_accept** _. Для вызова службы принятия сокет сервера должен находиться в состоянии LISTEN (ОЖИДАНИЕ ПЕРЕДАЧИ ДАННЫХ) или состоянии SYN RECEIVED (ПОЛУЧЕН ЗАПРОС СИНХРОНИЗАЦИИ) (т. е. сервер находится в состоянии LISTEN (ОЖИДАНИЕ ПЕРЕДАЧИ ДАННЫХ) и получил пакет SYN от клиента, запросившего соединение). Состояние успешного возврата из _ *_nx_tcp_server_socket_accept_** указывает, что подключение установлено, а сокет сервера находится в состоянии ESTABLISHED (УСТАНОВЛЕН).

Когда сокет сервера будет иметь допустимое подключение, дополнительные запросы на подключение клиентов будут помещаться в очередь, пока она не будет полностью занята. Длина очереди определяется параметром *listen_queue_size*, передаваемым в службу ***nx_tcp_server_socket_listen** _. Для обработки последующих соединений на порте сервера приложение должно вызвать _ *_nx_tcp_server_socket_relisten_** с доступным сокетом (т е. сокетом в состоянии CLOSED (ЗАКРЫТ)). Обратите внимание, что при этом может использоваться тот же сокет сервера, если связанное с ним предыдущее соединение завершено, а сокет находится в состоянии CLOSED (ЗАКРЫТ).

### <a name="tcp-server-disconnection"></a>Отключение сервера TCP

Закрытие соединения выполняется путем вызова ***nx_tcp_socket_disconnect***. Если не задана приостановка, сокет сервера отправляет пакет RST на сокет клиента и переводит сокет в состояние CLOSED (ЗАКРЫТ). В противном случае при запросе приостановки выполняется полный протокол отключения TCP, как показано ниже. |

- Если клиент ранее инициировал запрос на отключение (сокет сервера уже получил пакет FIN, ответил пакетом ACK и находится в состоянии CLOSE WAIT (ОЖИДАНИЕ ЗАКРЫТИЯ)), NetX переводит сокет TCP в состояние LAST ACK (ПОСЛЕДНЕЕ ПОДТВЕРЖДЕНИЕ) и отправляет пакет FIN. Затем он ожидает подтверждения от сервера перед завершением отключения и входом в состояние CLOSED (ЗАКРЫТ).

- Если, с другой стороны, сервер первым инициирует запрос на отключение (клиент не был отключен, а сокет по-прежнему находится в состоянии ESTABLISHED (УСТАНОВЛЕН)), NetX отправляет пакет FIN для инициации отключения и ожидает получения пакетов FIN и ACK от клиента, прежде чем завершить отключение и поместить сокет в состояние CLOSED (ЗАКРЫТ).

Если в очереди передачи сокета остались пакеты, NetX приостанавливается на указанное время ожидания, чтобы обеспечить подтверждение этих пакетов. По истечении времени ожидания NetX освобождает очередь передачи сокета сервера.

После завершения обработки отключения и перехода сокета сервера в состояние CLOSED (ЗАКРЫТ) приложение должно вызвать службу ***nx_tcp_server_socket_unaccept***, чтобы завершить сопоставление этого сокета с портом сервера. Примечание. Эта служба должна вызываться приложением, даже если ***nx_tcp_socket_disconnect*** или ***nx_tcp_server_socket_accept** _ возвращает состояние ошибки. После возврата _ *_nx_tcp_server_socket_unaccept_** сокет можно использовать в качестве сокета клиента или сервера или даже удалить, если он больше не требуется. Если требуется принять другое клиентское соединение на том же порте сервера, для этого сокета должна быть вызвана служба ***nx_tcp_server_socket_relisten***.

В следующем сегменте кода показана последовательность вызовов типичного сервера TCP.

```c
/* Set up a previously created TCP socket to listen on port 12 */

nx_tcp_server_socket_listen()

/* Loop to make a (another) connection. */
while(1) {

    /* Wait for a client socket connection request for 100 ticks. */
    nx_tcp_server_socket_accept();

    /* (Send and receive TCP messages with the TCP client) */

    /* Disconnect the server socket. */
    nx_tcp_socket_disconnect();

    /* Remove this server socket from listening on the port. */

    nx_tcp_server_socket_unaccept(&server_socket);

    /* Set up server socket to relisten on the same port for the next
    client. */
    nx_tcp_server_socket_relisten();
}
```

### <a name="mss-validation"></a>Проверка MSS

Максимальный размер сегмента (MSS) — это максимальное количество байтов, которые может получить узел TCP без фрагментации с помощью базового уровня IP. На этапе установки TCP-соединения оба его конца обмениваются своим значением MSS для TCP, чтобы отправитель не отправлял сегмент данных TCP, превышающий размер MSS получателя. При необходимости перед установкой соединения модуль TCP NetX проверяет значение MSS, объявленное для однорангового узла. По умолчанию NetX не разрешает такую проверку. Приложения, которым необходимо выполнить проверку MSS, должны определить ***NX_ENABLE_TCP_MSS_CHECKING** _ при создании библиотеки NetX, а минимальное значение должно быть определено в _*_NX_TCP_MSS_MINIMUM_*_. Входящие TCP-соединения со значениями MSS ниже _ *_NX_TCP_MSS_MINIMUM_** отбрасываются.

### <a name="stop-listening-on-a-server-port"></a>Прекращение прослушивания порта сервера

Если приложению больше не требуется ожидать передачи данных для запросов клиентского соединения на порте сервера, который был ранее указан при вызове службы ***nx_tcp_server_socket_listen** _, приложение просто вызывает службу _ *_nx_tcp_server_socket_unlisten_**. Эта служба переводит любой сокет, ожидающий подключения, в состояние CLOSED (ЗАКРЫТ) и освобождает все пакеты запросов на подключение клиентов, помещенные в очередь.

### <a name="tcp-window-size"></a>Размер окна TCP

Во время этапов настройки соединения и передачи данных каждый порт сообщает объем данных, которые он может обработать. Этот объем называется размером окна. При получении и обработке данных размер этого окна корректируется динамически. В протоколе TCP отправитель может передавать только объем данных, помещающихся в окно получателя. По сути, размер окна обеспечивает управление потоком для передачи данных в каждом направлении соединения.

### <a name="tcp-packet-send"></a>Отправка пакетов TCP

Отправку данных TCP можно легко выполнить, вызвав функцию ***nx_tcp_socket_send***. Если размер передаваемых данных превышает значение MSS для сокета или текущий размер окна приема однорангового узла (в зависимости от того, какое из этих значений меньше), внутренняя логика TCP отсекает при передаче данные, выходящие за пределы этого меньшего значения (MSS или окна однорангового узла). Затем эта служба создает заголовок TCP перед пакетом (в том числе вычисляет контрольную сумму). Если размер окна получателя не равен нулю, вызывающий объект будет передавать столько данных, сколько помещается в окно получателя. Если размер окна получения равен нулю, вызывающий объект может приостановить передачу и дождаться, пока размер окна получателя станет достаточно большим для отправки этого пакета. Если в какой-то момент времени несколько потоков попытаются отправить данные через один и тот же сокет, они могут быть приостановлены.

> [!IMPORTANT]
> *Данные TCP, находящиеся в структуре NX_PACKET, должны располагаться на границе длинных слов. Кроме того, необходимо иметь достаточно места между открывающим указателем и указателем начала данных, чтобы система NetX могла разместить заголовки TCP, IP и физических носителей.*

### <a name="tcp-packet-retransmit"></a>Повторная отправка TCP-пакетов

Ранее отправленные и переданные TCP-пакеты фактически хранятся внутри системы до тех пор, пока другая сторона соединения не возвратит пакет ACK. Если передача данных не подтверждается в течение времени ожидания, хранимый пакет отправляется повторно и задается следующий период времени ожидания. При получении пакета ACK окончательно освобождаются все пакеты, для которых действителен номер подтверждения во внутренней очереди передачи.

> [!IMPORTANT]
> *Приложение не должно повторно использовать пакет или изменять его содержимое после того, как функция ***nx_tcp_socket_send** _ возвратит результат со значением NX_SUCCESS. В итоге после подтверждения получения данных на другом конце переданный пакет освобождается службой внутренней обработки NetX._

### <a name="tcp-keepalive"></a>Проверка активности TCP-соединения

Функция проверки активности TCP-соединения позволяет сокету выявлять ситуации, когда его кэширующий узел отключается без правильного завершения (например, в случае аварийного завершения однорангового узла), а также предотвращать завершения подключения после длительных периодов бездействия определенными средствами мониторинга сетей. Функция проверки активности TCP-соединения периодически отправляет TCP-кадр без данных, а текущий порядковый номер уменьшается на единицу. При получении такого кадра проверки активности TCP-соединения получатель, если он по-прежнему активен, отвечает пакетом ACK для текущего порядкового номера. На этом транзакция проверки активности завершается.

По умолчанию функция проверки активности не включена. Для использования этой функции необходимо определить ***NX_ENABLE_TCP_KEEPALIVE** _ при создании библиотеки NetX. Символ _ *_NX_TCP_KEEPALIVE_INITIAL_** указывает число секунд бездействия до инициирования кадра проверки активности.

### <a name="tcp-packet-receive"></a>Получение TCP-пакетов

Функция обработки получаемых TCP-пакетов (вызывается из вспомогательного потока IP) отвечает за обработку различных действий подключения и отключения, а также обработку подтверждения передачи. Кроме того, функция обработки получаемых TCP-пакетов отвечает за помещение пакетов с получаемыми данными в очередь получения соответствующего сокета TCP или доставку пакета первому приостановленному потоку, ожидающему пакет.

### <a name="tcp-receive-notify"></a>Уведомление о получении TCP-пакета

Если поток приложения должен обрабатывать полученные данные из нескольких сокетов, следует использовать функцию ***nx_tcp_socket_receive_notify***. Эта функция регистрирует функцию обратного вызова получения пакетов для сокета. При каждом получении пакета сокетом выполняется функция обратного вызова.

Содержимое функции обратного вызова зависит от конкретного приложения. Однако функция, скорее всего, будет содержать логику для информирования потока обработки о том, что пакет доступен в соответствующем сокете.

### <a name="thread-suspension"></a>Приостановка потока

Как упоминалось ранее, потоки приложений могут быть приостановлены при попытке получить данные на определенном TCP-порте. После получения пакета на этом порте он передается первому приостановленному потоку, и этот поток возобновляется. Для большинства служб NetX можно использовать необязательный параметр времени ожидания при приостановке получения TCP-пакетов.

Приостановка потока также доступна для подключения (как клиента, так и сервера), привязки клиента и служб отключения.

### <a name="tcp-socket-statistics-and-errors"></a>Статистические показатели и ошибки сокета TCP

Если этот параметр включен, программное обеспечение TCP NetX отслеживает несколько статистических показателей и ошибок. Эти данные могут быть полезны для приложения. Для каждого IP/TCP-экземпляра поддерживаются следующие статистические показатели и отчеты об ошибках:

- общее число отправленных TCP-пакетов;
- общее число отправленных байтов TCP;
- общее число полученных TCP-пакетов;
- общее число полученных байтов TCP;
- общее число недопустимых TCP-пакетов;
- общее число отброшенных пакетов, получаемых по протоколу TCP;
- общее число ошибок контрольной суммы при получении по протоколу TCP;
- общее число TCP-соединений;
- общее число отключений TCP-соединений;
- общее число сброшенных TCP-соединений;
- общее число повторно отправленных TCP-пакетов;
- число отправленных пакетов сокета TCP;
- число отправленных байтов сокета TCP;
- число полученных пакетов сокета TCP;
- число полученных байтов сокета TCP;
- общее число повторно отправленных пакетов сокета TCP;
- число поставленных в очередь пакетов сокета TCP;
- число ошибок контрольной суммы сокета TCP;
- состояние сокета TCP;
- длина очереди передачи сокета TCP;
- размер окна передачи сокета TCP;
- размер окна получения сокета TCP.

Все эти статистические показатели и отчеты об ошибках предоставляются приложению службой ***nx_tcp_info_get** _ (для общей статистики TCP) и службой _ *_nx_tcp_socket_info_get_** (для статистики TCP каждого отдельного сокета).

## <a name="tcp-socket-control-block-nx_tcp_socket"></a>Блок управления сокетом TCP NX_TCP_SOCKET

Характеристики каждого из сокетов TCP находятся в связанном блоке управления *NX_TCP_SOCKET*, который содержит полезную информацию, такую как ссылка на структуру данных IP, интерфейс сетевого подключения, связанный порт и очередь получения пакетов. Эта структура определена в файле ***nx_api.h***.
