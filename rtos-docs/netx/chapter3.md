---
title: Глава 3. Функциональные компоненты ОСРВ Azure NetX
description: В этой главе описывается высокопроизводительный стек TCP/IP ОСРВ Azure NetX с точки зрения функциональности.
author: philmea
ms.author: philmea
ms.date: 05/19/2020
ms.topic: article
ms.service: rtos
ms.openlocfilehash: db23aa152b2765ac7cc9be098723fc5df0947484
ms.sourcegitcommit: e3d42e1f2920ec9cb002634b542bc20754f9544e
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/22/2021
ms.locfileid: "104815311"
---
# <a name="chapter-3---functional-components-of-azure-rtos-netx"></a><span data-ttu-id="0a867-103">Глава 3. Функциональные компоненты ОСРВ Azure NetX</span><span class="sxs-lookup"><span data-stu-id="0a867-103">Chapter 3 - Functional Components of Azure RTOS NetX</span></span>

<span data-ttu-id="0a867-104">В этой главе описывается высокопроизводительный стек TCP/IP ОСРВ Azure NetX с точки зрения функциональности.</span><span class="sxs-lookup"><span data-stu-id="0a867-104">This chapter contains a description of the high-performance Azure RTOS NetX TCP/IP stack from a functional perspective.</span></span> 

## <a name="execution-overview"></a><span data-ttu-id="0a867-105">Общие сведения о выполнении</span><span class="sxs-lookup"><span data-stu-id="0a867-105">Execution Overview</span></span>

<span data-ttu-id="0a867-106">В приложении NetX существует пять типов выполнения программы: инициализация, вызовы интерфейса приложения, внутренний IP-поток, периодические IP-таймеры и драйвер сети.</span><span class="sxs-lookup"><span data-stu-id="0a867-106">There are five types of program execution within a NetX application: initialization, application interface calls, internal IP thread, IP periodic timers, and the network driver.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="0a867-107">NetX использует выполнение потока, приостановку, периодические таймеры и средства взаимного исключения системы ThreadX, поэтому ее необходимо установить.</span><span class="sxs-lookup"><span data-stu-id="0a867-107">NetX requires the installation of ThreadX and depends on its thread execution, suspension, periodic timers, and mutual exclusion facilities.</span></span>

### <a name="initialization"></a><span data-ttu-id="0a867-108">Инициализация</span><span class="sxs-lookup"><span data-stu-id="0a867-108">Initialization</span></span>

<span data-ttu-id="0a867-109">Службу \***nx_system_initialize** _ необходимо вызывать до вызова любой другой службы NetX.</span><span class="sxs-lookup"><span data-stu-id="0a867-109">The service \***nx_system_initialize** _ must be called before any other NetX service is called.</span></span> <span data-ttu-id="0a867-110">Инициализацию системы можно вызвать с помощью подпрограммы _ *_tx_application_define_*\* или с помощью потоков приложения.</span><span class="sxs-lookup"><span data-stu-id="0a867-110">System initialization can be called either from the ThreadX _ *_tx_application_define_*\* routine or from application threads.</span></span>

<span data-ttu-id="0a867-111">После возврата \***nx_system_initialize** _ система готова к созданию пулов пакетов и IP-экземпляров.</span><span class="sxs-lookup"><span data-stu-id="0a867-111">After \***nx_system_initialize** _ returns, the system is ready to create packet pools and IP instances.</span></span> <span data-ttu-id="0a867-112">Так как для создания IP-экземпляра требуется пул пакетов по умолчанию, на момент его создания должен существовать по крайней мере один пул пакетов NetX.</span><span class="sxs-lookup"><span data-stu-id="0a867-112">Because creating an IP instance requires a default packet pool, at least one NetX packet pool must exist prior to creating an IP instance.</span></span> <span data-ttu-id="0a867-113">Создавать пулы пакетов и IP-экземпляры разрешено из функции инициализации ThreadX _ *_tx_application_define_*\* и из потоков приложения.</span><span class="sxs-lookup"><span data-stu-id="0a867-113">Creating packet pools and IP instances are allowed from the ThreadX initialization function _ *_tx_application_define_*\* and from application threads.</span></span>

<span data-ttu-id="0a867-114">С точки зрения внутренних процессов создание IP-экземпляра состоит из двух частей.</span><span class="sxs-lookup"><span data-stu-id="0a867-114">Internally, creating an IP instance is accomplished in two parts.</span></span> <span data-ttu-id="0a867-115">Первая часть выполняется в контексте вызывающего объекта из ***tx_application_define*** либо из контекста потока приложения.</span><span class="sxs-lookup"><span data-stu-id="0a867-115">The first part is done within the context of the caller, either from ***tx_application_define*** or from an application thread's context.</span></span> <span data-ttu-id="0a867-116">Она предусматривает настройку структуры данных IP и создание различных ресурсов IP, в том числе внутреннего IP-потока.</span><span class="sxs-lookup"><span data-stu-id="0a867-116">This includes setting up the IP data structure and creating various IP resources, including the internal IP thread.</span></span> <span data-ttu-id="0a867-117">Вторая часть осуществляется во время начального выполнения из внутреннего IP-потока.</span><span class="sxs-lookup"><span data-stu-id="0a867-117">The second part is performed during the initial execution from the internal IP thread.</span></span> <span data-ttu-id="0a867-118">Именно на этом этапе первый раз вызывается драйвер сети, предоставляемый при выполнении первой части процесса создания IP-экземпляра.</span><span class="sxs-lookup"><span data-stu-id="0a867-118">This is where the network driver, supplied during the first part of IP creation, is first called.</span></span> <span data-ttu-id="0a867-119">Вызов сетевого драйвера из внутреннего IP-потока позволяет драйверу выполнять операции ввода-вывода и приостанавливать выполнение при обработке инициализации.</span><span class="sxs-lookup"><span data-stu-id="0a867-119">Calling the network driver from the internal IP thread enables the driver to perform I/O and suspend during its initialization processing.</span></span> <span data-ttu-id="0a867-120">Когда сетевой драйвер возвращает результат обработки инициализации, создание IP-экземпляра завершается.</span><span class="sxs-lookup"><span data-stu-id="0a867-120">When the network driver returns from its initialization processing, the IP creation is complete.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="0a867-121">Для получения сведений об IP-экземпляре и состоянии его основного интерфейса можно воспользоваться службой NetX **nx_ip_status_check**.</span><span class="sxs-lookup"><span data-stu-id="0a867-121">The NetX service **nx_ip_status_check** is available to obtain information on the IP instance and its primary interface status.</span></span> <span data-ttu-id="0a867-122">В числе сведений о состоянии можно получить информацию о том, был ли инициализирован и включен канал и разрешен ли IP-адрес.</span><span class="sxs-lookup"><span data-stu-id="0a867-122">Such status information includes whether or not the link is initialized, enabled, and IP address is resolved.</span></span> <span data-ttu-id="0a867-123">Эти сведения используются для синхронизации потоков приложения, необходимых для использования только что созданного IP-экземпляра.</span><span class="sxs-lookup"><span data-stu-id="0a867-123">This information is used to synchronize application threads needing to use a newly created IP instance.</span></span> <span data-ttu-id="0a867-124">Сведения, касающиеся систем с множественной адресацией, см. ниже в разделе "Поддержка множественной адресации".</span><span class="sxs-lookup"><span data-stu-id="0a867-124">For multihome systems, see "Multihome Support" below.</span></span> <span data-ttu-id="0a867-125">Для получения сведений об указанном интерфейсе можно воспользоваться службой **nx_ip_interface_status_check**.</span><span class="sxs-lookup"><span data-stu-id="0a867-125">**nx_ip_interface_status_check** is available to obtain information on the specified interface.</span></span>

### <a name="application-interface-calls"></a><span data-ttu-id="0a867-126">Вызовы интерфейса приложения</span><span class="sxs-lookup"><span data-stu-id="0a867-126">Application Interface Calls</span></span>

<span data-ttu-id="0a867-127">Вызовы из приложения в основном выполняются из потоков приложений, работающих под управлением ОСРВ ThreadX.</span><span class="sxs-lookup"><span data-stu-id="0a867-127">Calls from the application are largely made from application threads running under the ThreadX RTOS.</span></span> <span data-ttu-id="0a867-128">Однако некоторые службы инициализации, создания и включения могут вызваться из ***tx_application_define***.</span><span class="sxs-lookup"><span data-stu-id="0a867-128">However, some initialization, create, and enable services may be called from ***tx_application_define***.</span></span> <span data-ttu-id="0a867-129">В разделах "Допустимые источники" главы 4 указывается, откуда можно вызывать каждую службу NetX.</span><span class="sxs-lookup"><span data-stu-id="0a867-129">The "Allowed From" sections in Chapter 4 indicate from which each NetX service can be called.</span></span>

<span data-ttu-id="0a867-130">В большинстве случаев обработка ресурсоемких операций, таких как вычисление контрольных сумм, выполняется в контексте вызывающего потока и не приводит к блокированию доступа других потоков к IP-экземпляру.</span><span class="sxs-lookup"><span data-stu-id="0a867-130">For the most part, processing intensive activities such as computing checksums is done within the calling thread's context—without blocking the access of other threads to the IP instance.</span></span> <span data-ttu-id="0a867-131">Например, при передаче перед вызовом базовой функции отправки IP-пакетов в службе ***nx_udp_socket_send*** выполняется расчет контрольной суммы UDP.</span><span class="sxs-lookup"><span data-stu-id="0a867-131">For example, on transmission, the UDP checksum calculation is performed inside the ***nx_udp_socket_send*** service, prior to calling the underlying IP send function.</span></span> <span data-ttu-id="0a867-132">Для полученного пакета контрольная сумма UDP вычисляется в службе ***nx_udp_socket_receive***, которая выполняется в контексте потока приложения.</span><span class="sxs-lookup"><span data-stu-id="0a867-132">On a received packet, the UDP checksum is calculated in the ***nx_udp_socket_receive*** service, executed in the context of the application thread.</span></span> <span data-ttu-id="0a867-133">Это помогает предотвратить приостановку обработки сетевых запросов с более высоким приоритетом в связи с ресурсоемким вычислением контрольной суммы в потоках с более низким приоритетом.</span><span class="sxs-lookup"><span data-stu-id="0a867-133">This helps prevent stalling network requests of higher-priority threads because of processing intensive checksum computation in lower-priority threads.</span></span>

<span data-ttu-id="0a867-134">Такие значения, как IP-адреса и номера портов, передаются функциям API в соответствии с порядком байтов узла.</span><span class="sxs-lookup"><span data-stu-id="0a867-134">Values, such as IP addresses and port numbers, are passed to API functions in host byte order.</span></span> <span data-ttu-id="0a867-135">Для внутренних целей эти значения также хранятся в соответствии с этим порядком.</span><span class="sxs-lookup"><span data-stu-id="0a867-135">Internally these values are stored in host byte order as well.</span></span> <span data-ttu-id="0a867-136">Это позволяет разработчикам легко просматривать значения с помощью отладчика.</span><span class="sxs-lookup"><span data-stu-id="0a867-136">This enables developers to easily view the values via a debugger.</span></span> <span data-ttu-id="0a867-137">Если эти значения запрограммированы в кадре для передачи, они преобразуются в сетевой порядок байтов.</span><span class="sxs-lookup"><span data-stu-id="0a867-137">When these values are programmed into a frame for transmission, they are converted to network byte order.</span></span>

### <a name="internal-ip-thread"></a><span data-ttu-id="0a867-138">Внутренний IP-поток</span><span class="sxs-lookup"><span data-stu-id="0a867-138">Internal IP Thread</span></span>

<span data-ttu-id="0a867-139">Как уже упоминалось, у каждого IP-экземпляра в NetX имеется собственный поток.</span><span class="sxs-lookup"><span data-stu-id="0a867-139">As mentioned, each IP instance in NetX has its own thread.</span></span> <span data-ttu-id="0a867-140">Приоритет и размер стека внутреннего IP-потока определяются в службе ***nx_ip_create***.</span><span class="sxs-lookup"><span data-stu-id="0a867-140">The priority and stack size of the internal IP thread is defined in the ***nx_ip_create*** service.</span></span> <span data-ttu-id="0a867-141">Внутренний IP-поток создается в режиме готовности к выполнению.</span><span class="sxs-lookup"><span data-stu-id="0a867-141">The internal IP thread is created in a ready-to-execute mode.</span></span> <span data-ttu-id="0a867-142">Если IP-поток имеет более высокий приоритет, чем вызывающий поток, при вызове операции создания IP-адреса может произойти вытеснение.</span><span class="sxs-lookup"><span data-stu-id="0a867-142">If the IP thread has a higher priority than the calling thread, preemption may occur inside the IP create call.</span></span>

<span data-ttu-id="0a867-143">Точка входа во внутренний IP-поток находится во внутренней функции ***_nx_ip_thread_entry***.</span><span class="sxs-lookup"><span data-stu-id="0a867-143">The entry point of the internal IP thread is at the internal function ***_nx_ip_thread_entry***.</span></span> <span data-ttu-id="0a867-144">При запуске внутренний IP-поток сначала выполняет инициализацию драйвера сети, которая заключается в выполнении трех вызовов драйвера сети конкретного приложения.</span><span class="sxs-lookup"><span data-stu-id="0a867-144">When started, the internal IP thread first completes network driver initialization, which consists of making three calls to the application-specific network driver.</span></span> <span data-ttu-id="0a867-145">Первый вызов обеспечивает присоединение сетевого драйвера к IP-экземпляру. Далее следует вызов инициализации, который позволяет сетевому драйверу пройти процесс инициализации.</span><span class="sxs-lookup"><span data-stu-id="0a867-145">The first call is to attach the network driver to the IP instance, followed by an initialization call, which allows the network driver to go through the initialization process.</span></span> <span data-ttu-id="0a867-146">После того как сетевой драйвер возвращается из состояния инициализации (он может быть приостановлен, ожидая правильной настройки оборудования), внутренний IP-поток снова вызывает его, чтобы включить канал.</span><span class="sxs-lookup"><span data-stu-id="0a867-146">After the network driver returns from initialization (it may suspend while waiting for the hardware to be properly set up), the internal IP thread calls the network driver again to enable the link.</span></span> 

<span data-ttu-id="0a867-147">После возврата сетевого драйвера из вызова включения канала внутренний IP-поток переходит в бесконечный цикл проверки для различных событий, требующих обработки для данного IP-экземпляра.</span><span class="sxs-lookup"><span data-stu-id="0a867-147">After the network driver returns from the link enable call, the internal IP thread enters an endless loop checking for various events that need processing for this IP instance.</span></span> <span data-ttu-id="0a867-148">События, обрабатываемые в этом цикле, включают отложенное получение IP-пакетов, сборку фрагментов IP-пакетов, обработку проверки связи ICMP, обработку IGMP, обработку очереди пакетов TCP, периодическую обработку TCP, истечение времени ожидания сборки фрагментов IP-адресов и периодическую обработку IGMP.</span><span class="sxs-lookup"><span data-stu-id="0a867-148">Events processed in this loop include deferred IP packet reception, IP packet fragment assembly, ICMP ping processing, IGMP processing, TCP packet queue processing, TCP periodic processing, IP fragment assembly timeouts, and IGMP periodic processing.</span></span> <span data-ttu-id="0a867-149">К событиям также относятся действия по разрешению адресов: обработка ARP-пакетов и периодическая обработка ARP в IP-сети.</span><span class="sxs-lookup"><span data-stu-id="0a867-149">Events also include address resolution activities: ARP packet processing and ARP periodic processing in the IP network.</span></span>

> [!NOTE]
> <span data-ttu-id="0a867-150">*Функции обратного вызова NetX, включая обратные вызовы операций ожидания передачи данных и отключения, вызываются не из исходного вызывающего потока, а из внутреннего IP-потока. В приложении должны быть приняты меры для предотвращения приостановки внутри любой функции обратного вызова NetX.*</span><span class="sxs-lookup"><span data-stu-id="0a867-150">*The NetX callback functions, including listen and disconnect callbacks, are called from the internal IP thread—not the original calling thread. The application must take care not to suspend inside any NetX callback function.*</span></span>

### <a name="ip-periodic-timers"></a><span data-ttu-id="0a867-151">Периодические таймеры IP-экземпляра</span><span class="sxs-lookup"><span data-stu-id="0a867-151">IP Periodic Timers</span></span>
<span data-ttu-id="0a867-152">Для каждого IP-экземпляра используется два периодических таймера ThreadX.</span><span class="sxs-lookup"><span data-stu-id="0a867-152">There are two ThreadX periodic timers used for each IP instance.</span></span> <span data-ttu-id="0a867-153">Первый — это секундный таймер для времени ожидания ARP, IGMP и TCP, а также для инициализации обработки повторной сборки фрагмента IP-пакета.</span><span class="sxs-lookup"><span data-stu-id="0a867-153">The first one is a one-second timer for ARP, IGMP, TCP timeout, and it also drives IP fragment reassemble processing.</span></span> <span data-ttu-id="0a867-154">Второй таймер — это таймер на 100 мс, позволяющий управлять временем ожидания повторной отправки TCP-пакетов.</span><span class="sxs-lookup"><span data-stu-id="0a867-154">The second timer is a 100ms timer to drive the TCP retransmission timeout.</span></span>

### <a name="network-driver"></a><span data-ttu-id="0a867-155">Сетевой драйвер</span><span class="sxs-lookup"><span data-stu-id="0a867-155">Network Driver</span></span>
<span data-ttu-id="0a867-156">Каждый IP-экземпляр в NetX имеет основной интерфейс, который определяется драйвером устройства, указанным в службе ***nx_ip_create***.</span><span class="sxs-lookup"><span data-stu-id="0a867-156">Each IP instance in NetX has a primary interface, which is identified by its device driver specified in the ***nx_ip_create*** service.</span></span> <span data-ttu-id="0a867-157">Сетевой драйвер отвечает за обработку различных запросов NetX, в том числе запросов на передачу и получение пакетов, а также запросов состояния и управления.</span><span class="sxs-lookup"><span data-stu-id="0a867-157">The network driver is responsible for handling various NetX requests, including packet transmission, packet reception, and requests for status and control.</span></span>

<span data-ttu-id="0a867-158">В системах с множественной адресацией IP-экземпляр имеет несколько интерфейсов, у каждого из которых имеется соответствующий сетевой драйвер, выполняющий эти задачи для соответствующего интерфейса.</span><span class="sxs-lookup"><span data-stu-id="0a867-158">For a multi-home system, the IP instance has multiple interfaces, each with an associated network driver that performs these tasks for the respective interface.</span></span>

<span data-ttu-id="0a867-159">Сетевой драйвер также должен обрабатывать асинхронные события, происходящие на носителе.</span><span class="sxs-lookup"><span data-stu-id="0a867-159">The network driver must also handle asynchronous events occurring on the media.</span></span> <span data-ttu-id="0a867-160">Асинхронные события с носителя включают в себя получение пакетов, завершение передачи пакетов и изменение состояния.</span><span class="sxs-lookup"><span data-stu-id="0a867-160">Asynchronous events from the media include packet reception, packet transmission completion, and status changes.</span></span> <span data-ttu-id="0a867-161">NetX предоставляет сетевой драйвер с несколькими функциями доступа для управления различными событиями.</span><span class="sxs-lookup"><span data-stu-id="0a867-161">NetX provides the network driver with several access functions to handle various events.</span></span> <span data-ttu-id="0a867-162">Эти функции предназначены для вызова из части сетевого драйвера, связанной с подпрограммой обработки прерываний.</span><span class="sxs-lookup"><span data-stu-id="0a867-162">These functions are designed to be called from the interrupt service routine portion of the network driver.</span></span> <span data-ttu-id="0a867-163">Для IP-сетей сетевой драйвер должен пересылать все полученные ARP-пакеты внутренней функции \* **_nx_arp_packet_deferred_receive** _.</span><span class="sxs-lookup"><span data-stu-id="0a867-163">For IP networks, the network driver should forward all ARP packets received to the \***_nx_arp_packet_deferred_receive** _ internal function.</span></span> <span data-ttu-id="0a867-164">Все пакеты RARP должны перенаправляться на внутреннюю функцию _ *_ _nx_rarp_packet_deferred_receive_* _.</span><span class="sxs-lookup"><span data-stu-id="0a867-164">All RARP packets should be forwarded to _ *_ _nx_rarp_packet_deferred_receive_* _ internal function.</span></span> <span data-ttu-id="0a867-165">Для IP-пакетов существует два варианта.</span><span class="sxs-lookup"><span data-stu-id="0a867-165">There are two options for IP packets.</span></span> <span data-ttu-id="0a867-166">Если требуется быстрая отправка IP-пакетов, входящие IP-пакеты должны перенаправляться в _ *_ _nx_ip_packet_receive_* _ для немедленной обработки.</span><span class="sxs-lookup"><span data-stu-id="0a867-166">If fast dispatch of IP packets is required, incoming IP packets should be forwarded to _ *_ _nx_ip_packet_receive_* _ for immediate processing.</span></span> <span data-ttu-id="0a867-167">Это значительно повышает производительность NetX при обработке IP-пакетов.</span><span class="sxs-lookup"><span data-stu-id="0a867-167">This greatly improves NetX performance in handling IP packets.</span></span> <span data-ttu-id="0a867-168">В противном случае сетевой драйвер должен пересылать IP-пакеты в _\*_ _nx_ip_packet_deferred_receive_\*\*.</span><span class="sxs-lookup"><span data-stu-id="0a867-168">Otherwise, the network driver should forward IP packets to _\*_ _nx_ip_packet_deferred_receive_\*\*.</span></span> <span data-ttu-id="0a867-169">Эта служба помещает IP-пакет в очередь отложенной обработки, где он обрабатывается внутренним IP-потоком, что обеспечивает минимальное время обработки ISR.</span><span class="sxs-lookup"><span data-stu-id="0a867-169">This service places the IP packet in the deferred processing queue where it is then handled by the internal IP thread, which results in the least amount of ISR processing time.</span></span>

<span data-ttu-id="0a867-170">Сетевой драйвер также может отложить обработку прерываний для выполнения вне контекста IP-потока.</span><span class="sxs-lookup"><span data-stu-id="0a867-170">The network driver can also defer interrupt processing to run out of the context of the IP thread.</span></span> <span data-ttu-id="0a867-171">В этом режиме ISR сохраняет необходимые сведения, вызывает внутреннюю функцию ***_nx_ip_driver_deferred_processing*** и подтверждает использование контроллера прерываний.</span><span class="sxs-lookup"><span data-stu-id="0a867-171">In this mode, the ISR shall save the necessary information, call the internal function ***_nx_ip_driver_deferred_processing***, and acknowledge the interrupt controller.</span></span> <span data-ttu-id="0a867-172">Эта служба уведомляет IP-поток о том, что необходимо запланировать обратный вызов драйвера устройства для завершения обработки события, вызывающего прерывание.</span><span class="sxs-lookup"><span data-stu-id="0a867-172">This service notifies IP thread to schedule a callback to the device driver to complete the processing of the event that causes the interrupt.</span></span>

<span data-ttu-id="0a867-173">Некоторые сетевые контроллеры способны выполнять вычисление и проверку контрольной суммы заголовков TCP/IP аппаратными средствами, не расходуя ценные ресурсы ЦП.</span><span class="sxs-lookup"><span data-stu-id="0a867-173">Some network controllers are capable of performing TCP/IP header checksum computation and validation in hardware, without taking up valuable CPU resources.</span></span> <span data-ttu-id="0a867-174">Чтобы воспользоваться преимуществами возможностей оборудования, NetX предоставляет параметры для включения и отключения различных вычислений контрольной суммы программными средствами во время компиляции, а также включения и отключения вычислений контрольной суммы во время выполнения.</span><span class="sxs-lookup"><span data-stu-id="0a867-174">To take advantage of the hardware capability feature, NetX provides options to enable or disable various software checksum computation at compilation time, as well as turning on or off checksum computation at run time.</span></span> <span data-ttu-id="0a867-175">Более подробные сведения о создании сетевых драйверов NetX см. в главе 5 [Сетевые драйверы NetX](chapter5.md).</span><span class="sxs-lookup"><span data-stu-id="0a867-175">See "[Chapter 5 NetX Network Drivers](chapter5.md)" for more detailed information on writing NetX network drivers.</span></span>

### <a name="multihome-support"></a><span data-ttu-id="0a867-176">Поддержка множественной адресации</span><span class="sxs-lookup"><span data-stu-id="0a867-176">Multihome Support</span></span>
<span data-ttu-id="0a867-177">NetX поддерживает системы, подключенные к нескольким физическим устройствам с помощью одного IP-экземпляра.</span><span class="sxs-lookup"><span data-stu-id="0a867-177">NetX supports systems connected to multiple physical devices using a single IP instance.</span></span> <span data-ttu-id="0a867-178">Каждый физический интерфейс назначается блоку управления взаимодействием в IP-экземпляре.</span><span class="sxs-lookup"><span data-stu-id="0a867-178">Each physical interface is assigned to an interface control block in the IP instance.</span></span> <span data-ttu-id="0a867-179">Приложения, желающие использовать систему с множественной адресацией, должны задать для **NX_MAX_PHSYCIAL_INTERFACES** значение, равное числу физических устройств, подключенных к системе, и перестроить библиотеку NetX.</span><span class="sxs-lookup"><span data-stu-id="0a867-179">Applications wishing to use a multihome system must define the value for **NX_MAX_PHSYCIAL_INTERFACES** to the number of physical devices attached to the system, and rebuild NetX library.</span></span> <span data-ttu-id="0a867-180">По умолчанию значение **NX_MAX_PHYSICAL_INTERFACES** равно единице, что обеспечивает создание одного блока управления взаимодействием в IP-экземпляре.</span><span class="sxs-lookup"><span data-stu-id="0a867-180">By default **NX_MAX_PHYSICAL_INTERFACES** is set to one, creating one interface control block in the IP instance.</span></span>

<span data-ttu-id="0a867-181">Приложение NetX создает один экземпляр IP-адреса для основного устройства с помощью службы \***nx_ip_create** _.</span><span class="sxs-lookup"><span data-stu-id="0a867-181">The NetX application creates a single IP instance for the primary device using the \***nx_ip_create** _ service.</span></span> <span data-ttu-id="0a867-182">Для каждого дополнительного сетевого устройства приложение подключает устройство к IP-экземпляру с помощью службы _ \*_nx_ip_interface_attach_\*\*.</span><span class="sxs-lookup"><span data-stu-id="0a867-182">For each additional network devices, the application attaches the device to the IP instance using the _ *_nx_ip_interface_attach_*\* service.</span></span>

<span data-ttu-id="0a867-183">Каждая структура сетевого интерфейса содержит подмножество сетевых сведений о сетевом интерфейсе, который содержится в блоке управления IP-экземпляра, в том числе IP-адрес интерфейса, маску подсети, размер MTU IP-экземпляра и сведения об адресе MAC-уровня.</span><span class="sxs-lookup"><span data-stu-id="0a867-183">Each network interface structure contains a subset of network information about the network interface that is contained in the IP control block, including interface IP address, subnet mask, IP MTU size, and MAC-layer address information.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="0a867-184">*NetX с поддержкой множественной адресации обеспечивает обратную совместимость с более ранними версиями NetX. Службы, которые не принимают явные сведения об интерфейсе, используют в качестве устройства по умолчанию основное сетевое устройство.*</span><span class="sxs-lookup"><span data-stu-id="0a867-184">*NetX with multihome support is backward compatible with earlier versions of NetX. Services that do not take explicit interface information default to the primary network device.*</span></span>

<span data-ttu-id="0a867-185">Первичный интерфейс имеет нулевой индекс в списке IP-экземпляров.</span><span class="sxs-lookup"><span data-stu-id="0a867-185">The primary interface has index zero in the IP instance list.</span></span> <span data-ttu-id="0a867-186">Каждому последующему устройству, подключенному к IP-экземпляру, присваивается следующий индекс.</span><span class="sxs-lookup"><span data-stu-id="0a867-186">Each subsequent device attached to the IP instance is assigned the next index.</span></span>

<span data-ttu-id="0a867-187">Все службы протокола верхнего уровня, для которых включен экземпляр IP-адресов, в том числе TCP, UDP, ICMP и IGMP, доступны для всех подключенных устройств.</span><span class="sxs-lookup"><span data-stu-id="0a867-187">All upper layer protocol services for which the IP instance is enabled, including TCP, UDP, ICMP, and IGMP, are available to all the attached devices.</span></span>

<span data-ttu-id="0a867-188">В большинстве случаев NetX может определить оптимальный исходный адрес, который будет использоваться при передаче пакета.</span><span class="sxs-lookup"><span data-stu-id="0a867-188">In most cases, NetX can determine the best source address to use when transmitting a packet.</span></span> <span data-ttu-id="0a867-189">Адрес источника выбирается на основе адреса назначения.</span><span class="sxs-lookup"><span data-stu-id="0a867-189">The source address selection is based on the destination address.</span></span> <span data-ttu-id="0a867-190">Чтобы разрешить приложениям указывать конкретный адрес источника для использования в тех случаях, когда наиболее подходящий адрес источника не может быть определен по адресу назначения, предоставляются службы NetX.</span><span class="sxs-lookup"><span data-stu-id="0a867-190">NetX services are provided to allow applications to specify a specific source address to use, in cases where the most suitable one cannot be determined by the destination address.</span></span> <span data-ttu-id="0a867-191">Например, в системе с множественной адресацией приложение должно отправлять пакет на широковещательный IP-адрес или адрес назначения многоадресной рассылки.</span><span class="sxs-lookup"><span data-stu-id="0a867-191">An example would be in a multihome system, an application needs to send a packet to an IP broadcast or multicast destination addresses.</span></span>

<span data-ttu-id="0a867-192">Ниже перечислены службы, предназначенные специально для разработки приложений с множественной адресацией.</span><span class="sxs-lookup"><span data-stu-id="0a867-192">Services specifically for developing multihome applications include the following:</span></span>

<span data-ttu-id="0a867-193">*nx_igmp_multicast_interface_join nx_ip_driver_interface_direct_command nx_ip_interface_address_get nx_ip_interface_address_set nx_ip_interface_attach nx_ip_interface_info_get nx_ip_interface_status_check nx_ip_raw_packet_interface_send nx_udp_socket_interface_send*</span><span class="sxs-lookup"><span data-stu-id="0a867-193">*nx_igmp_multicast_interface_join nx_ip_driver_interface_direct_command nx_ip_interface_address_get nx_ip_interface_address_set nx_ip_interface_attach nx_ip_interface_info_get nx_ip_interface_status_check nx_ip_raw_packet_interface_send nx_udp_socket_interface_send*</span></span>

<span data-ttu-id="0a867-194">Эти службы более подробно описаны в главе 4 [Описание служб NetX для ОСРВ Azure](chapter4.md).</span><span class="sxs-lookup"><span data-stu-id="0a867-194">These services are explained in greater detail in "[Chapter 4 - Description of Azure RTOS NetX Services](chapter4.md)".</span></span>

### <a name="loopback-interface"></a><span data-ttu-id="0a867-195">Интерфейс замыкания на себя</span><span class="sxs-lookup"><span data-stu-id="0a867-195">Loopback Interface</span></span>
<span data-ttu-id="0a867-196">Интерфейс замыкания на себя — это специальный сетевой интерфейс без подключения физического канала.</span><span class="sxs-lookup"><span data-stu-id="0a867-196">The loopback interface is a special network interface without an physical link attached to.</span></span> <span data-ttu-id="0a867-197">Интерфейс замыкания на себя позволяет приложениям взаимодействовать с помощью петлевого IP-адреса 127.0.0.1</span><span class="sxs-lookup"><span data-stu-id="0a867-197">The loopback interface allows applications to communicate using the IP loopback address 127.0.0.1</span></span>

<span data-ttu-id="0a867-198">Чтобы использовать логический интерфейс замыкания на себя, убедитесь, что параметр ***NX_DISABLE_LOOPBACK_INTERFACE*** не задан.</span><span class="sxs-lookup"><span data-stu-id="0a867-198">To utilize a logical loopback interface, ensure the configurable option ***NX_DISABLE_LOOPBACK_INTERFACE*** is not set.</span></span>

### <a name="interface-control-blocks"></a><span data-ttu-id="0a867-199">Блоки управления взаимодействием</span><span class="sxs-lookup"><span data-stu-id="0a867-199">Interface Control Blocks</span></span>
<span data-ttu-id="0a867-200">Количество блоков управления взаимодействием в IP-экземпляре — это число физических интерфейсов (определяемое \***NX_MAX_PHYSICAL_INTERFACES** _) и интерфейс замыкания на себя, если он включен.</span><span class="sxs-lookup"><span data-stu-id="0a867-200">The number of interface control blocks in the IP instance is the number of physical interfaces (defined by \***NX_MAX_PHYSICAL_INTERFACES** _) plus the loopback interface if it is enabled.</span></span> <span data-ttu-id="0a867-201">Общее число интерфейсов определяется в _\*_NX_MAX_IP_INTERFACES_\*\*.</span><span class="sxs-lookup"><span data-stu-id="0a867-201">The total number of interfaces is defined in _\*_NX_MAX_IP_INTERFACES_\*\*.</span></span>

## <a name="protocol-layering"></a><span data-ttu-id="0a867-202">Разделение протокола на уровни</span><span class="sxs-lookup"><span data-stu-id="0a867-202">Protocol Layering</span></span>

<span data-ttu-id="0a867-203">Протокол TCP/IP, реализованный в NetX, является многоуровневым. Это означает, что более сложные протоколы основаны на более простых базовых протоколах.</span><span class="sxs-lookup"><span data-stu-id="0a867-203">The TCP/IP implemented by NetX is a layered protocol, which means more complex protocols are built on top of simpler underlying protocols.</span></span> <span data-ttu-id="0a867-204">В протоколе TCP/IP протокол самого низкого уровня находится на *канальном уровне* и обрабатывается сетевым драйвером.</span><span class="sxs-lookup"><span data-stu-id="0a867-204">In TCP/ IP, the lowest layer protocol is at the *link Layer* and is handled by the network driver.</span></span> <span data-ttu-id="0a867-205">Этот уровень обычно предназначен для Ethernet, но он также может быть реализован на базе оптоволоконного или последовательного канала или практически любого физического носителя.</span><span class="sxs-lookup"><span data-stu-id="0a867-205">This level is typically targeted towards Ethernet, but it could also be fiber, serial, or virtually any physical media.</span></span>

<span data-ttu-id="0a867-206">Над канальным уровнем находится *сетевой*.</span><span class="sxs-lookup"><span data-stu-id="0a867-206">On top of the link layer is the *Network layer*.</span></span> <span data-ttu-id="0a867-207">В TCP/IP это IP-интерфейс, который, по сути, отвечает за отправку и получение простых пакетов по сети по принципу наименьших затрат.</span><span class="sxs-lookup"><span data-stu-id="0a867-207">In TCP/IP, this is the IP, which is basically responsible for sending and receiving simple packets, in a best-effort manner, across the network.</span></span> <span data-ttu-id="0a867-208">Протоколы, относящиеся к управляющим типам, например ICMP и IGMP, обычно также делятся на сетевые уровни, хотя и используют IP-протокол для отправки и получения.</span><span class="sxs-lookup"><span data-stu-id="0a867-208">Management type protocols like ICMP and IGMP are typically also categorized as network layers, even though they rely on IP for sending and receiving.</span></span>

<span data-ttu-id="0a867-209">*Транспортный уровень* располагается поверх сетевого.</span><span class="sxs-lookup"><span data-stu-id="0a867-209">The *Transport layer* rests on top of the network layer.</span></span> <span data-ttu-id="0a867-210">Этот уровень отвечает за управление потоком данных между узлами в сети.</span><span class="sxs-lookup"><span data-stu-id="0a867-210">This layer is responsible for managing the flow of data between hosts on the network.</span></span> <span data-ttu-id="0a867-211">NetX поддерживает два типа транспортных служб: UDP и TCP.</span><span class="sxs-lookup"><span data-stu-id="0a867-211">There are two types of transport services supported by NetX: UDP and TCP.</span></span> <span data-ttu-id="0a867-212">Службы UDP обеспечивают отправку и получение данных между двумя узлами по принципу наименьших затрат без установки подключения, в то время как TCP обеспечивает надежное обслуживание с ориентацией на подключение для передачи данных между двумя сущностями узла.</span><span class="sxs-lookup"><span data-stu-id="0a867-212">UDP services provide best-effort sending and receiving of data between two hosts in a connectionless manner, while TCP provides reliable connection-oriented service between two host entities.</span></span>

<span data-ttu-id="0a867-213">Это разделение на уровни отражается на фактических пакетах сетевых данных.</span><span class="sxs-lookup"><span data-stu-id="0a867-213">This layering is reflected in the actual network data packets.</span></span> <span data-ttu-id="0a867-214">Каждый слой в TCP/IP содержит блок данных, называемый заголовком.</span><span class="sxs-lookup"><span data-stu-id="0a867-214">Each layer in TCP/IP contains a block of information called a header.</span></span> <span data-ttu-id="0a867-215">Такой метод заключения данных (и, возможно, сведений о протоколе) в заголовок обычно называется инкапсуляцией данных.</span><span class="sxs-lookup"><span data-stu-id="0a867-215">This technique of surrounding data (and possibly protocol information) with a header is typically called data encapsulation.</span></span> <span data-ttu-id="0a867-216">На рис. 1 показан пример разделения NetX на уровни, а на рис. 2 — итоговая инкапсуляция отправляемых данных UDP.</span><span class="sxs-lookup"><span data-stu-id="0a867-216">Figure 1 shows an example of NetX layering and Figure 2 shows the resulting data encapsulation for UDP data being sent.</span></span>

![Разделение протокола на уровни](./media/user-guide/protocol-layering.png)

<span data-ttu-id="0a867-218">**РИС. 1. Разделение протокола на уровни**</span><span class="sxs-lookup"><span data-stu-id="0a867-218">**FIGURE 1. Protocol Layering**</span></span>

![Инкапсуляция данных UDP](./media/user-guide/udp-data-encapsulation.png)

<span data-ttu-id="0a867-220">**РИС. 2. Инкапсуляция данных UDP**</span><span class="sxs-lookup"><span data-stu-id="0a867-220">**FIGURE 2. UDP Data Encapsulation**</span></span>

## <a name="packet-pools"></a><span data-ttu-id="0a867-221">Пулы пакетов</span><span class="sxs-lookup"><span data-stu-id="0a867-221">Packet Pools</span></span>

<span data-ttu-id="0a867-222">Быстрое и детерминированное выделение пакетов — вечная проблема в сетевых приложениях реального времени.</span><span class="sxs-lookup"><span data-stu-id="0a867-222">Allocating packets in a fast and deterministic manner is always a challenge in real-time networking applications.</span></span> <span data-ttu-id="0a867-223">Ввиду этого NetX предоставляет возможность создания и администрирования нескольких пулов сетевых пакетов фиксированного размера.</span><span class="sxs-lookup"><span data-stu-id="0a867-223">With this in mind, NetX provides the ability to create and manage multiple pools of fixed-size network packets.</span></span>

<span data-ttu-id="0a867-224">Так как пулы пакетов NetX состоят из блоков памяти фиксированного размера, никаких внутренних проблем из-за фрагментации не возникает.</span><span class="sxs-lookup"><span data-stu-id="0a867-224">Because NetX packet pools consist of fixed-size memory blocks, there are never any internal fragmentation problems.</span></span> <span data-ttu-id="0a867-225">Конечно, фрагментация приводит к поведению, которое, по сути, является недетерминированным.</span><span class="sxs-lookup"><span data-stu-id="0a867-225">Of course, fragmentation causes behavior that is inherently nondeterministic.</span></span>

<span data-ttu-id="0a867-226">Кроме того, время, необходимое для выделения и освобождения пакета NetX, соответствует времени простой операции со связанным списком.</span><span class="sxs-lookup"><span data-stu-id="0a867-226">In addition, the time required to allocate and free a NetX packet amounts to simple linked-list manipulation.</span></span> <span data-ttu-id="0a867-227">Более того, выделение и освобождение пакета выполняется на уровне заголовка списка доступных ресурсов.</span><span class="sxs-lookup"><span data-stu-id="0a867-227">Furthermore, packet allocation and deallocation is done at the head of the available list.</span></span> <span data-ttu-id="0a867-228">Это обеспечивает максимально быструю обработку связанного списка.</span><span class="sxs-lookup"><span data-stu-id="0a867-228">This provides the fastest possible linked list processing.</span></span>

<span data-ttu-id="0a867-229">Отсутствие гибкости обычно является основным недостатком пулов пакетов фиксированного размера.</span><span class="sxs-lookup"><span data-stu-id="0a867-229">Lack of flexibility is typically the main drawback of fixed-size packet pools.</span></span> <span data-ttu-id="0a867-230">Определение оптимального размера полезных данных пакета, который также позволит обрабатывать входящие пакеты в худшем случае, — сложная задача.</span><span class="sxs-lookup"><span data-stu-id="0a867-230">Determining the optimal packet payload size that also handles the worst-case incoming packet is a difficult task.</span></span> <span data-ttu-id="0a867-231">Пакеты NetX устраняют эту проблему с помощью необязательного компонента, называемого *цепочкой пакетов*.</span><span class="sxs-lookup"><span data-stu-id="0a867-231">NetX packets address this problem with an optional feature called *packet chaining*.</span></span> <span data-ttu-id="0a867-232">Фактический сетевой пакет может состоять из одного или нескольких пакетов NetX, связанных друг с другом.</span><span class="sxs-lookup"><span data-stu-id="0a867-232">An actual network packet can be made of one or more NetX packets linked together.</span></span> <span data-ttu-id="0a867-233">Кроме того, в заголовке пакета хранится указатель на верхнюю часть пакета.</span><span class="sxs-lookup"><span data-stu-id="0a867-233">In addition, the packet header maintains a pointer to the top of the packet.</span></span> <span data-ttu-id="0a867-234">По мере добавления дополнительных протоколов этот указатель просто смещается назад, а непосредственно перед данными записывается новый заголовок.</span><span class="sxs-lookup"><span data-stu-id="0a867-234">As additional protocols are added, this pointer is simply moved backwards and the new header is written directly in front of the data.</span></span> <span data-ttu-id="0a867-235">Без технологии гибких пакетов стеку пришлось бы выделить другой буфер и скопировать данные в новый буфер с новым заголовком, а это весьма ресурсоемкая задача.</span><span class="sxs-lookup"><span data-stu-id="0a867-235">Without the flexible packet technology, the stack would have to allocate another buffer and copy the data into a new buffer with the new header, which is processing intensive.</span></span>

<span data-ttu-id="0a867-236">Так как размер полезных данных каждого пакета фиксирован для заданного пула пакетов, данные приложения, превышающие размер полезных данных, требуют объединения нескольких пакетов в цепочку.</span><span class="sxs-lookup"><span data-stu-id="0a867-236">Since each packet payload size is fixed for a given packet pool, application data larger than the payload size  requires multiple packets chained together.</span></span> <span data-ttu-id="0a867-237">При заполнении пакета данными пользователя приложение должно использовать службу ***nx_packet_data_append***.</span><span class="sxs-lookup"><span data-stu-id="0a867-237">When filling a packet with user data, the application must use the service ***nx_packet_data_append***.</span></span> <span data-ttu-id="0a867-238">Эта служба перемещает данные приложения в пакет.</span><span class="sxs-lookup"><span data-stu-id="0a867-238">This service moves application data into a packet.</span></span> <span data-ttu-id="0a867-239">В ситуациях, когда пакета недостаточно для хранения пользовательских данных, для них выделяются дополнительные пакеты.</span><span class="sxs-lookup"><span data-stu-id="0a867-239">In situations where a packet is not enough to hold user data, additional packets are allocated to store user data.</span></span> <span data-ttu-id="0a867-240">Чтобы использовать цепочку пакетов, у драйвера должна быть возможность получения и передачи данных в объединенных в цепочку пакетах.</span><span class="sxs-lookup"><span data-stu-id="0a867-240">To use packet chaining, the driver must be able to receive into or transmit from chained packets.</span></span>

<span data-ttu-id="0a867-241">Каждый пул памяти пакетов NetX является общедоступным ресурсом.</span><span class="sxs-lookup"><span data-stu-id="0a867-241">Each NetX packet memory pool is a public resource.</span></span> <span data-ttu-id="0a867-242">NetX не накладывает ограничений на то, как используются пулы пакетов.</span><span class="sxs-lookup"><span data-stu-id="0a867-242">NetX places no constraints on how packet pools are used.</span></span>

### <a name="packet-pool-memory-area"></a><span data-ttu-id="0a867-243">Область памяти пула пакетов</span><span class="sxs-lookup"><span data-stu-id="0a867-243">Packet Pool Memory Area</span></span>
<span data-ttu-id="0a867-244">Область памяти для пула пакетов задается во время его создания.</span><span class="sxs-lookup"><span data-stu-id="0a867-244">The memory area for the packet pool is specified during creation.</span></span> <span data-ttu-id="0a867-245">Как и в случае с другими областями памяти для объектов ThreadX и NetX, она может находиться в любом месте целевого адресного пространства.</span><span class="sxs-lookup"><span data-stu-id="0a867-245">Like other memory areas for ThreadX and NetX objects, it can be located anywhere in the target's address space.</span></span> <span data-ttu-id="0a867-246">Это важная возможность, так как она обеспечивает значительную гибкость для приложения.</span><span class="sxs-lookup"><span data-stu-id="0a867-246">This is an important feature because of the considerable flexibility it gives the application.</span></span> <span data-ttu-id="0a867-247">Например, предположим, что у продукта взаимодействия имеется высокоскоростная область памяти для операций сетевых буферов.</span><span class="sxs-lookup"><span data-stu-id="0a867-247">For example, suppose that a communication product has a high-speed memory area for network buffers.</span></span> <span data-ttu-id="0a867-248">Эту область памяти можно легко использовать, превратив ее в пул памяти пакетов NetX.</span><span class="sxs-lookup"><span data-stu-id="0a867-248">This memory area is easily utilized by making it into a NetX packet memory pool.</span></span>

### <a name="creating-packet-pools"></a><span data-ttu-id="0a867-249">Создание пулов пакетов</span><span class="sxs-lookup"><span data-stu-id="0a867-249">Creating Packet Pools</span></span>
<span data-ttu-id="0a867-250">Пулы пакетов создаются во время инициализации или выполнения потоками приложения.</span><span class="sxs-lookup"><span data-stu-id="0a867-250">Packet pools are created either during initialization or during runtime by application threads.</span></span> <span data-ttu-id="0a867-251">Количество пулов памяти пакетов в приложении NetX не ограничено.</span><span class="sxs-lookup"><span data-stu-id="0a867-251">There are no limits on the number of packet memory pools in a NetX application.</span></span>

### <a name="packet-header-nx_packet"></a><span data-ttu-id="0a867-252">NX_PACKET: заголовок пакета</span><span class="sxs-lookup"><span data-stu-id="0a867-252">Packet Header NX_PACKET</span></span>
<span data-ttu-id="0a867-253">По умолчанию NetX помещает заголовок пакета непосредственно перед областью полезных данных пакета.</span><span class="sxs-lookup"><span data-stu-id="0a867-253">By default, NetX places the packet header immediately before the packet payload area.</span></span> <span data-ttu-id="0a867-254">Пул памяти пакетов — это, по сути, ряд, состоящий из пакетов: заголовков, непосредственно за которыми следуют полезные данные пакета.</span><span class="sxs-lookup"><span data-stu-id="0a867-254">The packet memory pool is basically a series of packets—headers followed immediately by the packet payload.</span></span> <span data-ttu-id="0a867-255">Заголовок пакета (***NX_PACKET***) и макет пула пакетов изображены на рис. 3.</span><span class="sxs-lookup"><span data-stu-id="0a867-255">The packet header (***NX_PACKET***) and the layout of the packet pool are pictured in Figure 3.</span></span>

<span data-ttu-id="0a867-256">Обычно для драйвера сетевых устройств, который может выполнять операции без копирования, начальный адрес области полезных данных пакета запрограммирован в логике DMA.</span><span class="sxs-lookup"><span data-stu-id="0a867-256">For network devices driver that are able to perform zero copy operations, typically the starting address of the packet payload area is programmed into the DMA logic.</span></span> <span data-ttu-id="0a867-257">Некоторые модули DMA имеют требование к выравниванию для области полезных данных.</span><span class="sxs-lookup"><span data-stu-id="0a867-257">Certain DMA engines have alignment requirement on the payload area.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="0a867-258">\*Сетевой драйвер должен вызвать функцию \***nx_packet_transmit_release** _ после завершения передачи пакета.</span><span class="sxs-lookup"><span data-stu-id="0a867-258">\*The network driver to must call the \***nx_packet_transmit_release** _ function when the transmission of a packet is complete.</span></span> <span data-ttu-id="0a867-259">Эта функция следит за тем, чтобы пакет не был добавлен в очередь вывода TCP до его фактического помещения обратно в пул доступных ресурсов.</span><span class="sxs-lookup"><span data-stu-id="0a867-259">This function checks to make sure the packet is not part of a TCP output queue before it is actually placed back in the available pool.</span></span> <span data-ttu-id="0a867-260">Сбой вызова этой функции может привести к непредсказуемому поведению._</span><span class="sxs-lookup"><span data-stu-id="0a867-260">Failure to call this function can result in unpredictable behavior._</span></span>

![Заголовок пакета и макет пула пакетов](./media/user-guide/packet-header-packet-pool-layout.png)

<span data-ttu-id="0a867-262">**РИС. 3. Заголовок пакета и макет пула пакетов**</span><span class="sxs-lookup"><span data-stu-id="0a867-262">**FIGURE 3. Packet Header and Packet Pool Layout**</span></span>

<span data-ttu-id="0a867-263">Поля заголовка пакета определяются, как показано в следующей таблице.</span><span class="sxs-lookup"><span data-stu-id="0a867-263">The fields of the packet header are defined as shown in the following table.</span></span> <span data-ttu-id="0a867-264">Обратите внимание, что эта таблица не является исчерпывающим списком всех элементов структуры *NX_PACKET*.</span><span class="sxs-lookup"><span data-stu-id="0a867-264">Note that this table is not a comprehensive list of all the members in the *NX_PACKET* structure.</span></span>

| <span data-ttu-id="0a867-265">Заголовок пакета</span><span class="sxs-lookup"><span data-stu-id="0a867-265">Packet header</span></span>          | <span data-ttu-id="0a867-266">Назначение</span><span class="sxs-lookup"><span data-stu-id="0a867-266">Purpose</span></span>                                                                                                                                                                                                                                                                                                                            |
|------------------------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| <span data-ttu-id="0a867-267">*nx_packet_pool_owner*</span><span class="sxs-lookup"><span data-stu-id="0a867-267">*nx_packet_pool_owner*</span></span>   | <span data-ttu-id="0a867-268">Это поле указывает на пул пакетов, которому принадлежит этот конкретный пакет.</span><span class="sxs-lookup"><span data-stu-id="0a867-268">This field points to the packet pool that owns this particular packet.</span></span> <span data-ttu-id="0a867-269">После освобождения пакета он становится доступным в этом конкретном пуле.</span><span class="sxs-lookup"><span data-stu-id="0a867-269">When the packet is released, it is released to this particular pool.</span></span> <span data-ttu-id="0a867-270">Если владение пулом находится внутри каждого пакета, датаграмма может охватывать несколько пакетов из нескольких пулов пакетов.</span><span class="sxs-lookup"><span data-stu-id="0a867-270">With the pool ownership inside each packet, it is possible for a datagram to span multiple packets from multiple packet pools.</span></span>                                                         |
| <span data-ttu-id="0a867-271">*nx_packet_next*</span><span class="sxs-lookup"><span data-stu-id="0a867-271">*nx_packet_next*</span></span>         | <span data-ttu-id="0a867-272">Это поле указывает на следующий пакет в том же кадре.</span><span class="sxs-lookup"><span data-stu-id="0a867-272">This field points to the next packet within the same frame.</span></span> <span data-ttu-id="0a867-273">Если значение равно NULL, дополнительные пакеты, которые являются частью кадра, отсутствуют.</span><span class="sxs-lookup"><span data-stu-id="0a867-273">If NULL, there are no additional packets that are part of the frame.</span></span> |
| <span data-ttu-id="0a867-274">*nx_packet_last*</span><span class="sxs-lookup"><span data-stu-id="0a867-274">*nx_packet_last*</span></span>         | <span data-ttu-id="0a867-275">Это поле указывает на последний пакет в том же сетевом пакете.</span><span class="sxs-lookup"><span data-stu-id="0a867-275">This field points to the last packet within the same network packet.</span></span> <span data-ttu-id="0a867-276">Если значение равно NULL, этот пакет представляет весь сетевой пакет.</span><span class="sxs-lookup"><span data-stu-id="0a867-276">If NULL, this packet represents the entire network packet.</span></span>  |
| <span data-ttu-id="0a867-277">*nx_packet_length*</span><span class="sxs-lookup"><span data-stu-id="0a867-277">*nx_packet_length*</span></span>       | <span data-ttu-id="0a867-278">Это поле содержит общее число байтов во всем сетевом пакете, включая общее количество байтов во всех пакетах, связанных в цепочку с помощью элемента *nx_packet_next*.</span><span class="sxs-lookup"><span data-stu-id="0a867-278">This field contains the total number of bytes in the entire network packet, including the total of all bytes in all packets chained together by the *nx_packet_next* member.</span></span> |
| <span data-ttu-id="0a867-279">*nx_packet_ip_interface*</span><span class="sxs-lookup"><span data-stu-id="0a867-279">*nx_packet_ip_interface*</span></span> | <span data-ttu-id="0a867-280">Это поле является блоком управления взаимодействием, который назначается пакету при его получении драйвером интерфейса и его получении NetX для исходящих пакетов.</span><span class="sxs-lookup"><span data-stu-id="0a867-280">This field is the interface control block which is assigned to the packet when it is received by the interface driver, and by NetX for outgoing packets.</span></span> <span data-ttu-id="0a867-281">Блок управления взаимодействием описывает интерфейс, например сетевой адрес, MAC-адрес, IP-адрес, и его состояние, например, включена ли связь и требуется ли физическое сопоставление.</span><span class="sxs-lookup"><span data-stu-id="0a867-281">An interface control block describes the interface e.g. network address, MAC address, IP address and interface status such as link enabled and physical mapping required.</span></span> |
| <span data-ttu-id="0a867-282">*nx_packet_data_start*</span><span class="sxs-lookup"><span data-stu-id="0a867-282">*nx_packet_data_start*</span></span>   | <span data-ttu-id="0a867-283">Это поле указывает на начало физической области полезных данных этого пакета.</span><span class="sxs-lookup"><span data-stu-id="0a867-283">This field points to the start of the physical payload area of this packet.</span></span> <span data-ttu-id="0a867-284">Заголовок NX_PACKET не обязательно должен следовать непосредственно за ним, но для службы ***nx_packet_pool_create*** такая схема используется по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="0a867-284">It does not have to be immediately following the NX_PACKET header, but that is the default for the ***nx_packet_pool_create*** service.</span></span> |
| <span data-ttu-id="0a867-285">*nx_packet_data_end*</span><span class="sxs-lookup"><span data-stu-id="0a867-285">*nx_packet_data_end*</span></span>     | <span data-ttu-id="0a867-286">Это поле указывает на конец физической области полезных данных этого пакета.</span><span class="sxs-lookup"><span data-stu-id="0a867-286">This field points to the end of the physical payload area of this packet.</span></span> <span data-ttu-id="0a867-287">Разница между этим полем и полем nx_packet_data_start соответствует размеру полезных данных.</span><span class="sxs-lookup"><span data-stu-id="0a867-287">The difference between this field and the nx_packet_data_start field represents the payload size.</span></span> |
| <span data-ttu-id="0a867-288">*nx_packet_prepend_ptr*</span><span class="sxs-lookup"><span data-stu-id="0a867-288">*nx_packet_prepend_ptr*</span></span>  | <span data-ttu-id="0a867-289">Это поле указывает на расположение данных пакетов (заголовка протокола либо фактических данных), добавленных перед имеющимися данными в пакете (если таковые имеются) в области полезных данных пакета.</span><span class="sxs-lookup"><span data-stu-id="0a867-289">This field points to the location of where packet data, either protocol header or actual data, is added in front of the existing packet data (if any) in the packet payload area.</span></span> <span data-ttu-id="0a867-290">Его значение должно быть большим или равным значению положения указателя *nx_packet_data_start* и меньшим или равным указателю *nx_packet_append_ptr*.</span><span class="sxs-lookup"><span data-stu-id="0a867-290">It must be greater than or equal to the *nx_packet_data_start* pointer location and less than or equal to the *nx_packet_append_ptr* pointer.</span></span>  <span data-ttu-id="0a867-291">*В целях повышения производительности NetX предполагает, что когда пакет передается в службы NetX для передачи, то указатель в начале указывает на длинный адрес, выровненный по словам.*</span><span class="sxs-lookup"><span data-stu-id="0a867-291">*For performance reasons, NetX assumes that when the packet is passed into NetX services for transmission, the prepend pointer points to long word aligned address.*</span></span> |
| <span data-ttu-id="0a867-292">*nx_packet_append_ptr*</span><span class="sxs-lookup"><span data-stu-id="0a867-292">*nx_packet_append_ptr*</span></span>    | <span data-ttu-id="0a867-293">Это поле указывает на конец данных, находящихся в этот момент в области полезных данных пакета.</span><span class="sxs-lookup"><span data-stu-id="0a867-293">This field points to the end of the data currently in the packet payload area.</span></span> <span data-ttu-id="0a867-294">Он должен находиться между расположением в памяти, на которое указывают *nx_packet_prepend_ptr* и *nx_packet_data_end*.</span><span class="sxs-lookup"><span data-stu-id="0a867-294">It must be in between the memory location pointed to by *nx_packet_prepend_ptr* and *nx_packet_data_end*.</span></span> <span data-ttu-id="0a867-295">Разница между этим полем и полем *nx_packet_prepend_ptr* соответствует количеству данных в этом пакете.</span><span class="sxs-lookup"><span data-stu-id="0a867-295">The difference between this field and the *nx_packet_prepend_ptr* field represents the amount of data in this packet.</span></span> |
| <span data-ttu-id="0a867-296">*nx_packet_fragment_next*</span><span class="sxs-lookup"><span data-stu-id="0a867-296">*nx_packet_fragment_next*</span></span> | <span data-ttu-id="0a867-297">Это поле используется для хранения фрагментированных пакетов до тех пор, пока не будет выполнена повторная сборка всего пакета.</span><span class="sxs-lookup"><span data-stu-id="0a867-297">This field is used to hold fragmented packets until the entire packet can be re-assembled.</span></span> |
| <span data-ttu-id="0a867-298">*nx_packet_pad*</span><span class="sxs-lookup"><span data-stu-id="0a867-298">*nx_packet_pad*</span></span>           | <span data-ttu-id="0a867-299">Эти поля определяют длину заполнения (в 4-байтовых словах) для обеспечения требуемого выравнивания.</span><span class="sxs-lookup"><span data-stu-id="0a867-299">This fields defines the length of padding in 4- byte words to achieve the desired alignment requirement.</span></span> <span data-ttu-id="0a867-300">Это поле удаляется, если значение *NX_PACKET_HEADER_PAD* не определено.</span><span class="sxs-lookup"><span data-stu-id="0a867-300">This field is removed if *NX_PACKET_HEADER_PAD* is not defined.</span></span> |
|  |  |

### <a name="packet-header-offsets"></a><span data-ttu-id="0a867-301">Отступ для заголовка пакета</span><span class="sxs-lookup"><span data-stu-id="0a867-301">Packet Header Offsets</span></span>

<span data-ttu-id="0a867-302">Чтобы обеспечить достаточно места для размещения заголовка определенного размера, необходимо определить этот размер.</span><span class="sxs-lookup"><span data-stu-id="0a867-302">Packet header size is defined to allow enough room to accommodate the size of the header.</span></span> <span data-ttu-id="0a867-303">Служба *nx_packet_allocate* используется для выделения пакета и корректирует положение указателя, находящегося в начале в пакете, в соответствии с заданным типом пакета.</span><span class="sxs-lookup"><span data-stu-id="0a867-303">The *nx_packet_allocate* service is used to allocate a packet and adjusts the prepend pointer in the packet according to the type of packet specified.</span></span> <span data-ttu-id="0a867-304">Тип пакета указывает NetX, какой отступ необходим для вставки заголовка протокола (например, UDP, TCP или ICMP) перед данными протокола.</span><span class="sxs-lookup"><span data-stu-id="0a867-304">The packet type tells NetX the offset required for inserting the protocol header (such as UDP, TCP, or ICMP) in front of the protocol data.</span></span>

<span data-ttu-id="0a867-305">Чтобы учесть заголовок IP и физического уровня (Ethernet) в пакете в NetX определяются следующие типы.</span><span class="sxs-lookup"><span data-stu-id="0a867-305">The following types are defined in NetX to take into account the IP header and physical layer (Ethernet) header in the packet.</span></span> <span data-ttu-id="0a867-306">В последнем случае предполагается, что отступ равен 16 байтам при условии 4-байтового выравнивания.</span><span class="sxs-lookup"><span data-stu-id="0a867-306">In the latter case, it is assumed to be 16 bytes taking the required 4-byte alignment into consideration.</span></span> <span data-ttu-id="0a867-307">В NetX по-прежнему определяются IP-пакеты, чтобы приложения выделяли пакеты для IP-сетей.</span><span class="sxs-lookup"><span data-stu-id="0a867-307">IP packets are still defined in NetX for applications to allocate packets for IP networks.</span></span> <span data-ttu-id="0a867-308">В следующей таблице приведены определенные символы.</span><span class="sxs-lookup"><span data-stu-id="0a867-308">The following table shows symbols defined:</span></span>

| <span data-ttu-id="0a867-309">Тип пакета</span><span class="sxs-lookup"><span data-stu-id="0a867-309">Packet Type</span></span>   | <span data-ttu-id="0a867-310">Значение</span><span class="sxs-lookup"><span data-stu-id="0a867-310">Value</span></span> |
|---------------|-------|
| <span data-ttu-id="0a867-311">NX_IP_PACKET</span><span class="sxs-lookup"><span data-stu-id="0a867-311">NX_IP_PACKET</span></span>  | <span data-ttu-id="0a867-312">0x24</span><span class="sxs-lookup"><span data-stu-id="0a867-312">0x24</span></span>  |
| <span data-ttu-id="0a867-313">NX_UDP_PACKET</span><span class="sxs-lookup"><span data-stu-id="0a867-313">NX_UDP_PACKET</span></span> | <span data-ttu-id="0a867-314">0x2c</span><span class="sxs-lookup"><span data-stu-id="0a867-314">0x2c</span></span>  |
| <span data-ttu-id="0a867-315">NX_TCP_PACKET</span><span class="sxs-lookup"><span data-stu-id="0a867-315">NX_TCP_PACKET</span></span> | <span data-ttu-id="0a867-316">0x38</span><span class="sxs-lookup"><span data-stu-id="0a867-316">0x38</span></span>  |
|               |       |

### <a name="pool-capacity"></a><span data-ttu-id="0a867-317">Емкость пула</span><span class="sxs-lookup"><span data-stu-id="0a867-317">Pool Capacity</span></span>
<span data-ttu-id="0a867-318">Количество пакетов в пуле пакетов — это функция размера полезных данных, а также общего числа байтов в области памяти, предоставляемой службе создания пула пакетов.</span><span class="sxs-lookup"><span data-stu-id="0a867-318">The number of packets in a packet pool is a function of the payload size and the total number of bytes in the memory area supplied to the packet pool create service.</span></span> <span data-ttu-id="0a867-319">Емкость пула вычисляется путем деления размера пакета (с учетом размера заголовка NX_PACKET, размера полезных данных и правильного выравнивания) на общее число байтов в указанной области памяти.</span><span class="sxs-lookup"><span data-stu-id="0a867-319">The capacity of the pool is calculated by dividing the packet size (including the size of the NX_PACKET header, the payload size, and proper alignment) into the total number of bytes in the supplied memory area.</span></span>

### <a name="thread-suspension"></a><span data-ttu-id="0a867-320">Приостановка потока</span><span class="sxs-lookup"><span data-stu-id="0a867-320">Thread Suspension</span></span>
<span data-ttu-id="0a867-321">Потоки приложения могут быть приостановлены при ожидании пакета из пустого пула.</span><span class="sxs-lookup"><span data-stu-id="0a867-321">Application threads can suspend while waiting for a packet from an empty pool.</span></span> <span data-ttu-id="0a867-322">Когда пакет возвращается в пул, приостановленный поток получает этот пакет и его выполнение возобновляется.</span><span class="sxs-lookup"><span data-stu-id="0a867-322">When a packet is returned to the pool, the suspended thread is given this packet and resumed.</span></span>

<span data-ttu-id="0a867-323">Если на одном пуле пакетов приостанавливается несколько потоков, они возобновляются в том же порядке, в котором были приостановлены (FIFO).</span><span class="sxs-lookup"><span data-stu-id="0a867-323">If multiple threads are suspended on the same packet pool, they are resumed in the order they were suspended (FIFO).</span></span>

### <a name="pool-statistics-and-errors"></a><span data-ttu-id="0a867-324">Статистические показатели и ошибки пула</span><span class="sxs-lookup"><span data-stu-id="0a867-324">Pool Statistics and Errors</span></span>
<span data-ttu-id="0a867-325">Если этот параметр включен, в разделе **ошибок** программного обеспечения для управления пакетами NetX отслеживается несколько статистических показателей и ошибок. Эти данные могут быть полезны для приложения.</span><span class="sxs-lookup"><span data-stu-id="0a867-325">If enabled, the NetX packet management software **Errors** keeps track of several statistics and errors that may be useful to the application.</span></span> <span data-ttu-id="0a867-326">Для пулов пакетов поддерживаются следующие статистические показатели и отчеты об ошибках:</span><span class="sxs-lookup"><span data-stu-id="0a867-326">The following statistics and error reports are maintained for packet pools:</span></span>

* <span data-ttu-id="0a867-327">Общее количество пакетов в пуле</span><span class="sxs-lookup"><span data-stu-id="0a867-327">Total Packets in Pool</span></span>
* <span data-ttu-id="0a867-328">Количество свободных пакетов в пуле</span><span class="sxs-lookup"><span data-stu-id="0a867-328">Free Packets in Pool</span></span>
* <span data-ttu-id="0a867-329">Запросы на выделение из пустого пула</span><span class="sxs-lookup"><span data-stu-id="0a867-329">Pool Empty Allocation Requests</span></span>
* <span data-ttu-id="0a867-330">Приостановки выделения из пустого пула</span><span class="sxs-lookup"><span data-stu-id="0a867-330">Pool Empty Allocation Suspensions</span></span>
* <span data-ttu-id="0a867-331">Освобождения недопустимых пакетов</span><span class="sxs-lookup"><span data-stu-id="0a867-331">Invalid Packet Releases</span></span>

<span data-ttu-id="0a867-332">Все эти статистические показатели и отчеты об ошибках, за исключением общего числа пакетов в пуле и количества тех из них, которые свободны, встроены в библиотеку NetX, если не определено значение \***NX_DISABLE_PACKET_INFO** _.</span><span class="sxs-lookup"><span data-stu-id="0a867-332">All of these statistics and error reports, except for total and free packet count in pool, are built into NetX library unless \***NX_DISABLE_PACKET_INFO** _ is defined.</span></span> <span data-ttu-id="0a867-333">Эти данные предоставляет приложению служба _ \*_nx_packet_pool_info_get_\*\*.</span><span class="sxs-lookup"><span data-stu-id="0a867-333">This data is available to the application with the _ *_nx_packet_pool_info_get_*\* service.</span></span>

### <a name="packet-pool-control-block-nx_packet_pool"></a><span data-ttu-id="0a867-334">NX_PACKET_POOL: блок управления пула пакетов</span><span class="sxs-lookup"><span data-stu-id="0a867-334">Packet Pool Control Block NX_PACKET_POOL</span></span>

<span data-ttu-id="0a867-335">Характеристики каждого пула памяти пакетов находятся в его блоке управления.</span><span class="sxs-lookup"><span data-stu-id="0a867-335">The characteristics of each packet memory pool are found in its control block.</span></span> <span data-ttu-id="0a867-336">Он содержит полезную информацию, в том числе связанный список свободных пакетов, число свободных пакетов и размер полезных данных в пакетах этого пула.</span><span class="sxs-lookup"><span data-stu-id="0a867-336">It contains useful information such as the linked list of free packets, the number of free packets, and the payload size for packets in this pool.</span></span> <span data-ttu-id="0a867-337">Эта структура определена в файле *nx_api.h*.</span><span class="sxs-lookup"><span data-stu-id="0a867-337">This structure is defined in the *nx_api.h* file.</span></span>

<span data-ttu-id="0a867-338">Блоки управления пула пакетов могут размещаться в любом месте в памяти, но чаще всего они определяются вне области какой-либо функции, благодаря чему функционируют как глобальная структура.</span><span class="sxs-lookup"><span data-stu-id="0a867-338">Packet pool control blocks can be located anywhere in memory, but it is most common to make the control block a global structure by defining it outside the scope of any function.</span></span>

## <a name="ip-protocol"></a><span data-ttu-id="0a867-339">Протокол IP</span><span class="sxs-lookup"><span data-stu-id="0a867-339">IP Protocol</span></span>

<span data-ttu-id="0a867-340">Компонент протокола Интернета (IP) NetX отвечает за отправку и получение IP-пакетов в Интернете.</span><span class="sxs-lookup"><span data-stu-id="0a867-340">The Internet Protocol (IP) component of NetX is responsible for sending and receiving IP packets on the Internet.</span></span> <span data-ttu-id="0a867-341">В NetX этот компонент отвечает преимущественно за отправку и получение сообщений TCP, UDP, ICMP и IGMP с помощью базового драйвера сети.</span><span class="sxs-lookup"><span data-stu-id="0a867-341">In NetX, it is the component ultimately responsible for sending and receiving TCP, UDP, ICMP, and IGMP messages, utilizing the underlying network driver.</span></span>

<span data-ttu-id="0a867-342">NetX поддерживает протокол IP (RFC 791)</span><span class="sxs-lookup"><span data-stu-id="0a867-342">NetX supports IP protocol (RFC 791)</span></span>

### <a name="ip-addresses"></a><span data-ttu-id="0a867-343">IP-адреса</span><span class="sxs-lookup"><span data-stu-id="0a867-343">IP Addresses</span></span>

<span data-ttu-id="0a867-344">Каждый узел в Интернете имеет уникальный 32-разрядный идентификатор, называемый IP-адресом.</span><span class="sxs-lookup"><span data-stu-id="0a867-344">Each host on the Internet has a unique 32-bit identifier called an IP address.</span></span> <span data-ttu-id="0a867-345">Существует пять классов IP-адресов, которые продемонстрированы на рис. 4.</span><span class="sxs-lookup"><span data-stu-id="0a867-345">There are five classes of IP addresses as described in Figure 4.</span></span> <span data-ttu-id="0a867-346">Ниже перечислены диапазоны этих пяти классов IP-адресов.</span><span class="sxs-lookup"><span data-stu-id="0a867-346">The ranges of the five IP address classes are as follows:</span></span>

| <span data-ttu-id="0a867-347">Класс</span><span class="sxs-lookup"><span data-stu-id="0a867-347">Class</span></span> | <span data-ttu-id="0a867-348">Диапазон</span><span class="sxs-lookup"><span data-stu-id="0a867-348">Range</span></span>                        |
|-------|------------------------------|
| <span data-ttu-id="0a867-349">Объект</span><span class="sxs-lookup"><span data-stu-id="0a867-349">A</span></span>     | <span data-ttu-id="0a867-350">С 0.0.0.0 по 127.255.255.255</span><span class="sxs-lookup"><span data-stu-id="0a867-350">0.0.0.0 to 127.255.255.255</span></span>   |
| <span data-ttu-id="0a867-351">B</span><span class="sxs-lookup"><span data-stu-id="0a867-351">B</span></span>     | <span data-ttu-id="0a867-352">Со 128.0.0.0 по 191.255.255.255</span><span class="sxs-lookup"><span data-stu-id="0a867-352">128.0.0.0 to 191.255.255.255</span></span> |
| <span data-ttu-id="0a867-353">C</span><span class="sxs-lookup"><span data-stu-id="0a867-353">C</span></span>     | <span data-ttu-id="0a867-354">Со 192.0.0.0 по 223.255.255.255</span><span class="sxs-lookup"><span data-stu-id="0a867-354">192.0.0.0 to 223.255.255.255</span></span> |
| <span data-ttu-id="0a867-355">D</span><span class="sxs-lookup"><span data-stu-id="0a867-355">D</span></span>     | <span data-ttu-id="0a867-356">С 224.0.0.0 по 239.255.255.255</span><span class="sxs-lookup"><span data-stu-id="0a867-356">224.0.0.0 to 239.255.255.255</span></span> |
| <span data-ttu-id="0a867-357">E</span><span class="sxs-lookup"><span data-stu-id="0a867-357">E</span></span>     | <span data-ttu-id="0a867-358">С 240.0.0.0 по 247.255.255.255</span><span class="sxs-lookup"><span data-stu-id="0a867-358">240.0.0.0 to 247.255.255.255</span></span> |

<span data-ttu-id="0a867-359">**7 бит 24 бита**</span><span class="sxs-lookup"><span data-stu-id="0a867-359">**7 bits 24 bits**</span></span>

![Структура IP-адресов](./media/user-guide/ip-address-structure.png)

<span data-ttu-id="0a867-361">**РИС. 4. Структура IP-адресов**</span><span class="sxs-lookup"><span data-stu-id="0a867-361">**FIGURE 4. IP Address Structure**</span></span>

<span data-ttu-id="0a867-362">Существует также три типа спецификаций адресов: *одноадресная*, *широковещательная* и *многоадресная рассылка*.</span><span class="sxs-lookup"><span data-stu-id="0a867-362">There are also three types of address specifications: *unicast*, *broadcast*, and *multicast*.</span></span> <span data-ttu-id="0a867-363">Адреса одноадресной рассылки — это IP-адреса, которые определяют конкретный узел в Интернете.</span><span class="sxs-lookup"><span data-stu-id="0a867-363">Unicast addresses are those IP addresses that identify a specific host on the Internet.</span></span> <span data-ttu-id="0a867-364">Они могут быть IP-адресами источника или назначения.</span><span class="sxs-lookup"><span data-stu-id="0a867-364">Unicast addresses can be either a source or a destination IP address.</span></span> <span data-ttu-id="0a867-365">Широковещательный адрес позволяет идентифицировать все узлы в определенной сети или подсети и может использоваться только в качестве адреса назначения.</span><span class="sxs-lookup"><span data-stu-id="0a867-365">A broadcast address identifies all hosts on a specific network or sub-network and can only be used as destination addresses.</span></span> <span data-ttu-id="0a867-366">Чтобы задать широковещательные адреса, необходимо заполнить ту их часть, которая представляет идентификатор узла, единицами.</span><span class="sxs-lookup"><span data-stu-id="0a867-366">Broadcast addresses are specified by having the host ID portion of the address set to ones.</span></span> <span data-ttu-id="0a867-367">Адреса многоадресной рассылки (класс D) задают динамическую группу узлов в Интернете.</span><span class="sxs-lookup"><span data-stu-id="0a867-367">Multicast addresses (Class D) specify a dynamic group of hosts on the Internet.</span></span> <span data-ttu-id="0a867-368">Члены группы многоадресной рассылки могут присоединяться к группе и выходить из нее по мере необходимости.</span><span class="sxs-lookup"><span data-stu-id="0a867-368">Members of the multicast group may join and leave whenever they wish.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="0a867-369">*Только протоколы без подключения, такие как UDP через IP, могут использовать широковещательную рассылку и ограниченные возможности широковещательной рассылки группы многоадресной рассылки.*</span><span class="sxs-lookup"><span data-stu-id="0a867-369">*Only connectionless protocols like UDP over IP can utilize broadcast and the limited broadcast capability of the multicast group.*</span></span>

> [!IMPORTANT]
> <span data-ttu-id="0a867-370">В  \***nx_api.h** _ *определен* *макрос* IP_ADDRESS.</span><span class="sxs-lookup"><span data-stu-id="0a867-370">*The macro* IP_ADDRESS *is defined in* \***nx_api.h** _.</span></span> <span data-ttu-id="0a867-371">Это позволяет легко определить IP-адреса, используя запятые вместо точек.</span><span class="sxs-lookup"><span data-stu-id="0a867-371">It allows easy specification of IP addresses using commas instead of a periods.</span></span> <span data-ttu-id="0a867-372">Например, IP_ADDRESS (128,0,0,0) _задает первый адрес класса B, показанный на рис. 4\*.</span><span class="sxs-lookup"><span data-stu-id="0a867-372">For example, IP_ADDRESS(128,0,0,0) _specifies the first class B address shown in Figure 4.\*</span></span>

### <a name="ip-gateway-address"></a><span data-ttu-id="0a867-373">Адрес шлюза IP</span><span class="sxs-lookup"><span data-stu-id="0a867-373">IP Gateway Address</span></span>

<span data-ttu-id="0a867-374">Сетевые шлюзы помогают узлам в своих сетях передавать пакеты, предназначенные для мест назначений, находящихся за пределами локального домена.</span><span class="sxs-lookup"><span data-stu-id="0a867-374">Network gateways assist hosts on their networks to relay packets destined to destinations outside the local domain.</span></span> <span data-ttu-id="0a867-375">У каждого узла имеются определенные сведения о следующем прыжке для отправки (к месту назначения либо на один из соседних узлов) либо возможность воспользоваться предварительно запрограммированной статической таблицей маршрутизации.</span><span class="sxs-lookup"><span data-stu-id="0a867-375">Each node has some knowledge of which next hop to send to, either the destination one of its neighbors, or through a pre-programmed static routing table.</span></span> <span data-ttu-id="0a867-376">Однако если эти подходы не работают, то узел должен перенаправлять пакет в шлюз по умолчанию, который содержит дополнительные сведения о маршрутизации пакета в место назначения.</span><span class="sxs-lookup"><span data-stu-id="0a867-376">However if these approaches fail, the node should forward the packet to its default gateway which has more information on how to route the packet to its destination.</span></span> <span data-ttu-id="0a867-377">Обратите внимание, что шлюз по умолчанию должен быть напрямую доступен через один из физических интерфейсов, подключенных к IP-экземпляру.</span><span class="sxs-lookup"><span data-stu-id="0a867-377">Note that the default gateway must be directly accessible through one of the physical interfaces attached to the IP instance.</span></span> <span data-ttu-id="0a867-378">Приложение вызывает ***nx_ip_gateway_address_set***, чтобы настроить IP-адрес шлюза по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="0a867-378">The application calls ***nx_ip_gateway_address_set*** to configure IP default gateway address.</span></span>

### <a name="ip-header"></a><span data-ttu-id="0a867-379">Заголовок IP</span><span class="sxs-lookup"><span data-stu-id="0a867-379">IP Header</span></span>

<span data-ttu-id="0a867-380">Для отправки любого IP-пакета в Интернете у него должен быть заголовок IP.</span><span class="sxs-lookup"><span data-stu-id="0a867-380">For any IP packet to be sent on the Internet, it must have an IP header.</span></span> <span data-ttu-id="0a867-381">Когда протоколы более высокого уровня (UDP, TCP, ICMP или IGMP) вызывают компонент IP для отправки пакета, модуль передачи IP-пакетов помещает заголовок IP перед данными.</span><span class="sxs-lookup"><span data-stu-id="0a867-381">When higher-level protocols (UDP, TCP, ICMP, or IGMP) call the IP component to send a packet, the IP transmit module places an IP header in front of the data.</span></span> <span data-ttu-id="0a867-382">И наоборот, при получении IP-пакетов из сети компонент IP удаляет заголовок IP из пакета перед его доставкой протоколам более высокого уровня.</span><span class="sxs-lookup"><span data-stu-id="0a867-382">Conversely, when IP packets are received from the network, the IP component removes the IP header from the packet before delivery to the higher-level protocols.</span></span> <span data-ttu-id="0a867-383">На рис. 5 показан формат заголовка IP.</span><span class="sxs-lookup"><span data-stu-id="0a867-383">Figure 5 shows the format of the IP header.</span></span>

![Формат заголовка IP](./media/user-guide/ip-header-format.png)

<span data-ttu-id="0a867-385">**РИС. 5. Формат заголовка IP**</span><span class="sxs-lookup"><span data-stu-id="0a867-385">**FIGURE 5. IP Header Format**</span></span>

> [!IMPORTANT]
> <span data-ttu-id="0a867-386">*Все заголовки в реализации TCP/IP должны быть представлены в формате с обратным порядком байтов. В этом формате наиболее значимый байт слова размещается по наименьшему байтовому адресу. Например, в IP-адресе поля "4-разрядное поле версии" и "4-разрядное поле длины заголовка" должны располагаться в первом байте заголовка.*</span><span class="sxs-lookup"><span data-stu-id="0a867-386">*All headers in the TCP/IP implementation are expected to be in big endian format. In this format, the most significant byte of the word resides at the lowest byte address. For example, the 4-bit version and the 4-bit header length of the IP header must be located on the first byte of the header.*</span></span>

<span data-ttu-id="0a867-387">Ниже приведены определения полей заголовка IP.</span><span class="sxs-lookup"><span data-stu-id="0a867-387">The fields of the IP header are defined as follows:</span></span>

<span data-ttu-id="0a867-388">**Назначение поля заголовка IP**</span><span class="sxs-lookup"><span data-stu-id="0a867-388">**IP Header Field Purpose**</span></span>

<span data-ttu-id="0a867-389">***4-разрядное поле версии***. Это поле содержит версию IP-адреса, которую представляет этот заголовок.</span><span class="sxs-lookup"><span data-stu-id="0a867-389">***4-bit version*** This field contains the version of IP this header represents.</span></span> <span data-ttu-id="0a867-390">Для IP версии 4, которую поддерживает NetX, значение этого поля равно 4.</span><span class="sxs-lookup"><span data-stu-id="0a867-390">For IP version 4, which is what NetX supports, the value of this field is 4.</span></span>

<span data-ttu-id="0a867-391">***4-разрядное поле длины заголовка***. В этом поле указывается число 32-разрядных слов в заголовке IP.</span><span class="sxs-lookup"><span data-stu-id="0a867-391">***4-bit header length*** This field specifies the number of 32-bit words in the IP header.</span></span> <span data-ttu-id="0a867-392">Если необязательные слова отсутствуют, значение этого поля равно 5.</span><span class="sxs-lookup"><span data-stu-id="0a867-392">If no option words are present, the value for this field is 5.</span></span>

<span data-ttu-id="0a867-393">***8-разрядное поле типа службы (TOS)***. В этом поле указывается тип службы, запрошенной для этого IP-пакета.</span><span class="sxs-lookup"><span data-stu-id="0a867-393">***8-bit type of service (TOS)*** This field specifies the type of service requested for this IP packet.</span></span> <span data-ttu-id="0a867-394">Допустимые запросы приведены ниже.</span><span class="sxs-lookup"><span data-stu-id="0a867-394">Valid requests are as follows:</span></span>

| <span data-ttu-id="0a867-395">**Запрос TOS**</span><span class="sxs-lookup"><span data-stu-id="0a867-395">**TOS Request**</span></span>     | <span data-ttu-id="0a867-396">**Значение**</span><span class="sxs-lookup"><span data-stu-id="0a867-396">**Value**</span></span> |
| ------------------- | --------- |
| <span data-ttu-id="0a867-397">Норм.</span><span class="sxs-lookup"><span data-stu-id="0a867-397">Normal</span></span>              | <span data-ttu-id="0a867-398">0x00</span><span class="sxs-lookup"><span data-stu-id="0a867-398">0x00</span></span>      |
| <span data-ttu-id="0a867-399">Минимальная задержка</span><span class="sxs-lookup"><span data-stu-id="0a867-399">Minimum Delay</span></span>       | <span data-ttu-id="0a867-400">0x10</span><span class="sxs-lookup"><span data-stu-id="0a867-400">0x10</span></span>      |
| <span data-ttu-id="0a867-401">Максимальное количество данных</span><span class="sxs-lookup"><span data-stu-id="0a867-401">Maximum Data</span></span>        | <span data-ttu-id="0a867-402">0x08</span><span class="sxs-lookup"><span data-stu-id="0a867-402">0x08</span></span>      |
| <span data-ttu-id="0a867-403">Максимальная надежность</span><span class="sxs-lookup"><span data-stu-id="0a867-403">Maximum Reliability</span></span> | <span data-ttu-id="0a867-404">0x04</span><span class="sxs-lookup"><span data-stu-id="0a867-404">0x04</span></span>      |
| <span data-ttu-id="0a867-405">Минимальные издержки</span><span class="sxs-lookup"><span data-stu-id="0a867-405">Minimum Cost</span></span>        | <span data-ttu-id="0a867-406">0x02</span><span class="sxs-lookup"><span data-stu-id="0a867-406">0x02</span></span>      |

<span data-ttu-id="0a867-407">***16-разрядное поле общей длины***. Это поле содержит общую длину IP-датаграммы в байтах, включая заголовок IP.</span><span class="sxs-lookup"><span data-stu-id="0a867-407">***16-bit total length*** This field contains the total length of the IP datagram in bytes, including the IP header.</span></span> <span data-ttu-id="0a867-408">IP-датаграмма — это основная единица информации, передаваемая в Интернете по протоколу TCP/IP.</span><span class="sxs-lookup"><span data-stu-id="0a867-408">An IP datagram is the basic unit of information found on a TCP/IP Internet.</span></span> <span data-ttu-id="0a867-409">Помимо данных, она содержит адреса источника и назначения.</span><span class="sxs-lookup"><span data-stu-id="0a867-409">It contains a destination and source address in addition to data.</span></span> <span data-ttu-id="0a867-410">Так как это 16-разрядное поле, максимальный размер IP-датаграммы составляет 65 535 байт.</span><span class="sxs-lookup"><span data-stu-id="0a867-410">Because it is a 16-bit field, the maximum size of an IP datagram is 65,535 bytes.</span></span>

<span data-ttu-id="0a867-411">***16-разрядное поле идентификации***. Значение этого поля равно числу, используемому для уникальной идентификации каждой IP-датаграммы, отправленной с узла.</span><span class="sxs-lookup"><span data-stu-id="0a867-411">***16-bit identification*** The field is a number used to uniquely identify each IP datagram sent from a host.</span></span> <span data-ttu-id="0a867-412">Это число обычно увеличивается после отправки IP-датаграммы.</span><span class="sxs-lookup"><span data-stu-id="0a867-412">This number is typically incremented after an IP datagram is sent.</span></span> <span data-ttu-id="0a867-413">Оно играет важную роль при сборке полученных фрагментов IP-пакетов.</span><span class="sxs-lookup"><span data-stu-id="0a867-413">It is especially useful in assembling received IP packet fragments.</span></span>

<span data-ttu-id="0a867-414">***3-разрядное поле флагов***. Это поле содержит сведения о фрагментации IP-пакетов.</span><span class="sxs-lookup"><span data-stu-id="0a867-414">***3-bit flags*** This field contains IP fragmentation information.</span></span> <span data-ttu-id="0a867-415">14-й бит — это бит, указывающий на отсутствие фрагментации.</span><span class="sxs-lookup"><span data-stu-id="0a867-415">Bit 14 is the "don't fragment" bit.</span></span> <span data-ttu-id="0a867-416">Если этот бит задан, исходящая IP-датаграмма не фрагментируется.</span><span class="sxs-lookup"><span data-stu-id="0a867-416">If this bit is set, the outgoing IP datagram will not be fragmented.</span></span> <span data-ttu-id="0a867-417">13-й бит — это бит, указывающий на наличие дополнительных фрагментов.</span><span class="sxs-lookup"><span data-stu-id="0a867-417">Bit 13 is the "more fragments" bit.</span></span> <span data-ttu-id="0a867-418">Если этот бит задан, то существуют дополнительные фрагменты.</span><span class="sxs-lookup"><span data-stu-id="0a867-418">If this bit is set, there are more fragments.</span></span> <span data-ttu-id="0a867-419">Если этот бит очищен, это последний фрагмент IP-пакета.</span><span class="sxs-lookup"><span data-stu-id="0a867-419">If this bit is clear, this is the last fragment of the IP packet.</span></span>

<span data-ttu-id="0a867-420">**Назначение поля заголовка IP**</span><span class="sxs-lookup"><span data-stu-id="0a867-420">**IP Header Field Purpose**</span></span>

<span data-ttu-id="0a867-421">***13-разрядное поле смещения фрагмента***. Это поле содержит старшие 13 бит смещения фрагмента.</span><span class="sxs-lookup"><span data-stu-id="0a867-421">***13-bit fragment offset*** This field contains the upper 13-bits of the fragment offset.</span></span> <span data-ttu-id="0a867-422">По этой причине смещения фрагментов разрешены только для 8-байтовых границ.</span><span class="sxs-lookup"><span data-stu-id="0a867-422">Because of this, fragment offsets are only allowed on 8-byte boundaries.</span></span> <span data-ttu-id="0a867-423">В первом фрагменте фрагментированной IP-датаграммы будет установлен бит наличия дополнительных фрагментов, а смещение будет равно 0.</span><span class="sxs-lookup"><span data-stu-id="0a867-423">The first fragment of a fragmented IP datagram will have the “more fragments” bit set and have an offset of 0.</span></span>

<span data-ttu-id="0a867-424">***8-разрядное поле срока жизни (TTL)***. Это поле содержит число маршрутизаторов, через которые может быть передана эта датаграмма, и тем самым ограничивает время ее существования.</span><span class="sxs-lookup"><span data-stu-id="0a867-424">***8-bit time to live (TTL)*** This field contains the number of routers this datagram can pass, which limits the lifetime of the datagram.</span></span>

<span data-ttu-id="0a867-425">***8-разрядное поле протокола***. В этом поле указывается, какой протокол использует IP-датаграмму.</span><span class="sxs-lookup"><span data-stu-id="0a867-425">***8-bit protocol*** This field specifies which protocol is using the IP datagram.</span></span> <span data-ttu-id="0a867-426">Ниже приведен список допустимых протоколов и их значения.</span><span class="sxs-lookup"><span data-stu-id="0a867-426">The following is a list of valid protocols and their values:</span></span>

| <span data-ttu-id="0a867-427">Протокол</span><span class="sxs-lookup"><span data-stu-id="0a867-427">Protocol</span></span> | <span data-ttu-id="0a867-428">Значение</span><span class="sxs-lookup"><span data-stu-id="0a867-428">Value</span></span> |
|----------|-------|
| <span data-ttu-id="0a867-429">ICMP</span><span class="sxs-lookup"><span data-stu-id="0a867-429">ICMP</span></span>     | <span data-ttu-id="0a867-430">0x01</span><span class="sxs-lookup"><span data-stu-id="0a867-430">0x01</span></span>  |
| <span data-ttu-id="0a867-431">IGMP</span><span class="sxs-lookup"><span data-stu-id="0a867-431">IGMP</span></span>     | <span data-ttu-id="0a867-432">0x02</span><span class="sxs-lookup"><span data-stu-id="0a867-432">0x02</span></span>  |
| <span data-ttu-id="0a867-433">TCP</span><span class="sxs-lookup"><span data-stu-id="0a867-433">TCP</span></span>      | <span data-ttu-id="0a867-434">0x06</span><span class="sxs-lookup"><span data-stu-id="0a867-434">0X06</span></span>  |
| <span data-ttu-id="0a867-435">UDP</span><span class="sxs-lookup"><span data-stu-id="0a867-435">UDP</span></span>      | <span data-ttu-id="0a867-436">0x11</span><span class="sxs-lookup"><span data-stu-id="0a867-436">0X11</span></span>  |
|          |       |


<span data-ttu-id="0a867-437">***16-разрядное поле контрольной суммы***. Это поле содержит 16-разрядное значение контрольной суммы, охватывающее только заголовок IP.</span><span class="sxs-lookup"><span data-stu-id="0a867-437">***16-bit checksum*** This field contains the 16-bit checksum that covers the IP header only.</span></span> <span data-ttu-id="0a867-438">В протоколах более высокого уровня имеются дополнительные контрольные суммы, охватывающие полезные данные IP.</span><span class="sxs-lookup"><span data-stu-id="0a867-438">There are additional checksums in the higher level protocols that cover the IP payload.</span></span>

<span data-ttu-id="0a867-439">***32-разрядное поле IP-адреса источника***. Это поле содержит IP-адрес отправителя и всегда является адресом узла.</span><span class="sxs-lookup"><span data-stu-id="0a867-439">***32-bit source IP address*** This field contains the IP address of the sender and is always a host address.</span></span>

<span data-ttu-id="0a867-440">***32-разрядное поле IP-адреса назначения***. Это поле содержит IP-адрес одного или нескольких (если это широковещательный адрес или адрес многоадресной рассылки) получателей.</span><span class="sxs-lookup"><span data-stu-id="0a867-440">***32-bit destination IP address*** This field contains the IP address of the receiver or receivers if the address is a broadcast or multicast address.</span></span>

### <a name="creating-ip-instances"></a><span data-ttu-id="0a867-441">Создание IP-экземпляров</span><span class="sxs-lookup"><span data-stu-id="0a867-441">Creating IP Instances</span></span>

<span data-ttu-id="0a867-442">IP-экземпляры создаются во время инициализации или выполнения потоками приложения.</span><span class="sxs-lookup"><span data-stu-id="0a867-442">IP instances are created either during initialization or during runtime by application threads.</span></span> <span data-ttu-id="0a867-443">Начальный IP-адрес, маска сети, пул пакетов по умолчанию, драйвер носителя, а также память и приоритет внутреннего IP-потока определяются службой *nx_ip_create*.</span><span class="sxs-lookup"><span data-stu-id="0a867-443">The initial IP address, network mask, default packet pool, media driver, and memory and priority of the internal IP thread are defined by the *nx_ip_create* service.</span></span> <span data-ttu-id="0a867-444">Если приложение инициализирует IP-экземпляр с IP-адресом, значение которого недопустимо (0.0.0.0), предполагается, что адрес интерфейса будет разрешаться позже вручную с помощью RARP либо через DHCP или аналогичный протокол.</span><span class="sxs-lookup"><span data-stu-id="0a867-444">If the application initializes the IP instance with its IP address set to an invalid address(0.0.0.0), it is assumed that the interface address is going to resolved by manual configuration later, via RARP, or through DHCP or similar protocols.</span></span>

<span data-ttu-id="0a867-445">Для систем с несколькими сетевыми интерфейсами основной интерфейс назначается при вызове *nx_ip_create*.</span><span class="sxs-lookup"><span data-stu-id="0a867-445">For systems with multiple network interfaces, the primary interface is designated when calling *nx_ip_create*.</span></span> <span data-ttu-id="0a867-446">Все дополнительные интерфейсы можно подключить к одному и тому же IP-экземпляру, вызвав *nx_ip_interface_attach*.</span><span class="sxs-lookup"><span data-stu-id="0a867-446">Each additional interface can be attached to the same IP instance by calling *nx_ip_interface_attach*.</span></span> <span data-ttu-id="0a867-447">Эта служба хранит сведения о сетевом интерфейсе (например, IP-адрес, маску сети) в блоке управления взаимодействием и связывает экземпляр драйвера с блоком управления взаимодействием в IP-экземпляре.</span><span class="sxs-lookup"><span data-stu-id="0a867-447">This service stores information about the network interface (such as IP address, network mask) in the interface control block, and associates the driver instance with the interface control block in the IP instance.</span></span> <span data-ttu-id="0a867-448">Когда драйвер получает пакет данных, ему необходимо сохранить сведения об интерфейсе в структуре NX_PACKET перед отправкой в логику приема IP-пакетов.</span><span class="sxs-lookup"><span data-stu-id="0a867-448">As the driver receives a data packet, it needs to store the interface information in the NX_PACKET structure before forwarding it to the IP receive logic.</span></span> <span data-ttu-id="0a867-449">Обратите внимание, что перед присоединением интерфейсов необходимо сначала создать IP-экземпляр.</span><span class="sxs-lookup"><span data-stu-id="0a867-449">Note an IP instance must already be created before attaching any interfaces.</span></span>

 ### <a name="ip-send"></a><span data-ttu-id="0a867-450">Отправка IP-пакетов</span><span class="sxs-lookup"><span data-stu-id="0a867-450">IP Send</span></span>
 <span data-ttu-id="0a867-451">Обработка отправки IP-пакетов в NetX выполняется очень просто.</span><span class="sxs-lookup"><span data-stu-id="0a867-451">The IP send processing in NetX is very streamlined.</span></span>

<span data-ttu-id="0a867-452">Указатель в начале пакета перемещается назад для размещения заголовка IP.</span><span class="sxs-lookup"><span data-stu-id="0a867-452">The prepend pointer in the packet is moved backwards to accommodate the IP header.</span></span> <span data-ttu-id="0a867-453">Заголовок IP-адреса готов (содержит все параметры, заданные на уровне вызывающего протокола), контрольная сумма IP вычисляется в строке, а пакет отправляется в соответствующий драйвер сети.</span><span class="sxs-lookup"><span data-stu-id="0a867-453">The IP header is completed (with all the options specified by the calling protocol layer), the IP checksum is computed in-line, and the packet is dispatched to the associated network driver.</span></span> <span data-ttu-id="0a867-454">Кроме того, исходящая фрагментация также координируется в рамках обработки отправки IP-пакетов.</span><span class="sxs-lookup"><span data-stu-id="0a867-454">In addition, outgoing fragmentation is also coordinated from within the IP send processing.</span></span>

<span data-ttu-id="0a867-455">Если для IP-адреса назначения требуется физическое сопоставление, NetX инициирует для IP запросы ARP.</span><span class="sxs-lookup"><span data-stu-id="0a867-455">For IP, NetX initiates ARP requests if physical mapping is needed for the destination IP address.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="0a867-456">*Для подключений по протоколу IP пакеты, требующие разрешения IP-адресов (т. е. физического сопоставления), помещаются в очередь ARP до тех пор, пока число пакетов в очереди не превысит глубину очереди ARP (определяется* *символом **NX_ARP_MAX_QUEUE_DEPTH**). Если* *глубина очереди достигнута, NetX удалит самый старый пакет в очереди и продолжит ожидание разрешения адреса для оставшихся пакетов, поставленных в очередь. С другой стороны, если разрешение записи ARP не выполнено, ожидающие пакеты в записи ARP освобождаются после истечения времени ожидания записи ARP.*</span><span class="sxs-lookup"><span data-stu-id="0a867-456">*For IP connectivity, packets that require IP address resolution (i.e., physical mapping) are enqueued on the ARP queue until the number of packets queued exceeds the ARP queue depth (defined by the* *symbol **NX_ARP_MAX_QUEUE_DEPTH**). If the* *queue depth is reached, NetX will remove the oldest packet on the queue and continue waiting for address resolution for the remaining packets enqueued. On the other hand, if an ARP entry is not resolved, the pending packets on the ARP entry are released upon ARP entry timeout.*</span></span>

<span data-ttu-id="0a867-457">Для систем с несколькими сетевыми интерфейсами NetX выбирает интерфейс на основе IP-адреса назначения.</span><span class="sxs-lookup"><span data-stu-id="0a867-457">For systems with multiple network interfaces, NetX chooses an interface based on the destination IP address.</span></span> <span data-ttu-id="0a867-458">В процессе выбора применяется следующая процедура.</span><span class="sxs-lookup"><span data-stu-id="0a867-458">The following procedure applies to the selection process:</span></span>

1. <span data-ttu-id="0a867-459">Если адрес назначения является широковещательным или адресом многоадресной рассылки по протоколу IP, а также указан допустимый исходящий интерфейс, используется этот интерфейс.</span><span class="sxs-lookup"><span data-stu-id="0a867-459">If a destination address is IP broadcast or multicast, and if a valid outgoing interface is specified, use that interface.</span></span> <span data-ttu-id="0a867-460">В противном случае используется первый физический интерфейс.</span><span class="sxs-lookup"><span data-stu-id="0a867-460">Otherwise, the first physical interface is used.</span></span>

2. <span data-ttu-id="0a867-461">Если адрес назначения присутствует в таблице статической маршрутизации, используется интерфейс, связанный со шлюзом.</span><span class="sxs-lookup"><span data-stu-id="0a867-461">If the destination address is found in the static routing table, the interface associated with the gateway is used.</span></span>

3. <span data-ttu-id="0a867-462">Если назначением является адрес с прямым подключением, используется интерфейс прямого подключения.</span><span class="sxs-lookup"><span data-stu-id="0a867-462">If the destination is on-link, the on-link interface is used.</span></span>

4. <span data-ttu-id="0a867-463">Если адрес назначения петлевой (127.0.0.1), используется интерфейс замыкания на себя.</span><span class="sxs-lookup"><span data-stu-id="0a867-463">If the destination address is a loopback address 127.0.0.1, the loopback interface is used.</span></span>

5. <span data-ttu-id="0a867-464">Если шлюз по умолчанию настроен правильно, для передачи пакета используется интерфейс, связанный со шлюзом по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="0a867-464">If the default gateway is properly configured, use the interface associated with the default gateway to transmit the packet.</span></span>

6. <span data-ttu-id="0a867-465">Выходной пакет удаляется, если все вышеуказанные сбои завершились ошибкой.</span><span class="sxs-lookup"><span data-stu-id="0a867-465">The output packet is dropped if all the above fails.</span></span>

### <a name="ip-receive"></a><span data-ttu-id="0a867-466">Получение IP-пакетов</span><span class="sxs-lookup"><span data-stu-id="0a867-466">IP Receive</span></span>

<span data-ttu-id="0a867-467">Обработка получения IP-пакетов вызывается либо из сетевого драйвера, либо из внутреннего IP-потока (для обработки пакетов в очереди пакетов с отложенным получением).</span><span class="sxs-lookup"><span data-stu-id="0a867-467">The IP receive processing is either called from the network driver or the internal IP thread (for processing packets on the deferred received packet queue).</span></span> <span data-ttu-id="0a867-468">При обработке получения IP-пакетов проверяется поле протокола и предпринимается попытка отправить пакет в соответствующий компонент протокола.</span><span class="sxs-lookup"><span data-stu-id="0a867-468">The IP receive processing examines the protocol field and attempts to dispatch the packet to the proper protocol component.</span></span> <span data-ttu-id="0a867-469">Перед тем как пакет будет фактически отправлен, заголовок IP удаляется путем перемещения расположенного в начале пакета указателя за заголовок IP.</span><span class="sxs-lookup"><span data-stu-id="0a867-469">Before the packet is actually dispatched, the IP header is removed by advancing the prepend pointer past the IP header.</span></span>

<span data-ttu-id="0a867-470">При обработке получения IP-пакетов также обнаруживаются фрагментированные IP-пакеты и, если включена фрагментация, выполняются необходимые действия для их сборки.</span><span class="sxs-lookup"><span data-stu-id="0a867-470">IP receive processing also detects fragmented IP packets and performs the necessary steps to reassemble them if fragmentation is enabled.</span></span> <span data-ttu-id="0a867-471">Если требуется фрагментация, но она не включена, пакет удаляется.</span><span class="sxs-lookup"><span data-stu-id="0a867-471">If fragmentation is needed but not enabled, the packet is dropped.</span></span>

<span data-ttu-id="0a867-472">NetX определяет соответствующий сетевой интерфейс на основе интерфейса, указанного в пакете.</span><span class="sxs-lookup"><span data-stu-id="0a867-472">NetX determines the appropriate network interface based on the interface specified in the packet.</span></span> <span data-ttu-id="0a867-473">Если поле интерфейса пакета имеет значение NULL, по умолчанию NetX будет использовать основной интерфейс.</span><span class="sxs-lookup"><span data-stu-id="0a867-473">If the packet interface is NULL, NetX defaults to the primary interface.</span></span> <span data-ttu-id="0a867-474">Это делается для обеспечения совместимости с устаревшими драйверами Ethernet NetX.</span><span class="sxs-lookup"><span data-stu-id="0a867-474">This is done to guarantee compatibility with legacy NetX Ethernet drivers.</span></span>

### <a name="raw-ip-send"></a><span data-ttu-id="0a867-475">Отправка необработанных IP-пакетов</span><span class="sxs-lookup"><span data-stu-id="0a867-475">Raw IP Send</span></span>

<span data-ttu-id="0a867-476">Необработанный IP-пакет — это IP-кадр, который содержит полезные данные протокола верхнего уровня, которые не поддерживаются напрямую (и не обрабатываются) NetX.</span><span class="sxs-lookup"><span data-stu-id="0a867-476">A raw IP packet is an IP frame that contains upper layer protocol payload not directly supported (and processed) by NetX.</span></span> <span data-ttu-id="0a867-477">Необработанный пакет позволяет разработчикам определять собственные приложения на основе протокола IP.</span><span class="sxs-lookup"><span data-stu-id="0a867-477">A raw packet allows developers to define their own IP-based applications.</span></span> <span data-ttu-id="0a867-478">Приложение может отправлять необработанные IP-пакеты напрямую с помощью службы ***nx_ip_raw_packet_send** _, если в службе _*_nx_ip_raw_packet_enabled_\*_ включена их обработка.</span><span class="sxs-lookup"><span data-stu-id="0a867-478">An application may send raw IP packets directly using the ***nx_ip_raw_packet_send** _ service if raw IP packet processing has been enabled with the _*_nx_ip_raw_packet_enabled_\*_ service.</span></span> <span data-ttu-id="0a867-479">Однако если адрес назначения является адресом многоадресной рассылки (или широковещательной рассылки для IP), то NetX по умолчанию будет использовать первый (основной) интерфейс.</span><span class="sxs-lookup"><span data-stu-id="0a867-479">If the destination address is a multicast or broadcast address, however, NetX defaults to the first (primary) interface.</span></span> <span data-ttu-id="0a867-480">Таким образом, чтобы отправить такие пакеты во вторичные интерфейсы, приложение должно воспользоваться службой _ \*_nx_ip_raw_packet_interface_send_\*\*, чтобы задать исходный адрес, используемый для исходящего пакета.</span><span class="sxs-lookup"><span data-stu-id="0a867-480">Therefore, to send such packets out on secondary interfaces, the application must use the _ *_nx_ip_raw_packet_interface_send_*\* service to specify the source address to use for the outgoing packet.</span></span>

### <a name="raw-ip-receive"></a><span data-ttu-id="0a867-481">Получение необработанных IP-пакетов</span><span class="sxs-lookup"><span data-stu-id="0a867-481">Raw IP Receive</span></span>

<span data-ttu-id="0a867-482">Если включена обработка необработанных IP-пакетов, приложение может получать необработанные IP-пакеты с помощью службы \***nx_ip_raw_packet_receive** _.</span><span class="sxs-lookup"><span data-stu-id="0a867-482">If raw IP packet processing is enabled, the application may receive raw IP packets through the \***nx_ip_raw_packet_receive** _ service.</span></span> <span data-ttu-id="0a867-483">Все входящие пакеты обрабатываются в соответствии с протоколом, указанным в заголовке IP.</span><span class="sxs-lookup"><span data-stu-id="0a867-483">All incoming packets are processed according to the protocol specified in the IP header.</span></span> <span data-ttu-id="0a867-484">Если в поле протокола указан UDP, TCP, IGMP или ICMP, NetX обработает пакет, используя соответствующий обработчик для типа протокола пакетов.</span><span class="sxs-lookup"><span data-stu-id="0a867-484">If the protocol specifies UDP, TCP, IGMP or ICMP, NetX will process the packet using the appropriate handler for the packet protocol type.</span></span> <span data-ttu-id="0a867-485">Если протокол не является одним из этих протоколов и включено получение необработанных IP-пакетов, входящий пакет будет помещен в очередь необработанных пакетов, ожидая, когда приложение получит его через службу _ \*_nx_ip_raw_packet_receive_\*\*.</span><span class="sxs-lookup"><span data-stu-id="0a867-485">If the protocol is not one of these protocols, and raw IP receive is enabled, the incoming packet will be put into the raw packet queue waiting for the application to receive it via the _ *_nx_ip_raw_packet_receive_*\* service.</span></span> <span data-ttu-id="0a867-486">Кроме того, потоки приложений могут быть приостановлены в ожидании необработанного IP-пакета, если задан необязательный параметр времени ожидания.</span><span class="sxs-lookup"><span data-stu-id="0a867-486">In addition, application threads may suspend with an optional timeout while waiting for a raw IP packet.</span></span>

### <a name="default-packet-pool"></a><span data-ttu-id="0a867-487">Пул пакетов по умолчанию</span><span class="sxs-lookup"><span data-stu-id="0a867-487">Default Packet Pool</span></span>

<span data-ttu-id="0a867-488">Каждый IP-экземпляр получает во время создания пул пакетов по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="0a867-488">Each IP instance is given a default packet pool during creation.</span></span> <span data-ttu-id="0a867-489">Этот пул пакетов используется для выделения пакетов для ARP, RARP, ICMP, IGMP и различных пакетов управления TCP (таких как SYN и ACK).</span><span class="sxs-lookup"><span data-stu-id="0a867-489">This packet pool is used to allocate packets for ARP, RARP, ICMP, IGMP, various TCP control packets (such as SYN, ACK).</span></span> <span data-ttu-id="0a867-490">Если пул пакетов по умолчанию пуст, когда система NetX должна выделить пакет, ей, возможно, потребуется прервать эту конкретную операцию. В этом случае она по возможности возвращает сообщение об ошибке.</span><span class="sxs-lookup"><span data-stu-id="0a867-490">If the default packet pool is empty when NetX needs to allocate a packet, NetX may have to abort the particular operation, and will return an error message if possible.</span></span>

### <a name="ip-helper-thread"></a><span data-ttu-id="0a867-491">Вспомогательный IP-поток</span><span class="sxs-lookup"><span data-stu-id="0a867-491">IP Helper Thread</span></span>

<span data-ttu-id="0a867-492">Каждый IP-экземпляр имеет вспомогательный поток.</span><span class="sxs-lookup"><span data-stu-id="0a867-492">Each IP instance has a helper thread.</span></span> <span data-ttu-id="0a867-493">Этот поток отвечает за выполнение обработки всех отложенных пакетов и периодической обработки.</span><span class="sxs-lookup"><span data-stu-id="0a867-493">This thread is responsible for handling all deferred packet processing and all periodic processing.</span></span> <span data-ttu-id="0a867-494">Вспомогательный IP-поток создается в ***nx_ip_create.***</span><span class="sxs-lookup"><span data-stu-id="0a867-494">The IP helper thread is created in ***nx_ip_create.***</span></span> <span data-ttu-id="0a867-495">Именно здесь потоку назначается стек и приоритет.</span><span class="sxs-lookup"><span data-stu-id="0a867-495">This is where the thread is given its stack and priority.</span></span> <span data-ttu-id="0a867-496">Обратите внимание, что первая обработка во вспомогательном IP-потоке заключается в завершении инициализации сетевого драйвера, связанного со службой создания IP-экземпляра.</span><span class="sxs-lookup"><span data-stu-id="0a867-496">Note that the first processing in the IP helper thread is to finish the network driver initialization associated with the IP create service.</span></span> <span data-ttu-id="0a867-497">После завершения инициализации сетевого драйвера вспомогательный поток запускает бесконечный цикл обработки пакетов и периодических запросов.</span><span class="sxs-lookup"><span data-stu-id="0a867-497">After the network driver initialization is complete, the helper thread starts an endless loop to process packet and periodic requests.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="0a867-498">*Если во вспомогательном IP-потоке наблюдается необъяснимое поведение, первым этапом отладки будет увеличение размера стека во время работы службы создания IP-экземпляра. Если стек слишком мал, вспомогательный IP-поток может перезаписывать память, что может вызвать необычные проблемы.*</span><span class="sxs-lookup"><span data-stu-id="0a867-498">*If unexplained behavior is seen within the IP helper thread, increasing its stack size during the IP create service is the first debugging step. If the stack is too small, the IP helper thread could possibly be overwriting memory, which may cause unusual problems.*</span></span>

### <a name="thread-suspension"></a><span data-ttu-id="0a867-499">Приостановка потока</span><span class="sxs-lookup"><span data-stu-id="0a867-499">Thread Suspension</span></span>

<span data-ttu-id="0a867-500">При попытке получения необработанных IP-пакетов потоки приложения могут быть приостановлены.</span><span class="sxs-lookup"><span data-stu-id="0a867-500">Application threads can suspend while attempting to receive raw IP packets.</span></span> <span data-ttu-id="0a867-501">После получения необработанного пакета первому приостановленному потоку присваивается новый пакет и этот поток возобновляется.</span><span class="sxs-lookup"><span data-stu-id="0a867-501">After a raw packet is received, the new packet is given to the first thread suspended and that thread is resumed.</span></span> <span data-ttu-id="0a867-502">У всех служб получения пакетов NetX имеется дополнительная функция возобновления по истечении времени ожидания.</span><span class="sxs-lookup"><span data-stu-id="0a867-502">NetX services for receiving packets all have an optional suspension timeout.</span></span> <span data-ttu-id="0a867-503">При получении пакета или истечении времени ожидания выполнение потока приложения возобновляется с соответствующим состоянием завершения.</span><span class="sxs-lookup"><span data-stu-id="0a867-503">When a packet is received or the timeout expires, the application thread is resumed with the appropriate completion status.</span></span>

### <a name="ip-statistics-and-errors"></a><span data-ttu-id="0a867-504">Статистические показатели и ошибки IP-экземпляра</span><span class="sxs-lookup"><span data-stu-id="0a867-504">IP Statistics and Errors</span></span>

<span data-ttu-id="0a867-505">Если этот параметр включен, NetX отслеживает несколько статистических показателей и ошибок. Эти данные могут быть полезны для приложения.</span><span class="sxs-lookup"><span data-stu-id="0a867-505">If enabled, the NetX keeps track of several statistics and errors that may be useful to the application.</span></span> <span data-ttu-id="0a867-506">Для каждого IP-экземпляра поддерживаются следующие статистические показатели и отчеты об ошибках:</span><span class="sxs-lookup"><span data-stu-id="0a867-506">The following statistics and error reports are maintained for each IP instance:</span></span>

- <span data-ttu-id="0a867-507">общее число отправленных IP-пакетов;</span><span class="sxs-lookup"><span data-stu-id="0a867-507">Total IP Packets Sent</span></span>
- <span data-ttu-id="0a867-508">общее число байтов, отправленных по протоколу IP;</span><span class="sxs-lookup"><span data-stu-id="0a867-508">Total IP Bytes Sent</span></span>
- <span data-ttu-id="0a867-509">общее число полученных IP-пакетов;</span><span class="sxs-lookup"><span data-stu-id="0a867-509">Total IP Packets Received</span></span>
- <span data-ttu-id="0a867-510">общее число байтов, полученных по протоколу IP;</span><span class="sxs-lookup"><span data-stu-id="0a867-510">Total IP Bytes Received</span></span>
- <span data-ttu-id="0a867-511">общее число недопустимых IP-пакетов;</span><span class="sxs-lookup"><span data-stu-id="0a867-511">Total IP Invalid Packets</span></span>
- <span data-ttu-id="0a867-512">общее число отброшенных пакетов, получаемых по протоколу IP;</span><span class="sxs-lookup"><span data-stu-id="0a867-512">Total IP Receive Packets Dropped</span></span>
- <span data-ttu-id="0a867-513">общее число ошибок контрольной суммы при получении по протоколу IP;</span><span class="sxs-lookup"><span data-stu-id="0a867-513">Total IP Receive Checksum Errors</span></span>
- <span data-ttu-id="0a867-514">общее число отброшенных пакетов, отправляемых по протоколу IP;</span><span class="sxs-lookup"><span data-stu-id="0a867-514">Total IP Send Packets Dropped</span></span>
- <span data-ttu-id="0a867-515">общее число отправленных фрагментов IP-пакетов;</span><span class="sxs-lookup"><span data-stu-id="0a867-515">Total IP Fragments Sent</span></span>
- <span data-ttu-id="0a867-516">общее число полученных фрагментов IP-пакетов.</span><span class="sxs-lookup"><span data-stu-id="0a867-516">Total IP Fragments Received</span></span>

<span data-ttu-id="0a867-517">Все эти статистические показатели и отчеты об ошибках предоставляются приложению службой ***nx_ip_info_get***.</span><span class="sxs-lookup"><span data-stu-id="0a867-517">All of these statistics and error reports are available to the application with the ***nx_ip_info_get*** service.</span></span>

### <a name="ip-control-block-nx_ip"></a><span data-ttu-id="0a867-518">NX_IP: блок управления IP-экземпляра</span><span class="sxs-lookup"><span data-stu-id="0a867-518">IP Control Block NX_IP</span></span>

<span data-ttu-id="0a867-519">Характеристики каждого IP-экземпляра находятся в его блоке управления.</span><span class="sxs-lookup"><span data-stu-id="0a867-519">The characteristics of each IP instance are found in its control block.</span></span> <span data-ttu-id="0a867-520">Он содержит такие полезные сведения, как IP-адреса и маски сети каждого сетевого устройства, а также таблицу соседних IP-адресов и сопоставления адресов физического оборудования.</span><span class="sxs-lookup"><span data-stu-id="0a867-520">It contains useful information such as the IP addresses and network masks of each network device, and a table of neighbor IP and physical hardware address mapping.</span></span> <span data-ttu-id="0a867-521">Эта структура определена в блоках управления IP-экземпляра ***nx_api.h***, которые могут размещаться в любом месте в памяти, но чаще всего определяются вне области какой-либо функции, благодаря чему функционируют как глобальная структура.</span><span class="sxs-lookup"><span data-stu-id="0a867-521">This structure is defined in the ***nx_api.h*** IP instance control blocks can be located anywhere in memory, but it is most common to make the control block a global structure by defining it outside the scope of any function.</span></span>

### <a name="static-ip-routing"></a><span data-ttu-id="0a867-522">Маршрутизация статических IP-адресов</span><span class="sxs-lookup"><span data-stu-id="0a867-522">Static IP Routing</span></span>

<span data-ttu-id="0a867-523">Функция статической маршрутизации позволяет приложению указать IP-сеть и адрес следующего прыжка для конкретных IP-адресов назначения вне сети.</span><span class="sxs-lookup"><span data-stu-id="0a867-523">The static routing feature allows an application to specify an IP network and next hop address for specific out of network destination IP addresses.</span></span> <span data-ttu-id="0a867-524">Если включена статическая маршрутизация, NetX выполняет поиск записи, соответствующей адресу назначения отправляемого пакета, в статической таблице маршрутизации.</span><span class="sxs-lookup"><span data-stu-id="0a867-524">If static routing is enabled, NetX searches through the static routing table for an entry matching the destination address of the packet to send.</span></span> <span data-ttu-id="0a867-525">Если совпадений не найдено, NetX выполняет поиск по списку физических интерфейсов и выбирает исходный IP-адрес и адрес следующего прыжка на основе IP-адреса назначения и маски сети.</span><span class="sxs-lookup"><span data-stu-id="0a867-525">If no match is found, NetX searches through the list of physical interfaces and chooses a source IP address and next hop address based on the destination IP address and the network mask.</span></span> <span data-ttu-id="0a867-526">Если назначение не соответствует ни одному из IP-адресов сетевых драйверов, подключенных к экземпляру IP-адреса, NetX выбирает интерфейс, напрямую подключенный к шлюзу по умолчанию, и использует IP-адрес интерфейса в качестве исходного адреса, а шлюз по умолчанию — в качестве места для следующего прыжка.</span><span class="sxs-lookup"><span data-stu-id="0a867-526">If the destination does not match any of the IP addresses of the network drivers attached to the IP instance, NetX chooses an interface that is directly connected to the default gateway, and uses the IP address of the interface as source address, and the default gateway as the next hop.</span></span>

<span data-ttu-id="0a867-527">Записи можно добавлять и удалять из таблицы статической маршрутизации с помощью служб ***nx_ip_static_route_add*** и \***nx_ip_static_route_delete** _ соответственно.</span><span class="sxs-lookup"><span data-stu-id="0a867-527">Entries can be added and removed from the static routing table using the ***nx_ip_static_route_add*** and \***nx_ip_static_route_delete** _ services, respectively.</span></span> <span data-ttu-id="0a867-528">Чтобы использовать статическую маршрутизацию, ведущее приложение должно включить эту функцию, определив значение _ \*_NX_ENABLE_IP_STATIC_ROUTING_\*\*.</span><span class="sxs-lookup"><span data-stu-id="0a867-528">To use static routing, the host application must enable this feature by defining _ *_NX_ENABLE_IP_STATIC_ROUTING_*.\*</span></span>

> [!IMPORTANT]
> <span data-ttu-id="0a867-529">*При добавлении записи в таблицу статической маршрутизации NetX проверяет наличие соответствующей записи для указанного адреса назначения, уже находящегося в таблице. Если таковая существует, NetX отдает предпочтение записи с меньшей сетью (более длинным префиксом) в маске сети.*</span><span class="sxs-lookup"><span data-stu-id="0a867-529">*When adding an entry to the static routing table, NetX checks for a matching entry for the specified destination address already in the table. If one exists, it gives preference to the entry with the smaller network (longer prefix) in the network mask.*</span></span>

### <a name="ip-fragmentation"></a><span data-ttu-id="0a867-530">Фрагментация IP-пакетов</span><span class="sxs-lookup"><span data-stu-id="0a867-530">IP Fragmentation</span></span>

<span data-ttu-id="0a867-531">У сетевого устройства могут быть ограничения на размер исходящих пакетов.</span><span class="sxs-lookup"><span data-stu-id="0a867-531">The network device may have limits on the size of outgoing packets.</span></span> <span data-ttu-id="0a867-532">Это ограничение называется максимальной единицей передачи данных (MTU).</span><span class="sxs-lookup"><span data-stu-id="0a867-532">This limit is called the maximum transmission unit (MTU).</span></span> <span data-ttu-id="0a867-533">Значение MTU для протокола IP равно размеру наибольшего IP-кадра, который драйвер канального уровня может передавать без фрагментации IP-пакета.</span><span class="sxs-lookup"><span data-stu-id="0a867-533">IP MTU is the largest IP frame size a link layer driver is able to transmit without fragmenting the IP packet.</span></span> <span data-ttu-id="0a867-534">На этапе инициализации драйвера устройства модуль драйвера должен настроить его размер MTU для протокола IP с помощью службы ***nx_ip_interface_mtu_set***.</span><span class="sxs-lookup"><span data-stu-id="0a867-534">During a device driver initialization phase, the driver module must configure its IP MTU size via the service \***nx_ip_interface_mtu_set**.\*</span></span>

<span data-ttu-id="0a867-535">Хотя это и не рекомендуется, приложение может формировать датаграммы, размер которых превышает базовый размер MTU для протокола IP, поддерживаемый устройством.</span><span class="sxs-lookup"><span data-stu-id="0a867-535">Although not recommended, the application may generate datagrams larger than the underlying IP MTU supported by the device.</span></span> <span data-ttu-id="0a867-536">Перед передачей такой IP-датаграммы эти пакеты должны быть фрагментированы на уровне IP.</span><span class="sxs-lookup"><span data-stu-id="0a867-536">Before transmitting such IP datagram, the IP layer must fragment these packets.</span></span> <span data-ttu-id="0a867-537">При получении фрагментированных IP-кадров принимающая конечная точка должна хранить все фрагментированные кадры IP-адресов с одинаковым идентификатором фрагментации и повторно собирать их по порядку.</span><span class="sxs-lookup"><span data-stu-id="0a867-537">On receiving fragmented IP frames, the receiving end must store all fragmented IP frames with the same fragmentation ID, and reassemble them in order.</span></span> <span data-ttu-id="0a867-538">Если логике получения IP-пакетов не удается вовремя собрать все фрагменты для восстановления исходного IP-кадра, все фрагменты освобождаются.</span><span class="sxs-lookup"><span data-stu-id="0a867-538">If the IP receive logic is unable to collect all the fragments to restore the original IP frame in time, all the fragments are released.</span></span> <span data-ttu-id="0a867-539">За обнаружение потери пакетов и их восстановление отвечает протокол верхнего уровня.</span><span class="sxs-lookup"><span data-stu-id="0a867-539">It is up to the upper layer protocol to detect such packet loss and recover from it.</span></span>

<span data-ttu-id="0a867-540">Для обеспечения поддержки фрагментации IP-пакетов и операции повторной сборки конструктор систем должен включить функцию фрагментации IP-пакетов в NetX с помощью службы ***nx_ip_fragment_enable***.</span><span class="sxs-lookup"><span data-stu-id="0a867-540">In order to support IP fragmentation and reassembly operation, the system designer must enable the IP fragmentation feature in NetX using the ***nx_ip_fragment_enable*** service.</span></span> <span data-ttu-id="0a867-541">Если эта функция не включена, входящие фрагментированные IP-пакеты отклоняются, как и пакеты, превышающие MTU сетевого драйвера.</span><span class="sxs-lookup"><span data-stu-id="0a867-541">If this feature is not enabled, incoming fragmented IP packets are discarded, as well as packets that exceed the network driver's MTU.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="0a867-542">*Логика фрагментации IP-пакетов может быть полностью удалена путем определения*  \***NX_DISABLE_FRAGMENTATION** _ _при создании библиотеки NetX.</span><span class="sxs-lookup"><span data-stu-id="0a867-542">*The IP Fragmentation logic can be removed completely by defining* \***NX_DISABLE_FRAGMENTATION** _ _when building theNetX library.</span></span> <span data-ttu-id="0a867-543">Это помогает сократить размер кода NetX\*.</span><span class="sxs-lookup"><span data-stu-id="0a867-543">Doing so helps reduce the code size of NetX.\*</span></span>

## <a name="address-resolution-protocol-arp-in-ip"></a><span data-ttu-id="0a867-544">Протокол разрешения адресов в IP-экземпляре</span><span class="sxs-lookup"><span data-stu-id="0a867-544">Address Resolution Protocol (ARP) in IP</span></span>

<span data-ttu-id="0a867-545">Протокол разрешения адресов (ARP) отвечает за динамическое сопоставление 32-разрядных IP-адресов с базовыми физическими носителями (RFC 826).</span><span class="sxs-lookup"><span data-stu-id="0a867-545">The Address Resolution Protocol (ARP) is responsible for dynamically mapping 32-bit IP addresses to those of the underlying physical media (RFC 826).</span></span> <span data-ttu-id="0a867-546">Ethernet — это наиболее распространенный физический носитель, который поддерживает 48-разрядные адреса.</span><span class="sxs-lookup"><span data-stu-id="0a867-546">Ethernet is the most typical physical media, and it supports 48-bit addresses.</span></span> <span data-ttu-id="0a867-547">Необходимость в ARP определяется драйвером сети, предоставленным службе ***nx_ip_create***.</span><span class="sxs-lookup"><span data-stu-id="0a867-547">The need for ARP is determined by the network driver supplied to the ***nx_ip_create*** service.</span></span> <span data-ttu-id="0a867-548">Если требуется физическое сопоставление, сетевой драйвер должен установить флаг ***nx_interface_address_mapping_needed*** в структуре интерфейса.</span><span class="sxs-lookup"><span data-stu-id="0a867-548">If physical mapping is required, the network driver must set the flag ***nx_interface_address_mapping_needed*** in the interface strcuture.</span></span>

### <a name="arp-enable"></a><span data-ttu-id="0a867-549">Включение ARP</span><span class="sxs-lookup"><span data-stu-id="0a867-549">ARP Enable</span></span>
<span data-ttu-id="0a867-550">Чтобы протокол ARP правильно функционировал, он должен быть включен приложением с помощью службы ***nx_arp_enable***.</span><span class="sxs-lookup"><span data-stu-id="0a867-550">For ARP to function properly, it must first be enabled by the application with the ***nx_arp_enable*** service.</span></span> <span data-ttu-id="0a867-551">Эта служба настраивает различные структуры данных для обработки ARP, включая создание области кэша ARP из памяти, предоставляемой службе включения ARP.</span><span class="sxs-lookup"><span data-stu-id="0a867-551">This service sets up various data structures for ARP processing, including the creation of an ARP cache area from the memory supplied to the ARP enable service.</span></span>

### <a name="arp-cache"></a><span data-ttu-id="0a867-552">Кэш ARP</span><span class="sxs-lookup"><span data-stu-id="0a867-552">ARP Cache</span></span>
<span data-ttu-id="0a867-553">Кэш ARP можно рассматривать как массив внутренних структур данных сопоставления ARP.</span><span class="sxs-lookup"><span data-stu-id="0a867-553">The ARP cache can be viewed as an array of internal ARP mapping data structures.</span></span> <span data-ttu-id="0a867-554">Каждая внутренняя структура может поддерживать связь между IP-адресом и адресом физического оборудования.</span><span class="sxs-lookup"><span data-stu-id="0a867-554">Each internal structure is capable of maintaining the relationship between an IP address and a physical hardware address.</span></span> <span data-ttu-id="0a867-555">Кроме того, каждая структура данных имеет указатели на каналы, поэтому она может быть включена в несколько связанных списков.</span><span class="sxs-lookup"><span data-stu-id="0a867-555">In addition, each data structure has link pointers so it can be part of multiple linked lists.</span></span>

<span data-ttu-id="0a867-556">Если сопоставление присутствует в таблице ARP, приложение может найти IP-адрес в кэше ARP, указав MAC-адрес оборудования с помощью службы \***nx_arp_ip_address_find** _.</span><span class="sxs-lookup"><span data-stu-id="0a867-556">Application can look up an IP address from the ARP cache by supplying hardware MAC address using the service \***nx_arp_ip_address_find** _ if the mapping exists in the ARP table.</span></span> <span data-ttu-id="0a867-557">Аналогичным образом служба _ *_nx_arp_hardware_address_find_*\* возвращает MAC-адрес для заданного IP-адреса.</span><span class="sxs-lookup"><span data-stu-id="0a867-557">Similarly, the service _ *_nx_arp_hardware_address_find_*\* returns the MAC address for a given IP address.</span></span>


### <a name="arp-dynamic-entries"></a><span data-ttu-id="0a867-558">Динамические записи ARP</span><span class="sxs-lookup"><span data-stu-id="0a867-558">ARP Dynamic Entries</span></span>

<span data-ttu-id="0a867-559">По умолчанию служба включения ARP размещает все записи в кэше ARP в списке доступных динамических записей ARP.</span><span class="sxs-lookup"><span data-stu-id="0a867-559">By default, the ARP enable service places all entries in the ARP cache on the list of available dynamic ARP entries.</span></span> <span data-ttu-id="0a867-560">При обнаружении запроса на отправку по несопоставленному IP-адресу NetX выделяет из этого списка динамические записи ARP.</span><span class="sxs-lookup"><span data-stu-id="0a867-560">A dynamic ARP entry is allocated from this list by NetX when a send request to an unmapped IP address is detected.</span></span> <span data-ttu-id="0a867-561">После выделения настраивается запись ARP, а на физический носитель отправляется запрос ARP.</span><span class="sxs-lookup"><span data-stu-id="0a867-561">After allocation, the ARP entry is set up and an ARP request is sent to the physical media.</span></span>

<span data-ttu-id="0a867-562">Динамическая запись также может быть создана службой ***nx_arp_dynamic_entry_setом***.</span><span class="sxs-lookup"><span data-stu-id="0a867-562">A dynamic entry can also be created by the service ***nx_arp_dynamic_entry_set***.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="0a867-563">*Если используются все динамические записи ARP, то по крайней мере недавно использованная запись ARP заменяется новым сопоставлением.*</span><span class="sxs-lookup"><span data-stu-id="0a867-563">*If all dynamic ARP entries are in use, the least recently used ARP entry is replaced with a new mapping.*</span></span>

### <a name="arp-static-entries"></a><span data-ttu-id="0a867-564">Статические записи ARP</span><span class="sxs-lookup"><span data-stu-id="0a867-564">ARP Static Entries</span></span>
<span data-ttu-id="0a867-565">Приложение также может настроить статическое сопоставление ARP с помощью службы ***nx_arp_static_entry_create***.</span><span class="sxs-lookup"><span data-stu-id="0a867-565">The application can also set up static ARP mapping by using the ***nx_arp_static_entry_create*** service.</span></span> <span data-ttu-id="0a867-566">Эта служба выделяет запись ARP из динамического списка записей ARP и помещает ее в статический список с информацией о сопоставлении, предоставленной приложением.</span><span class="sxs-lookup"><span data-stu-id="0a867-566">This service allocates an ARP entry from the dynamic ARP entry list and places it on the static list with the mapping information supplied by the application.</span></span> <span data-ttu-id="0a867-567">Статические записи ARP не предусматривают повторное использование или устаревание.</span><span class="sxs-lookup"><span data-stu-id="0a867-567">Static ARP entries are not subject to reuse or aging.</span></span> <span data-ttu-id="0a867-568">Приложение может удалить статическую запись с помощью службы ***nx_arp_static_entry_delete***.</span><span class="sxs-lookup"><span data-stu-id="0a867-568">The application can delete a static entry by using the service ***nx_arp_static_entry_delete***.</span></span>
<span data-ttu-id="0a867-569">Чтобы удалить все статические записи в таблице ARP, приложение может использовать службу ***nx_arp_static_entries_delete***.</span><span class="sxs-lookup"><span data-stu-id="0a867-569">To remove all static entries in the ARP table, the application may use the service ***nx_arp_static_entries_delete***.</span></span>

### <a name="automatic-arp-entry"></a><span data-ttu-id="0a867-570">Автоматическая запись ARP</span><span class="sxs-lookup"><span data-stu-id="0a867-570">Automatic ARP Entry</span></span>
<span data-ttu-id="0a867-571">NetX записывает сопоставление IP/MAC-адресов однорангового узла после его ответов на запрос ARP.</span><span class="sxs-lookup"><span data-stu-id="0a867-571">NetX records the peer's IP/MAC mapping after the peer responses to the ARP request.</span></span> <span data-ttu-id="0a867-572">NetX также реализует возможность автоматической записи ARP, с помощью которой осуществляется запись сопоставления IP/MAC-адресов однорангового узла на основе непредусмотренных запросов ARP из сети.</span><span class="sxs-lookup"><span data-stu-id="0a867-572">NetX also implements the automatic ARP entry feature where it records peer IP/MAC address mapping based on unsolicited ARP requests from the network.</span></span> <span data-ttu-id="0a867-573">Эта функция позволяет заполнить таблицу ARP данными однорангового узла, уменьшая задержку, возникающую при прохождении цикла запросов и ответов ARP.</span><span class="sxs-lookup"><span data-stu-id="0a867-573">This feature allows the ARP table to be populated with peer information, reducing the delay needed to go through the ARP request/response cycle.</span></span> <span data-ttu-id="0a867-574">Однако у автоматической записи ARP есть и свой недостаток. Он заключается в том, что при включении этой функции в загруженной сети с большим количеством узлов на локальном канале таблица ARP быстро заполняется, что в конечном итоге приводит к замене записи ARP.</span><span class="sxs-lookup"><span data-stu-id="0a867-574">However the downside with enabling automatic ARP is that the ARP table tend to fill up quickly on a busy network with many nodes on the local link, which would eventually lead to ARP entry replacement.</span></span>

<span data-ttu-id="0a867-575">Эта функция включена по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="0a867-575">This feature is enabled by default.</span></span> <span data-ttu-id="0a867-576">Чтобы ее отключить, необходимо скомпилировать библиотеку NetX, определив символ ***NX_DISABLE_ARP_AUTO_ENTRY***.</span><span class="sxs-lookup"><span data-stu-id="0a867-576">To disable it, the NetX library must be compiled with the symbol ***NX_DISABLE_ARP_AUTO_ENTRY*** defined.</span></span>

### <a name="arp-messages"></a><span data-ttu-id="0a867-577">Сообщения ARP</span><span class="sxs-lookup"><span data-stu-id="0a867-577">ARP Messages</span></span>

<span data-ttu-id="0a867-578">Как упоминалось ранее, если при выполнении задачи IP-экземпляра обнаруживается, что для IP-адреса требуется сопоставление, отправляется сообщение запроса ARP.</span><span class="sxs-lookup"><span data-stu-id="0a867-578">As mentioned previously, an ARP request message is sent when the IP task detects that mapping is needed for an IP address.</span></span> <span data-ttu-id="0a867-579">Запросы ARP отправляются периодически (каждые \***NX_ARP_UPDATE_RATE** _ секунд), пока не будет получен соответствующий ответ ARP.</span><span class="sxs-lookup"><span data-stu-id="0a867-579">ARP requests are sent periodically (every \***NX_ARP_UPDATE_RATE** _ seconds) until a corresponding ARP response is received.</span></span> <span data-ttu-id="0a867-580">Попытки ARP прекращаются после того, как общее количество запросов ARP достигает _ \*_NX_ARP_MAXIMUM_RETRIES_\*\*.</span><span class="sxs-lookup"><span data-stu-id="0a867-580">A total of _ *_NX_ARP_MAXIMUM_RETRIES_*\* ARP requests are made before the ARP attempt is abandoned.</span></span> <span data-ttu-id="0a867-581">При получении ответа ARP сведения о связанном физическом адресе сохраняются в записи ARP, которая находится в кэше.</span><span class="sxs-lookup"><span data-stu-id="0a867-581">When an ARP response is received, the associated physical address information is stored in the ARP entry that is in the cache.</span></span>

<span data-ttu-id="0a867-582">Для систем с множественной адресацией NetX определяет, какой интерфейс будет отправлять запросы и ответы ARP, на основе указанного адреса назначения.</span><span class="sxs-lookup"><span data-stu-id="0a867-582">For multihome systems, NetX determines which interface to send the ARP requests and responses based on destination address specified.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="0a867-583">*Исходящие IP-пакеты помещаются в очередь, NetX ожидает ответа ARP. Число исходящих IP*-*пакетов в очереди определяется константой* ***NX_ARP_MAX_QUEUE_DEPTH***.</span><span class="sxs-lookup"><span data-stu-id="0a867-583">*Outgoing IP packets are queued while NetX waits for the ARP response. The number of outgoing IP* *packets queued is defined by the constant* \***NX_ARP_MAX_QUEUE_DEPTH**.\*</span></span>

<span data-ttu-id="0a867-584">NetX также отвечает на запросы ARP от других узлов локальной IP-сети.</span><span class="sxs-lookup"><span data-stu-id="0a867-584">NetX also responds to ARP requests from other nodes on the local IP network.</span></span> <span data-ttu-id="0a867-585">Когда выполняется внешний запрос ARP, совпадающий с текущим IP-адресом интерфейса, получающего запрос ARP, NetX создает ответное сообщение ARP, содержащее текущий физический адрес.</span><span class="sxs-lookup"><span data-stu-id="0a867-585">When an external ARP request is made that matches the current IP address of the interface that receives the ARP request, NetX builds an ARP response message that contains the current physical address.</span></span>

<span data-ttu-id="0a867-586">Форматы запросов и ответов ARP в Ethernet показаны на рис. 6 и описаны ниже.</span><span class="sxs-lookup"><span data-stu-id="0a867-586">The formats of Ethernet ARP requests and responses are shown in Figure 6 and are described below:</span></span>

| <span data-ttu-id="0a867-587">Поле запроса или ответа</span><span class="sxs-lookup"><span data-stu-id="0a867-587">Request/Response Field</span></span>       | <span data-ttu-id="0a867-588">Назначение</span><span class="sxs-lookup"><span data-stu-id="0a867-588">Purpose</span></span>    |
|------------------------------|-----------------|
| <span data-ttu-id="0a867-589">Адрес назначения в Ethernet</span><span class="sxs-lookup"><span data-stu-id="0a867-589">Ethernet Destination Address</span></span> | <span data-ttu-id="0a867-590">Это 6-разрядное поле содержит адрес назначения для ответа ARP и является широковещательным для запросов ARP (применяется для всех).</span><span class="sxs-lookup"><span data-stu-id="0a867-590">This 6-byte field contains the destination address for the ARP response and is a broadcast (all ones) for ARP requests.</span></span> <span data-ttu-id="0a867-591">Это поле настраивается сетевым драйвером.</span><span class="sxs-lookup"><span data-stu-id="0a867-591">This field is setup by the network driver.</span></span> |
| <span data-ttu-id="0a867-592">Адрес источника в Ethernet</span><span class="sxs-lookup"><span data-stu-id="0a867-592">Ethernet Source Address</span></span>      | <span data-ttu-id="0a867-593">Это 6-разрядное поле содержит адрес отправителя запроса или ответа ARP и настраивается сетевым драйвером.</span><span class="sxs-lookup"><span data-stu-id="0a867-593">This 6-byte field contains the address of the sender of the ARP request or response and is set up by the network driver.</span></span> |
| <span data-ttu-id="0a867-594">Тип кадра</span><span class="sxs-lookup"><span data-stu-id="0a867-594">Frame Type</span></span>                   | <span data-ttu-id="0a867-595">Это 2-разрядное поле содержит тип представления кадра Ethernet. Для запросов и ответов ARP его значение равно 0x0806.</span><span class="sxs-lookup"><span data-stu-id="0a867-595">This 2-byte field contains the type of Ethernet frame present and, for ARP requests and responses, this is equal to 0x0806.</span></span> <span data-ttu-id="0a867-596">Это последнее поле, за настройку которого отвечает сетевой драйвер.</span><span class="sxs-lookup"><span data-stu-id="0a867-596">This is the last field the network driver is responsible for setting up.</span></span> |
| <span data-ttu-id="0a867-597">Тип оборудования</span><span class="sxs-lookup"><span data-stu-id="0a867-597">Hardware Type</span></span>                | <span data-ttu-id="0a867-598">Это 2-разрядное поле содержит тип оборудования и имеет значение 0x0001 для Ethernet.</span><span class="sxs-lookup"><span data-stu-id="0a867-598">This 2-byte field contains the hardware type, which is 0x0001 for Ethernet.</span></span> |
| <span data-ttu-id="0a867-599">Тип протокола</span><span class="sxs-lookup"><span data-stu-id="0a867-599">Protocol Type</span></span>                | <span data-ttu-id="0a867-600">Это 2-разрядное поле содержит тип протокола и имеет значение 0x0800 для IP-адреса.</span><span class="sxs-lookup"><span data-stu-id="0a867-600">This 2-byte field contains the protocol type, which is 0x0800 for IP addresses.</span></span> |
| <span data-ttu-id="0a867-601">Размер оборудования</span><span class="sxs-lookup"><span data-stu-id="0a867-601">Hardware Size</span></span>                | <span data-ttu-id="0a867-602">Это поле размером 1 байт содержит размер аппаратного адреса (6 для адресов Ethernet).</span><span class="sxs-lookup"><span data-stu-id="0a867-602">This 1-byte field contains the hardware address size, which is 6 for Ethernet addresses.</span></span> |


![Формат пакетов ARP](./media/user-guide/arp-packet-format.png)

<span data-ttu-id="0a867-604">**РИС. 6. Формат пакетов ARP**</span><span class="sxs-lookup"><span data-stu-id="0a867-604">**FIGURE 6. ARP Packet Format**</span></span>

| <span data-ttu-id="0a867-605">Поле запроса или ответа</span><span class="sxs-lookup"><span data-stu-id="0a867-605">Request/Response Field</span></span> | <span data-ttu-id="0a867-606">Назначение</span><span class="sxs-lookup"><span data-stu-id="0a867-606">Purpose</span></span>  |
|---|---|
| <span data-ttu-id="0a867-607">Размер для протокола</span><span class="sxs-lookup"><span data-stu-id="0a867-607">Protocol Size</span></span> | <span data-ttu-id="0a867-608">Это поле размером 1 байт содержит размер IP-адреса, который равен 4 для IP-адресов.</span><span class="sxs-lookup"><span data-stu-id="0a867-608">This 1-byte field contains the IP address size, which is 4 for IP addresses.</span></span>  |
| <span data-ttu-id="0a867-609">Код операции</span><span class="sxs-lookup"><span data-stu-id="0a867-609">Operation Code</span></span> | <span data-ttu-id="0a867-610">Это 2-байтовое поле содержит операцию для этого пакета ARP.</span><span class="sxs-lookup"><span data-stu-id="0a867-610">This 2-byte field contains the operation for this ARP packet.</span></span> <span data-ttu-id="0a867-611">Запрос ARP задается значением 0x0001, а ответ ARP представляется значением 0x0002.</span><span class="sxs-lookup"><span data-stu-id="0a867-611">An ARP request is specified with the value of 0x0001, while an ARP response is represented by a value of 0x0002.</span></span>  |
| <span data-ttu-id="0a867-612">Адрес Ethernet отправителя</span><span class="sxs-lookup"><span data-stu-id="0a867-612">Sender Ethernet Address</span></span> | <span data-ttu-id="0a867-613">В этом 6-байтовом поле содержится адрес Ethernet отправителя.</span><span class="sxs-lookup"><span data-stu-id="0a867-613">This 6-byte field contains the sender's Ethernet address.</span></span> |
| <span data-ttu-id="0a867-614">IP-адрес отправителя</span><span class="sxs-lookup"><span data-stu-id="0a867-614">Sender IP Address</span></span> | <span data-ttu-id="0a867-615">В этом 4-байтовом поле содержится IP-адрес отправителя.</span><span class="sxs-lookup"><span data-stu-id="0a867-615">This 4-byte field contains the sender's IP address.</span></span> |
| <span data-ttu-id="0a867-616">Целевой адрес Ethernet</span><span class="sxs-lookup"><span data-stu-id="0a867-616">Target Ethernet Address</span></span> | <span data-ttu-id="0a867-617">В этом 6-байтовом поле содержится целевой адрес Ethernet.</span><span class="sxs-lookup"><span data-stu-id="0a867-617">This 6-byte field contains the target's Ethernet address.</span></span> |
| <span data-ttu-id="0a867-618">Целевой IP-адрес</span><span class="sxs-lookup"><span data-stu-id="0a867-618">Target IP Address</span></span> | <span data-ttu-id="0a867-619">В этом 4-байтовом поле содержится целевой IP-адрес.</span><span class="sxs-lookup"><span data-stu-id="0a867-619">This 4-byte field contains the target's IP address.</span></span> |

> [!IMPORTANT]
> <span data-ttu-id="0a867-620">*Запросы и ответы ARP — это пакеты уровня Ethernet. Все остальные пакеты TCP/IP инкапсулируются в заголовке IP-пакета.*</span><span class="sxs-lookup"><span data-stu-id="0a867-620">*ARP requests and responses are Ethernet-level packets. All other TCP/IP packets are encapsulated by an IP packet header.*</span></span>

> [!IMPORTANT]
> <span data-ttu-id="0a867-621">*Все сообщения ARP в реализации TCP/IP должны быть представлены в формате с обратным порядком байтов. В этом формате наиболее значимый байт слова размещается по наименьшему байтовому адресу.*</span><span class="sxs-lookup"><span data-stu-id="0a867-621">*All ARP messages in the TCP/IP implementation are expected to be in big endian format. In this format, the most significant byte of the word resides at the lowest byte address.*</span></span>

### <a name="arp-aging"></a><span data-ttu-id="0a867-622">Устаревание ARP</span><span class="sxs-lookup"><span data-stu-id="0a867-622">ARP Aging</span></span>

<span data-ttu-id="0a867-623">NetX поддерживает автоматическое аннулирование динамической записи ARP.</span><span class="sxs-lookup"><span data-stu-id="0a867-623">NetX supports automatic dynamic ARP entry invalidation.</span></span><span data-ttu-id="0a867-624">\ ***NX_ARP_EXPIRATION_RATE** _ задает время (в секундах), в течение которого установленное сопоставление IP-адреса с физическим адресом остается действительным.</span><span class="sxs-lookup"><span data-stu-id="0a867-624">\ ***NX_ARP_EXPIRATION_RATE** _specifies the number of seconds an established IP address to physical mapping stays valid.</span></span> <span data-ttu-id="0a867-625">После истечения срока действия запись ARP удаляется из кэша ARP.</span><span class="sxs-lookup"><span data-stu-id="0a867-625">After expiration, the ARP entry is removed from the ARP cache.</span></span> <span data-ttu-id="0a867-626">Следующая попытка отправить на соответствующий IP-адрес приведет к появлению нового запроса ARP.</span><span class="sxs-lookup"><span data-stu-id="0a867-626">The next attempt to send to the corresponding IP address will result in a new ARP request.</span></span> <span data-ttu-id="0a867-627">Установка нулевого значения для _ *_NX_ARP_EXPIRATION_RATE_*\* отключает устаревание ARP (конфигурация по умолчанию).</span><span class="sxs-lookup"><span data-stu-id="0a867-627">Setting _ *_NX_ARP_EXPIRATION_RATE_*\* to zero disables ARP aging, which is the default configuration.</span></span>

### <a name="arp-defend"></a><span data-ttu-id="0a867-628">Защита ARP</span><span class="sxs-lookup"><span data-stu-id="0a867-628">ARP Defend</span></span>

<span data-ttu-id="0a867-629">Если при получении пакета запроса или ответа ARP отправитель имеет IP-адрес, который конфликтует с IP-адресом этого узла, NetX отправляет запрос ARP для этого адреса в качестве защиты.</span><span class="sxs-lookup"><span data-stu-id="0a867-629">When an ARP request or ARP response packet is received and the sender has the same IP address, which conflicts with the IP address of this node, NetX sends an ARP request for that address as a defense.</span></span> <span data-ttu-id="0a867-630">Если конфликтный пакет ARP получен несколько раз в течение 10 секунд, NetX не отправляет другие пакеты защиты.</span><span class="sxs-lookup"><span data-stu-id="0a867-630">If the conflict ARP packet is received more than once in 10 seconds, NetX does not send more defend packets.</span></span> <span data-ttu-id="0a867-631">Заданный по умолчанию интервал в 10 секунд можно переопределить с помощью \***NX_ARP_DEFEND_INTERVAL** _.</span><span class="sxs-lookup"><span data-stu-id="0a867-631">The default interval 10 seconds can be redefined by \***NX_ARP_DEFEND_INTERVAL** _.</span></span> <span data-ttu-id="0a867-632">Это поведение соответствует политике, заданной в разделе 2.4(c) RFC5227.</span><span class="sxs-lookup"><span data-stu-id="0a867-632">This behavior follows the policy specified in 2.4(c) of RFC5227.</span></span> <span data-ttu-id="0a867-633">Так как Windows XP игнорирует объявление ARP как ответ на пробу ARP, пользователь может определить _*_NX_ARP_DEFEND_BY_REPLY_*\* для отправки ответа ARP в качестве дополнительной защиты.</span><span class="sxs-lookup"><span data-stu-id="0a867-633">Since Windows XP ignores ARP announcement as a response for its ARP probe, user can define _\*_NX_ARP_DEFEND_BY_REPLY_\*\*to send ARP response as additional defence.</span></span>

### <a name="arp-statistics-and-errors"></a><span data-ttu-id="0a867-634">Статистические показатели и ошибки ARP</span><span class="sxs-lookup"><span data-stu-id="0a867-634">ARP Statistics and Errors</span></span>

<span data-ttu-id="0a867-635">Если этот параметр включен, программное обеспечение ARP NetX отслеживает несколько статистических показателей и ошибок. Эти данные могут быть полезны для приложения.</span><span class="sxs-lookup"><span data-stu-id="0a867-635">If enabled, the NetX ARP software keeps track of several statistics and errors that may be useful to the application.</span></span> <span data-ttu-id="0a867-636">Для каждой обработки ARP в IP-экземпляре поддерживаются следующие статистические показатели и отчеты об ошибках:</span><span class="sxs-lookup"><span data-stu-id="0a867-636">The following statistics and error reports are maintained for each IP's ARP processing:</span></span>

- <span data-ttu-id="0a867-637">общее число отправленных запросов ARP;</span><span class="sxs-lookup"><span data-stu-id="0a867-637">Total ARP Requests Sent</span></span>
- <span data-ttu-id="0a867-638">общее число полученных запросов ARP;</span><span class="sxs-lookup"><span data-stu-id="0a867-638">Total ARP Requests Received</span></span>
- <span data-ttu-id="0a867-639">общее число отправленных ответов ARP;</span><span class="sxs-lookup"><span data-stu-id="0a867-639">Total ARP Responses Sent</span></span>
- <span data-ttu-id="0a867-640">общее число полученных ответов ARP;</span><span class="sxs-lookup"><span data-stu-id="0a867-640">Total ARP Responses Received</span></span>
- <span data-ttu-id="0a867-641">общее число динамических записей ARP;</span><span class="sxs-lookup"><span data-stu-id="0a867-641">Total ARP Dynamic Entries</span></span>
- <span data-ttu-id="0a867-642">общее число статических записей ARP;</span><span class="sxs-lookup"><span data-stu-id="0a867-642">Total ARP Static Entries</span></span>
- <span data-ttu-id="0a867-643">общее число устаревших записей ARP;</span><span class="sxs-lookup"><span data-stu-id="0a867-643">Total ARP Aged Entries</span></span>
- <span data-ttu-id="0a867-644">общее число недопустимых сообщений ARP.</span><span class="sxs-lookup"><span data-stu-id="0a867-644">Total ARP Invalid Messages</span></span>

<span data-ttu-id="0a867-645">Все эти статистические показатели и отчеты об ошибках предоставляются приложению службой ***nx_arp_info_get***.</span><span class="sxs-lookup"><span data-stu-id="0a867-645">All these statistics and error reports are available to the application with the ***nx_arp_info_get*** service.</span></span>

## <a name="reverse-address-resolution-protocol-rarp-in-ip"></a><span data-ttu-id="0a867-646">Протокол обратного разрешения адресов (RARP) в IP-экземпляре</span><span class="sxs-lookup"><span data-stu-id="0a867-646">Reverse Address Resolution Protocol (RARP) in IP</span></span>

<span data-ttu-id="0a867-647">Протокол обратного разрешения адресов (RARP) — это протокол для запроса сетевого назначения 32-разрядных IP-адресов узла (RFC 903).</span><span class="sxs-lookup"><span data-stu-id="0a867-647">The Reverse Address Resolution Protocol (RARP) is the protocol for requesting network assignment of the host's 32-bit IP addresses (RFC 903).</span></span> <span data-ttu-id="0a867-648">Для этого используется запрос RARP, который периодически повторяется, пока элемент сети не присвоит IP-адрес сетевому интерфейсу узла в ответе RARP.</span><span class="sxs-lookup"><span data-stu-id="0a867-648">This is done through an RARP request and continues periodically until a network member assigns an IP address to the host network interface in an RARP response.</span></span> <span data-ttu-id="0a867-649">Приложение создает IP-экземпляр с нулевым IP-адресом с помощью службы ***nx_ip_create***.</span><span class="sxs-lookup"><span data-stu-id="0a867-649">The application creates an IP instance by the service ***nx_ip_create*** with a zero IP address.</span></span> <span data-ttu-id="0a867-650">Если в приложении включен протокол RARP, оно может использовать протокол RARP для запроса IP-адреса у сетевого сервера, доступного через интерфейс с нулевым IP-адресом.</span><span class="sxs-lookup"><span data-stu-id="0a867-650">If RARP is enabled by the application, it can use the RARP protocol to request an IP address from the network server accessible through the interface that has a zero IP address.</span></span>

### <a name="rarp-enable"></a><span data-ttu-id="0a867-651">Включение RARP</span><span class="sxs-lookup"><span data-stu-id="0a867-651">RARP Enable</span></span>

<span data-ttu-id="0a867-652">Чтобы использовать RARP, приложение должно создать IP-экземпляр с нулевым IP-адресом, а затем включить RARP с помощью службы ***nx_rarp_enable***.</span><span class="sxs-lookup"><span data-stu-id="0a867-652">To use RARP, the application must create the IP instance with an IP address of zero, then enable RARP using the service ***nx_rarp_enable***.</span></span> <span data-ttu-id="0a867-653">Для систем с множественной адресацией по крайней мере одно сетевое устройство, связанное с IP-экземпляром, должно иметь IP-адрес, равный нулю.</span><span class="sxs-lookup"><span data-stu-id="0a867-653">For multihome systems, at least one network device associated with the IP instance must have an IP address of zero.</span></span> <span data-ttu-id="0a867-654">При обработке RARP для системы NetX периодически отправляются сообщения о запросах RARP на получение IP-адреса. Это продолжается, пока не будет получен допустимый ответ RARP с назначенным сетевым IP-адресом.</span><span class="sxs-lookup"><span data-stu-id="0a867-654">The RARP processing periodically sends RARP request messages for the NetX system requiring an IP address until a valid RARP reply with the network designated IP address is received.</span></span> <span data-ttu-id="0a867-655">На этом обработка RARP завершается.</span><span class="sxs-lookup"><span data-stu-id="0a867-655">At this point, RARP processing is complete.</span></span>

<span data-ttu-id="0a867-656">После включения протокола RARP он автоматически отключается после разрешения всех адресов интерфейсов.</span><span class="sxs-lookup"><span data-stu-id="0a867-656">After RARP has been enabled, it is disabled automatically after all interface addresses are resolved.</span></span> <span data-ttu-id="0a867-657">Приложение может принудительно завершить использование RARP с помощью службы ***nx_rarp_disable***.</span><span class="sxs-lookup"><span data-stu-id="0a867-657">The application may force RARP to terminate by using the service ***nx_rarp_disable***.</span></span>

###  <a name="rarp-request"></a><span data-ttu-id="0a867-658">Запрос RARP</span><span class="sxs-lookup"><span data-stu-id="0a867-658">RARP Request</span></span>

<span data-ttu-id="0a867-659">Формат пакета запроса службы практически идентичен формату пакета ARP, показанному на рис. 6 в разделе [Сообщения ARP](#arp-messages). Единственное отличие заключается в том, что значение поля типа кадра равно 0x8035, а значение поля *Код операции* равно 3, что соответствует запросу RARP.</span><span class="sxs-lookup"><span data-stu-id="0a867-659">The format of an RARP request packet is almost identical to the ARP packet shown in Figure 6 in the topic [ARP Messages](#arp-messages).The only difference is the frame type field is 0x8035 and the *Operation Code* field is 3, designating an RARP request.</span></span> <span data-ttu-id="0a867-660">Как упоминалось ранее, запросы RARP будут отправляться периодически (каждые ***NX_RARP_UPDATE_RATE*** секунд) до получения ответа RARP с назначенным сетью IP-адресом.</span><span class="sxs-lookup"><span data-stu-id="0a867-660">As mentioned previously, RARP requests will be sent periodically (every ***NX_RARP_UPDATE_RATE*** seconds) until a RARP reply with the network assigned IP address is received.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="0a867-661">*Все сообщения RARP в реализации TCP/IP должны быть представлены в формате с обратным порядком байтов. В этом формате наиболее значимый байт слова размещается по наименьшему байтовому адресу.*</span><span class="sxs-lookup"><span data-stu-id="0a867-661">*All RARP messages in the TCP/IP implementation are expected to be in big endian format. In this format, the most significant byte of the word resides at the lowest byte address.*</span></span>

### <a name="rarp-reply"></a><span data-ttu-id="0a867-662">Ответ RARP</span><span class="sxs-lookup"><span data-stu-id="0a867-662">RARP Reply</span></span>

<span data-ttu-id="0a867-663">Сообщения с ответами RARP принимаются из сети и содержат IP-адрес, назначенный сетью этому узлу.</span><span class="sxs-lookup"><span data-stu-id="0a867-663">RARP reply messages are received from the network and contain the network assigned IP address for this host.</span></span> <span data-ttu-id="0a867-664">Формат пакета ответа RARP практически идентичен формату пакета ARP, показанному на рис. 6.</span><span class="sxs-lookup"><span data-stu-id="0a867-664">The format of an RARP reply packet is almost identical to the ARP packet shown in Figure 6.</span></span> <span data-ttu-id="0a867-665">Единственное отличие заключается в том, что значение поля типа кадра равно 0x8035, а значение поля *Код операции* равно 4, что соответствует ответу RARP.</span><span class="sxs-lookup"><span data-stu-id="0a867-665">The only difference is the frame type field is 0x8035 and the *Operation Code* field is 4, which designates an RARP reply.</span></span> <span data-ttu-id="0a867-666">После получения ответа в IP-экземпляре настраивается IP-адрес, отключается периодическая отправка запроса RARP, а IP-экземпляр переходит в состояние готовности к нормальной работе в сети.</span><span class="sxs-lookup"><span data-stu-id="0a867-666">After received, the IP address is setup in the IP instance, the periodic RARP request is disabled, and the IP instance is now ready for normal network operation.</span></span>

<span data-ttu-id="0a867-667">Для узлов с множественной адресацией IP-адрес применяется к запрашивающему сетевому интерфейсу.</span><span class="sxs-lookup"><span data-stu-id="0a867-667">For multihome hosts, the IP address is applied to the requesting network interface.</span></span> <span data-ttu-id="0a867-668">Если есть другие сетевые интерфейсы, которые по-прежнему запрашивают назначение IP-адресов, периодическое обслуживание RARP продолжается до тех пор, пока не будут разрешены все запросы IP-адресов интерфейса.</span><span class="sxs-lookup"><span data-stu-id="0a867-668">If there are other network interfaces still requesting an IP address assignment, the periodic RARP service continues until all interface IP address requests are resolved.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="0a867-669">*Приложение не должно использовать IP-экземпляр до завершения обработки RARP. Приложения могут использовать **nx_ip_status_check** для ожидания завершения RARP. Для систем с множественной адресацией приложение не должно использовать запрашивающий интерфейс до завершения обработки RARP на этом интерфейсе. Состояние IP-адреса на вторичном устройстве можно проверить с помощью службы **nx_ip_interface_status_check**.*</span><span class="sxs-lookup"><span data-stu-id="0a867-669">*The application should not use the IP instance until the RARP processing is complete. The **nx_ip_status_check** may be used by applications to wait for the RARP completion. For multihome systems, the application should not use the requesting interface until the RARP processing is complete on that interface. Status of the IP address on the secondary device can be checked with the **nx_ip_interface_status_check** service.*</span></span>

### <a name="rarp-statistics-and-errors"></a><span data-ttu-id="0a867-670">Статистические показатели и ошибки RARP</span><span class="sxs-lookup"><span data-stu-id="0a867-670">RARP Statistics and Errors</span></span>

<span data-ttu-id="0a867-671">Если этот параметр включен, программное обеспечение RARP NetX отслеживает несколько статистических показателей и ошибок. Эти данные могут быть полезны для приложения.</span><span class="sxs-lookup"><span data-stu-id="0a867-671">If enabled, the NetX RARP software keeps track of several statistics and errors that may be useful to the application.</span></span> <span data-ttu-id="0a867-672">Для каждой обработки RARP в IP-экземпляре поддерживаются следующие статистические показатели и отчеты об ошибках:</span><span class="sxs-lookup"><span data-stu-id="0a867-672">The following statistics and error reports are maintained for each IP's RARP processing:</span></span>

- <span data-ttu-id="0a867-673">общее число отправленных запросов RARP;</span><span class="sxs-lookup"><span data-stu-id="0a867-673">Total RARP Requests Sent</span></span>
- <span data-ttu-id="0a867-674">общее число полученных ответов RARP;</span><span class="sxs-lookup"><span data-stu-id="0a867-674">Total RARP Responses Received</span></span>
- <span data-ttu-id="0a867-675">общее число недопустимых сообщений RARP.</span><span class="sxs-lookup"><span data-stu-id="0a867-675">Total RARP Invalid Messages</span></span>

<span data-ttu-id="0a867-676">Все эти статистические показатели и отчеты об ошибках предоставляются приложению службой ***nx_rarp_info_get***.</span><span class="sxs-lookup"><span data-stu-id="0a867-676">All these statistics and error reports are available to the application with the ***nx_rarp_info_get*** service.</span></span>

## <a name="internet-control-message-protocol-icmp"></a><span data-ttu-id="0a867-677">Протокол межсетевых управляющих сообщений (ICMP)</span><span class="sxs-lookup"><span data-stu-id="0a867-677">Internet Control Message Protocol (ICMP)</span></span>

<span data-ttu-id="0a867-678">Применение протокола межсетевых управляющих сообщений для IP (ICMP) ограничивается передачей сведений об ошибках и управлении между элементами IP-сети.</span><span class="sxs-lookup"><span data-stu-id="0a867-678">Internet Control Message Protocol for IP (ICMP) is limited to passing error and control information between IP network members.</span></span>

<span data-ttu-id="0a867-679">Как и на большинстве других уровней приложений (например, TCP/IP), сообщения ICMP инкапсулируются в заголовке IP с помощью обозначения протокола ICMP.</span><span class="sxs-lookup"><span data-stu-id="0a867-679">Like most other application layer (e.g., TCP/IP) messages, ICMP messages are encapsulated by an IP header with the ICMP protocol designation.</span></span>

### <a name="icmp-statistics-and-errors"></a><span data-ttu-id="0a867-680">Статистические показатели и ошибки ICMP</span><span class="sxs-lookup"><span data-stu-id="0a867-680">ICMP Statistics and Errors</span></span>

<span data-ttu-id="0a867-681">Если этот параметр включен, NetX отслеживает несколько статистических показателей и ошибок ICMP. Эти данные могут быть полезны для приложения.</span><span class="sxs-lookup"><span data-stu-id="0a867-681">If enabled, NetX keeps track of several ICMP statistics and errors that may be useful to the application.</span></span> <span data-ttu-id="0a867-682">Для каждой обработки ICMP в IP-экземпляре поддерживаются следующие статистические показатели и отчеты об ошибках:</span><span class="sxs-lookup"><span data-stu-id="0a867-682">The following statistics and error reports are maintained for each IP's ICMP processing:</span></span>

- <span data-ttu-id="0a867-683">общее число отправленных запросов проверки связи ICMP;</span><span class="sxs-lookup"><span data-stu-id="0a867-683">Total ICMP Pings Sent</span></span>
- <span data-ttu-id="0a867-684">общее число случаев истечения времени ожидания проверки связи ICMP;</span><span class="sxs-lookup"><span data-stu-id="0a867-684">Total ICMP Ping Timeouts</span></span>
- <span data-ttu-id="0a867-685">общее число приостановленных потоков проверки связи ICMP;</span><span class="sxs-lookup"><span data-stu-id="0a867-685">Total ICMP Ping Threads Suspended</span></span>
- <span data-ttu-id="0a867-686">общее число полученных ответов проверки связи ICMP;</span><span class="sxs-lookup"><span data-stu-id="0a867-686">Total ICMP Ping Responses Received</span></span>
- <span data-ttu-id="0a867-687">общее число ошибок контрольной суммы ICMP;</span><span class="sxs-lookup"><span data-stu-id="0a867-687">Total ICMP Checksum Errors</span></span>
- <span data-ttu-id="0a867-688">общее число необработанных сообщений ICMP.</span><span class="sxs-lookup"><span data-stu-id="0a867-688">Total ICMP Unhandled Messages</span></span>

<span data-ttu-id="0a867-689">Все эти статистические показатели и отчеты об ошибках предоставляются приложению службой ***nx_icmp_info_get***.</span><span class="sxs-lookup"><span data-stu-id="0a867-689">All these statistics and error reports are available to the application with the ***nx_icmp_info_get*** service.</span></span>

### <a name="icmp-enable"></a><span data-ttu-id="0a867-690">Включение ICMP</span><span class="sxs-lookup"><span data-stu-id="0a867-690">ICMP Enable</span></span>
<span data-ttu-id="0a867-691">Чтобы система NetX могла обработать сообщения ICMP, приложение должно вызвать службу ***nx_icmp_enable***, включающую обработку ICMP.</span><span class="sxs-lookup"><span data-stu-id="0a867-691">Before ICMP messages can be processed by NetX, the application must call the ***nx_icmp_enable*** service to enable ICMP processing.</span></span> <span data-ttu-id="0a867-692">После этого приложение может отправить запросы проверки связи и принять входящие пакеты проверки связи.</span><span class="sxs-lookup"><span data-stu-id="0a867-692">After this is done, the application can issue ping requests and field incoming ping packets.</span></span>

### <a name="icmp-echo-request"></a><span data-ttu-id="0a867-693">Запрос проверки связи ICMP</span><span class="sxs-lookup"><span data-stu-id="0a867-693">ICMP Echo Request</span></span>
<span data-ttu-id="0a867-694">Запрос проверки связи — это один из типов сообщений ICMP, который обычно используется для проверки существования определенного узла в сети, идентифицируемого по IP-адресу узла.</span><span class="sxs-lookup"><span data-stu-id="0a867-694">An echo request is one type of ICMP message that is typically used to check for the existence of a specific node on the network, as identified by its host IP address.</span></span> <span data-ttu-id="0a867-695">Популярная команда проверки связи реализуется с помощью сообщений с запросами проверки связи и ответами на них по протоколу ICMP.</span><span class="sxs-lookup"><span data-stu-id="0a867-695">The popular ping command is implemented using ICMP echo request/echo reply messages.</span></span> <span data-ttu-id="0a867-696">При наличии конкретного узла его сетевой стек обрабатывает запрос проверки связи и ответы на него с помощью ответа на команду проверки связи.</span><span class="sxs-lookup"><span data-stu-id="0a867-696">If the specific host is present, its network stack processes the ping request and responses with a ping response.</span></span> <span data-ttu-id="0a867-697">На рис. 7 подробно описывается формат сообщения проверки связи ICMP.</span><span class="sxs-lookup"><span data-stu-id="0a867-697">Figure 7 details the ICMP ping message format.</span></span>

![Сообщение проверки связи ICMP](./media/user-guide/icmp-ping-message.png)

<span data-ttu-id="0a867-699">**РИС. 7. Сообщение проверки связи ICMP**</span><span class="sxs-lookup"><span data-stu-id="0a867-699">**FIGURE 7. ICMP Ping Message**</span></span>

> [!IMPORTANT]
> <span data-ttu-id="0a867-700">*Все сообщения ICMP в реализации TCP/IP должны быть представлены в формате с обратным порядком байтов. В этом формате наиболее значимый байт слова размещается по наименьшему байтовому адресу.*</span><span class="sxs-lookup"><span data-stu-id="0a867-700">*All ICMP messages in the TCP/IP implementation are expected to be in big endian format. In this format, the most significant byte of the word resides at the lowest byte address.*</span></span>

<span data-ttu-id="0a867-701">В следующей таблице описывается формат заголовка ICMP.</span><span class="sxs-lookup"><span data-stu-id="0a867-701">The following table describes the ICMP header format:</span></span>

| <span data-ttu-id="0a867-702">Поле заголовка</span><span class="sxs-lookup"><span data-stu-id="0a867-702">Header Field</span></span>    | <span data-ttu-id="0a867-703">Назначение</span><span class="sxs-lookup"><span data-stu-id="0a867-703">Purpose</span></span> |
|-----------------|---------------------------------------------------|
| <span data-ttu-id="0a867-704">Тип</span><span class="sxs-lookup"><span data-stu-id="0a867-704">Type</span></span>            | <span data-ttu-id="0a867-705">В этом поле указывается сообщение ICMP (биты 31–24).</span><span class="sxs-lookup"><span data-stu-id="0a867-705">This field specifies the ICMP message (bits 31- 24).</span></span> <span data-ttu-id="0a867-706">Самые распространенные — это 0 (ответ на запрос проверки связи) и 8 (запрос проверки связи).</span><span class="sxs-lookup"><span data-stu-id="0a867-706">The most common are:   0 Echo Reply   8 Echo Request</span></span> |
| <span data-ttu-id="0a867-707">Код</span><span class="sxs-lookup"><span data-stu-id="0a867-707">Code</span></span>            | <span data-ttu-id="0a867-708">Это поле зависит от контекста в поле типа (биты 23–16).</span><span class="sxs-lookup"><span data-stu-id="0a867-708">This field is context specific on the type field (bits 23-16).</span></span> <span data-ttu-id="0a867-709">Для запроса проверки связи или ответа на него код имеет значение 0.</span><span class="sxs-lookup"><span data-stu-id="0a867-709">For an echo request or reply the code is set to zero.</span></span> |
| <span data-ttu-id="0a867-710">Контрольная сумма</span><span class="sxs-lookup"><span data-stu-id="0a867-710">Checksum</span></span>        | <span data-ttu-id="0a867-711">Это поле содержит 16-разрядную контрольную сумму для суммы, дополняющей единицу, в сообщении ICMP, включая весь заголовок ICMP, начинающийся с поля типа.</span><span class="sxs-lookup"><span data-stu-id="0a867-711">This field contains the 16-bit checksum of the one's complement sum of the ICMP message including the entire the ICMP header starting with the Type field.</span></span> <span data-ttu-id="0a867-712">Перед созданием контрольной суммы поле контрольной суммы очищается.</span><span class="sxs-lookup"><span data-stu-id="0a867-712">Before generating the checksum, the checksum field is cleared.</span></span>                 |
| <span data-ttu-id="0a867-713">Идентификация</span><span class="sxs-lookup"><span data-stu-id="0a867-713">Identification</span></span>  | <span data-ttu-id="0a867-714">Это поле содержит значение идентификатора, по которому можно определить узел. Для узла должен использоваться идентификатор, извлеченный из запроса проверки связи и ответа на него (биты 31–16).</span><span class="sxs-lookup"><span data-stu-id="0a867-714">This field contains an ID value identifying the host; a host should use the ID extracted from an ECHO request in the ECHO REPLY (bits 31-16).</span></span> |
| <span data-ttu-id="0a867-715">Порядковый номер</span><span class="sxs-lookup"><span data-stu-id="0a867-715">Sequence number</span></span> | <span data-ttu-id="0a867-716">Это поле содержит значение идентификатора. Для узла должен использоваться идентификатор, извлеченный из запроса проверки связи и ответа на него (биты 31–16).</span><span class="sxs-lookup"><span data-stu-id="0a867-716">This field contains an ID value; a host should use the ID extracted from an ECHO request in the ECHO REPLY (bits 31-16).</span></span> <span data-ttu-id="0a867-717">В отличие от поля идентификатора, это значение изменится в последующем запросе проверки связи, отправленном с того же узла (биты 15–0).</span><span class="sxs-lookup"><span data-stu-id="0a867-717">Unlike the identifier field, this value will change in a subsequent Echo request from the same host (bits 15-0).</span></span> |


### <a name="icmp-echo-response"></a><span data-ttu-id="0a867-718">Ответ на запрос проверки связи ICMP</span><span class="sxs-lookup"><span data-stu-id="0a867-718">ICMP Echo Response</span></span>
<span data-ttu-id="0a867-719">Ответ на запрос проверки связи — это еще один тип сообщения ICMP, который создается внутренними средствами с помощью компонента ICMP в ответ на внешний запрос проверки связи.</span><span class="sxs-lookup"><span data-stu-id="0a867-719">A ping response is another type of ICMP message that is generated internally by the ICMP component in response to an external ping request.</span></span> <span data-ttu-id="0a867-720">Кроме подтверждения, ответ на запрос проверки связи также содержит копию данных пользователя, содержащихся в запросе проверки связи.</span><span class="sxs-lookup"><span data-stu-id="0a867-720">In addition to acknowledgement, the ping response also contains a copy of the user data supplied in the ping request.</span></span>

## <a name="internet-group-management-protocol-igmp"></a><span data-ttu-id="0a867-721">протокол управления группами Интернета (IGMP)</span><span class="sxs-lookup"><span data-stu-id="0a867-721">Internet Group Management Protocol (IGMP)</span></span>

<span data-ttu-id="0a867-722">Протокол управления группами Интернета (IGMP) предоставляет устройству возможность взаимодействовать с его соседями и маршрутизаторами, связь с которыми он намеревается установить. Иными словами, он позволяет присоединиться к группе многоадресной рассылки по протоколу IP (RFC 1112 и RFC 2236).</span><span class="sxs-lookup"><span data-stu-id="0a867-722">The Internet Group Management Protocol (IGMP) provides a device to communicate with its neighbors and its routers that it intends to receive, or join, an IP multicast group (RFC 1112 and RFC 2236).</span></span> <span data-ttu-id="0a867-723">Группа многоадресной рассылки, по сути, является динамической коллекцией сетевых элементов и представляется IP-адресом класса D.</span><span class="sxs-lookup"><span data-stu-id="0a867-723">A multicast group is basically a dynamic collection of network members and is represented by a Class D IP address.</span></span> <span data-ttu-id="0a867-724">Группа многоадресной рассылки поддерживает исключение из нее текущих элементов и присоединение новых в любое время.</span><span class="sxs-lookup"><span data-stu-id="0a867-724">Members of the multicast group may leave at any time, and new members may join at any time.</span></span> <span data-ttu-id="0a867-725">За координацию, связанную с присоединением к группе и выходом из нее, отвечает IGMP.</span><span class="sxs-lookup"><span data-stu-id="0a867-725">The coordination involved in joining and leaving the group is the responsibility of IGMP.</span></span>

### <a name="igmp-enable"></a><span data-ttu-id="0a867-726">Включение IGMP</span><span class="sxs-lookup"><span data-stu-id="0a867-726">IGMP Enable</span></span>

<span data-ttu-id="0a867-727">Прежде чем выполнить какую-либо многоадресную операцию в NetX, приложение должно вызвать службу ***nx_igmp_enable***.</span><span class="sxs-lookup"><span data-stu-id="0a867-727">Before any multicasting activity can take place in NetX, the application must call the ***nx_igmp_enable*** service.</span></span> <span data-ttu-id="0a867-728">Эта служба выполняет базовую инициализацию IGMP при подготовке запросов многоадресной рассылки.</span><span class="sxs-lookup"><span data-stu-id="0a867-728">This service performs basic IGMP initialization in preparation for multicast requests.</span></span>

### <a name="multicast-ip-addressing"></a><span data-ttu-id="0a867-729">IP-адресация многоадресной рассылки</span><span class="sxs-lookup"><span data-stu-id="0a867-729">Multicast IP Addressing</span></span>

<span data-ttu-id="0a867-730">Как упоминалось ранее, адреса многоадресной рассылки фактически представляют собой IP-адреса класса D, как показано на рис. 4 на стр. 58.</span><span class="sxs-lookup"><span data-stu-id="0a867-730">As mentioned previously, multicast addresses are actually Class D IP addresses as shown in Figure 4 on page 58.</span></span> <span data-ttu-id="0a867-731">Младшие 28 разрядов адреса класса D соответствуют идентификатору группы многоадресной рассылки.</span><span class="sxs-lookup"><span data-stu-id="0a867-731">The lower 28-bits of the Class D address correspond to the multicast group ID.</span></span> <span data-ttu-id="0a867-732">Существует ряд предварительно определенных адресов многоадресной рассылки.</span><span class="sxs-lookup"><span data-stu-id="0a867-732">There are a series of pre-defined multicast addresses.</span></span> <span data-ttu-id="0a867-733">Однако для обработки IGMP особенно важен *адрес всех узлов* (244.0.0.1).</span><span class="sxs-lookup"><span data-stu-id="0a867-733">However, the *all hosts address* (244.0.0.1) is particularly important to IGMP processing.</span></span> <span data-ttu-id="0a867-734">*Адрес всех узлов* используется маршрутизаторами для запроса у участников многоадресной рассылки отчетов о том, к каким группам многоадресной рассылки они принадлежат.</span><span class="sxs-lookup"><span data-stu-id="0a867-734">The *all hosts address* is used by routers to query all multicast members to report on which multicast groups they belong to.</span></span>

### <a name="physical-address-mapping-in-ip"></a><span data-ttu-id="0a867-735">Сопоставление физических адресов в IP-экземпляре</span><span class="sxs-lookup"><span data-stu-id="0a867-735">Physical Address Mapping in IP</span></span>

<span data-ttu-id="0a867-736">Адреса многоадресной рассылки класса D сопоставляются непосредственно с физическими адресами Ethernet в диапазоне от 01.00.5e.00.00.00 до 01.00.5e.7f.ff.ff.</span><span class="sxs-lookup"><span data-stu-id="0a867-736">Class D multicast addresses map directly to physical Ethernet addresses ranging from 01.00.5e.00.00.00 through 01.00.5e.7f.ff.ff.</span></span> <span data-ttu-id="0a867-737">Младшие 23 бита IP-адреса многоадресной рассылки сопоставляются непосредственно с младшими 23 битами адреса Ethernet.</span><span class="sxs-lookup"><span data-stu-id="0a867-737">The lower 23 bits of the IP multicast address map directly to the lower 23 bits of the Ethernet address.</span></span>

### <a name="multicast-group-join"></a><span data-ttu-id="0a867-738">Присоединение к группе многоадресной рассылки</span><span class="sxs-lookup"><span data-stu-id="0a867-738">Multicast Group Join</span></span>

<span data-ttu-id="0a867-739">Приложения, которым необходимо присоединиться к определенной группе многоадресной рассылки, могут сделать это, вызвав службу ***nx_igmp_multicast_join***.</span><span class="sxs-lookup"><span data-stu-id="0a867-739">Applications that need to join a particular multicast group may do so by calling the ***nx_igmp_multicast_join*** service.</span></span> <span data-ttu-id="0a867-740">Эта служба отслеживает количество запросов на присоединение к данной группе многоадресной рассылки.</span><span class="sxs-lookup"><span data-stu-id="0a867-740">This service keeps track of the number of requests to join this multicast group.</span></span> <span data-ttu-id="0a867-741">Если это первый запрос приложения на присоединение к группе многоадресной рассылки, то в основной сети отправляется отчет IGMP, указывающий на то, что этот узел намерен присоединиться к группе.</span><span class="sxs-lookup"><span data-stu-id="0a867-741">If this is the first application request to join the multicast group, an IGMP report is sent out on the primary network indicating this host's intention to join the group.</span></span> <span data-ttu-id="0a867-742">Затем, чтобы настроить ожидание передачи данных пакетов с адресом Ethernet для этой группы многоадресной рассылки, вызывается драйвер сети.</span><span class="sxs-lookup"><span data-stu-id="0a867-742">Next, the network driver is called to set up for listening for packets with the Ethernet address for this multicast group.</span></span>

<span data-ttu-id="0a867-743">Если в системе с множественной адресацией группа многоадресной рассылки доступна через конкретный интерфейс, приложение должно использовать службу ***nx_igmp_multicast_interface_join*** вместо службы ***nx_igmp_multicast_join***, действие которой ограничено группами многоадресной рассылки в основной сети.</span><span class="sxs-lookup"><span data-stu-id="0a867-743">In a multihome system, if the multicast group is accessible via a specific interface, application shall use the service ***nx_igmp_multicast_interface_join*** instead of \***nx_igmp_multicast_join**,\* which is limited to multicast groups on the primary network.</span></span>

### <a name="multicast-group-leave"></a><span data-ttu-id="0a867-744">Выход из группы многоадресной рассылки</span><span class="sxs-lookup"><span data-stu-id="0a867-744">Multicast Group Leave</span></span>

<span data-ttu-id="0a867-745">Приложения, которым необходимо выйти из группы многоадресной рассылки, к которой они присоединились ранее, могут сделать это, вызвав службу ***nx_igmp_multicast_leave***.</span><span class="sxs-lookup"><span data-stu-id="0a867-745">Applications that need to leave a previously joined multicast group may do so by calling the ***nx_igmp_multicast_leave*** service.</span></span> <span data-ttu-id="0a867-746">Эта служба уменьшает значение внутреннего счетчика, связанного с числом операций присоединения к группе.</span><span class="sxs-lookup"><span data-stu-id="0a867-746">This service reduces the internal count associated with how many times the group was joined.</span></span> <span data-ttu-id="0a867-747">При отсутствии необработанных запросов на присоединение к группе вызывается драйвер сети для отключения ожидания передачи данных пакетов с адресом Ethernet этой группы многоадресной рассылки.</span><span class="sxs-lookup"><span data-stu-id="0a867-747">If there are no outstanding join requests for a group, the network driver is called to disable listening for packets with this multicast group's Ethernet address</span></span>

### <a name="multicast-loopback"></a><span data-ttu-id="0a867-748">Замыкание на себя многоадресной рассылки</span><span class="sxs-lookup"><span data-stu-id="0a867-748">Multicast Loopback</span></span>

<span data-ttu-id="0a867-749">Приложению может потребоваться получать трафик многоадресной рассылки из одного из источников, находящихся на том же узле.</span><span class="sxs-lookup"><span data-stu-id="0a867-749">An application may wish to receive multicast traffic originated from one of the sources on the same node.</span></span> <span data-ttu-id="0a867-750">Для этого требуется включить для компонента многоадресной рассылки в IP-экземпляре замыкание на себя с помощью службы ***nx_igmp_loopback_enable***.</span><span class="sxs-lookup"><span data-stu-id="0a867-750">This requires the IP multicast component to have loopback enabled by using the service ***nx_igmp_loopback_enable***.</span></span>

### <a name="igmp-report-message"></a><span data-ttu-id="0a867-751">Сообщение с отчетом IGMP</span><span class="sxs-lookup"><span data-stu-id="0a867-751">IGMP Report Message</span></span>

<span data-ttu-id="0a867-752">Когда приложение присоединяется к группе многоадресной рассылки, в сети отправляется сообщение с отчетом IGMP, указывающее на намерение узла присоединиться к определенной группе многоадресной рассылки.</span><span class="sxs-lookup"><span data-stu-id="0a867-752">When the application joins a multicast group, an IGMP report message is sent via the network to indicate the host's intention to join a particular multicast group.</span></span> <span data-ttu-id="0a867-753">Формат сообщения с отчетом IGMP показан на рис. 8.</span><span class="sxs-lookup"><span data-stu-id="0a867-753">The format of the IGMP report message is shown in Figure 8.</span></span> <span data-ttu-id="0a867-754">Для сообщения группы в сообщении с отчетом IGMP и IP-адреса назначения используется адрес группы многоадресной рассылки.</span><span class="sxs-lookup"><span data-stu-id="0a867-754">The multicast group address is used for both the group message in the IGMP report message and the destination IP address.</span></span>

![Сообщение с отчетом IGMP](./media/user-guide/igmp-report-message.png)

<span data-ttu-id="0a867-756">**РИС. 8. Сообщение с отчетом IGMP**</span><span class="sxs-lookup"><span data-stu-id="0a867-756">**FIGURE 8. IGMP Report Message**</span></span>

<span data-ttu-id="0a867-757">На рисунке выше (рис. 8) заголовок IGMP содержит поле версии и типа, максимальное время отклика, поле контрольной суммы и поле адреса группы многоадресной рассылки.</span><span class="sxs-lookup"><span data-stu-id="0a867-757">In the figure above (Figure 8), the IGMP header contains a version/type field, maximum response time, a checksum field, and a multicast group address field.</span></span> <span data-ttu-id="0a867-758">Для сообщений IGMPv1 значение поля максимального времени ответа всегда равно 0, так как оно не предусмотрено в протоколе IGMPv1.</span><span class="sxs-lookup"><span data-stu-id="0a867-758">For IGMPv1 messages, the Maximum Response Time field is always set to zero, as this is not part of the IGMPv1 protocol.</span></span> <span data-ttu-id="0a867-759">Поле максимального времени ответа задается, когда узел получает сообщение IGMP с типом запроса, и удаляется, когда узел получает сообщение с типом отчета другого узла, что предусмотрено определением протокола IGMPv2.</span><span class="sxs-lookup"><span data-stu-id="0a867-759">The Maximum Response Time field is set when the host receives a Query type IGMP message and cleared when a host receives another host's Report type message as defined by the IGMPv2 protocol.</span></span>

<span data-ttu-id="0a867-760">В следующей таблице описывается формат заголовка IGMP.</span><span class="sxs-lookup"><span data-stu-id="0a867-760">The following describes the IGMP header format:</span></span>

| <span data-ttu-id="0a867-761">**Поле заголовка**</span><span class="sxs-lookup"><span data-stu-id="0a867-761">**Header Field**</span></span>          | <span data-ttu-id="0a867-762">**Назначение**</span><span class="sxs-lookup"><span data-stu-id="0a867-762">**Purpose**</span></span> |
|-----------------------|--------------------------------------------------------------------|
| <span data-ttu-id="0a867-763">Version</span><span class="sxs-lookup"><span data-stu-id="0a867-763">Version</span></span>               | <span data-ttu-id="0a867-764">В этом поле указывается версия протокола IGMP (биты 31–28).</span><span class="sxs-lookup"><span data-stu-id="0a867-764">This field specifies the IGMP version (bits 31- 28).</span></span>                                                                               |
| <span data-ttu-id="0a867-765">Тип</span><span class="sxs-lookup"><span data-stu-id="0a867-765">Type</span></span>                  | <span data-ttu-id="0a867-766">В этом поле указывается тип сообщения IGMP (биты 27–24).</span><span class="sxs-lookup"><span data-stu-id="0a867-766">This field specifies the type of IGMP message (bits 27 -24).</span></span>                                                                       |
| <span data-ttu-id="0a867-767">Максимальное время ответа</span><span class="sxs-lookup"><span data-stu-id="0a867-767">Maximum Response Time</span></span> | <span data-ttu-id="0a867-768">Не используется в IGMPv1.</span><span class="sxs-lookup"><span data-stu-id="0a867-768">Not used in IGMPv1.</span></span> <span data-ttu-id="0a867-769">В IGMPv2 это поле служит для определения максимального времени ответа.</span><span class="sxs-lookup"><span data-stu-id="0a867-769">In IGMPv2 this field serves as the maximum response time.</span></span>                                                      |
| <span data-ttu-id="0a867-770">Контрольная сумма</span><span class="sxs-lookup"><span data-stu-id="0a867-770">Checksum</span></span>              | <span data-ttu-id="0a867-771">Это поле содержит 16-разрядную контрольную сумму для суммы, дополняющей единицу, для сообщения IGMP, начинающегося с версии IGMP (биты 0–15).</span><span class="sxs-lookup"><span data-stu-id="0a867-771">This field contains the 16-bit checksum of the one's complement sum of the IGMP message starting with the IGMP version (bits 0-15)</span></span> |
| <span data-ttu-id="0a867-772">Адрес группы</span><span class="sxs-lookup"><span data-stu-id="0a867-772">Group Address</span></span>         | <span data-ttu-id="0a867-773">32-разрядный IP-адрес группы класса D.</span><span class="sxs-lookup"><span data-stu-id="0a867-773">32-bit class D group IP address</span></span> |


<span data-ttu-id="0a867-774">Сообщения с отчетами IGMP отправляются в ответ на сообщения с запросами IGMP, отправляемые маршрутизатором многоадресной рассылки.</span><span class="sxs-lookup"><span data-stu-id="0a867-774">IGMP report messages are also sent in response to IGMP query messages sent by a multicast router.</span></span> <span data-ttu-id="0a867-775">Маршрутизаторы многоадресной рассылки периодически отправляют сообщения с запросами, чтобы установить, какие узлы все еще остаются в группе.</span><span class="sxs-lookup"><span data-stu-id="0a867-775">Multicast routers periodically send query messages out to see which hosts still require group membership.</span></span> <span data-ttu-id="0a867-776">Как показано на рис. 8, сообщения с запросами имеют тот же формат, что и сообщение с отчетами IGMP.</span><span class="sxs-lookup"><span data-stu-id="0a867-776">Query messages have the same format as the IGMP Report message shown in Figure 8.</span></span> <span data-ttu-id="0a867-777">Единственное отличие состоит в том, что тип IGMP равен 1, а поле адреса группы имеет значение 0.</span><span class="sxs-lookup"><span data-stu-id="0a867-777">The only differences are the IGMP type is equal to 1 and the group address field is set to 0.</span></span> <span data-ttu-id="0a867-778">Сообщения с запросами IGMP отправляются маршрутизатором многоадресной рассылки на IP-адрес *всех узлов*.</span><span class="sxs-lookup"><span data-stu-id="0a867-778">IGMP Query messages are sent to the *all hosts* IP address by the multicast router.</span></span> <span data-ttu-id="0a867-779">Узел, который по-прежнему хочет сохранить членство в группе, отправляет в ответ еще одно сообщение с отчетом IGMP.</span><span class="sxs-lookup"><span data-stu-id="0a867-779">A host that still wishes to maintain group membership responds by sending another IGMP Report message.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="0a867-780">*Все сообщения в реализации TCP/IP должны быть представлены в формате с **обратным порядком байтов**. В этом формате наиболее значимый байт слова размещается по наименьшему байтовому адресу.*</span><span class="sxs-lookup"><span data-stu-id="0a867-780">*All messages in the TCP/IP implementation are expected to be in **big endian** format. In this format, the most significant byte of the word resides at the lowest byte address.*</span></span>

### <a name="igmp-statistics-and-errors"></a><span data-ttu-id="0a867-781">Статистические показатели и ошибки IGMP</span><span class="sxs-lookup"><span data-stu-id="0a867-781">IGMP Statistics and Errors</span></span>

<span data-ttu-id="0a867-782">Если этот параметр включен, программное обеспечение IGMP NetX отслеживает несколько статистических показателей и ошибок. Эти данные могут быть полезны для приложения.</span><span class="sxs-lookup"><span data-stu-id="0a867-782">If enabled, the NetX IGMP software keeps track of several statistics and errors that may be useful to the application.</span></span> <span data-ttu-id="0a867-783">Для каждой обработки IGMP в IP-экземпляре поддерживаются следующие статистические показатели и отчеты об ошибках:</span><span class="sxs-lookup"><span data-stu-id="0a867-783">The following statistics and error reports are maintained for each IP's IGMP processing:</span></span>

- <span data-ttu-id="0a867-784">общее число отправленных отчетов IGMP;</span><span class="sxs-lookup"><span data-stu-id="0a867-784">Total IGMP Reports Sent</span></span>
- <span data-ttu-id="0a867-785">общее число полученных запросов IGMP;</span><span class="sxs-lookup"><span data-stu-id="0a867-785">Total IGMP Queries Received</span></span>
- <span data-ttu-id="0a867-786">общее число ошибок контрольной суммы IGMP;</span><span class="sxs-lookup"><span data-stu-id="0a867-786">Total IGMP Checksum Errors</span></span>
- <span data-ttu-id="0a867-787">общее число элементов, присоединившихся к текущей группе IGMP.</span><span class="sxs-lookup"><span data-stu-id="0a867-787">Total IGMP Current Groups Joined</span></span>

<span data-ttu-id="0a867-788">Все эти статистические показатели и отчеты об ошибках предоставляются приложению службой ***nx_igmp_info_get***.</span><span class="sxs-lookup"><span data-stu-id="0a867-788">All these statistics and error reports are available to the application with the ***nx_igmp_info_get*** service.</span></span>

## <a name="user-datagram-protocol-udp"></a><span data-ttu-id="0a867-789">Протокол пользовательских датаграмм (UDP)</span><span class="sxs-lookup"><span data-stu-id="0a867-789">User Datagram Protocol (UDP)</span></span>

<span data-ttu-id="0a867-790">Протокол пользовательских датаграмм (UDP) обеспечивает простейшую форму передачи данных между участниками сети (RFC 768).</span><span class="sxs-lookup"><span data-stu-id="0a867-790">The User Datagram Protocol (UDP) provides the simplest form of data transfer between network members (RFC 768).</span></span> <span data-ttu-id="0a867-791">Пакеты данных UDP отправляются от одного участника сети к другому по принципу наименьших затрат, т. е. встроенный механизм подтверждения получателем пакета отсутствует.</span><span class="sxs-lookup"><span data-stu-id="0a867-791">UDP data packets are sent from one network member to another in a best effort fashion; i.e., there is no built-in mechanism for acknowledgement by the packet recipient.</span></span> <span data-ttu-id="0a867-792">Кроме того, в данном случае перед отправкой пакета UDP не требуется устанавливать подключение заранее.</span><span class="sxs-lookup"><span data-stu-id="0a867-792">In addition, sending a UDP packet does not require any connection to be established in advance.</span></span> <span data-ttu-id="0a867-793">По этой причине передача пакетов UDP очень эффективна.</span><span class="sxs-lookup"><span data-stu-id="0a867-793">Because of this, UDP packet transmission is very efficient.</span></span>

### <a name="udp-header"></a><span data-ttu-id="0a867-794">Заголовок UDP</span><span class="sxs-lookup"><span data-stu-id="0a867-794">UDP Header</span></span>
<span data-ttu-id="0a867-795">При передаче UDP помещает простой заголовок пакета перед данными приложения и удаляет аналогичный заголовок UDP из пакета при его получении, прежде чем передавать полученный UDP-пакет приложению.</span><span class="sxs-lookup"><span data-stu-id="0a867-795">UDP places a simple packet header in front of the application's data on transmission, and removes a similar UDP header from the packet on reception before delivering a received UDP packet to the application.</span></span> <span data-ttu-id="0a867-796">UDP использует протокол IP для отправки и получения пакетов, поэтому, когда пакет находится в сети, перед его заголовком UDP размещается заголовок IP.</span><span class="sxs-lookup"><span data-stu-id="0a867-796">UDP utilizes the IP protocol for sending and receiving packets, which means there is an IP header in front of the UDP header when the packet is on the network.</span></span> <span data-ttu-id="0a867-797">На рис. 9 показан формат заголовка UDP.</span><span class="sxs-lookup"><span data-stu-id="0a867-797">Figure 9 shows the format of the UDP header.</span></span>

![Заголовок UDP](./media/user-guide/udp-header.png)

<span data-ttu-id="0a867-799">**РИС. 9. Заголовок UDP**</span><span class="sxs-lookup"><span data-stu-id="0a867-799">**FIGURE 9. UDP Header**</span></span>

> [!IMPORTANT]
> <span data-ttu-id="0a867-800">*Все заголовки в реализации UDP/IP должны быть представлены в формате с обратным порядком байтов. В этом формате наиболее значимый байт слова размещается по наименьшему байтовому адресу.*</span><span class="sxs-lookup"><span data-stu-id="0a867-800">*All headers in the UDP/IP implementation are expected to be in big endian format. In this format, the most significant byte of the word resides at the lowest byte address.*</span></span>

<span data-ttu-id="0a867-801">В следующей таблице описывается формат заголовка UDP.</span><span class="sxs-lookup"><span data-stu-id="0a867-801">The following describes the UDP header format:</span></span>

| <span data-ttu-id="0a867-802">Поле заголовка</span><span class="sxs-lookup"><span data-stu-id="0a867-802">Header Field</span></span>                   | <span data-ttu-id="0a867-803">Назначение</span><span class="sxs-lookup"><span data-stu-id="0a867-803">Purpose</span></span> |
|--------------------------------|---------------------------------------------|
| <span data-ttu-id="0a867-804">16-разрядное поле номера исходного порта</span><span class="sxs-lookup"><span data-stu-id="0a867-804">16-bit source port number</span></span>      | <span data-ttu-id="0a867-805">Это поле содержит порт, из которого отправляется UDP-пакет.</span><span class="sxs-lookup"><span data-stu-id="0a867-805">This field contains the port on which the UDP packet is being sent from.</span></span> <span data-ttu-id="0a867-806">Допустимый диапазон UDP-портов — от 1 до 0xFFFF.</span><span class="sxs-lookup"><span data-stu-id="0a867-806">Valid UDP ports range from 1 through 0xFFFF.</span></span> |
| <span data-ttu-id="0a867-807">16-разрядное поле номера порта назначения</span><span class="sxs-lookup"><span data-stu-id="0a867-807">16-bit destination port number</span></span> | <span data-ttu-id="0a867-808">Это поле содержит порт UDP, на который отправляется UDP-пакет.</span><span class="sxs-lookup"><span data-stu-id="0a867-808">This field contains the UDP port to which the packet is being sent to.</span></span> <span data-ttu-id="0a867-809">Допустимый диапазон UDP-портов — от 1 до 0xFFFF.</span><span class="sxs-lookup"><span data-stu-id="0a867-809">Valid UDP ports range from 1 through 0xFFFF.</span></span>   |
| <span data-ttu-id="0a867-810">16-разрядное поле длины UDP-пакета</span><span class="sxs-lookup"><span data-stu-id="0a867-810">16-bit UDP length</span></span>   | <span data-ttu-id="0a867-811">Это поле содержит число байтов в UDP-пакете, включая размер заголовка UDP.</span><span class="sxs-lookup"><span data-stu-id="0a867-811">This field contains the number of bytes in the UDP packet, including the size of the UDP header.</span></span>                                  |
| <span data-ttu-id="0a867-812">16-разрядное поле контрольной суммы UDP</span><span class="sxs-lookup"><span data-stu-id="0a867-812">16-bit UDP checksum</span></span> | <span data-ttu-id="0a867-813">Это поле содержит 16-разрядную контрольную сумму пакета, включая заголовок UDP, область данных пакета и псевдозаголовок IP.</span><span class="sxs-lookup"><span data-stu-id="0a867-813">This field contains the 16-bit checksum for the packet, including the UDP header, the packet data area, and the pseudo IP header.</span></span> |

### <a name="udp-enable"></a><span data-ttu-id="0a867-814">Включение UDP</span><span class="sxs-lookup"><span data-stu-id="0a867-814">UDP Enable</span></span>

<span data-ttu-id="0a867-815">Перед передачей UDP-пакетов приложение должно сначала включить протокол UDP, вызвав службу ***nx_udp_enable***.</span><span class="sxs-lookup"><span data-stu-id="0a867-815">Before UDP packet transmission is possible, the application must first enable UDP by calling the ***nx_udp_enable*** service.</span></span> <span data-ttu-id="0a867-816">После включения приложение может отправлять и получать UDP-пакеты.</span><span class="sxs-lookup"><span data-stu-id="0a867-816">After enabled, the application is free to send and receive UDP packets.</span></span>

### <a name="udp-socket-create"></a><span data-ttu-id="0a867-817">Создание UDP-сокета</span><span class="sxs-lookup"><span data-stu-id="0a867-817">UDP Socket Create</span></span>

<span data-ttu-id="0a867-818">Сокеты UDP создаются во время инициализации или выполнения потоками приложения.</span><span class="sxs-lookup"><span data-stu-id="0a867-818">UDP sockets are created either during initialization or during runtime by application threads.</span></span> <span data-ttu-id="0a867-819">Начальный тип службы, срок жизни и длина очереди получения определяются службой ***nx_udp_socket_create***.</span><span class="sxs-lookup"><span data-stu-id="0a867-819">The initial type of service, time to live, and receive queue depth are defined by the ***nx_udp_socket_create*** service.</span></span> <span data-ttu-id="0a867-820">Число сокетов UDP в приложении не ограничено.</span><span class="sxs-lookup"><span data-stu-id="0a867-820">There are no limits on the number of UDP sockets in an application.</span></span>

### <a name="udp-checksum"></a><span data-ttu-id="0a867-821">Контрольная сумма UDP</span><span class="sxs-lookup"><span data-stu-id="0a867-821">UDP Checksum</span></span>

<span data-ttu-id="0a867-822">Протокол UDP указывает свою дополняющую 16-разрядную контрольную сумму, охватывающую псевдозаголовок IP (состоящий из исходного IP-адреса, IP-адреса назначения и IP-слова, указывающего протокол и длину), заголовок UDP и данные пакета UDP.</span><span class="sxs-lookup"><span data-stu-id="0a867-822">UDP specifies a one's complement 16-bit checksum that covers the IP pseudo header (consisting of the source IP address, destination IP address, and the protocol/length IP word), the UDP header, and the UDP packet data.</span></span> <span data-ttu-id="0a867-823">Если вычисленная контрольная сумма UDP равна 0, она сохраняется как значение, состоящее только из единиц (0xFFFF).</span><span class="sxs-lookup"><span data-stu-id="0a867-823">If the calculated UDP checksum is 0, it is stored as all ones (0xFFFF).</span></span> <span data-ttu-id="0a867-824">Если для отправляющего сокета отключена логика контрольной суммы UDP, в поле контрольной суммы UDP помещается нулевое значение, указывающее, что контрольная сумма не вычислена.</span><span class="sxs-lookup"><span data-stu-id="0a867-824">If the sending socket has the UDP checksum logic disabled, a zero is placed in the UDP checksum field to indicate the checksum was not calculated.</span></span> <span data-ttu-id="0a867-825">Если контрольная сумма UDP не совпадает с вычисленной контрольной суммой получателя, пакет UDP просто отбрасывается.</span><span class="sxs-lookup"><span data-stu-id="0a867-825">If the UDP checksum does not match the computed checksum by the receiver, the UDP packet is simply discarded.</span></span>

<span data-ttu-id="0a867-826">В IP-сети контрольная сумма UDP необязательна.</span><span class="sxs-lookup"><span data-stu-id="0a867-826">On the IP network, UDP checksum is optional.</span></span> <span data-ttu-id="0a867-827">NetX позволяет приложению включать или отключать расчет контрольной суммы UDP для каждого сокета.</span><span class="sxs-lookup"><span data-stu-id="0a867-827">NetX allows an application to enable or disable UDP checksum calculation on a per-socket basis.</span></span> <span data-ttu-id="0a867-828">По умолчанию логика контрольной суммы UDP-сокета включена.</span><span class="sxs-lookup"><span data-stu-id="0a867-828">By default, the UDP socket checksum logic is enabled.</span></span> <span data-ttu-id="0a867-829">Приложение может отключить логику контрольной суммы для определенного сокета UDP, вызвав службу ***nx_udp_socket_checksum_disable***.</span><span class="sxs-lookup"><span data-stu-id="0a867-829">The application can disable checksum logic for a particular UDP socket by calling the ***nx_udp_socket_checksum_disable*** service.</span></span>

<span data-ttu-id="0a867-830">Некоторые контроллеры Ethernet могут создавать контрольную сумму UDP на лету.</span><span class="sxs-lookup"><span data-stu-id="0a867-830">Certain Ethernet controllers are able to generate the UDP checksum on the fly.</span></span> <span data-ttu-id="0a867-831">Если система может использовать возможность аппаратного вычисления контрольной суммы, библиотеку NetX можно построить без логики контрольной суммы.</span><span class="sxs-lookup"><span data-stu-id="0a867-831">If the system is able to use hardware checksum computation feature, the NetX library can be built without the checksum logic.</span></span> <span data-ttu-id="0a867-832">Чтобы отключить программное вычисление контрольной суммы UDP, при построении библиотеки NetX необходимо определить следующие символы: ***NX_DISABLE_UDP_TX_CHECKSUM*** и ***NX_DISABLE_UDP_RX_CHECKSUM \* *_ (описывается в [главе 2](chapter2.md)). Такие параметры конфигурации приводят к полному удалению логики контрольной суммы UDP из NetX, а вызов службы _* nx_udp_socket_checksum_disable*** позволяет приложению отключить обработку контрольной суммы UDP в IP-экземпляре для каждого сокета.</span><span class="sxs-lookup"><span data-stu-id="0a867-832">To disable UDP software checksum, the NetX library must be built with the following symbols defined: ***NX_DISABLE_UDP_TX_CHECKSUM*** and ***NX_DISABLE_UDP_RX_CHECKSUM\*\*_ (described in [Chapter 2](chapter2.md)). The configuration options remove UDP checksum logic from NetX entirely, while calling the _* nx_udp_socket_checksum_disable**\* service allows the application to disable IP UDP checksum processing on a per socket basis.</span></span>

### <a name="udp-ports-and-binding"></a><span data-ttu-id="0a867-833">Порты и привязка UDP</span><span class="sxs-lookup"><span data-stu-id="0a867-833">UDP Ports and Binding</span></span>

<span data-ttu-id="0a867-834">UDP-порт — это логическая конечная точка в протоколе UDP.</span><span class="sxs-lookup"><span data-stu-id="0a867-834">A UDP port is a logical end point in the UDP protocol.</span></span> <span data-ttu-id="0a867-835">В компоненте UDP системы NetX имеется 65 535 допустимых портов в диапазоне от 1 до 0xFFFF.</span><span class="sxs-lookup"><span data-stu-id="0a867-835">There are 65,535 valid ports in the UDP component of NetX, ranging from 1 through 0xFFFF.</span></span> <span data-ttu-id="0a867-836">Для отправки или получения данных UDP приложение должно сначала создать сокет UDP, а затем привязать его к нужному порту.</span><span class="sxs-lookup"><span data-stu-id="0a867-836">To send or receive UDP data, the application must first create a UDP socket, then bind it to a desired port.</span></span> <span data-ttu-id="0a867-837">После привязки UDP-сокета к порту приложение может отправлять и получать данные на этом сокете.</span><span class="sxs-lookup"><span data-stu-id="0a867-837">After binding a UDP socket to a port, the application may send and receive data on that socket.</span></span>

### <a name="udp-fast-pathtrade"></a><span data-ttu-id="0a867-838">UDP Fast Path&trade;</span><span class="sxs-lookup"><span data-stu-id="0a867-838">UDP Fast Path&trade;</span></span>

<span data-ttu-id="0a867-839">UDP Fast Path&trade; — это имя для пути с низкими временными затратами на передачу пакетов с помощью реализации UDP в NetX.</span><span class="sxs-lookup"><span data-stu-id="0a867-839">The UDP Fast Path&trade; is the name for a low packet overhead path through the NetX UDP implementation.</span></span> <span data-ttu-id="0a867-840">Для отправки UDP-пакета требуется вызов всего нескольких функций (***nx_udp_socket_send** _ и _*_nx_ip_packet_send_\*_) с дальнейшим вызовом сетевого драйвера.</span><span class="sxs-lookup"><span data-stu-id="0a867-840">Sending a UDP packet requires just a few function calls: ***nx_udp_socket_send** _, _*_nx_ip_packet_send_\*_, and the eventual call to the network driver.</span></span> <span data-ttu-id="0a867-841">Функция _*_nx_udp_socket_send_*_ доступна в NetX для имеющихся приложений NetX и применяется только для IP-пакетов.</span><span class="sxs-lookup"><span data-stu-id="0a867-841">_*_nx_udp_socket_send_*_ is available in NetX for existing NetX applications and is only applicable for IP packets.</span></span> <span data-ttu-id="0a867-842">Однако предпочтительным методом является использование службы _ \*_nx_udp_socket_send_\*\*, описанной ниже.</span><span class="sxs-lookup"><span data-stu-id="0a867-842">The preferred method, however, is to use _ *_nx_udp_socket_send_*\* service discussed below.</span></span> <span data-ttu-id="0a867-843">При получении UDP-пакета он помещается в соответствующую очередь получения в сокете UDP либо доставляется в приостановленный поток приложения в ходе одного вызова функции из обработки прерывания получения сетевого драйвера.</span><span class="sxs-lookup"><span data-stu-id="0a867-843">On UDP packet reception, the UDP packet is either placed on the appropriate UDP socket receive queue or delivered to a suspended application thread in a single function call from the network driver's receive interrupt processing.</span></span> <span data-ttu-id="0a867-844">Эта логика с высокой степенью оптимизации для отправки и получения пакетов UDP является основой технологии UDP Fast Path.</span><span class="sxs-lookup"><span data-stu-id="0a867-844">This highly optimized logic for sending and receiving UDP packets is the essence of UDP Fast Path technology.</span></span>

### <a name="udp-packet-send"></a><span data-ttu-id="0a867-845">Отправка UDP-пакета</span><span class="sxs-lookup"><span data-stu-id="0a867-845">UDP Packet Send</span></span>

<span data-ttu-id="0a867-846">Отправка данных UDP через IP-сети легко осуществляется путем вызова функции \***nx_udp_socket_send** _.</span><span class="sxs-lookup"><span data-stu-id="0a867-846">Sending UDP data over IP networks is easily accomplished by calling the \***nx_udp_socket_send** _ function.</span></span> <span data-ttu-id="0a867-847">Вызывающий объект должен задать версию IP в поле _IP-адреса\*.</span><span class="sxs-lookup"><span data-stu-id="0a867-847">The caller must set the IP version in the _IP address\* field.</span></span> <span data-ttu-id="0a867-848">NetX определит оптимальный исходный адрес для передаваемых UDP-пакетов на основе IP-адреса назначения.</span><span class="sxs-lookup"><span data-stu-id="0a867-848">NetX will determine the best source address for transmitted UDP packets based on the destination IP address.</span></span> <span data-ttu-id="0a867-849">Эта служба помещает заголовок UDP перед данными пакета и отправляет его в сеть с помощью внутренней подпрограммы отправки IP-пакетов.</span><span class="sxs-lookup"><span data-stu-id="0a867-849">This service places a UDP header in front of the packet data and sends it out onto the network using an internal IP send routine.</span></span> <span data-ttu-id="0a867-850">При отправке UDP-пакетов приостановка потока не применяется, так как все операции передачи UDP-пакетов обрабатываются незамедлительно.</span><span class="sxs-lookup"><span data-stu-id="0a867-850">There is no thread suspension on sending UDP packets because all UDP packet transmissions are processed immediately.</span></span>

<span data-ttu-id="0a867-851">Для мест назначения многоадресной или широковещательной рассылки приложение должно указать исходный IP-адрес, который будет использоваться, если у устройства NetX есть несколько IP-адресов на выбор.</span><span class="sxs-lookup"><span data-stu-id="0a867-851">For multicast or broadcast destinations, the application should specify the source IP address to use if the NetX device has multiple IP addresses to choose from.</span></span> <span data-ttu-id="0a867-852">Это можно сделать с помощью служб ***nx_udp_socket_interface_send.***</span><span class="sxs-lookup"><span data-stu-id="0a867-852">This can be done with the services ***nx_udp_socket_interface_send.***</span></span>

> [!IMPORTANT]
> <span data-ttu-id="0a867-853">*Если для передачи многоадресных или широковещательных пакетов используется **nx_udp_socket_send**, в качестве исходного адреса используется IP-адрес первого интерфейса.*</span><span class="sxs-lookup"><span data-stu-id="0a867-853">*If **nx_udp_socket_send** is used for transmitting multicast or broadcast packets, the IP address of the first interface is used as source address.*</span></span>

> [!IMPORTANT]
> <span data-ttu-id="0a867-854">*Если для этого сокета включена логика контрольной суммы UDP, операция вычисления контрольной суммы выполняется в контексте вызывающего потока, не блокируя доступ к структурам данных UDP или IP.*</span><span class="sxs-lookup"><span data-stu-id="0a867-854">*If UDP checksum logic is enabled for this socket, the checksum operation is performed in the context of the calling thread, without blocking access to the UDP or IP data structures.*</span></span>

> [!NOTE]
> <span data-ttu-id="0a867-855">*Полезные данные UDP, находящиеся в структуре **NX_PACKET**, должны располагаться на границе длинных слов. Приложению необходимо оставить достаточно места между открывающим указателем и указателем начала данных, чтобы система NetX могла разместить заголовки UDP, IP и физических носителей.*</span><span class="sxs-lookup"><span data-stu-id="0a867-855">*The UDP payload data residing in the **NX_PACKET** structure should reside on a long-word boundary. The application needs to leave sufficient space between the prepend pointer and the data start pointer for NetX to place the UDP, IP, and physical media headers.*</span></span>

### <a name="udp-packet-receive"></a><span data-ttu-id="0a867-856">Получение UDP-пакетов</span><span class="sxs-lookup"><span data-stu-id="0a867-856">UDP Packet Receive</span></span>

<span data-ttu-id="0a867-857">Потоки приложения могут получить UDP-пакеты от определенного сокета, вызвав ***nx_udp_socket_receive***.</span><span class="sxs-lookup"><span data-stu-id="0a867-857">Application threads may receive UDP packets from a particular socket by calling ***nx_udp_socket_receive***.</span></span> <span data-ttu-id="0a867-858">Функция получения сокета доставляет самый старый пакет в его очереди получения.</span><span class="sxs-lookup"><span data-stu-id="0a867-858">The socket receive function delivers the oldest packet on the socket's receive queue.</span></span> <span data-ttu-id="0a867-859">Если в очереди получения нет пакетов, вызывающий поток может быть приостановлен (с необязательным временем ожидания) до поступления пакета.</span><span class="sxs-lookup"><span data-stu-id="0a867-859">If there are no packets on the receive queue, the calling thread can suspend (with an optional timeout) until a packet arrives.</span></span>

<span data-ttu-id="0a867-860">Функция обработки получаемых UDP-пакетов (обычно вызывается из обработчика прерываний получения сетевого драйвера) отвечает за помещение пакета в очередь получения UDP-сокета или доставку его первому приостановленному потоку, ожидающему пакет.</span><span class="sxs-lookup"><span data-stu-id="0a867-860">The UDP receive packet processing (usually called from the network driver's receive interrupt handler) is responsible for either placing the packet on the UDP socket's receive queue or delivering it to the first suspended thread waiting for a packet.</span></span> <span data-ttu-id="0a867-861">Если пакет находится в очереди, то при обработке получения проверяется также связанная с сокетом максимальная длина очереди получения.</span><span class="sxs-lookup"><span data-stu-id="0a867-861">If the packet is queued, the receive processing also checks the maximum receive queue depth associated with the socket.</span></span> <span data-ttu-id="0a867-862">Если размер нового пакета, поступившего в очередь, превышает длину очереди, самый старый пакет в очереди отбрасывается.</span><span class="sxs-lookup"><span data-stu-id="0a867-862">If this newly queued packet exceeds the queue depth, the oldest packet in the queue is discarded.</span></span>

### <a name="udp-receive-notify"></a><span data-ttu-id="0a867-863">Уведомление о получении UDP-пакета</span><span class="sxs-lookup"><span data-stu-id="0a867-863">UDP Receive Notify</span></span>

<span data-ttu-id="0a867-864">Если поток приложения должен обрабатывать полученные данные из нескольких сокетов, следует использовать функцию ***nx_udp_socket_receive_notify***.</span><span class="sxs-lookup"><span data-stu-id="0a867-864">If the application thread needs to process received data from more than one socket, the ***nx_udp_socket_receive_notify*** function should be used.</span></span> <span data-ttu-id="0a867-865">Эта функция регистрирует функцию обратного вызова получения пакетов для сокета.</span><span class="sxs-lookup"><span data-stu-id="0a867-865">This function registers a receive packet callback function for the socket.</span></span> <span data-ttu-id="0a867-866">При каждом получении пакета сокетом выполняется функция обратного вызова.</span><span class="sxs-lookup"><span data-stu-id="0a867-866">Whenever a packet is received on the socket, the callback function is executed.</span></span>

<span data-ttu-id="0a867-867">Содержимое функции обратного вызова зависит от конкретного приложения.</span><span class="sxs-lookup"><span data-stu-id="0a867-867">The contents of the callback function is application-specific.</span></span> <span data-ttu-id="0a867-868">Однако, скорее всего, она будет содержать логику для информирования потока обработки о доступности пакета на соответствующем сокете.</span><span class="sxs-lookup"><span data-stu-id="0a867-868">However, it would most likely contain logic to inform the processing thread that a packet is now available on the corresponding socket.</span></span>

### <a name="peer-address-and-port"></a><span data-ttu-id="0a867-869">Адрес и порт однорангового узла</span><span class="sxs-lookup"><span data-stu-id="0a867-869">Peer Address and Port</span></span>

<span data-ttu-id="0a867-870">При получении UDP-пакета приложение может найти IP-адрес и номер порта отправителя с помощью службы ***nx_udp_packet_info_extract***.</span><span class="sxs-lookup"><span data-stu-id="0a867-870">On receiving a UDP packet, application may find the sender's IP address and port number by using the service ***nx_udp_packet_info_extract***.</span></span> <span data-ttu-id="0a867-871">При успешном возвращении результата эта служба предоставляет сведения об IP-адресе и номере порта отправителя, а также локальном интерфейсе, через который был получен пакет.</span><span class="sxs-lookup"><span data-stu-id="0a867-871">On successful return, this service provides information on the sender's IP address, sender's port number, and the local interface through which the packet was received.</span></span>

### <a name="thread-suspension"></a><span data-ttu-id="0a867-872">Приостановка потока</span><span class="sxs-lookup"><span data-stu-id="0a867-872">Thread Suspension</span></span>

<span data-ttu-id="0a867-873">Как упоминалось ранее, потоки приложений могут быть приостановлены при попытке получить UDP-пакет на определенном UDP-порте.</span><span class="sxs-lookup"><span data-stu-id="0a867-873">As mentioned previously, application threads can suspend while attempting to receive a UDP packet on a particular UDP port.</span></span> <span data-ttu-id="0a867-874">После получения пакета на этом порте он передается первому приостановленному потоку, и этот поток возобновляется.</span><span class="sxs-lookup"><span data-stu-id="0a867-874">After a packet is received on that port, it is given to the first thread suspended and that thread is then resumed.</span></span> <span data-ttu-id="0a867-875">Для большинства служб NetX можно использовать необязательный параметр времени ожидания при приостановке получения UDP-пакетов.</span><span class="sxs-lookup"><span data-stu-id="0a867-875">An optional timeout is available when suspending on a UDP receive packet, a feature available for most NetX services.</span></span>

### <a name="udp-socket-statistics-and-errors"></a><span data-ttu-id="0a867-876">Статистические показатели и ошибки UDP-сокета</span><span class="sxs-lookup"><span data-stu-id="0a867-876">UDP Socket Statistics and Errors</span></span>

<span data-ttu-id="0a867-877">Если этот параметр включен, программное обеспечение UDP NetX отслеживает несколько статистических показателей и ошибок. Эти данные могут быть полезны для приложения.</span><span class="sxs-lookup"><span data-stu-id="0a867-877">If enabled, the NetX UDP socket software keeps track of several statistics and errors that may be useful to the application.</span></span> <span data-ttu-id="0a867-878">Для каждого IP/UDP-экземпляра поддерживаются следующие статистические показатели и отчеты об ошибках:</span><span class="sxs-lookup"><span data-stu-id="0a867-878">The following statistics and error reports are maintained for each IP/UDP instance:</span></span>

- <span data-ttu-id="0a867-879">общее число отправленных UDP-пакетов;</span><span class="sxs-lookup"><span data-stu-id="0a867-879">Total UDP Packets Sent</span></span>
- <span data-ttu-id="0a867-880">общее число отправленных байтов UDP;</span><span class="sxs-lookup"><span data-stu-id="0a867-880">Total UDP Bytes Sent</span></span>
- <span data-ttu-id="0a867-881">общее число полученных UDP-пакетов;</span><span class="sxs-lookup"><span data-stu-id="0a867-881">Total UDP Packets Received</span></span>
- <span data-ttu-id="0a867-882">общее число полученных байтов UDP;</span><span class="sxs-lookup"><span data-stu-id="0a867-882">Total UDP Bytes Received</span></span>
- <span data-ttu-id="0a867-883">общее число недопустимых UDP-пакетов;</span><span class="sxs-lookup"><span data-stu-id="0a867-883">Total UDP Invalid Packets</span></span>
- <span data-ttu-id="0a867-884">общее число отброшенных пакетов, получаемых по протоколу UDP;</span><span class="sxs-lookup"><span data-stu-id="0a867-884">Total UDP Receive Packets Dropped</span></span>
- <span data-ttu-id="0a867-885">общее число ошибок контрольной суммы при получении по протоколу UDP;</span><span class="sxs-lookup"><span data-stu-id="0a867-885">Total UDP Receive Checksum Errors</span></span>
- <span data-ttu-id="0a867-886">число отправленных пакетов UDP-сокета;</span><span class="sxs-lookup"><span data-stu-id="0a867-886">UDP Socket Packets Sent</span></span>
- <span data-ttu-id="0a867-887">число отправленных байтов UDP-сокета;</span><span class="sxs-lookup"><span data-stu-id="0a867-887">UDP Socket Bytes Sent</span></span>
- <span data-ttu-id="0a867-888">число полученных пакетов UDP-сокета;</span><span class="sxs-lookup"><span data-stu-id="0a867-888">UDP Socket Packets Received</span></span>
- <span data-ttu-id="0a867-889">число полученных байтов UDP-сокета;</span><span class="sxs-lookup"><span data-stu-id="0a867-889">UDP Socket Bytes Received</span></span>
- <span data-ttu-id="0a867-890">число поставленных в очередь пакетов UDP-сокета;</span><span class="sxs-lookup"><span data-stu-id="0a867-890">UDP Socket Packets Queued</span></span>
- <span data-ttu-id="0a867-891">число отброшенных пакетов, получаемых от UDP-сокета;</span><span class="sxs-lookup"><span data-stu-id="0a867-891">UDP Socket Receive Packets Dropped</span></span>
- <span data-ttu-id="0a867-892">число ошибок контрольной суммы UDP-сокета.</span><span class="sxs-lookup"><span data-stu-id="0a867-892">UDP Socket Checksum Errors</span></span>

<span data-ttu-id="0a867-893">Все эти статистические показатели и отчеты об ошибках предоставляются приложению службой ***nx_udp_info_get*** (для статистики UDP, собранной по всем UDP-сокетам) и службой ***nx_udp_socket_info_get*** (для статистики UDP, собранной для заданного UDP-сокета).</span><span class="sxs-lookup"><span data-stu-id="0a867-893">All these statistics and error reports are available to the application with the ***nx_udp_info_get*** service for UDP statistics amassed over all UDP sockets, and the ***nx_udp_socket_info_get*** service for UDP statistics on the specified UDP socket.</span></span>

### <a name="udp-socket-control-block-nx_udp_socket"></a><span data-ttu-id="0a867-894">NX_UDP_SOCKET: блок управления сокетом UDP</span><span class="sxs-lookup"><span data-stu-id="0a867-894">UDP Socket Control Block NX_UDP_SOCKET</span></span>

<span data-ttu-id="0a867-895">Характеристики каждого UDP-сокета находятся в связанном блоке управления **NX_UDP_SOCKET**.</span><span class="sxs-lookup"><span data-stu-id="0a867-895">The characteristics of each UDP socket are found in the associated **NX_UDP_SOCKET** control block.</span></span> <span data-ttu-id="0a867-896">Он содержит такие полезные сведения, как ссылка на структуру данных IP, сетевой интерфейс для путей отправки и получения, привязанный порт и очередь получения пакетов.</span><span class="sxs-lookup"><span data-stu-id="0a867-896">It contains useful information such as the link to the IP data structure, the network interface for the sending and receiving paths, the bound port, and the receive packet queue.</span></span> <span data-ttu-id="0a867-897">Эта структура определена в файле **_nx_api.h_**.</span><span class="sxs-lookup"><span data-stu-id="0a867-897">This structure is defined in the **_nx_api.h_** file.</span></span>

## <a name="transmission-control-protocol-tcp"></a><span data-ttu-id="0a867-898">Управляющий протокол передачи (TCP)</span><span class="sxs-lookup"><span data-stu-id="0a867-898">Transmission Control Protocol (TCP)</span></span>

<span data-ttu-id="0a867-899">Управляющий протокол передачи (TCP) обеспечивает надежную передачу потоковых данных между двумя элементами сети (RFC 793).</span><span class="sxs-lookup"><span data-stu-id="0a867-899">The Transmission Control Protocol (TCP) provides reliable stream data transfer between two network members (RFC 793).</span></span> <span data-ttu-id="0a867-900">Все данные, отправленные одним элементом сети, проверяются и подтверждаются получающим элементом.</span><span class="sxs-lookup"><span data-stu-id="0a867-900">All data sent from one network member are verified and acknowledged by the receiving member.</span></span> <span data-ttu-id="0a867-901">Кроме того, перед любой передачей данных эти два элемента должны установить соединение.</span><span class="sxs-lookup"><span data-stu-id="0a867-901">In addition, the two members must have established a connection prior to any data transfer.</span></span> <span data-ttu-id="0a867-902">Все это обеспечивает надежную передачу данных, однако требует значительно больших временных затрат, чем описанная ранее передача данных UDP.</span><span class="sxs-lookup"><span data-stu-id="0a867-902">All this results in reliable data transfer; however, it does require substantially more overhead than the previously described UDP data transfer.</span></span>

### <a name="tcp-header"></a><span data-ttu-id="0a867-903">Заголовок TCP</span><span class="sxs-lookup"><span data-stu-id="0a867-903">TCP Header</span></span>

<span data-ttu-id="0a867-904">При передаче заголовок TCP помещается перед данными, полученными от пользователя.</span><span class="sxs-lookup"><span data-stu-id="0a867-904">On transmission, TCP header is placed in front of the data from the user.</span></span> <span data-ttu-id="0a867-905">При получении заголовок TCP удаляется из входящего пакета, а для приложения остаются только пользовательские данные.</span><span class="sxs-lookup"><span data-stu-id="0a867-905">On reception, TCP header is removed from the incoming packet, leaving only the user data available to the application.</span></span> <span data-ttu-id="0a867-906">TCP использует протокол IP для отправки и получения пакетов, поэтому, когда пакет находится в сети, перед его заголовком TCP размещается заголовок IP.</span><span class="sxs-lookup"><span data-stu-id="0a867-906">TCP utilizes the IP protocol to send and receive packets, which means there is an IP header in front of the TCP header when the packet is on the network.</span></span> <span data-ttu-id="0a867-907">На рис. 10 показан формат заголовка TCP.</span><span class="sxs-lookup"><span data-stu-id="0a867-907">Figure 10 shows the format of the TCP header.</span></span>

![Заголовок TCP](./media/user-guide/tcp-header.png)

<span data-ttu-id="0a867-909">**РИС. 10. Заголовок TCP**</span><span class="sxs-lookup"><span data-stu-id="0a867-909">**FIGURE 10. TCP Header**</span></span>

<span data-ttu-id="0a867-910">В следующей таблице описывается формат заголовка TCP.</span><span class="sxs-lookup"><span data-stu-id="0a867-910">The following describes the TCP header format:</span></span>

| <span data-ttu-id="0a867-911">Поле заголовка</span><span class="sxs-lookup"><span data-stu-id="0a867-911">Header Field</span></span> | <span data-ttu-id="0a867-912">Назначение</span><span class="sxs-lookup"><span data-stu-id="0a867-912">Purpose</span></span> |
|---|---|
| <span data-ttu-id="0a867-913">16-разрядное поле номера исходного порта</span><span class="sxs-lookup"><span data-stu-id="0a867-913">16-bit source port number</span></span> | <span data-ttu-id="0a867-914">Это поле содержит порт, на который отправляется TCP-пакет.</span><span class="sxs-lookup"><span data-stu-id="0a867-914">This field contains the port the TCP packet is being sent out on.</span></span> <span data-ttu-id="0a867-915">Допустимый диапазон TCP-портов — от 1 до 0xFFFF.</span><span class="sxs-lookup"><span data-stu-id="0a867-915">Valid TCP ports range from 1 through 0xFFFF.</span></span> |
| <span data-ttu-id="0a867-916">16-разрядное поле номера порта назначения</span><span class="sxs-lookup"><span data-stu-id="0a867-916">16-bit destination port number</span></span> | <span data-ttu-id="0a867-917">Это поле содержит TCP-порт, на который отправляется пакет.</span><span class="sxs-lookup"><span data-stu-id="0a867-917">This field contains the TCP port the packet is being sent to.</span></span> <span data-ttu-id="0a867-918">Допустимый диапазон TCP-портов — от 1 до 0xFFFF.</span><span class="sxs-lookup"><span data-stu-id="0a867-918">Valid TCP ports range from 1 through 0xFFFF.</span></span> |
| <span data-ttu-id="0a867-919">32-разрядное поле порядкового номера</span><span class="sxs-lookup"><span data-stu-id="0a867-919">32-bit sequence number</span></span> | <span data-ttu-id="0a867-920">Это поле содержит порядковый номер для данных, отправляемых с данного конца соединения.</span><span class="sxs-lookup"><span data-stu-id="0a867-920">This field contains the sequence number for data sent from this end of the connection.</span></span> <span data-ttu-id="0a867-921">Во время начальной последовательности соединения между двумя узлами TCP устанавливается исходная последовательность.</span><span class="sxs-lookup"><span data-stu-id="0a867-921">The original sequence is established during the initial connection sequence between two TCP nodes.</span></span> <span data-ttu-id="0a867-922">С этого момента каждая передача данных приводит к увеличению порядкового номера на количество отправленных байтов.</span><span class="sxs-lookup"><span data-stu-id="0a867-922">Every data transfer from that point results in an increment of the sequence number by the amount bytes sent.</span></span> |
| <span data-ttu-id="0a867-923">32-разрядное поле номера подтверждения</span><span class="sxs-lookup"><span data-stu-id="0a867-923">32-bit acknowledgement number</span></span> | <span data-ttu-id="0a867-924">Это поле содержит порядковый номер, соответствующий последнему байту, полученному данной стороной соединения.</span><span class="sxs-lookup"><span data-stu-id="0a867-924">This field contains the sequence number corresponding to the last byte received by this side of the connection.</span></span> <span data-ttu-id="0a867-925">Используется для определения того, были ли отправленные ранее данные успешно получены на другом конце соединения.</span><span class="sxs-lookup"><span data-stu-id="0a867-925">This is used to determine whether or not data previously sent has successfully been received by the other end of the connection.</span></span> |
| <span data-ttu-id="0a867-926">4-разрядное поле длины заголовка</span><span class="sxs-lookup"><span data-stu-id="0a867-926">4-bit header length</span></span>           | <span data-ttu-id="0a867-927">Это поле содержит число 32-разрядных слов в заголовке TCP.</span><span class="sxs-lookup"><span data-stu-id="0a867-927">This field contains the number of 32-bit words in the TCP header.</span></span> <span data-ttu-id="0a867-928">Если в заголовке TCP отсутствуют параметры, значение этого поля равно 5.</span><span class="sxs-lookup"><span data-stu-id="0a867-928">If no options are present in the TCP header, this field is 5.</span></span> |
| <span data-ttu-id="0a867-929">6-разрядное поле битов кода</span><span class="sxs-lookup"><span data-stu-id="0a867-929">6-bit code bits</span></span>               | <span data-ttu-id="0a867-930">Это поле содержит шесть разных битов кода, используемых для обозначения различных управляющих сведений, связанных с соединением.</span><span class="sxs-lookup"><span data-stu-id="0a867-930">This field contains the six different code bits used to indicate various control information associated with the connection.</span></span> <span data-ttu-id="0a867-931">Управляющие биты определяются следующим образом.</span><span class="sxs-lookup"><span data-stu-id="0a867-931">The control bits are defined as follows:</span></span> |



| <span data-ttu-id="0a867-932">Имя</span><span class="sxs-lookup"><span data-stu-id="0a867-932">Name</span></span> | <span data-ttu-id="0a867-933">bit</span><span class="sxs-lookup"><span data-stu-id="0a867-933">Bit</span></span> | <span data-ttu-id="0a867-934">Значение</span><span class="sxs-lookup"><span data-stu-id="0a867-934">Meaning</span></span>                                                     |
|------|-----|-------------------------------------------------------------|
| <span data-ttu-id="0a867-935">URG</span><span class="sxs-lookup"><span data-stu-id="0a867-935">URG</span></span>  | <span data-ttu-id="0a867-936">21</span><span class="sxs-lookup"><span data-stu-id="0a867-936">21</span></span>  | <span data-ttu-id="0a867-937">Имеются срочные данные</span><span class="sxs-lookup"><span data-stu-id="0a867-937">Urgent data present</span></span>                                         |
| <span data-ttu-id="0a867-938">ACK</span><span class="sxs-lookup"><span data-stu-id="0a867-938">ACK</span></span>  | <span data-ttu-id="0a867-939">20</span><span class="sxs-lookup"><span data-stu-id="0a867-939">20</span></span>  | <span data-ttu-id="0a867-940">Допустимый номер подтверждения</span><span class="sxs-lookup"><span data-stu-id="0a867-940">Acknowledgement number is valid</span></span>                             |
| <span data-ttu-id="0a867-941">PSH</span><span class="sxs-lookup"><span data-stu-id="0a867-941">PSH</span></span>  | <span data-ttu-id="0a867-942">19</span><span class="sxs-lookup"><span data-stu-id="0a867-942">19</span></span>  | <span data-ttu-id="0a867-943">Требуется немедленная обработка этих данных</span><span class="sxs-lookup"><span data-stu-id="0a867-943">Handle this data immediately</span></span>                                |
| <span data-ttu-id="0a867-944">RST</span><span class="sxs-lookup"><span data-stu-id="0a867-944">RST</span></span>  | <span data-ttu-id="0a867-945">18</span><span class="sxs-lookup"><span data-stu-id="0a867-945">18</span></span>  | <span data-ttu-id="0a867-946">Требуется сброс соединения</span><span class="sxs-lookup"><span data-stu-id="0a867-946">Reset the connection</span></span>                                        |
| <span data-ttu-id="0a867-947">SYN</span><span class="sxs-lookup"><span data-stu-id="0a867-947">SYN</span></span>  | <span data-ttu-id="0a867-948">17</span><span class="sxs-lookup"><span data-stu-id="0a867-948">17</span></span>  | <span data-ttu-id="0a867-949">Синхронизация порядковых номеров (используется для установления соединения)</span><span class="sxs-lookup"><span data-stu-id="0a867-949">Synchronize sequence numbers (used to establish connection)</span></span> |
| <span data-ttu-id="0a867-950">FIN</span><span class="sxs-lookup"><span data-stu-id="0a867-950">FIN</span></span>  | <span data-ttu-id="0a867-951">16</span><span class="sxs-lookup"><span data-stu-id="0a867-951">16</span></span>  | <span data-ttu-id="0a867-952">Отправитель завершил передачу (используется для закрытия соединения)</span><span class="sxs-lookup"><span data-stu-id="0a867-952">Sender is finished with transmit (used to close connection)</span></span> |

<span data-ttu-id="0a867-953">**16-разрядное поле окна**</span><span class="sxs-lookup"><span data-stu-id="0a867-953">**16-bit window**</span></span>

<span data-ttu-id="0a867-954">Это поле используется для управления потоком.</span><span class="sxs-lookup"><span data-stu-id="0a867-954">This field is used for flow control.</span></span> <span data-ttu-id="0a867-955">Оно содержит количество байтов, которое сокет может получить в данный момент.</span><span class="sxs-lookup"><span data-stu-id="0a867-955">It contains the amount of bytes the socket can currently receive.</span></span> <span data-ttu-id="0a867-956">По сути, оно используется для управления потоком.</span><span class="sxs-lookup"><span data-stu-id="0a867-956">This basically is used for flow control.</span></span> <span data-ttu-id="0a867-957">Ответственность за то, чтобы отправляемые данные помещались в объявленное окно получателя, несет отправитель.</span><span class="sxs-lookup"><span data-stu-id="0a867-957">The sender is responsible for making sure the data to send will fit into the receiver’s advertised window.</span></span>

| <span data-ttu-id="0a867-958">**Поле заголовка**</span><span class="sxs-lookup"><span data-stu-id="0a867-958">**Header Field**</span></span>          | <span data-ttu-id="0a867-959">**Назначение**</span><span class="sxs-lookup"><span data-stu-id="0a867-959">**Purpose**</span></span> |
| ------------------------- | --- |
| <span data-ttu-id="0a867-960">**16-разрядное поле контрольной суммы TCP**</span><span class="sxs-lookup"><span data-stu-id="0a867-960">**16-bit TCP checksum**</span></span>   | <span data-ttu-id="0a867-961">Это поле содержит 16-разрядную контрольную сумму пакета, включая заголовок TCP, область данных пакета и псевдозаголовок IP.</span><span class="sxs-lookup"><span data-stu-id="0a867-961">This field contains the 16-bit checksum for the packet including the TCP header, the packet data area, and the pseudo IP header.</span></span>                |
| <span data-ttu-id="0a867-962">**16-разрядное поле указателя срочности**</span><span class="sxs-lookup"><span data-stu-id="0a867-962">**16-bit urgent pointer**</span></span> | <span data-ttu-id="0a867-963">Это поле содержит положительное смещение последнего байта срочных данных.</span><span class="sxs-lookup"><span data-stu-id="0a867-963">This field contains the positive offset of the last byte of the urgent data.</span></span> <span data-ttu-id="0a867-964">Оно допустимо только в случае, если в заголовке задан бит кода URG.</span><span class="sxs-lookup"><span data-stu-id="0a867-964">This field is only valid if the URG code bit is set in the header.</span></span> |

> [!IMPORTANT]
> <span data-ttu-id="0a867-965">*Все заголовки в реализации TCP/IP должны быть представлены в формате с обратным порядком байтов. В этом формате наиболее значимый байт слова размещается по наименьшему байтовому адресу.*</span><span class="sxs-lookup"><span data-stu-id="0a867-965">*All headers in the TCP/IP implementation are expected to be in big endian format. In this format, the most significant byte of the word resides at the lowest byte address.*</span></span>

### <a name="tcp-enable"></a><span data-ttu-id="0a867-966">Включение TCP</span><span class="sxs-lookup"><span data-stu-id="0a867-966">TCP Enable</span></span>

<span data-ttu-id="0a867-967">Перед установкой TCP-соединения и передачей TCP-пакетов приложение должно сначала включить протокол TCP, вызвав службу nx_tcp_enable service.</span><span class="sxs-lookup"><span data-stu-id="0a867-967">Before TCP connections and packet transmissions are possible, the application must first enable TCP by calling the nx_tcp_enable service.</span></span> <span data-ttu-id="0a867-968">После включения приложение может получить доступ ко всем службам TCP.</span><span class="sxs-lookup"><span data-stu-id="0a867-968">After enabled, the application is free to access all TCP services.</span></span>

### <a name="tcp-socket-create"></a><span data-ttu-id="0a867-969">Создание сокета TCP</span><span class="sxs-lookup"><span data-stu-id="0a867-969">TCP Socket Create</span></span>

<span data-ttu-id="0a867-970">Сокеты TCP создаются во время инициализации или выполнения потоками приложения.</span><span class="sxs-lookup"><span data-stu-id="0a867-970">TCP sockets are created either during initialization or during runtime by application threads.</span></span> <span data-ttu-id="0a867-971">Начальный тип службы, срок жизни и размер окна определяются службой ***nx_tcp_socket_create***.</span><span class="sxs-lookup"><span data-stu-id="0a867-971">The initial type of service, time to live, and window size are defined by the ***nx_tcp_socket_create*** service.</span></span> <span data-ttu-id="0a867-972">Число сокетов TCP в приложении не ограничено.</span><span class="sxs-lookup"><span data-stu-id="0a867-972">There are no limits on the number of TCP sockets in an application.</span></span>

### <a name="tcp-checksum"></a><span data-ttu-id="0a867-973">Контрольная сумма TCP</span><span class="sxs-lookup"><span data-stu-id="0a867-973">TCP Checksum</span></span>

<span data-ttu-id="0a867-974">Протокол TCP указывает свою дополняющую 16-разрядную контрольную сумму, охватывающую псевдозаголовок IP (состоящий из исходного IP-адреса, IP-адреса назначения и IP-слова, указывающего протокол и длину), заголовок TCP и данные пакета TCP.</span><span class="sxs-lookup"><span data-stu-id="0a867-974">TCP specifies a one’s complement 16-bit checksum that covers the IP pseudo header, (consisting of the source IP address, destination IP address, and the protocol/length IP word), the TCP header, and the TCP packet data.</span></span>

<span data-ttu-id="0a867-975">Некоторые сетевые контроллеры могут выполнять вычисление и проверку контрольной суммы TCP в оборудовании.</span><span class="sxs-lookup"><span data-stu-id="0a867-975">Certain network controllers are able to perform TCP checksum computation and validation in hardware.</span></span> <span data-ttu-id="0a867-976">В таких системах приложения могут в максимальной мере использовать аппаратную логику вычисления контрольной суммы, чтобы сократить количество служебных данных во время выполнения.</span><span class="sxs-lookup"><span data-stu-id="0a867-976">For such systems, applications may want to use hardware checksum logic as much as possible to reduce runtime overhead.</span></span> <span data-ttu-id="0a867-977">Приложения могут полностью отключить логику вычисления контрольной суммы TCP в библиотеке NetX во время сборки, определив **NX_DISABLE_TCP_TX_CHECKSUM** и **NX_DISABLE_TCP_RX_CHECKSUM**.</span><span class="sxs-lookup"><span data-stu-id="0a867-977">Applications may disable TCP checksum computation logic from the NetX library altogether at build time by defining **NX_DISABLE_TCP_TX_CHECKSUM** and **NX_DISABLE_TCP_RX_CHECKSUM**.</span></span> <span data-ttu-id="0a867-978">В этом случае код для вычисления контрольной суммы TCP не компилируется.</span><span class="sxs-lookup"><span data-stu-id="0a867-978">This way, the TCP checksum code is not compiled in.</span></span>

### <a name="tcp-port"></a><span data-ttu-id="0a867-979">TCP-порт</span><span class="sxs-lookup"><span data-stu-id="0a867-979">TCP Port</span></span>

<span data-ttu-id="0a867-980">TCP-порт — это логическая точка подключения в протоколе TCP.</span><span class="sxs-lookup"><span data-stu-id="0a867-980">A TCP port is a logical connection point in the TCP protocol.</span></span> <span data-ttu-id="0a867-981">В компоненте TCP системы NetX имеется 65 535 допустимых портов в диапазоне от 1 до 0xFFFF.</span><span class="sxs-lookup"><span data-stu-id="0a867-981">There are 65,535 valid ports in the TCP component of NetX, ranging from 1 through 0xFFFF.</span></span> <span data-ttu-id="0a867-982">В отличие от протокола UDP, в котором данные с одного порта могут отправляться на любой другой порт назначения, один TCP-порт подключается к другому конкретному TCP-порту, а передача данных может осуществляться, только если это подключение установлено. При этом передача возможна только между двумя портами, между которыми установлено соединение.</span><span class="sxs-lookup"><span data-stu-id="0a867-982">Unlike UDP in which data from one port can be sent to any other destination port, a TCP port is connected to another specific TCP port, and only when this connection is established can any data transfer take place—and only between the two ports making up the connection.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="0a867-983">*TCP-порты полностью отделены от UDP-портов. Например, UDP-порт с номером 1 не связан с TCP-портом с номером 1.*</span><span class="sxs-lookup"><span data-stu-id="0a867-983">*TCP ports are completely separate from UDP ports; e.g., UDP port number 1 has no relation to TCP port number 1.*</span></span>

## <a name="client-server-model"></a><span data-ttu-id="0a867-984">Модель "клиент — сервер"</span><span class="sxs-lookup"><span data-stu-id="0a867-984">Client-Server Model</span></span>

<span data-ttu-id="0a867-985">Чтобы использовать протокол TCP для передачи данных, необходимо сначала установить соединение между двумя сокетами TCP.</span><span class="sxs-lookup"><span data-stu-id="0a867-985">To use TCP for data transfer, a connection must first be established between the two TCP sockets.</span></span> <span data-ttu-id="0a867-986">Установка соединения выполняется на стороне клиента и на стороне сервера.</span><span class="sxs-lookup"><span data-stu-id="0a867-986">The establishment of the connection is done in a client-server fashion.</span></span> <span data-ttu-id="0a867-987">Клиентская часть соединения — это сторона, которая инициирует соединение, а серверная часть просто ожидает запросы на подключение от клиента до завершения обработки.</span><span class="sxs-lookup"><span data-stu-id="0a867-987">The client side of the connection is the side that initiates the connection, while the server side simply waits for client connection requests before any processing is done.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="0a867-988">*Для устройств с поддержкой множественной адресации NetX автоматически определяет используемый для подключения исходный адрес и адрес следующего прыжка на основе IP-адреса назначения соединения.*</span><span class="sxs-lookup"><span data-stu-id="0a867-988">*For multihome devices, NetX automatically determines the source address to use for the connection, and the next hop address based on the destination IP address of the connection.*</span></span>

### <a name="tcp-socket-state-machine"></a><span data-ttu-id="0a867-989">Конечный автомат сокета TCP</span><span class="sxs-lookup"><span data-stu-id="0a867-989">TCP Socket State Machine</span></span>

<span data-ttu-id="0a867-990">Соединение между двумя сокетами TCP (один клиент и один сервер) реализовать сложно. Для управления такими соединениями используется конечный автомат.</span><span class="sxs-lookup"><span data-stu-id="0a867-990">The connection between two TCP sockets (one client and one server) is complex and is managed in a state machine manner.</span></span> <span data-ttu-id="0a867-991">Каждый сокет TCP запускается в состоянии CLOSED (ЗАКРЫТ).</span><span class="sxs-lookup"><span data-stu-id="0a867-991">Each TCP socket starts in a CLOSED state.</span></span> <span data-ttu-id="0a867-992">Через события подключения конечный автомат каждого сокета переводит его в состояние ESTABLISHED (УСТАНОВЛЕН), в котором выполняется основная часть передачи данных в TCP.</span><span class="sxs-lookup"><span data-stu-id="0a867-992">Through connection events each socket's state machine migrates into the ESTABLISHED state, which is where the bulk of the data transfer in TCP takes place.</span></span> <span data-ttu-id="0a867-993">Когда одной стороне соединения больше не требуется отправлять данные, она отключается.</span><span class="sxs-lookup"><span data-stu-id="0a867-993">When one side of the connection no longer wishes to send data, it disconnects.</span></span> <span data-ttu-id="0a867-994">После отключения другой стороны сокет TCP фактически возвращается в состояние CLOSED (ЗАКРЫТ).</span><span class="sxs-lookup"><span data-stu-id="0a867-994">After the other side disconnects, eventually the TCP socket returns to the CLOSED state.</span></span> <span data-ttu-id="0a867-995">Этот процесс повторяется всякий раз, когда клиент и сервер TCP устанавливают и закрывают соединение.</span><span class="sxs-lookup"><span data-stu-id="0a867-995">This process repeats each time a TCP client and server establish and close a connection.</span></span> <span data-ttu-id="0a867-996">На рис. 11 показаны различные состояния конечного автомата TCP.</span><span class="sxs-lookup"><span data-stu-id="0a867-996">Figure 11 shows the various states of the TCP state machine.</span></span>

![Состояния конечного автомата TCP](./media/user-guide/states-tcp-state-machine.png)

### <a name="figure-11-states-of-the-tcp-state-machine"></a><span data-ttu-id="0a867-998">РИС. 11.</span><span class="sxs-lookup"><span data-stu-id="0a867-998">FIGURE 11.</span></span> <span data-ttu-id="0a867-999">Состояния конечного автомата TCP</span><span class="sxs-lookup"><span data-stu-id="0a867-999">States of the TCP State Machine</span></span>

### <a name="tcp-client-connection"></a><span data-ttu-id="0a867-1000">Подключение клиента TCP</span><span class="sxs-lookup"><span data-stu-id="0a867-1000">TCP Client Connection</span></span>

<span data-ttu-id="0a867-1001">Как упоминалось ранее, клиентская сторона TCP-соединения инициирует запрос на подключение к серверу TCP.</span><span class="sxs-lookup"><span data-stu-id="0a867-1001">As mentioned previously, the client side of the TCP connection initiates a connection request to a TCP server.</span></span> <span data-ttu-id="0a867-1002">Перед запросом на подключение необходимо включить протокол TCP на клиентском IP-экземпляре.</span><span class="sxs-lookup"><span data-stu-id="0a867-1002">Before a connection request can be made, TCP must be enabled on the client IP instance.</span></span> <span data-ttu-id="0a867-1003">Кроме того, необходимо создать клиентский сокет TCP с помощью службы ***nx_tcp_socket_create** _ и привязать его к порту посредством службы _*_nx_tcp_client_socket_bind_\*_.</span><span class="sxs-lookup"><span data-stu-id="0a867-1003">In addition, the client TCP socket must next be created with the ***nx_tcp_socket_create** _ service and bound to a port via the _*_nx_tcp_client_socket_bind_\*_ service.</span></span> <span data-ttu-id="0a867-1004">После привязки клиентского сокета для установления соединения с TCP-сервером используется служба _ \*_nx_tcp_client_socket_connect_\*\*.</span><span class="sxs-lookup"><span data-stu-id="0a867-1004">After the client socket is bound, the _ *_nx_tcp_client_socket_connect_*\* service is used to establish a connection with a TCP server.</span></span> <span data-ttu-id="0a867-1005">Обратите внимание, что сокет должен находиться в состоянии CLOSED (ЗАКРЫТ) для инициации попытки подключения.</span><span class="sxs-lookup"><span data-stu-id="0a867-1005">Note the socket must be in a CLOSED state to initiate a connection attempt.</span></span> <span data-ttu-id="0a867-1006">Установка подключения начинается с выдачи пакета SYN системой NetX и последующего ожидания передачи пакета SYN ACK с сервера, которая означает принятие запроса на подключение.</span><span class="sxs-lookup"><span data-stu-id="0a867-1006">Establishing the connection starts with NetX issuing a SYN packet and then waiting for a SYN ACK packet back from the server, which signifies acceptance of the connection request.</span></span> <span data-ttu-id="0a867-1007">После получения пакета SYN ACK система NetX реагирует на пакет ACK и переводит сокет клиента в состояние ESTABLISHED (УСТАНОВЛЕН).</span><span class="sxs-lookup"><span data-stu-id="0a867-1007">After the SYN ACK is received, NetX responds with an ACK packet and promotes the client socket to the ESTABLISHED state.</span></span>

### <a name="tcp-client-disconnection"></a><span data-ttu-id="0a867-1008">Отключение клиента TCP</span><span class="sxs-lookup"><span data-stu-id="0a867-1008">TCP Client Disconnection</span></span>

<span data-ttu-id="0a867-1009">Закрытие соединения выполняется путем вызова ***nx_tcp_socket_disconnect***.</span><span class="sxs-lookup"><span data-stu-id="0a867-1009">Closing the connection is accomplished by calling ***nx_tcp_socket_disconnect***.</span></span> <span data-ttu-id="0a867-1010">Если не задана приостановка, сокет клиента отправляет пакет RST на сокет сервера и переводит сокет в состояние CLOSED (ЗАКРЫТ).</span><span class="sxs-lookup"><span data-stu-id="0a867-1010">If no suspension is specified, the client socket sends a RST packet to the server socket and places the socket in the CLOSED state.</span></span> <span data-ttu-id="0a867-1011">В противном случае при запросе приостановки выполняется полный протокол отключения TCP, как показано ниже.</span><span class="sxs-lookup"><span data-stu-id="0a867-1011">Otherwise, if a suspension is requested, the full TCP disconnect protocol is performed, as follows:</span></span>

- <span data-ttu-id="0a867-1012">Если сервер ранее инициировал запрос на отключение (сокет клиента уже получил пакет FIN, ответил пакетом ACK и находится в состоянии CLOSE WAIT (ОЖИДАНИЕ ЗАКРЫТИЯ)), NetX переводит сокет TCP клиента в состояние LAST ACK (ПОСЛЕДНЕЕ ПОДТВЕРЖДЕНИЕ) и отправляет пакет FIN.</span><span class="sxs-lookup"><span data-stu-id="0a867-1012">If the server previously initiated a disconnect request (the client socket has already received a FIN packet, responded with an ACK, and is in the CLOSE WAIT state), NetX promotes the client TCP socket state to the LAST ACK state and sends a FIN packet.</span></span> <span data-ttu-id="0a867-1013">Затем он ожидает подтверждения от сервера перед завершением отключения и переходом в состояние CLOSED (ЗАКРЫТ).</span><span class="sxs-lookup"><span data-stu-id="0a867-1013">It then waits for an ACK from the server before completing the disconnect and entering the CLOSED state.</span></span>

- <span data-ttu-id="0a867-1014">Если, с другой стороны, клиент первым инициирует запрос на отключение (сервер не был отключен, а сокет по-прежнему находится в состоянии ESTABLISHED (УСТАНОВЛЕН)), NetX отправляет пакет FIN для инициации отключения и ожидает получения пакетов FIN и ACK от сервера, прежде завершить отключение и перевести сокет в состояние CLOSED (ЗАКРЫТ).</span><span class="sxs-lookup"><span data-stu-id="0a867-1014">If on the other hand, the client is the first to initiate a disconnect request (the server has not disconnected and the socket is still in the ESTABLISHED state), NetX sends a FIN packet to initiate the disconnect and waits to receive a FIN and an ACK from the server before completing the disconnect and placing the socket in a CLOSED state.</span></span>

<span data-ttu-id="0a867-1015">Если в очереди передачи сокета остались пакеты, NetX приостанавливается на указанное время ожидания, чтобы обеспечить подтверждение этих пакетов.</span><span class="sxs-lookup"><span data-stu-id="0a867-1015">If there are still packets on the socket transmit queue, NetX suspends for the specified timeout to allow the packets to be acknowledged.</span></span> <span data-ttu-id="0a867-1016">По истечении времени ожидания NetX очищает очередь передачи сокета клиента.</span><span class="sxs-lookup"><span data-stu-id="0a867-1016">If the timeout expires, NetX empties the transmit queue of the client socket.</span></span>

<span data-ttu-id="0a867-1017">Чтобы отменить привязку порта к сокету клиента, приложение вызывает ***nx_tcp_client_socket_unbind***.</span><span class="sxs-lookup"><span data-stu-id="0a867-1017">To unbind the port from the client socket, the application calls ***nx_tcp_client_socket_unbind***.</span></span> <span data-ttu-id="0a867-1018">Сокет должен находиться в состоянии CLOSED (ЗАКРЫТ) или в процессе отсоединения (т. е. в состоянии TIMED WAIT (ОЖИДАНИЕ С ПРИВЯЗКОЙ КО ВРЕМЕНИ)) до освобождения порта. В противном случае возвращается ошибка.</span><span class="sxs-lookup"><span data-stu-id="0a867-1018">The socket must be in a CLOSED state or in the process of disconnecting (i.e., TIMED WAIT state) before the port is released; otherwise, an error is returned.</span></span>

<span data-ttu-id="0a867-1019">Наконец, если сокет клиента приложению больше не требуется, вызывается ***nx_tcp_socket_delete*** для удаления сокета.</span><span class="sxs-lookup"><span data-stu-id="0a867-1019">Finally, if the application no longer needs the client socket, it calls ***nx_tcp_socket_delete*** to delete the socket.</span></span>

### <a name="tcp-server-connection"></a><span data-ttu-id="0a867-1020">Подключение к серверу TCP</span><span class="sxs-lookup"><span data-stu-id="0a867-1020">TCP Server Connection</span></span>

<span data-ttu-id="0a867-1021">Серверная сторона TCP-соединения является пассивной; т. е. сервер ожидает инициирования клиентом запроса на подключение.</span><span class="sxs-lookup"><span data-stu-id="0a867-1021">The server side of a TCP connection is passive; i.e., the server waits for a client to initiate connection request.</span></span> <span data-ttu-id="0a867-1022">Чтобы принять клиентское подключение, необходимо сначала включить TCP в экземпляре IP, вызвав службу \***nx_tcp_enable** _.</span><span class="sxs-lookup"><span data-stu-id="0a867-1022">To accept a client connection, TCP must first be enabled on the IP instance by calling the service \***nx_tcp_enable** _.</span></span> <span data-ttu-id="0a867-1023">Затем приложение должно создать сокет TCP с помощью службы _ \*_nx_tcp_socket_create_\*\*.</span><span class="sxs-lookup"><span data-stu-id="0a867-1023">Next, the application must create a TCP socket using the _ *_nx_tcp_socket_create_*\* service.</span></span>

<span data-ttu-id="0a867-1024">Сокет сервера также должен быть настроен для ожидания передачи данных запросов на подключение.</span><span class="sxs-lookup"><span data-stu-id="0a867-1024">The server socket must also be set up for listening for connection requests.</span></span> <span data-ttu-id="0a867-1025">Для этого используется служба ***nx_tcp_server_socket_listen***.</span><span class="sxs-lookup"><span data-stu-id="0a867-1025">This is achieved by using the ***nx_tcp_server_socket_listen*** service.</span></span> <span data-ttu-id="0a867-1026">Эта служба переводит сокет сервера в состояние LISTEN (ОЖИДАНИЕ ПЕРЕДАЧИ ДАННЫХ) и привязывает указанный порт сервера к сокету.</span><span class="sxs-lookup"><span data-stu-id="0a867-1026">This service places the server socket in the LISTEN state and binds the specified server port to the socket.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="0a867-1027">*Чтобы задать подпрограмму обратного вызова для ожидания передачи данных сокета, приложение указывает соответствующую функцию обратного вызова для аргумента tcp_listen_callback службы **nx_tcp_server_socket_listen**. Затем эта функция обратного вызова приложения выполняется системой NetX всякий раз, когда на этом порте сервера запрашивается новое подключение. Обработкой при обратном вызове управляет приложение.*</span><span class="sxs-lookup"><span data-stu-id="0a867-1027">*To set a socket listen callback routine the application specifies the appropriate callback function for the tcp_listen_callback argument of the **nx_tcp_server_socket_listen** service. This application callback function is then executed by NetX whenever a new connection is requested on this server port. The processing in the callback is under application control.*</span></span>

<span data-ttu-id="0a867-1028">Чтобы принимать клиентские запросы на подключение, приложение вызывает службу \***nx_tcp_server_socket_accept** _.</span><span class="sxs-lookup"><span data-stu-id="0a867-1028">To accept client connection requests, the application calls the \***nx_tcp_server_socket_accept** _ service.</span></span> <span data-ttu-id="0a867-1029">Для вызова службы принятия сокет сервера должен находиться в состоянии LISTEN (ОЖИДАНИЕ ПЕРЕДАЧИ ДАННЫХ) или состоянии SYN RECEIVED (ПОЛУЧЕН ЗАПРОС СИНХРОНИЗАЦИИ) (т. е. сервер находится в состоянии LISTEN (ОЖИДАНИЕ ПЕРЕДАЧИ ДАННЫХ) и получил пакет SYN от клиента, запросившего соединение).</span><span class="sxs-lookup"><span data-stu-id="0a867-1029">The server socket must either be in a LISTEN state or a SYN RECEIVED state (i.e., the server is in the LISTEN state and has received a SYN packet from a client requesting a connection) to call the accept service.</span></span> <span data-ttu-id="0a867-1030">Состояние успешного возврата из _ *_nx_tcp_server_socket_accept_*\* указывает, что подключение установлено, а сокет сервера находится в состоянии ESTABLISHED (УСТАНОВЛЕН).</span><span class="sxs-lookup"><span data-stu-id="0a867-1030">A successful return status from _ *_nx_tcp_server_socket_accept_*\* indicates the connection has been set up and the server socket is in the ESTABLISHED state.</span></span>

<span data-ttu-id="0a867-1031">Когда сокет сервера будет иметь допустимое подключение, дополнительные запросы на подключение клиентов будут помещаться в очередь, пока она не будет полностью занята. Длина очереди определяется параметром *listen_queue_size*, передаваемым в службу \***nx_tcp_server_socket_listen** _.</span><span class="sxs-lookup"><span data-stu-id="0a867-1031">After the server socket has a valid connection, additional client connection requests are queued up to the depth specified by the *listen_queue_size*, passed into the \***nx_tcp_server_socket_listen** _ service.</span></span> <span data-ttu-id="0a867-1032">Для обработки последующих соединений на порте сервера приложение должно вызвать _ *_nx_tcp_server_socket_relisten_*\* с доступным сокетом (т е. сокетом в состоянии CLOSED (ЗАКРЫТ)).</span><span class="sxs-lookup"><span data-stu-id="0a867-1032">In order to process subsequent connections on a server port, the application must call _ *_nx_tcp_server_socket_relisten_*\* with an available socket (i.e., a socket in a CLOSED state).</span></span> <span data-ttu-id="0a867-1033">Обратите внимание, что при этом может использоваться тот же сокет сервера, если связанное с ним предыдущее соединение завершено, а сокет находится в состоянии CLOSED (ЗАКРЫТ).</span><span class="sxs-lookup"><span data-stu-id="0a867-1033">Note that the same server socket could be used if the previous connection associated with the socket is now finished and the socket is in the CLOSED state.</span></span>

### <a name="tcp-server-disconnection"></a><span data-ttu-id="0a867-1034">Отключение сервера TCP</span><span class="sxs-lookup"><span data-stu-id="0a867-1034">TCP Server Disconnection</span></span>

<span data-ttu-id="0a867-1035">Закрытие соединения выполняется путем вызова ***nx_tcp_socket_disconnect***.</span><span class="sxs-lookup"><span data-stu-id="0a867-1035">Closing the connection is accomplished by calling ***nx_tcp_socket_disconnect***.</span></span> <span data-ttu-id="0a867-1036">Если не задана приостановка, сокет сервера отправляет пакет RST на сокет клиента и переводит сокет в состояние CLOSED (ЗАКРЫТ).</span><span class="sxs-lookup"><span data-stu-id="0a867-1036">If no suspension is specified, the server socket sends a RST packet to the client socket and places the socket in the CLOSED state.</span></span> <span data-ttu-id="0a867-1037">В противном случае при запросе приостановки выполняется полный протокол отключения TCP, как показано ниже. |</span><span class="sxs-lookup"><span data-stu-id="0a867-1037">Otherwise, if a suspension is requested, the full TCP disconnect protocol is performed, as follows: |</span></span>

- <span data-ttu-id="0a867-1038">Если клиент ранее инициировал запрос на отключение (сокет сервера уже получил пакет FIN, ответил пакетом ACK и находится в состоянии CLOSE WAIT (ОЖИДАНИЕ ЗАКРЫТИЯ)), NetX переводит сокет TCP в состояние LAST ACK (ПОСЛЕДНЕЕ ПОДТВЕРЖДЕНИЕ) и отправляет пакет FIN.</span><span class="sxs-lookup"><span data-stu-id="0a867-1038">If the client previously initiated a disconnect request (the server socket has already received a FIN packet, responded with an ACK, and is in the CLOSE WAIT state), NetX promotes the TCP socket state to the LAST ACK state and sends a FIN packet.</span></span> <span data-ttu-id="0a867-1039">Затем он ожидает подтверждения от сервера перед завершением отключения и входом в состояние CLOSED (ЗАКРЫТ).</span><span class="sxs-lookup"><span data-stu-id="0a867-1039">It then waits for an ACK from the client before completing the disconnect and entering the CLOSED state.</span></span>

- <span data-ttu-id="0a867-1040">Если, с другой стороны, сервер первым инициирует запрос на отключение (клиент не был отключен, а сокет по-прежнему находится в состоянии ESTABLISHED (УСТАНОВЛЕН)), NetX отправляет пакет FIN для инициации отключения и ожидает получения пакетов FIN и ACK от клиента, прежде чем завершить отключение и поместить сокет в состояние CLOSED (ЗАКРЫТ).</span><span class="sxs-lookup"><span data-stu-id="0a867-1040">If on the other hand, the server is the first to initiate a disconnect request (the client has not disconnected and the socket is still in the ESTABLISHED state), NetX sends a FIN packet to initiate the disconnect and waits to receive a FIN and an ACK from the client before completing the disconnect and placing the socket in a CLOSED state.</span></span>

<span data-ttu-id="0a867-1041">Если в очереди передачи сокета остались пакеты, NetX приостанавливается на указанное время ожидания, чтобы обеспечить подтверждение этих пакетов.</span><span class="sxs-lookup"><span data-stu-id="0a867-1041">If there are still packets on the socket transmit queue, NetX suspends for the specified timeout to allow those packets to be acknowledged.</span></span> <span data-ttu-id="0a867-1042">По истечении времени ожидания NetX освобождает очередь передачи сокета сервера.</span><span class="sxs-lookup"><span data-stu-id="0a867-1042">If the timeout expires, NetX flushes the transmit queue of the server socket.</span></span>

<span data-ttu-id="0a867-1043">После завершения обработки отключения и перехода сокета сервера в состояние CLOSED (ЗАКРЫТ) приложение должно вызвать службу ***nx_tcp_server_socket_unaccept***, чтобы завершить сопоставление этого сокета с портом сервера.</span><span class="sxs-lookup"><span data-stu-id="0a867-1043">After the disconnect processing is complete and the server socket is in the CLOSED state, the application must call the ***nx_tcp_server_socket_unaccept*** service to end the association of this socket with the server port.</span></span> <span data-ttu-id="0a867-1044">Примечание. Эта служба должна вызываться приложением, даже если ***nx_tcp_socket_disconnect*** или \***nx_tcp_server_socket_accept** _ возвращает состояние ошибки.</span><span class="sxs-lookup"><span data-stu-id="0a867-1044">Note this service must be called by the application even if ***nx_tcp_socket_disconnect*** or \***nx_tcp_server_socket_accept** _ return an error status.</span></span> <span data-ttu-id="0a867-1045">После возврата _ *_nx_tcp_server_socket_unaccept_*\* сокет можно использовать в качестве сокета клиента или сервера или даже удалить, если он больше не требуется.</span><span class="sxs-lookup"><span data-stu-id="0a867-1045">After the _ *_nx_tcp_server_socket_unaccept_*\* returns, the socket can be used as a client or server socket, or even deleted if it is no longer needed.</span></span> <span data-ttu-id="0a867-1046">Если требуется принять другое клиентское соединение на том же порте сервера, для этого сокета должна быть вызвана служба ***nx_tcp_server_socket_relisten***.</span><span class="sxs-lookup"><span data-stu-id="0a867-1046">If accepting another client connection on the same server port is desired, the ***nx_tcp_server_socket_relisten*** service should be called on this socket.</span></span>

<span data-ttu-id="0a867-1047">В следующем сегменте кода показана последовательность вызовов типичного сервера TCP.</span><span class="sxs-lookup"><span data-stu-id="0a867-1047">The following code segment illustrates the sequence of calls a typical TCP server uses:</span></span>

```c
/* Set up a previously created TCP socket to listen on port 12 */

nx_tcp_server_socket_listen()

/* Loop to make a (another) connection. */
while(1) {

    /* Wait for a client socket connection request for 100 ticks. */
    nx_tcp_server_socket_accept();

    /* (Send and receive TCP messages with the TCP client) */

    /* Disconnect the server socket. */
    nx_tcp_socket_disconnect();

    /* Remove this server socket from listening on the port. */

    nx_tcp_server_socket_unaccept(&server_socket);

    /* Set up server socket to relisten on the same port for the next
    client. */
    nx_tcp_server_socket_relisten();
}
```

### <a name="mss-validation"></a><span data-ttu-id="0a867-1048">Проверка MSS</span><span class="sxs-lookup"><span data-stu-id="0a867-1048">MSS Validation</span></span>

<span data-ttu-id="0a867-1049">Максимальный размер сегмента (MSS) — это максимальное количество байтов, которые может получить узел TCP без фрагментации с помощью базового уровня IP.</span><span class="sxs-lookup"><span data-stu-id="0a867-1049">The Maximum Segment Size (MSS) is the maximum amount of bytes a TCP host can receive without being fragmented by the underlying IP layer.</span></span> <span data-ttu-id="0a867-1050">На этапе установки TCP-соединения оба его конца обмениваются своим значением MSS для TCP, чтобы отправитель не отправлял сегмент данных TCP, превышающий размер MSS получателя.</span><span class="sxs-lookup"><span data-stu-id="0a867-1050">During TCP connection establishment phase, both ends exchanges its own TCP MSS value, so that the sender does not send a TCP data segment that is larger than the receiver's MSS.</span></span> <span data-ttu-id="0a867-1051">При необходимости перед установкой соединения модуль TCP NetX проверяет значение MSS, объявленное для однорангового узла.</span><span class="sxs-lookup"><span data-stu-id="0a867-1051">NetX TCP module will optionally validate its peer's advertised MSS value before establishing a connection.</span></span> <span data-ttu-id="0a867-1052">По умолчанию NetX не разрешает такую проверку.</span><span class="sxs-lookup"><span data-stu-id="0a867-1052">By default NetX does not enable such a check.</span></span> <span data-ttu-id="0a867-1053">Приложения, которым необходимо выполнить проверку MSS, должны определить ***NX_ENABLE_TCP_MSS_CHECKING** _ при создании библиотеки NetX, а минимальное значение должно быть определено в _*_NX_TCP_MSS_MINIMUM_\*_.</span><span class="sxs-lookup"><span data-stu-id="0a867-1053">Applications wishing to perform MSS validation shall define ***NX_ENABLE_TCP_MSS_CHECKING** _ when building the NetX library, and the minimum value shall be defined in _*_NX_TCP_MSS_MINIMUM_\*_.</span></span> <span data-ttu-id="0a867-1054">Входящие TCP-соединения со значениями MSS ниже _ *_NX_TCP_MSS_MINIMUM_*\* отбрасываются.</span><span class="sxs-lookup"><span data-stu-id="0a867-1054">Incoming TCP connections with MSS values below _ *_NX_TCP_MSS_MINIMUM_*\* are dropped.</span></span>

### <a name="stop-listening-on-a-server-port"></a><span data-ttu-id="0a867-1055">Прекращение прослушивания порта сервера</span><span class="sxs-lookup"><span data-stu-id="0a867-1055">Stop Listening on a Server Port</span></span>

<span data-ttu-id="0a867-1056">Если приложению больше не требуется ожидать передачи данных для запросов клиентского соединения на порте сервера, который был ранее указан при вызове службы \***nx_tcp_server_socket_listen** _, приложение просто вызывает службу _ \*_nx_tcp_server_socket_unlisten_\*\*.</span><span class="sxs-lookup"><span data-stu-id="0a867-1056">If the application no longer wishes to listen for client connection requests on a server port that was previously specified by a call to the ***nx_tcp_server_socket_listen** _ service, the application simply calls the _ *_nx_tcp_server_socket_unlisten_** service.</span></span> <span data-ttu-id="0a867-1057">Эта служба переводит любой сокет, ожидающий подключения, в состояние CLOSED (ЗАКРЫТ) и освобождает все пакеты запросов на подключение клиентов, помещенные в очередь.</span><span class="sxs-lookup"><span data-stu-id="0a867-1057">This service places any socket waiting for a connection back in the CLOSED state and releases any queued client connection request packets.</span></span>

### <a name="tcp-window-size"></a><span data-ttu-id="0a867-1058">Размер окна TCP</span><span class="sxs-lookup"><span data-stu-id="0a867-1058">TCP Window Size</span></span>

<span data-ttu-id="0a867-1059">Во время этапов настройки соединения и передачи данных каждый порт сообщает объем данных, которые он может обработать. Этот объем называется размером окна.</span><span class="sxs-lookup"><span data-stu-id="0a867-1059">During both the setup and data transfer phases of the connection, each port reports the amount of data it can handle, which is called its window size.</span></span> <span data-ttu-id="0a867-1060">При получении и обработке данных размер этого окна корректируется динамически.</span><span class="sxs-lookup"><span data-stu-id="0a867-1060">As data are received and processed, this window size is adjusted dynamically.</span></span> <span data-ttu-id="0a867-1061">В протоколе TCP отправитель может передавать только объем данных, помещающихся в окно получателя.</span><span class="sxs-lookup"><span data-stu-id="0a867-1061">In TCP, a sender can only send an amount of data that fits into the receiver's window.</span></span> <span data-ttu-id="0a867-1062">По сути, размер окна обеспечивает управление потоком для передачи данных в каждом направлении соединения.</span><span class="sxs-lookup"><span data-stu-id="0a867-1062">In essence, the window size provides flow control for data transfer in each direction of the connection.</span></span>

### <a name="tcp-packet-send"></a><span data-ttu-id="0a867-1063">Отправка пакетов TCP</span><span class="sxs-lookup"><span data-stu-id="0a867-1063">TCP Packet Send</span></span>

<span data-ttu-id="0a867-1064">Отправку данных TCP можно легко выполнить, вызвав функцию ***nx_tcp_socket_send***.</span><span class="sxs-lookup"><span data-stu-id="0a867-1064">Sending TCP data is easily accomplished by calling the ***nx_tcp_socket_send*** function.</span></span> <span data-ttu-id="0a867-1065">Если размер передаваемых данных превышает значение MSS для сокета или текущий размер окна приема однорангового узла (в зависимости от того, какое из этих значений меньше), внутренняя логика TCP отсекает при передаче данные, выходящие за пределы этого меньшего значения (MSS или окна однорангового узла).</span><span class="sxs-lookup"><span data-stu-id="0a867-1065">If the size of the data being transmitted is larger than the MSS value of the socket or the current peer receive window size, whichever is smaller, TCP internal logic carves off the data that fits into min (MSS, peer receive Window) for transmission.</span></span> <span data-ttu-id="0a867-1066">Затем эта служба создает заголовок TCP перед пакетом (в том числе вычисляет контрольную сумму).</span><span class="sxs-lookup"><span data-stu-id="0a867-1066">This service then builds a TCP header in front of the packet (including the checksum calculation).</span></span> <span data-ttu-id="0a867-1067">Если размер окна получателя не равен нулю, вызывающий объект будет передавать столько данных, сколько помещается в окно получателя.</span><span class="sxs-lookup"><span data-stu-id="0a867-1067">If the receiver's window size is not zero, the caller will send as much data as it can to fill up the receiver window size.</span></span> <span data-ttu-id="0a867-1068">Если размер окна получения равен нулю, вызывающий объект может приостановить передачу и дождаться, пока размер окна получателя станет достаточно большим для отправки этого пакета.</span><span class="sxs-lookup"><span data-stu-id="0a867-1068">If the receive window becomes zero, the caller may suspend and wait for the receiver's window size to increase enough for this packet to be sent.</span></span> <span data-ttu-id="0a867-1069">Если в какой-то момент времени несколько потоков попытаются отправить данные через один и тот же сокет, они могут быть приостановлены.</span><span class="sxs-lookup"><span data-stu-id="0a867-1069">At any given time, multiple threads may suspend while trying to send data through the same socket.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="0a867-1070">*Данные TCP, находящиеся в структуре NX_PACKET, должны располагаться на границе длинных слов. Кроме того, необходимо иметь достаточно места между открывающим указателем и указателем начала данных, чтобы система NetX могла разместить заголовки TCP, IP и физических носителей.*</span><span class="sxs-lookup"><span data-stu-id="0a867-1070">*The TCP data residing in the NX_PACKET structure should reside on a long-word boundary. In addition, there needs to be sufficient space between the prepend pointer and the data start pointer to place the TCP, IP, and physical media headers.*</span></span>

### <a name="tcp-packet-retransmit"></a><span data-ttu-id="0a867-1071">Повторная отправка TCP-пакетов</span><span class="sxs-lookup"><span data-stu-id="0a867-1071">TCP Packet Retransmit</span></span>

<span data-ttu-id="0a867-1072">Ранее отправленные и переданные TCP-пакеты фактически хранятся внутри системы до тех пор, пока другая сторона соединения не возвратит пакет ACK.</span><span class="sxs-lookup"><span data-stu-id="0a867-1072">Previously transmitted TCP packets sent actually stored internally until an ACK is returned from the other side of the connection.</span></span> <span data-ttu-id="0a867-1073">Если передача данных не подтверждается в течение времени ожидания, хранимый пакет отправляется повторно и задается следующий период времени ожидания.</span><span class="sxs-lookup"><span data-stu-id="0a867-1073">If transmitted data is not acknowledged within the timeout period, the stored packet is re-sent and the next timeout period is set.</span></span> <span data-ttu-id="0a867-1074">При получении пакета ACK окончательно освобождаются все пакеты, для которых действителен номер подтверждения во внутренней очереди передачи.</span><span class="sxs-lookup"><span data-stu-id="0a867-1074">When an ACK is received, all packets covered by the acknowledgement number in the internal transmit queue are finally released.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="0a867-1075">\*Приложение не должно повторно использовать пакет или изменять его содержимое после того, как функция \***nx_tcp_socket_send** _ возвратит результат со значением NX_SUCCESS.</span><span class="sxs-lookup"><span data-stu-id="0a867-1075">\*Application shall not reuse the packet or alter the contents of the packet after the \***nx_tcp_socket_send** _ function returns with NX_SUCCESS.</span></span> <span data-ttu-id="0a867-1076">В итоге после подтверждения получения данных на другом конце переданный пакет освобождается службой внутренней обработки NetX._</span><span class="sxs-lookup"><span data-stu-id="0a867-1076">The transmitted packet is eventually released by NetX internal processing after the data is acknowledged by the other end._</span></span>

### <a name="tcp-keepalive"></a><span data-ttu-id="0a867-1077">Проверка активности TCP-соединения</span><span class="sxs-lookup"><span data-stu-id="0a867-1077">TCP Keepalive</span></span>

<span data-ttu-id="0a867-1078">Функция проверки активности TCP-соединения позволяет сокету выявлять ситуации, когда его кэширующий узел отключается без правильного завершения (например, в случае аварийного завершения однорангового узла), а также предотвращать завершения подключения после длительных периодов бездействия определенными средствами мониторинга сетей.</span><span class="sxs-lookup"><span data-stu-id="0a867-1078">TCP Keepalive feature allows a socket to detect whether or not its peer disconnects without proper termination (for example, the peer crashed), or to prevent certain network monitoring facilities to terminate a connection for long periods of idle.</span></span> <span data-ttu-id="0a867-1079">Функция проверки активности TCP-соединения периодически отправляет TCP-кадр без данных, а текущий порядковый номер уменьшается на единицу.</span><span class="sxs-lookup"><span data-stu-id="0a867-1079">TCP Keepalive works by periodically sending a TCP frame with no data, and the sequence number set to one less than the current sequence number.</span></span> <span data-ttu-id="0a867-1080">При получении такого кадра проверки активности TCP-соединения получатель, если он по-прежнему активен, отвечает пакетом ACK для текущего порядкового номера.</span><span class="sxs-lookup"><span data-stu-id="0a867-1080">On receiving such TCP Keepalive frame, the recipient, if still alive, responses with an ACK for its current sequence number.</span></span> <span data-ttu-id="0a867-1081">На этом транзакция проверки активности завершается.</span><span class="sxs-lookup"><span data-stu-id="0a867-1081">This completes the keepalive transaction.</span></span>

<span data-ttu-id="0a867-1082">По умолчанию функция проверки активности не включена.</span><span class="sxs-lookup"><span data-stu-id="0a867-1082">By default the keepalive feature is not enabled.</span></span> <span data-ttu-id="0a867-1083">Для использования этой функции необходимо определить \***NX_ENABLE_TCP_KEEPALIVE** _ при создании библиотеки NetX.</span><span class="sxs-lookup"><span data-stu-id="0a867-1083">To use this feature, NetX library must be built with \***NX_ENABLE_TCP_KEEPALIVE** _ defined.</span></span> <span data-ttu-id="0a867-1084">Символ _ *_NX_TCP_KEEPALIVE_INITIAL_*\* указывает число секунд бездействия до инициирования кадра проверки активности.</span><span class="sxs-lookup"><span data-stu-id="0a867-1084">The symbol _ *_NX_TCP_KEEPALIVE_INITIAL_*\* specifies the number of seconds of inactivity before the keepalive frame is initiated.</span></span>

### <a name="tcp-packet-receive"></a><span data-ttu-id="0a867-1085">Получение TCP-пакетов</span><span class="sxs-lookup"><span data-stu-id="0a867-1085">TCP Packet Receive</span></span>

<span data-ttu-id="0a867-1086">Функция обработки получаемых TCP-пакетов (вызывается из вспомогательного потока IP) отвечает за обработку различных действий подключения и отключения, а также обработку подтверждения передачи.</span><span class="sxs-lookup"><span data-stu-id="0a867-1086">The TCP receive packet processing (called from the IP helper thread) is responsible for handling various connection and disconnection actions as well as transmit acknowledge processing.</span></span> <span data-ttu-id="0a867-1087">Кроме того, функция обработки получаемых TCP-пакетов отвечает за помещение пакетов с получаемыми данными в очередь получения соответствующего сокета TCP или доставку пакета первому приостановленному потоку, ожидающему пакет.</span><span class="sxs-lookup"><span data-stu-id="0a867-1087">In addition, the TCP receive packet processing is responsible for placing packets with receive data on the appropriate TCP socket's receive queue or delivering the packet to the first suspended thread waiting for a packet.</span></span>

### <a name="tcp-receive-notify"></a><span data-ttu-id="0a867-1088">Уведомление о получении TCP-пакета</span><span class="sxs-lookup"><span data-stu-id="0a867-1088">TCP Receive Notify</span></span>

<span data-ttu-id="0a867-1089">Если поток приложения должен обрабатывать полученные данные из нескольких сокетов, следует использовать функцию ***nx_tcp_socket_receive_notify***.</span><span class="sxs-lookup"><span data-stu-id="0a867-1089">If the application thread needs to process received data from more than one socket, the ***nx_tcp_socket_receive_notify*** function should be used.</span></span> <span data-ttu-id="0a867-1090">Эта функция регистрирует функцию обратного вызова получения пакетов для сокета.</span><span class="sxs-lookup"><span data-stu-id="0a867-1090">This function registers a receive packet callback function for the socket.</span></span> <span data-ttu-id="0a867-1091">При каждом получении пакета сокетом выполняется функция обратного вызова.</span><span class="sxs-lookup"><span data-stu-id="0a867-1091">Whenever a packet is received on the socket, the callback function is executed.</span></span>

<span data-ttu-id="0a867-1092">Содержимое функции обратного вызова зависит от конкретного приложения. Однако функция, скорее всего, будет содержать логику для информирования потока обработки о том, что пакет доступен в соответствующем сокете.</span><span class="sxs-lookup"><span data-stu-id="0a867-1092">The contents of the callback function are application-specific; however, the function would most likely contain logic to inform the processing thread that a packet is available on the corresponding socket.</span></span>

### <a name="thread-suspension"></a><span data-ttu-id="0a867-1093">Приостановка потока</span><span class="sxs-lookup"><span data-stu-id="0a867-1093">Thread Suspension</span></span>

<span data-ttu-id="0a867-1094">Как упоминалось ранее, потоки приложений могут быть приостановлены при попытке получить данные на определенном TCP-порте.</span><span class="sxs-lookup"><span data-stu-id="0a867-1094">As mentioned previously, application threads can suspend while attempting to receive data from a particular TCP port.</span></span> <span data-ttu-id="0a867-1095">После получения пакета на этом порте он передается первому приостановленному потоку, и этот поток возобновляется.</span><span class="sxs-lookup"><span data-stu-id="0a867-1095">After a packet is received on that port, it is given to the first thread suspended and that thread is then resumed.</span></span> <span data-ttu-id="0a867-1096">Для большинства служб NetX можно использовать необязательный параметр времени ожидания при приостановке получения TCP-пакетов.</span><span class="sxs-lookup"><span data-stu-id="0a867-1096">An optional timeout is available when suspending on a TCP receive packet, a feature available for most NetX services.</span></span>

<span data-ttu-id="0a867-1097">Приостановка потока также доступна для подключения (как клиента, так и сервера), привязки клиента и служб отключения.</span><span class="sxs-lookup"><span data-stu-id="0a867-1097">Thread suspension is also available for connection (both client and server), client binding, and disconnection services.</span></span>

### <a name="tcp-socket-statistics-and-errors"></a><span data-ttu-id="0a867-1098">Статистические показатели и ошибки сокета TCP</span><span class="sxs-lookup"><span data-stu-id="0a867-1098">TCP Socket Statistics and Errors</span></span>

<span data-ttu-id="0a867-1099">Если этот параметр включен, программное обеспечение TCP NetX отслеживает несколько статистических показателей и ошибок. Эти данные могут быть полезны для приложения.</span><span class="sxs-lookup"><span data-stu-id="0a867-1099">If enabled, the NetX TCP socket software keeps track of several statistics and errors that may be useful to the application.</span></span> <span data-ttu-id="0a867-1100">Для каждого IP/TCP-экземпляра поддерживаются следующие статистические показатели и отчеты об ошибках:</span><span class="sxs-lookup"><span data-stu-id="0a867-1100">The following statistics and error reports are maintained for each IP/TCP instance:</span></span>

- <span data-ttu-id="0a867-1101">общее число отправленных TCP-пакетов;</span><span class="sxs-lookup"><span data-stu-id="0a867-1101">Total TCP Packets Sent</span></span>
- <span data-ttu-id="0a867-1102">общее число отправленных байтов TCP;</span><span class="sxs-lookup"><span data-stu-id="0a867-1102">Total TCP Bytes Sent</span></span>
- <span data-ttu-id="0a867-1103">общее число полученных TCP-пакетов;</span><span class="sxs-lookup"><span data-stu-id="0a867-1103">Total TCP Packets Received</span></span>
- <span data-ttu-id="0a867-1104">общее число полученных байтов TCP;</span><span class="sxs-lookup"><span data-stu-id="0a867-1104">Total TCP Bytes Received</span></span>
- <span data-ttu-id="0a867-1105">общее число недопустимых TCP-пакетов;</span><span class="sxs-lookup"><span data-stu-id="0a867-1105">Total TCP Invalid Packets</span></span>
- <span data-ttu-id="0a867-1106">общее число отброшенных пакетов, получаемых по протоколу TCP;</span><span class="sxs-lookup"><span data-stu-id="0a867-1106">Total TCP Receive Packets Dropped</span></span>
- <span data-ttu-id="0a867-1107">общее число ошибок контрольной суммы при получении по протоколу TCP;</span><span class="sxs-lookup"><span data-stu-id="0a867-1107">Total TCP Receive Checksum Errors</span></span>
- <span data-ttu-id="0a867-1108">общее число TCP-соединений;</span><span class="sxs-lookup"><span data-stu-id="0a867-1108">Total TCP Connections</span></span>
- <span data-ttu-id="0a867-1109">общее число отключений TCP-соединений;</span><span class="sxs-lookup"><span data-stu-id="0a867-1109">Total TCP Disconnections</span></span>
- <span data-ttu-id="0a867-1110">общее число сброшенных TCP-соединений;</span><span class="sxs-lookup"><span data-stu-id="0a867-1110">Total TCP Connections Dropped</span></span>
- <span data-ttu-id="0a867-1111">общее число повторно отправленных TCP-пакетов;</span><span class="sxs-lookup"><span data-stu-id="0a867-1111">Total TCP Packet Retransmits</span></span>
- <span data-ttu-id="0a867-1112">число отправленных пакетов сокета TCP;</span><span class="sxs-lookup"><span data-stu-id="0a867-1112">TCP Socket Packets Sent</span></span>
- <span data-ttu-id="0a867-1113">число отправленных байтов сокета TCP;</span><span class="sxs-lookup"><span data-stu-id="0a867-1113">TCP Socket Bytes Sent</span></span>
- <span data-ttu-id="0a867-1114">число полученных пакетов сокета TCP;</span><span class="sxs-lookup"><span data-stu-id="0a867-1114">TCP Socket Packets Received</span></span>
- <span data-ttu-id="0a867-1115">число полученных байтов сокета TCP;</span><span class="sxs-lookup"><span data-stu-id="0a867-1115">TCP Socket Bytes Received</span></span>
- <span data-ttu-id="0a867-1116">общее число повторно отправленных пакетов сокета TCP;</span><span class="sxs-lookup"><span data-stu-id="0a867-1116">TCP Socket Packet Retransmits</span></span>
- <span data-ttu-id="0a867-1117">число поставленных в очередь пакетов сокета TCP;</span><span class="sxs-lookup"><span data-stu-id="0a867-1117">TCP Socket Packets Queued</span></span>
- <span data-ttu-id="0a867-1118">число ошибок контрольной суммы сокета TCP;</span><span class="sxs-lookup"><span data-stu-id="0a867-1118">TCP Socket Checksum Errors</span></span>
- <span data-ttu-id="0a867-1119">состояние сокета TCP;</span><span class="sxs-lookup"><span data-stu-id="0a867-1119">TCP Socket State</span></span>
- <span data-ttu-id="0a867-1120">длина очереди передачи сокета TCP;</span><span class="sxs-lookup"><span data-stu-id="0a867-1120">TCP Socket Transmit Queue Depth</span></span>
- <span data-ttu-id="0a867-1121">размер окна передачи сокета TCP;</span><span class="sxs-lookup"><span data-stu-id="0a867-1121">TCP Socket Transmit Window Size</span></span>
- <span data-ttu-id="0a867-1122">размер окна получения сокета TCP.</span><span class="sxs-lookup"><span data-stu-id="0a867-1122">TCP Socket Receive Window Size</span></span>

<span data-ttu-id="0a867-1123">Все эти статистические показатели и отчеты об ошибках предоставляются приложению службой ***nx_tcp_info_get** _ (для общей статистики TCP) и службой _ *_nx_tcp_socket_info_get_** (для статистики TCP каждого отдельного сокета).</span><span class="sxs-lookup"><span data-stu-id="0a867-1123">All these statistics and error reports are available to the application with the ***nx_tcp_info_get** _ service for total TCP statistics and the _ *_nx_tcp_socket_info_get_** service for TCP statistics per socket.</span></span>

## <a name="tcp-socket-control-block-nx_tcp_socket"></a><span data-ttu-id="0a867-1124">NX_TCP_SOCKET: блок управления сокетом TCP</span><span class="sxs-lookup"><span data-stu-id="0a867-1124">TCP Socket Control Block NX_TCP_SOCKET</span></span>

<span data-ttu-id="0a867-1125">Характеристики каждого из сокетов TCP находятся в связанном блоке управления *NX_TCP_SOCKET*, который содержит такую полезную информацию, как ссылка на структуру данных IP, интерфейс сетевого подключения, связанный порт и очередь получения пакетов.</span><span class="sxs-lookup"><span data-stu-id="0a867-1125">The characteristics of each TCP socket are found in the associated *NX_TCP_SOCKET* control block, which contains useful information such as the link to the IP data structure, the network connection interface, the bound port, and the receive packet queue.</span></span> <span data-ttu-id="0a867-1126">Эта структура определена в файле ***nx_api.h***.</span><span class="sxs-lookup"><span data-stu-id="0a867-1126">This structure is defined in the ***nx_api.h*** file.</span></span>
